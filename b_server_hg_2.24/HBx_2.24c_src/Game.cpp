// Game.cpp: implementation of the CGame class.
//
//////////////////////////////////////////////////////////////////////

#include "Game.h"

class CDebugWindow *DbgWnd;

extern void PutLogList(char * cMsg);
extern char G_cTxt[512];
extern char	G_cData50000[50000];	// Â´Ã«Â¿Ã«Â·Â®Ã€Ã‡ ÂµÂ¥Ã€ÃŒÃ…ÃÂ¸Â¦ ÃÂ¢Â±Ã™Ã‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã”.

extern void PutLogFileList(char * cStr);
extern void PutAdminLogFileList(char * cStr);
extern void PutItemLogFileList(char * cStr);
extern void PutLogEventFileList(char * cStr);
extern void PutHackLogFileList(char * cStr);
extern void PutPvPLogFileList(char * cStr);

// extern void PutDebugMsg(char * cStr);	// 2002-09-09 #2

extern FILE * pLogFile;
extern HWND	G_hWnd;

// Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã›Â¼ÂºÂ¿Ã« Ã‚Ã¼ÃÂ¶ÃˆÂ­Ã€Ã. 
int _tmp_iMoveLocX[9][37] = {
	 // 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	// 1
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//2
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,-1},
	//3
	{20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//4
	{20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,19,18,17,16,
	 15,14,13,12,11,10,9,8,7,6,
	 5,4,3,2,1,0,-1},
	//5
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//6
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,1,2,3,4,
	 5,6,7,8,9,10,11,12,13,14,
	 15,16,17,18,19,20,-1},
	//7
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//8
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,1,2,3,4,
	 5,6,7,8,9,10,11,12,13,14,
	 15,16,17,18,19,20,-1}
};

int _tmp_iMoveLocY[9][37] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//1
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//2
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1},
	//3
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//4
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,-1},
	//5
	{15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//6
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,-1},
	//7
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	// 8
	{15,14,13,12,11,10,9,8,7,6,
	 5,4,3,2,1,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,-1}
};

char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

extern BOOL	G_bIsThread;
extern void ThreadProc(void *ch);

CGame::CGame(HWND hWnd)
{
 int i, x;
	
	m_bIsGameStarted = FALSE;
	m_hWnd           = hWnd;
	m_pMainLogSock   = NULL;
	m_pGateSock      = NULL;
	m_bIsLogSockAvailable   = FALSE;
	m_bIsGateSockAvailable  = FALSE;
	m_bIsItemAvailable      = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable       = FALSE;
	m_bIsMagicAvailable     = FALSE;
	m_bIsSkillAvailable     = FALSE;
	m_bIsQuestAvailable     = FALSE;
	m_bIsPortionAvailable   = FALSE;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));

	m_iPlayerMaxLevel = DEF_PLAYERMAXLEVEL;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = NULL;

	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = NULL;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;
	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
		m_pPortionConfigList[i] = NULL;

//	/for (i = 0; i < DEF_MAXTELEPORTTYPE; i++)
//		m_pTeleportConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
		m_pDupItemIDList[i] = NULL;

	// New 06/05/2004
	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		m_stPartyInfo[i].iTotalMembers = 0;
		for(x = 0; x < DEF_MAXPARTYMEMBERS; x++)
			m_stPartyInfo[i].iIndex[x] = 0;
	}

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;

	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour   = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds  = 0;
	m_stCityStatus[1].iWins   = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds  = 0;
	m_stCityStatus[2].iWins   = 0;

	m_iAutoRebootingCount	= 0;
	m_bEnemyKillMode		= FALSE; 
	m_iEnemyKillAdjust      = 1; 
	m_bAdminSecurity		= TRUE; 
	m_sRaidTimeMonday		= 0; 
	m_sRaidTimeTuesday      = 0; 
	m_sRaidTimeWednesday	= 0; 
	m_sRaidTimeThursday     = 0; 
	m_sRaidTimeFriday		= 0; 
	m_sRaidTimeSaturday     = 0; 
	m_sRaidTimeSunday		= 0;
	m_sCharPointLimit		= 0;
	m_sSlateSuccessRate		= 0;
	
	//Show Debug Window
	//DbgWnd = new CDebugWindow();
	//DbgWnd->Startup();
	//DbgWnd->AddEventMsg("CGame Startup");
	// 2002-09-09 #1
	m_bReceivedItemList = FALSE;

}

CGame::~CGame()
{
	//DbgWnd->Shutdown();
	//delete DbgWnd;
}

BOOL CGame::bAccept(class XSocket * pXSock)
{
 register int i;
 class XSocket * pTmpSock;

	if ((m_bIsGateSockAvailable == FALSE)  || (m_bIsLogSockAvailable == FALSE)   || 
		(m_bIsItemAvailable == FALSE)      || (m_bIsNpcAvailable == FALSE)       || 
		(m_bIsMagicAvailable == FALSE)     || (m_bIsSkillAvailable == FALSE)     || 
		(m_bIsPortionAvailable == FALSE)   || (m_bOnExitProcess == TRUE)         || 
		(m_bIsQuestAvailable == FALSE)     || (m_bIsBuildItemAvailable == FALSE) || 
		(m_bIsGameStarted == FALSE))
		goto CLOSE_ANYWAY;

	// ÂºÃ±Â¾Ã®Ã€Ã–Â´Ã‚ Â¹Ã¨Â¿Â­Ã€Â» ÃƒÂ£Â´Ã‚Â´Ã™. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] == NULL) {
		
		m_pClientList[i] = new class CClient(m_hWnd);
		// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Ã€ÃÂµÂ¦Â½Âº Â¸Â®Â½ÂºÃ†Â®Â¿Â¡ Â±Ã¢Â·Ã 
		bAddClientShortCut(i);
		// ÃÂ¢Â¼Ã“Â½ÃƒÂ°Â£ Â±Ã¢Â·Ã - Ã€Ã¥Â½ÃƒÂ°Â£ Ã€Ã€Â´Ã¤Â¾Ã¸Â´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¸Â¦ ÃÂ¦Â°Ã…Ã‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã”Ã€ÃŒÂ´Ã™. 
		m_pClientList[i]->m_dwSPTime = m_pClientList[i]->m_dwMPTime = 
			m_pClientList[i]->m_dwHPTime = m_pClientList[i]->m_dwAutoSaveTime = 
				m_pClientList[i]->m_dwTime = m_pClientList[i]->m_dwHungerTime = m_pClientList[i]->m_dwExpStockTime = 
					m_pClientList[i]->m_dwRecentAttackTime = m_pClientList[i]->m_dwAutoExpTime = m_pClientList[i]->m_dwSpeedHackCheckTime = timeGetTime();
		
		pXSock->bAccept(m_pClientList[i]->m_pXSock, WM_ONCLIENTSOCKETEVENT + i); 
	
		// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® ÃÂ¢Â¼Ã“ÃÃ¶Ã€Ã‡ ÃÃ–Â¼Ã’Â¸Â¦ Â¾Ã²Â¾Ã®Â¿Ã‚Â´Ã™.
		ZeroMemory(m_pClientList[i]->m_cIPaddress, sizeof(m_pClientList[i]->m_cIPaddress));
		m_pClientList[i]->m_pXSock->iGetPeerAddress(m_pClientList[i]->m_cIPaddress);
		
		wsprintf(G_cTxt,"<%d> Client Connected: (%s)", i, m_pClientList[i]->m_cIPaddress);
		PutLogList(G_cTxt);

		m_iTotalClients++;

		if (m_iTotalClients > m_iMaxClients) { 
			// ÃƒÃ–Â´Ã« Â»Ã§Â¿Ã«Ã€Ãš Â¼Ã¶Â°Â¡ Â°Â»Â½Ã…ÂµÃ‡Â¾ÃºÂ´Ã™. 
			m_iMaxClients = m_iTotalClients;
			//GetLocalTime(&m_MaxUserSysTime);
			//wsprintf(cTxt, "Maximum Players: %d", m_iMaxClients);
			//PutLogFileList(cTxt);
		}

		// ÃÂ¢Â¼Ã“Ã€Âº Â¹ÃÂ¾Ã’ÃÃ¶Â¸Â¸ Â¾Ã†ÃÃ· Â°Ã”Ã€Ã“ÂµÂ¥Ã€ÃŒÃ…ÃÂ´Ã‚ Ã€Ã¼Â¼Ã›Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰Ã‡Ã‘ Â»Ã³Ã…Ã‚Ã€ÃŒÂ´Ã™. ÂµÂ¥Ã€ÃŒÃ…ÃÂ°Â¡ ÃƒÃŠÂ±Ã¢ÃˆÂ­ ÂµÃˆ ÃˆÃ„Â¿Â¡ Â°Â¡Â´Ã‰Ã‡Ã˜ÃÃ¸Â´Ã™.
		//m_pClientList[iClientH]->m_bIsInitComplete Â°ÂªÃ€Â» Ã‚Ã¼ÃÂ¶Ã‡Ã˜Â¾ÃŸ Ã‡Ã‘Â´Ã™.
		return TRUE;
	}

CLOSE_ANYWAY:;

	// ÂºÃ±Â¾Ã®Ã€Ã–Â´Ã‚ Â¹Ã¨Â¿Â­Ã€ÃŒ Â¾Ã¸Â¾Ã® ÃÂ¢Â¼Ã“Ã€Â» Â¹ÃÃ€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™. AcceptÃ‡ÃÃ€Ãš Â¸Â¶Ã€Ãš Â²Ã·Â´Ã‚Â´Ã™.
	pTmpSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	pXSock->bAccept(pTmpSock, NULL); 
	delete pTmpSock;

	return FALSE;
}


void CGame::OnClientSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 UINT iTmp;
 register int iClientH, iRet;
 DWORD dwTime = timeGetTime();

	iTmp = WM_ONCLIENTSOCKETEVENT;
	iClientH = message - iTmp;
	
	if (m_pClientList[iClientH] == NULL) return;

	iRet = m_pClientList[iClientH]->m_pXSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_READCOMPLETE:
		OnClientRead(iClientH);
		m_pClientList[iClientH]->m_dwTime = timeGetTime();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		PutLogList("Socket BLOCKED!");
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		wsprintf(G_cTxt,"<%d> Confirmcode notmatch!", iClientH);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, FALSE, TRUE);
		break;

	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		wsprintf(G_cTxt,"<%d> Client Disconnected! (%s)", iClientH, m_pClientList[iClientH]->m_cIPaddress);
		PutLogList(G_cTxt); 
		if ((dwTime - m_pClientList[iClientH]->m_dwLogoutHackCheck) < 1000) {
				wsprintf(G_cTxt, "Logout Hack: (%s) Player: (%s) - disconnected within 10 seconds of most recent damage. Hack? Lag?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
		}

		DeleteClient(iClientH, TRUE, TRUE);
		break;
	}													    
}

BOOL CGame::bInit()		   
{
 char * cp, cTxt[120];
 DWORD * dwp;
 WORD * wp;
 int  i;
 SYSTEMTIME SysTime;
 DWORD dwTime = timeGetTime(); //µ±Ç°Ê±¼ä

	//m_Misc.Temp();

	PutLogList("(!) INITIALIZING GAME SERVER...");
	//

	for (i = 0; i < DEF_MAXCLIENTS+1; i++)//³õÊ¼»¯m_iClientShortCut[i] ¿Í»§¶ËĞÅÏ¢
		m_iClientShortCut[i] = 0;

	if (m_pMainLogSock != NULL) delete m_pMainLogSock;
	if (m_pGateSock != NULL) delete m_pGateSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)//³õÊ¼»¯m_pSubLogSock[i] ¿Í»§¶ËĞÅÏ¢
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < DEF_MAXCLIENTS; i++)//³õÊ¼»¯m_pSubLogSock[i] ¿Í»§¶ËĞÅÏ¢
	if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) delete m_pNpcList[i]; //Í¬ÉÏ£¬ËûÃÇ¶¼ÊÇÏàÓ¦µÄÀà£¬ÕâĞ©ÀàÖĞÃ»ÓĞÊµÏÖ´úÂë¾ÍÊÇcppÎÄ¼ş£¬ËûÃÇµÄ×÷ÓÃ¾ÍÏàµ±ÓÚ½á¹¹Ìå

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
	if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];//Í¬ÉÏ

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
	if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];//Í¬ÉÏ

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];//Í¬ÉÏ

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];//Í¬ÉÏ

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
	if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];//Í¬ÉÏ

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
	if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
	if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
	if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
	if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
	if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];

//	for (i = 0; i < DEF_MAXTELEPORTTYPE; i++)
//	if (m_pTeleportConfigList[i] != NULL) delete m_pTeleportConfigList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_iNpcConstructionPoint[i] = NULL;
	

	for (i = 0; i < DEF_MAXSCHEDULE; i++) {
		m_stCrusadeWarSchedule[i].iDay = -1;
		m_stCrusadeWarSchedule[i].iHour = -1;
		m_stCrusadeWarSchedule[i].iMinute = -1;
	}
	
	for (i = 0; i < DEF_MAXAPOCALYPSE; i++) {
		m_stApocalypseScheduleStart[i].iDay = -1;
		m_stApocalypseScheduleStart[i].iHour = -1;
		m_stApocalypseScheduleStart[i].iMinute = -1;
	}
	
	for (i = 0; i < DEF_MAXHELDENIAN; i++) {
		m_stHeldenianSchedule[i].iDay = -1;
		m_stHeldenianSchedule[i].StartiHour = -1;
		m_stHeldenianSchedule[i].StartiMinute = -1;
		m_stHeldenianSchedule[i].EndiHour = -1;
		m_stHeldenianSchedule[i].EndiMinute = -1;
	}

	for (i = 0; i < DEF_MAXAPOCALYPSE; i++) {
		m_stApocalypseScheduleEnd[i].iDay = -1;
		m_stApocalypseScheduleEnd[i].iHour = -1;
		m_stApocalypseScheduleEnd[i].iMinute = -1;
	}

	// Ã€ÃÂ´Ãœ Â¿Â©Â±Ã¢Â¼Â­ Â¼Â³ÃÂ¤ 
	m_iNpcConstructionPoint[1]  = 100; // MS
	m_iNpcConstructionPoint[2]  = 100; // MS
	m_iNpcConstructionPoint[3]  = 100; // MS
	m_iNpcConstructionPoint[4]  = 100; // MS
	m_iNpcConstructionPoint[5]  = 100; // MS
	m_iNpcConstructionPoint[6]  = 100; // MS
		
	m_iNpcConstructionPoint[43] = 1000; // LWB
	m_iNpcConstructionPoint[44] = 2000; // GHK
	m_iNpcConstructionPoint[45] = 3000; // GHKABS
	m_iNpcConstructionPoint[46] = 2000; // TK
	m_iNpcConstructionPoint[47] = 3000; // BG
	m_iNpcConstructionPoint[51] = 1500; // Catapult
	//

	m_bIsGameStarted = FALSE;

	m_pMainLogSock  = NULL;
	m_pGateSock = NULL;
	m_bIsLogSockAvailable   = FALSE;
	m_bIsGateSockAvailable  = FALSE;
	m_bIsItemAvailable      = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable       = FALSE;
	m_bIsMagicAvailable     = FALSE;
	m_bIsSkillAvailable     = FALSE;
	m_bIsQuestAvailable     = FALSE;
	m_bIsPortionAvailable   = FALSE;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = NULL;

	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = NULL;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;
	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
		m_pPortionConfigList[i] = NULL;

//	for (i = 0; i < DEF_MAXTELEPORTTYPE; i++)
//		m_pTeleportConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		ZeroMemory(m_stCrusadeStructures[i].cMapName, sizeof(m_stCrusadeStructures[i].cMapName));
		m_stCrusadeStructures[i].cType = NULL;
		m_stCrusadeStructures[i].dX    = NULL;
		m_stCrusadeStructures[i].dY    = NULL;
	}

	for (i = 0; i < DEF_MAXADMINS; i++) {
		ZeroMemory(m_stAdminList[i].m_cGMName, sizeof(m_stAdminList[i].m_cGMName));
	}

	for (i = 0; i < DEF_MAXBANNED; i++) {
		ZeroMemory(m_stBannedList[i].m_cBannedIPaddress, sizeof(m_stBannedList[i].m_cBannedIPaddress));
	}
	
	for (i = 0; i < DEF_MAXGUILDS; i++)
		m_pGuildTeleportLoc[i].m_iV1 = NULL;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		m_stMiddleCrusadeStructureInfo[i].cType = NULL;
		m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
		m_stMiddleCrusadeStructureInfo[i].sX = NULL;
		m_stMiddleCrusadeStructureInfo[i].sY = NULL;
	}
	m_iTotalMiddleCrusadeStructures = 0;
	
	m_pNoticementData = NULL;

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;

	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour   = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenMapIndex    = -1;
	m_iElvineMapIndex     = -1;
	m_iGodHMapIndex	      = -1;
	m_iBTFieldMapIndex    = -1;

	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;

	m_iSubLogSockInitIndex   = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds  = 0;
	m_stCityStatus[1].iWins   = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds  = 0;
	m_stCityStatus[2].iWins   = 0;
 
	m_iStrategicStatus = 0;

	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;

	m_iAresdenMana = 0;
	m_iElvineMana  = 0;

	m_dwSpecialEventTime = m_dwWhetherTime = m_dwGameTime1 =
		m_dwGameTime2 = m_dwGameTime3 = m_dwGameTime4 = m_dwGameTime5 = m_dwGameTime6 = m_dwFishTime = dwTime;

	m_bIsSpecialEventTime = FALSE;

	GetLocalTime(&SysTime);
	// dwTime - Â³Â²Ã€Âº Â¿Â¹Â¾Ã  Â°Â¡Â´Ã‰Ã‡Ã‘ Â½ÃƒÂ°Â£ 
	m_dwCanFightzoneReserveTime =  dwTime -  ((SysTime.wHour%2)*60*60 + SysTime.wMinute*60) *1000 ;
		
	// v1.4311-3 ÃƒÃŸÂ°Â¡ ÂºÂ¯Â¼Ã¶ ÃƒÃŠÂ±Ã¢ÃˆÂ­ Â»Ã§Ã…ÃµÃ€Ã¥ Â¿Â¹Â¾Ã  Â°Ã¼Â·Ãƒ 
	for(i =0; i < DEF_MAXFIGHTZONE; i++) 
		m_iFightZoneReserve[i] = 0 ;

	// v1.4311-3 ÃƒÃŸÂ°Â¡ ÂºÂ¯Â¼Ã¶ ÃƒÃŠÂ±Ã¢ÃˆÂ­ Â»Ã§Ã…ÃµÃ€Ã¥ Â°Â­Ã„Ã Â°Ã¼Â·Ãƒ 
	m_iFightzoneNoForceRecall = 0;
	
	// Â°Â¢ Â·Â¹ÂºÂ§ÂºÂ° Â°Ã¦Ã‡Ã¨Ã„Â¡ Â¸Â®Â½ÂºÃ†Â®Â¸Â¦ Ã€Ã›Â¼ÂºÃ‡Ã‘Â´Ã™.
	for (i = 1; i < 3500; i++) {
		m_iLevelExpTable[i] = iGetLevelExp(i);
		//testcode
		//wsprintf(G_cTxt, "Level:%d --- Exp:%d", i, m_iLevelExpTable[i]);
		//PutLogFileList(G_cTxt);
	}

	m_iLimitedUserExp = m_iLevelExpTable[DEF_LEVELLIMIT+1]; // ÃƒÂ¼Ã‡Ã¨Ã†Ã‡ Ã€Â¯Ã€ÃºÂ´Ã‚ 20Â·Â¹ÂºÂ§Ã€ÃŒÂ»Ã³Ã€Ã‡ Â°Ã¦Ã‡Ã¨Ã„Â¡Â´Ã‚ Â¾Ã²Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.  Ã€Ã“Â½ÃƒÂ·Ã Â·Â¹ÂºÂ§ 60Â±Ã®ÃÃ¶
	m_iLevelExp20     = m_iLevelExpTable[20]; 

	m_iGameServerMode = 0;
	if (bReadProgramConfigFile("GServer.cfg") == FALSE) { //½âÎöGServer.cfgÎÄ¼şº¯Êı
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! GServer.cfg file contents error!");
		return FALSE;	
	}
	if (bReadSettingsConfigFile("GameConfigs\\Settings.cfg") == FALSE) {;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! Settings.cfg file contents error!");
		return FALSE;
	}
	if (bReadAdminListConfigFile("GameConfigs\\AdminList.cfg") == FALSE) {;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! AdminList.cfg file contents error!");
		return FALSE;
	}
	if (bReadBannedListConfigFile("GameConfigs\\BannedList.cfg") == FALSE) {;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! BannedList.cfg file contents error!");
		return FALSE;
	}
	if (bReadAdminSetConfigFile("GameConfigs\\AdminSettings.cfg") == FALSE) {;
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! AdminSettings.cfg file contents error!");
		return FALSE;
	}	
	srand( (unsigned)time( NULL ) );   
	// Main Log SocketÂ·ÃÃ€Ã‡ Â¿Â¬Â°Ã¡ Â½ÃƒÂµÂµ 
	m_pMainLogSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	m_pMainLogSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_ONLOGSOCKETEVENT);
	m_pMainLogSock->bInitBufferSize(DEF_MSGBUFFERSIZE);

	wsprintf(cTxt, "(!) Try to Connect main-log-socket... Addr:%s  Port:%d", m_cLogServerAddr, m_iLogServerPort);
	PutLogList(cTxt);
	//Sleep(100);
	// Gate ServerÂ·ÃÃ€Ã‡ Â¿Â¬Â°Ã¡Â½ÃƒÂµÂµ 

	m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
	m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
	// v1.41 Â¿Â¬Â°Ã¡ Â½ÃƒÂ°Â£ ÃƒÂ¼Ã…Â©Â¿Ã« 
	m_iGateSockConnRetryTimes = 1;

	wsprintf(cTxt, "(!) Try to Connect Gate Server... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
	PutLogList(cTxt);

	m_bF1pressed = m_bF4pressed = m_bF12pressed = m_bF5pressed = FALSE;
	
	// Â¼Â­Â¹Ã¶ Â¼Ã‹Â´Ã™Â¿Ã® Ã‡ÃÂ·ÃÂ¼Â¼Â½Âº ÂºÂ¯Â¼Ã¶. Ã€ÃŒÂºÂ¯Â¼Ã¶Â°Â¡ Ã„Ã‘ÃÃ¶Â¸Ã© Â´ÃµÃ€ÃŒÂ»Ã³ Â»Ãµ ÃÂ¢Â¼Ã“Ã€Â» Â¹ÃÃÃ¶ Â¾ÃŠÃ€Â¸Â¸Ã§ Ã…Â¸Ã€ÃŒÂ¸Ã“Â´Ã§ 50Â¸Ã­Â¾Â¿ Â°Â­ÃÂ¦ ÃÂ¢Â¼Ã“ ÃÂ¾Â·Ã¡Â½ÃƒÃ…Â²Â´Ã™.
	m_bOnExitProcess = FALSE;
	
	// SkillSSN Ã†Ã·Ã€ÃÃ†Â®Â¸Â¦ Â¹ÃŒÂ¸Â® Â°Ã¨Â»ÃªÃ‡Ã˜ Â³ÃµÂ´Ã‚Â´Ã™.
	for (i = 0; i <= 100; i++) {
		m_iSkillSSNpoint[i] = _iCalcSkillSSNpoint(i);
	}

	// ÃÃ–, Â¾ÃŸÂ°Â£ Â¸Ã°ÂµÃ¥ Â¼Â³ÃÂ¤ 
	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= DEF_NIGHTTIME) //DEF_NIGHTTIME Îª40
		 m_cDayOrNight = 2;  //ÊÇºÚÒ¹»¹ÊÇ°×Ìì
	else m_cDayOrNight = 1;


	bReadNotifyMsgListFile("notice.txt"); //ÕÒ²»µ½Õâ¸öÎÄ¼ş£¿£¿ÕâÊÇ¸öÍ¨ÖªÉ¶µÄÎÄ¼ş£¿
	m_dwNoticeTime = dwTime;

	m_iCurSubLogSockIndex    = 0;
	m_iSubLogSockFailCount   = 0;
	m_iSubLogSockActiveCount = 0;

	m_pNoticementData      = NULL;
	m_dwNoticementDataSize = 0;

	m_dwMapSectorInfoTime = dwTime;
	m_iMapSectorInfoUpdateCount = 0;

	m_iCrusadeCount  = NULL;
	m_bIsCrusadeMode = FALSE;
	m_bIsApocalypseMode = FALSE;
	m_wServerID_GSS = iDice(1,65535);

	ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
	cp = (char *)m_cGateServerStockMsg;
	dwp = (DWORD *)cp;
	*dwp = MSGID_SERVERSTOCKMSG;
	cp += 4;
	wp = (WORD *)cp;
	*wp = DEF_MSGTYPE_CONFIRM;
	cp += 2;

	m_iIndexGSS = 6;
	m_dwCrusadeGUID = NULL;
	m_iCrusadeWinnerSide = NULL;
	m_iLastCrusadeWinner = 0;
	m_sLastHeldenianWinner = 0;
	m_sLastCrusadeDate = -1;
	m_iFinalShutdownCount = 0;
	m_bIsCrusadeWarStarter = FALSE;
	m_bIsApocalypseStarter = FALSE;
	m_iLatestCrusadeDayOfWeek = -1;

	m_bHeldenianInitiated = FALSE;
	m_cHeldenianType = FALSE;
	m_bIsHeldenianMode = FALSE;
	m_bHeldenianRunning	= FALSE;
	m_iHeldenianAresdenLeftTower = 0;
	m_cHeldenianModeType = -1;
	m_sLastHeldenianWinner = -1;
	m_iHeldenianAresdenLeftTower = 0;
	m_iHeldenianElvineLeftTower = 0;
	m_iHeldenianAresdenDead = 0;
	m_iHeldenianElvineDead = 0;

	return TRUE;
}

void CGame::OnClientRead(int iClientH)
{
 char  * pData, cKey;
 DWORD  dwMsgSize;
	
	if (m_pClientList[iClientH] == NULL) return;
 
	pData = m_pClientList[iClientH]->m_pXSock->pGetRcvDataPointer(&dwMsgSize, &cKey); // v1.4
	
	if (bPutMsgQuene(DEF_MSGFROM_CLIENT, pData, dwMsgSize, iClientH, cKey) == FALSE) {
		// Â¸ÃÂ½ÃƒÃÃ¶ Ã…Â¥Â¿Â¡ Ã€ÃŒÂ»Ã³Ã€ÃŒ Â»Ã½Â°Ã¥Â´Ã™. Ã„Â¡Â¸Ã­Ã€Ã»Ã€Ã Â¿Â¡Â·Â¯.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}


void CGame::DisplayInfo(HDC hdc)
{
 char cTxt[350], cDave[350];  
 int  i, iLine;

	// NTÂ¿Â¡Â¼Â­ Â¿Â¡Â·Â¯Â³Â²! ÃÃ–Ã€Ã‡ 
	wsprintf(cTxt, "Server-Name(%s) Max.Level(%d) Players(%d/%d - %d/%d) Crusade(%d:%d) SLSock(%d:%d) GTSock(%d) RBT(%d)", m_cServerName, m_iPlayerMaxLevel, m_iTotalClients, m_iMaxClients, m_iTotalGameServerClients, m_iTotalGameServerMaxClients, m_dwCrusadeGUID, (int)m_bIsCrusadeMode, m_iSubLogSockActiveCount, m_iSubLogSockFailCount, m_iGateSockConnRetryTimes, m_iAutoRebootingCount);
	TextOut(hdc, 5, 10, cTxt, strlen(cTxt));

//#ifdef DEF_TESTSERVER
//	ZeroMemory(cTxt, sizeof(cTxt));
//	strcpy(cTxt, "ì¸ì ‘í•œ í´ë¼ì´ì–¸íŠ¸ë“¤ì—ê²Œ ë°©í–¥ì „í™˜ ì´ë²¤íŠ¸ë¥¼ ì•Œë¦°ë‹¤. ********** TEST SERVER MODE **********");
//	TextOut(hdc, 5, 25, cTxt, strlen(cTxt));
//#endif

	GayDave(cDave, "Bobobob");
	TextOut(hdc, 5, 25, cDave, strlen(cDave));


	iLine = 0;
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {

		ZeroMemory(G_cTxt, sizeof(G_cTxt));
		wsprintf(G_cTxt, "Map(%s)    Object(%d)    P(%d, %d)    N(%d, %d)    A(%d, %d)    E(%d, %d)    M(%d, %d)", 
			     m_pMapList[i]->m_cName, m_pMapList[i]->m_iTotalActiveObject,  m_pMapList[i]->m_iMaxPx*20+10, m_pMapList[i]->m_iMaxPy*20+10, 
				 m_pMapList[i]->m_iMaxNx*20+10, m_pMapList[i]->m_iMaxNy*20+10, m_pMapList[i]->m_iMaxAx*20+10, m_pMapList[i]->m_iMaxAy*20+10, 
				 m_pMapList[i]->m_iMaxEx*20+10, m_pMapList[i]->m_iMaxEy*20+10, m_pMapList[i]->m_iMaxMx*20+10, m_pMapList[i]->m_iMaxMy*20+10);
		
		TextOut(hdc, 5, 400 + iLine*15, G_cTxt, strlen(G_cTxt));
		iLine++;
	}
}

void CGame::GayDave(char cDave[350], char cInput[350])
{
 char * pDisplay, * wdap, * pInput;
	pInput = cInput;
	pDisplay = cDave;

	wdap = (char *)pDisplay; memcpy(wdap, "S", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "v", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "b", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "y", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "Z", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, ",", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "H", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "y", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "p", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "n", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "t", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "d", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, ",", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "A", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "c", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "h", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "A", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "n", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "g", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "l", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, ",", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "K", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "L", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "K", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "S", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, ",", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "n", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "d", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "D", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "y", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "l", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "-", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "w", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "w", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "w", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, ".", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "h", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "b", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "x", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "t", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "m", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, ".", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "t", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "k", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "       ********** TEST SERVER MODE **********               ", 60); pDisplay++;
	return;
}

void CGame::ClientMotionHandler(int iClientH, char * pData)
{
 DWORD * dwp, dwClientTime;
 WORD * wp, wCommand, wTargetObjectID;
 short * sp, sX, sY, dX, dY, wType;
 char  * cp, cDir;
 int   iRet, iTemp;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	
	/*m_pClientList[iClientH]->m_cConnectionCheck++;
	if (m_pClientList[iClientH]->m_cConnectionCheck > 50) {
		wsprintf(G_cTxt, "Hex: (%s) Player: (%s) - removed 03203203h, vital to hack detection.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}*/
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;

	sp = (short *)cp;
	dX = *sp;
	cp += 2;

	sp = (short *)cp;
	dY = *sp;
	cp += 2;

	sp = (short *)cp;
	wType = *sp;
	cp += 2;

	if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE)) { // v1.4
		wp = (WORD *)cp;
		wTargetObjectID = *wp;
		cp += 2;
	}
	
	// v2.171
	dwp = (DWORD *)cp;
	dwClientTime = *dwp;
	cp += 4;

	switch (wCommand) {
	case DEF_OBJECTSTOP:
		iRet = iClientMotion_Stop_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTSTOP, NULL, NULL, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTRUN:
		// Â´ÃÂ¸Â°Â°ÃÂ¿Â¡ Â´Ã«Ã‡Ã‘ ÃˆÂ¿Â°ÃºÂ¸Â¦ ÃƒÂ³Â¸Â®Ã‡Ã‘Â´Ã™. ÃƒÂ¼Â·Ã‚Â°Â¨Â¼Ã’ÂµÃ®ÂµÃ®
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 1);
		if (iRet == 1) {
			// Ã€ÃÃÂ¢Ã‡Ã‘ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®ÂµÃ©Â¿Â¡Â°Ã” Ã€ÃŒÂµÂ¿ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ Â¾Ã‹Â¸Â°Â´Ã™. 
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTRUN, NULL, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		// v2.171
		bCheckClientMoveFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 2);
		if (iRet == 1) {
			// Ã€ÃÃÂ¢Ã‡Ã‘ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®ÂµÃ©Â¿Â¡Â°Ã” Ã€ÃŒÂµÂ¿ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ Â¾Ã‹Â¸Â°Â´Ã™. 
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		// v2.171
		bCheckClientMoveFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTDAMAGEMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0);
		if (iRet == 1) {
			// Ã€ÃÃÂ¢Ã‡Ã‘ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®ÂµÃ©Â¿Â¡Â°Ã” Ã€ÃŒÂµÂ¿ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ Â¾Ã‹Â¸Â°Â´Ã™.                                                      
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, m_pClientList[iClientH]->m_iLastDamage, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		break;

	case DEF_OBJECTATTACKMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, 0);
		if ((iRet == 1) && (m_pClientList[iClientH] != NULL)) {
			// Ã€ÃÃÂ¢Ã‡Ã‘ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®ÂµÃ©Â¿Â¡Â°Ã” Ã€ÃŒÂµÂ¿ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ Â¾Ã‹Â¸Â°Â´Ã™. 
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACKMOVE, NULL, NULL, NULL);
			// Â°Ã¸Â°Ã ÃˆÂ¿Â°ÃºÂ¸Â¦ Â°Ã¨Â»Ãª
			iClientMotion_Attack_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, wType, cDir, wTargetObjectID, FALSE, TRUE); // v1.4
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		// v2.171
		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTATTACK:
		// Ã€ÃŒ Ã€Â§Â¿Â¡Â¼Â­ wTypeÃ€ÃŒ Ã‡Ã•Â´Ã§Ã‡Ã‘ÃÃ¶Â¸Â¦ Â¸Ã•Ã€Ãº ÃƒÂ³Â¸Â®Ã‡Ã‘Â´Ã™. 
		_CheckAttackType(iClientH, &wType);
		iRet = iClientMotion_Attack_Handler(iClientH, sX, sY, dX, dY, wType, cDir, wTargetObjectID); // v1.4
		if (iRet == 1) {
			if (wType >= 20) {
				// Ã‡ÃŠÂ»Ã¬Â±Ã¢ Ã„Â«Â¿Ã®Ã†Â®Â¸Â¦ Â°Â¨Â¼Ã’Ã‡Ã‘Â´Ã™.
				m_pClientList[iClientH]->m_iSuperAttackLeft--;
				// Ã„Â«Â¿Ã®Ã†Â®Â°Â¡ Â¸Â¶Ã€ÃŒÂ³ÃŠÂ½ÂºÂ°Â¡ ÂµÃ‰ Ã€ÃÃ€Âº Â¾Ã¸Â°ÃšÃÃ¶Â¸Â¸ Â¿Â¡Â·Â¯ Â¹Ã¦ÃÃ¶Â¿Ã«
				if (m_pClientList[iClientH]->m_iSuperAttackLeft < 0) m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
			}

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, wType);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		// v2.171
		bCheckClientAttackFrequency(iClientH, dwClientTime);
		break;

	case DEF_OBJECTGETITEM:
		iRet = iClientMotion_GetItem_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTGETITEM, NULL, NULL, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTMAGIC:
		iRet = iClientMotion_Magic_Handler(iClientH, sX, sY, cDir);
		//client hp recorded here ONLY if its less than
		if (iRet == 1) {
			if (m_pClientList[iClientH]->m_bMagicPauseTime == FALSE) {
				m_pClientList[iClientH]->m_bMagicPauseTime = TRUE;
				iTemp = 10;
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMAGIC, dX, iTemp, NULL);
				m_pClientList[iClientH]->m_iSpellCount++;
				bCheckClientMagicFrequency(iClientH, dwClientTime);
			}
			else if (m_pClientList[iClientH]->m_bMagicPauseTime == TRUE) {
				wsprintf(G_cTxt, "Cast Delay Hack: (%s) Player: (%s) - player casting too fast.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, TRUE, TRUE);
			}
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
			break;

	default:
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, char cMoveType)
//  description			:: Handles how player or npc run, walk, attack, or get flown by attack
//  last updated		:: October 30, 2004; 1:52 AM; Hypnotoad
//	return value		:: int
//  commentary			:: - contains speed hack detection previously unavailable
//						   - changed variable 5 to char, prior BOOL.
//								1 = object run
//								2 = object malk
//								0 = object damage move, object attack move
//						   - fixed bump bug removing aura
/////////////////////////////////////////////////////////////////////////////////////
// Missing 3.51: 
//			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->3CA18h
// 			bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->sub_4C0F20(dX, dY, cTemp, wV1, wV2);
//
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, char cMoveType)
{
 char  * cp, cData[3000];
 class CTile * pTile;
 DWORD * dwp, dwTime;
 WORD  * wp, wObjectID;
 short * sp, dX, dY, sTemp, sTemp2, sDOtype, pTopItem;
 int   * ip, iRet, iSize, iDamage;
 BOOL  bRet, bIsBlocked = FALSE;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;
	
	/*dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;
	if (cMoveType == 2) {
		if (m_pClientList[iClientH]->m_iRecentWalkTime > dwTime) {
			m_pClientList[iClientH]->m_iRecentWalkTime = dwTime;
			if (m_pClientList[iClientH]->m_sV1 < 1) {
				if (m_pClientList[iClientH]->m_iRecentWalkTime < dwTime) {	
					m_pClientList[iClientH]->m_sV1++;	
				} 
				else {
					bIsBlocked = TRUE;
					m_pClientList[iClientH]->m_sV1 = 0;
				}
			}
		m_pClientList[iClientH]->m_iRecentWalkTime = dwTime;
		}
		if (bIsBlocked == FALSE) m_pClientList[iClientH]->m_iMoveMsgRecvCount++;
		if (m_pClientList[iClientH]->m_iMoveMsgRecvCount >= 3) {
			if (m_pClientList[iClientH]->m_dwMoveLAT != 0) {
				if ((dwTime - m_pClientList[iClientH]->m_dwMoveLAT) < (590)) {
					//wsprintf(G_cTxt, "3.51 Walk Speeder: (%s) Player: (%s) walk difference: %d. Speed Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, dwTime - m_pClientList[iClientH]->m_dwMoveLAT);
					//PutHackLogFileList(G_cTxt);
					bIsBlocked = TRUE;
				}
			}
			m_pClientList[iClientH]->m_dwMoveLAT = dwTime;
			m_pClientList[iClientH]->m_iMoveMsgRecvCount = 0;
		}
	}
	else if (cMoveType == 1) {
		if (m_pClientList[iClientH]->m_iRecentRunTime > dwTime) {
			m_pClientList[iClientH]->m_iRecentRunTime = dwTime;
			if (m_pClientList[iClientH]->m_sV1 < 1) {
				if (m_pClientList[iClientH]->m_iRecentRunTime < dwTime) {	
					m_pClientList[iClientH]->m_sV1++;	
				}
				else {
					bIsBlocked = TRUE;
					m_pClientList[iClientH]->m_sV1 = 0;
				}
			}
		m_pClientList[iClientH]->m_iRecentRunTime = dwTime;
		}
		if (bIsBlocked == FALSE) m_pClientList[iClientH]->m_iRunMsgRecvCount++;
		if (m_pClientList[iClientH]->m_iRunMsgRecvCount >= 3) {
			if (m_pClientList[iClientH]->m_dwRunLAT != 0) {
				if ((dwTime - m_pClientList[iClientH]->m_dwRunLAT) < (290)) {
					//wsprintf(G_cTxt, "3.51 Run Speeder: (%s) Player: (%s) run difference: %d. Speed Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, dwTime - m_pClientList[iClientH]->m_dwRunLAT);
					//PutHackLogFileList(G_cTxt);
					bIsBlocked = TRUE;
				}
			}
			m_pClientList[iClientH]->m_dwRunLAT	= dwTime;
			m_pClientList[iClientH]->m_iRunMsgRecvCount = 0;
		}
	}*/

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	
	ClearSkillUsingStatus(iClientH);
	
	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}

	pTopItem = 0;
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(dX, dY, &sDOtype, &pTopItem);
	
	if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_HOLDOBJECT] != 0)
		bRet = FALSE;
  
	if ((bRet == TRUE) && (bIsBlocked == FALSE)) {
		if (m_pClientList[iClientH]->m_iQuest != NULL) _bCheckIsQuestCompleted(iClientH);

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

		m_pClientList[iClientH]->m_sX   = dX;
		m_pClientList[iClientH]->m_sY   = dY;
		m_pClientList[iClientH]->m_cDir = cDir;

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner((short)iClientH,
			                                                       DEF_OWNERTYPE_PLAYER,
																   dX, dY);

		if (sDOtype == DEF_DYNAMICOBJECT_SPIKE) {
			if ((m_pClientList[iClientH]->m_bIsNeutral == TRUE) && ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0)) {

			}
			else {
				iDamage = iDice(2,4);

				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
					m_pClientList[iClientH]->m_iHP -= iDamage;
			}
		}
		
		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOVE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);
		
		sp  = (short *)cp;
		*sp = (short)(dX - 10); 
		cp += 2;
		
		sp  = (short *)cp;
		*sp = (short)(dY - 7); 
		cp += 2;
		
		*cp = cDir;
		cp++;
		
		if (cMoveType == 1) {
			if (m_pClientList[iClientH]->m_iSP > 0) {
				*cp = 0;
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
			}
			else {
				*cp = 0;
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
				if (m_pClientList[iClientH]->m_iSP < -10) {
					m_pClientList[iClientH]->m_iSP = 0;
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
				}
			}
		}
		else *cp = 0;
		cp++;
		
		pTile = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + dX + dY*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
		*cp = (char)pTile->m_iOccupyStatus;
		cp++;
		
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iHP;
		cp += 4;
		
		iSize = iComposeMoveMapData((short)(dX - 10), (short)(dY - 7), iClientH, cDir, cp);	
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
		/*if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->3CA18h == TRUE) {
			
			.text:00406037                 mov     [ebp+var_C1C], 0
			.text:0040603E                 xor     edx, edx
			.text:00406040                 mov     [ebp+var_C1B], edx
			.text:00406046                 mov     [ebp+var_C17], edx
			.text:0040604C                 mov     [ebp+var_C13], dx
			
			bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->sub_4C0F20(dX, dY, cTemp, wV1, wV2);
			if (bRet == 1) {
				RequestTeleportHandler(iClientH, "2   ", cTemp, wV1, wV2);
			}
		}*/
	}
	else {
		m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE;

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOVE_REJECT;
		if (bIsBlocked == TRUE) {
			m_pClientList[iClientH]->m_dwAttackLAT = 1050;
		}
		m_pClientList[iClientH]->m_dwAttackLAT = 1010;

		wObjectID = (WORD)iClientH;

		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		wp  = (WORD *)cp;
		*wp = wObjectID;
		cp += 2;

		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;

		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;

		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;

		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;

		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;

		ip  = (int *)cp;
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp+= 4;

		ip  = (int *)cp;
		sTemp = m_pClientList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp;
		sTemp2 = iGetPlayerABSStatus(wObjectID, iClientH);
		sTemp  = (sTemp | (sTemp2 << 28));
		*ip = sTemp;
		cp += 4;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 42);
		
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
		return 0;
	}

	return 1;
}

void CGame::RequestInitPlayerHandler(int iClientH, char * pData, char cKey)
{
 register int i;
 char * cp, cCharName[11], cAccountName[11], cAccountPassword[11], cTxt[120];
 BOOL bIsObserverMode;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return;

	// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Ã€ÃŒÂ¸Â§, Â°Ã¨ÃÂ¤Ã€Ã‡ Ã€ÃŒÂ¸Â§, Ã†ÃÂ½ÂºÂ¿Ã¶ÂµÃ¥Â¸Â¦ Â±Ã¢Â·ÃÃ‡ÃÂ°Ã­ Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â·Ã Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® ÂµÂ¥Ã€ÃŒÃ…Ã Ã€Ã¼Â¼Ã›Ã€Â» Â¿Ã¤ÃƒÂ»Ã‡Ã‘Â´Ã™.

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	ZeroMemory(m_pClientList[iClientH]->m_cCharName, sizeof(m_pClientList[iClientH]->m_cCharName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountName, sizeof(m_pClientList[iClientH]->m_cAccountName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountPassword, sizeof(m_pClientList[iClientH]->m_cAccountPassword));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cCharName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cCharName, sizeof(cCharName));
	memcpy(cCharName, cTxt, 10);

	//testcode
	if (strlen(cTxt) == 0) PutLogList("RIPH - cTxt: Char NULL!");

	memcpy(cAccountName, cp, 10);
	cp += 10;
	
	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountName, sizeof(cAccountName));
	memcpy(cAccountName, cTxt, 10);

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountPassword, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	memcpy(cAccountPassword, cTxt, 10);
	
	bIsObserverMode = (BOOL)*cp;
	cp++;

	// ÃÃŸÂºÂ¹ÂµÃˆ Â°Ã¨ÃÂ¤Ã€Â» Â°Â®Â°Ã­Ã€Ã–Â´Ã‚ Ã„Â³Â¸Â¯Ã…ÃÂ¸Â¦ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cAccountName, cAccountName, 10) == 0)) {
		// Ã†ÃÂ½ÂºÂ¿Ã¶ÂµÃ¥Â°Â¡ Ã€ÃÃ„Â¡Ã‡ÃÂ¸Ã© Â¶Ã•Â°Ã­ ÂµÃ©Â¾Ã®Â°Â¥ Â¼Ã¶ Ã€Ã–Â´Ã™. Â±Ã—Â·Â¯Â³Âª Â´Ã™Â¸Â£Â¸Ã© ÃÂ¢Â¼Ã“ ÂºÃ’Â°Â¡. 
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) { 
			// Ã†ÃÂ½ÂºÂ¿Ã¶ÂµÃ¥Â°Â¡ Ã€ÃÃ„Â¡Ã‡Ã‘Â´Ã™. 
			wsprintf(G_cTxt, "<%d> Duplicate account player! Deleted with data save : CharName(%s) AccntName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);
			//PutLogFileList(G_cTxt);
			DeleteClient(i, TRUE, TRUE, FALSE);	// 3Â¹Ã¸Ã‚Â° FALSE:Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â·Ã Ã„Â«Â¿Ã®Ã†Ãƒ Â´Ã™Â¿Ã®Ã€Âº Ã‡ÃÃÃ¶ Â¸Â»Â¶Ã³Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ 
		}
		else {
			// v1.4 Â°Ã¨ÃÂ¤ ÃÂ¤ÂºÂ¸Â¸Â¦ Ã€Ã”Â·Ã‚Ã‡Ã˜Â¾ÃŸ Â·ÃÂ±Ã—Ã€Ã Â¼Â­Â¹Ã¶Â·Ã Ã…Ã«ÂºÂ¸Â°Â¡ Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™.  
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
			
			// Ã†ÃÂ½ÂºÂ¿Ã¶ÂµÃ¥Â°Â¡ Ã€ÃÃ„Â¡Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.  ÃÂ¢Â¼Ã“ ÂºÃ’Â°Â¡. 
			DeleteClient(iClientH, FALSE, FALSE, FALSE);
			return;
		}
	}	
	
	// ÃÃŸÂºÂ¹ÂµÃˆ Ã€ÃŒÂ¸Â§Ã€Â» Â°Â®Â°Ã­ Ã€Ã–Â´Ã‚ Ã„Â³Â¸Â¯Ã…ÃÂ°Â¡ Ã€Ã–Â´Ã™Â¸Ã© Â¸Â¶Ã‚Ã¹Â°Â¡ÃÃ¶Â·Ã Â»Ã¨ÃÂ¦ 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
		// Ã†ÃÂ½ÂºÂ¿Ã¶ÂµÃ¥Â°Â¡ Ã€ÃÃ„Â¡Ã‡ÃÂ¸Ã© Â¶Ã•Â°Ã­ ÂµÃ©Â¾Ã®Â°Â¥ Â¼Ã¶ Ã€Ã–Â´Ã™. Â±Ã—Â·Â¯Â³Âª Â´Ã™Â¸Â£Â¸Ã© ÃÂ¢Â¼Ã“ ÂºÃ’Â°Â¡. 
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) { 
			wsprintf(G_cTxt, "<%d> Duplicate player! Deleted with data save : CharName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);
			//PutLogFileList(G_cTxt);
			DeleteClient(i, TRUE, TRUE, FALSE);	
		}
		else {
			// v1.4 Â°Ã¨ÃÂ¤ ÃÂ¤ÂºÂ¸Â¸Â¦ Ã€Ã”Â·Ã‚Ã‡Ã˜Â¾ÃŸ Â·ÃÂ±Ã—Ã€Ã Â¼Â­Â¹Ã¶Â·Ã Ã…Ã«ÂºÂ¸Â°Â¡ Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™.  
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
			
			// Ã†ÃÂ½ÂºÂ¿Ã¶ÂµÃ¥Â°Â¡ Ã€ÃÃ„Â¡Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.  ÃÂ¢Â¼Ã“ ÂºÃ’Â°Â¡. 
			DeleteClient(iClientH, FALSE, FALSE);
			return;
		}
	}

	// ÃÂ¤ÂºÂ¸ Ã€Ã”Â·Ã‚  
	memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
	
	m_pClientList[iClientH]->m_bIsObserverMode = bIsObserverMode;
		
	// Log ServerÂ·Ã ÂµÂ¥Ã€ÃŒÃ…Ã Â¿Ã¤ÃƒÂ» Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™. 
	bSendMsgToLS(MSGID_REQUEST_PLAYERDATA, iClientH);
}

// 05/22/2004 - Hypnotoad - sends client to proper location after dieing
void CGame::RequestInitDataHandler(int iClientH, char * pData, char cKey)
{
	char  * pBuffer = NULL;
	short * sp;
	DWORD * dwp;
	WORD  * wp;
	char  * cp, cPlayerName[11], cTxt[120], sSummonPoints;
	int   * ip, i, iTotalItemA, iTotalItemB, iSize, iRet, iStats;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;

	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);

	// Ã­Å¡â€Ã­Å¡Å“Ã­Å¡â€Ã­Å¡Å½ Ã­Å¡ÂÃ¬Â§â€“Ã¬Â©Å’Ã­Å¡â„¢ Ã¬Â¨â€°Ã¬Â§Å“?Ã­Å¡â€˜Ã­Å¡â€¡Ã­Å¡â€™Ã¬Â¨ÂÃ¬Â§Â ?Ã¬Â²Â´Ã¬Â©Å’Ã­Å¡Â¤Ã­Å¡â€°Ã­Å¡Â  Ã­Å¡ÂÃ­Å¡Â Ã¬Â¨Ë†Ã­Å¡Â¢. Ã¬Â©â€Ã¬Â§Â¤Ã¬Â§Â¹Ã¬Â°Â½Ã¬Â©Å’Ã¬Â§Â¯ ?Ã­Å¡â€˜Ã¬Â¨ÂÃ¬Â§Â ?Ã­Å¡â€˜ ?Ã­Å¡â€¢Ã­Å¡â€ Ã¬Â§â€¢Ã­Å¡â€°Ã­Å¡â€¢Ã¬Â¨Ë†Ã­Å¡â€šÃ­Å¡ÂÃ¬Â²Â  Ã­Å¡Å Ã¬Â§Â°?Ã­Å¡â€œÃ­Å¡â€°Ã­Å¡Ëœ Ã¬Â©Å’Ã¬Â²Â Ã¬Â¨â€°Ã¬Â¨â€° ?Ã­Å¡Å“Ã¬Â¨Ë†Ã­Å¡Â¢.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, cp, 10);

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cPlayerName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, cTxt, 10);

	// ?Ã­Å¡â€˜Ã¬Â¨ÂÃ¬Â§Â ?Ã­Å¡â€˜ ?Ã­Å¡â€¢Ã­Å¡â€ Ã¬Â§â€¢Ã­Å¡â€°Ã­Å¡â€¢Ã¬Â¨Ë†Ã­Å¡â€šÃ­Å¡ÂÃ¬Â²Â  Ã¬Â§Â¸Ã­Å¡ÂÃ¬Â¨Â©Ã¬Â±Å’Ã­Å¡â€°Ã­Å¡â€”Ã¬Â¨Ë†Ã­Å¡Â¢. ?Ã­Å¡â€¢Ã­Å¡â€ Ã¬Â§â€¢Ã­Å¡â€°Ã­Å¡â€¢Ã­Å¡ÂÃ¬Â²Â  Ã¬Â©ÂÃ­Å¡Å½?Ã¬Â¨ÂÃ¬Â¨ÂÃ¬Â±â€¢ Ã¬Â¨Â©Ã¬Â±â€Ã­Å¡ÂÃ¬Â§ÂÃ­Å¡â€°Ã­Å¡â€¢Ã¬Â§Â¸Ã¬Â±Â  Ã¬Â§Â¹Ã­Å¡â€™Ã­Å¡Å Ã¬Â§Â±Ã­Å¡â€°Ã­Å¡â€”Ã¬Â¨Ë†Ã­Å¡Â¢. 
	if (memcmp(m_pClientList[iClientH]->m_cCharName, cPlayerName, 10) != 0) {
		DeleteClient(iClientH, FALSE, TRUE);
		return;
	}

	// Ã­Å¡â€ Ã¬Â¨â‚¬Ã¬Â¨ÂÃ¬Â§Â±Ã­Å¡â€¡Ã­Å¡â€™?Ã­Å¡â€° Ã¬Â©ÂÃ­Å¡â€¡Ã¬Â¨Â©Ã¬Â²ËœÃ­Å¡ÂÃ¬Â§Å¡Ã¬Â¨ËœÃ¬Â¨ÂÃ¬Â¨ÂÃ¬Â§Â ?Ã¬Â²Â´Ã¬Â©Å’Ã­Å¡Â¤Ã­Å¡â€°Ã­Å¡â€”Ã¬Â¨Ë†Ã­Å¡Â¢.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERCHARACTERCONTENTS; // 0x0Fm_cHeldenianVictoryType000 = 262406144
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iSP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDefenseRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHitRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iLevel;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iStr;		
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iInt;					
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iVit;								
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDex;			
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMag;						
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iCharisma;
	cp  += 4;

	iStats = (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +  
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma); 

	m_pClientList[iClientH]->m_iLU_Pool =  m_pClientList[iClientH]->m_iLevel*3 - (iStats - 70);
	wp = (WORD *)cp; 
	//*wp = m_pClientList[iClientH]->m_iLevel*3 - (iStats - 70); 
	*wp = m_pClientList[iClientH]->m_iLU_Pool;
	cp += 2;

	*cp = m_pClientList[iClientH]->m_cVar;
	cp++;

	*cp = 0;
	cp++;

	*cp = 0;
	cp++;

	*cp = 0;
	cp++;

	*cp = 0;
	cp++;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iExp;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iEnemyKillCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iPKCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iRewardGold;
	cp  += 4;

	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp  += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
	cp  += 20;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iGuildRank;
	cp  += 4;

	// v1.4311
	*cp = (char)m_pClientList[iClientH]->m_iSuperAttackLeft;
	cp++;

	// v1.4311-3 Ã­Å¡â€Ã­Å¡Â©Ã¬Â§Â¸Ã¬Â§â€¢ Ã¬Â¨Â©Ã¬Â±Å’Ã­Å¡â€¡Ã¬Â²Å“?Ã¬Â±â€¦Ã¬Â©â€Ã¬Â¨â€Ã¬Â©ÂÃ­Å¡Âª Ã¬Â©â€Ã¬Â§Â¤Ã¬Â¨ËœÃ­Å¡â€œÃ¬Â¨ÂÃ¬Â§Â Ã­Å¡â€¡Ã¬Â§Â­Ã¬Â¨â€¹Ã¬Â²Ëœ?Ã­Å¡â€˜Ã¬Â©ÂÃ¬Â±Â¨Ã­Å¡Ë†Ã¬Â§Â°Ã¬Â©â€Ã¬Â§â€¢ Ã¬Â¨ËœÃ¬Â¨ÂÃ¬Â¨â‚¬Ã¬Â©ÂÃ¬Â¨Ë†Ã­Å¡Â¢.
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iFightzoneNumber;
	cp  += 4;

	//Syntax : ======HP==MP==SP==DRatHRatLVL=STR=INT=VIT=DEX=MAG=CHR=LUstatEXP=EK==PK==RewaLocation==GuildName=RankAF
	//Syntax : 1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
	//Syntax : ......145212521152........376.200=200=200=200=200=195=......big.8...17......aresden...NONE......NONE30
	// 0x0Fm_cHeldenianVictoryType000 = 262406144
	// Ã¬Â¨ÂÃ­Å¡Â§Ã¬Â©ÂÃ­Å¡â€Ã­Å¡ÂÃ¬Â²Â  ?Ã¬Â²Â´Ã¬Â©Å’Ã­Å¡Â¤ 

	//Debug Event
	//DbgWnd->AddEventMsg(MSG_SEND,pBuffer,180,0);

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 118);// Original : 115
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Ã¬Â¨ÂÃ­Å¡Â§Ã¬Â©ÂÃ­Å¡â€Ã­Å¡ÂÃ¬Â²Â Ã¬Â¨ÂÃ¬Â§Â Ã¬Â¨ËœÃ¬Â¨ÂÃ¬Â¨â‚¬Ã¬Â©ÂÃ¬Â¨â€¹Ã¬Â§Â  Ã¬Â©â€Ã¬Â§â€¢Ã¬Â¨Å’Ã¬Â§Â±Ã¬Â§Â¸Ã¬Â§â€¢ Ã¬Â¨â€Ã­Å¡Â©Ã¬Â¨Â©Ã¬Â²ÂµÃ­Å¡â€°Ã­Å¡Â©Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨ÂÃ¬Â±â€¢ Ã­Å¡ÂÃ¬Â§ÂÃ¬Â§Â¸Ã­Å¡â€¡Ã­Å¡â€°Ã­Å¡â€”Ã¬Â¨Ë†Ã­Å¡Â¢.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	// Ã­Å¡â€ Ã¬Â¨â‚¬Ã¬Â¨ÂÃ¬Â§Â±Ã­Å¡â€¡Ã­Å¡â€™?Ã­Å¡â€° Ã¬Â©ÂÃ­Å¡Ë†?Ã­Å¡â€˜Ã­Å¡â€¡Ã­Å¡Â¤ Ã­Å¡ÂÃ¬Â§Å¡Ã¬Â¨ËœÃ¬Â¨ÂÃ¬Â¨ÂÃ¬Â§Â ?Ã¬Â²Â´Ã¬Â©Å’Ã­Å¡Â¤Ã­Å¡â€°Ã­Å¡â€”Ã¬Â¨Ë†Ã­Å¡Â¢. 
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERITEMLISTCONTENTS;
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	// Ã¬Â¨ÂÃ­Å¡â€º?Ã¬Â²Â¬ Ã¬Â©Å’Ã­Å¡ËœÃ­Å¡ÂÃ¬Â²Â Ã­Å¡â€°Ã­Å¡â€¢Ã¬Â§Â¸Ã¬Â±Â  ?Ã­Å¡Å“Ã¬Â¨Ë†Ã­Å¡â€š Ã¬Â©ÂÃ­Å¡Ë†?Ã­Å¡â€˜Ã­Å¡â€¡Ã­Å¡Â¤ 
	// Ã¬Â©ÂÃ­Å¡Ë†?Ã­Å¡â€˜Ã­Å¡â€¡Ã­Å¡Â¤?Ã­Å¡â€° Ã­Å¡â€Ã­Å¡â€” Ã¬Â§Â¸Ã¬Â¨â€Ã¬Â©Å’Ã¬Â²Â  
	iTotalItemA = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
			iTotalItemA++;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	*cp = iTotalItemA;
	cp++;

	for (i = 0; i < iTotalItemA; i++) {
		// ### ERROR POINT!!!
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
			// Ã¬Â©â€Ã¬Â§â€¢Ã¬Â¨Å’Ã¬Â§Â± Ã¬Â¨â€Ã¬Â±Ë†Ã­Å¡ÂÃ¬Â²Â Ã¬Â©â€Ã¬Â±Ëœ Ã­Å¡â€ Ã­Å¡Â£Ã¬Â¨â€°Ã¬Â±â€¦?Ã­Å¡â€˜Ã¬Â¨Ë†Ã­Å¡Â¢. Ã¬Â¨â€Ã¬Â§Â°Ã­Å¡ÂÃ¬Â§ÂÃ¬Â§Â¸Ã¬Â§â€¢ ?Ã­Å¡Å“Ã¬Â¨Ë†Ã­Å¡â€š Ã­Å¡â€ Ã¬Â¨â‚¬Ã¬Â¨ÂÃ¬Â§Â±Ã­Å¡â€¡Ã­Å¡â€™?Ã­Å¡â€° Ã¬Â¨â€°Ã¬Â§Å“?Ã­Å¡â€˜Ã­Å¡â€¡Ã­Å¡â€™Ã¬Â¨ÂÃ¬Â§Â Ã¬Â¨ËœÃ­Å¡â€“Ã¬Â©Å’Ã¬Â§Â°Ã­Å¡â€°Ã­Å¡ËœÃ¬Â§Â¸Ã­Å¡â€™. Ã¬Â©â€Ã­Å¡Å“ Ã¬Â¨â‚¬Ã­Å¡â€œ?Ã­Å¡â€¢Ã¬Â§Â¹Ã¬Â±Â¤?
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_bIsItemEquipped[i];
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute & 0x00000001); // Custom-Item?Ã­Å¡â€œÃ­Å¡ÂÃ¬Â²Â ?Ã­Å¡â€° Ã¬Â©â€Ã¬Â§Â¤Ã¬Â¨ËœÃ­Å¡â€œ 
		cp++;
		*/
	}

	// Ã¬Â¨Ë†Ã­Å¡Â¢?Ã¬Â©Â Ã¬Â¨ËœÃ¬Â¨ÂÃ¬Â§Â¸Ã¬Â²Â´Ã­Å¡ÂÃ­Å¡Â©?Ã­Å¡â€œ Ã¬Â©ÂÃ­Å¡Ë†?Ã­Å¡â€˜Ã­Å¡â€¡Ã­Å¡Â¤ 
	// Ã¬Â©ÂÃ­Å¡Ë†?Ã­Å¡â€˜Ã­Å¡â€¡Ã­Å¡Â¤?Ã­Å¡â€° Ã­Å¡â€Ã­Å¡â€” Ã¬Â§Â¸Ã¬Â¨â€Ã¬Â©Å’Ã¬Â²Â  
	iTotalItemB = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) 
			iTotalItemB++;

	*cp = iTotalItemB;
	cp++;

	for (i = 0; i < iTotalItemB; i++) {
		// ### ?Ã­Å¡â€°Ã¬Â©ÂÃ­Å¡â€¹Ã¬Â©ÂÃ¬Â¨ËœÃ¬Â¨Å’Ã¬Â§Â±Ã¬Â©â€Ã¬Â±Â¤ ERROR POINT
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
			// Ã¬Â©â€Ã¬Â§â€¢Ã¬Â¨Å’Ã¬Â§Â± Ã¬Â¨â€Ã¬Â±Ë†Ã­Å¡ÂÃ¬Â²Â Ã¬Â©â€Ã¬Â±Ëœ Ã­Å¡â€ Ã­Å¡Â£Ã¬Â¨â€°Ã¬Â±â€¦?Ã­Å¡â€˜Ã¬Â¨Ë†Ã­Å¡Â¢. Ã¬Â¨â€Ã¬Â§Â°Ã­Å¡ÂÃ¬Â§ÂÃ¬Â§Â¸Ã¬Â§â€¢ ?Ã­Å¡Å“Ã¬Â¨Ë†Ã­Å¡â€š Ã­Å¡â€ Ã¬Â¨â‚¬Ã¬Â¨ÂÃ¬Â§Â±Ã­Å¡â€¡Ã­Å¡â€™?Ã­Å¡â€° Ã¬Â¨â€°Ã¬Â§Å“?Ã­Å¡â€˜Ã­Å¡â€¡Ã­Å¡â€™Ã¬Â¨ÂÃ¬Â§Â Ã¬Â¨ËœÃ­Å¡â€“Ã¬Â©Å’Ã¬Â§Â°Ã­Å¡â€°Ã­Å¡ËœÃ¬Â§Â¸Ã­Å¡â€™. Ã¬Â©â€Ã­Å¡Å“ Ã¬Â¨â‚¬Ã­Å¡â€œ?Ã­Å¡â€¢Ã¬Â§Â¹Ã¬Â±Â¤?
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Bank-Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cEquipPos;
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute & 0x00000001); // Custom-Item?Ã­Å¡â€œÃ­Å¡ÂÃ¬Â²Â ?Ã­Å¡â€° Ã¬Â©â€Ã¬Â§Â¤Ã¬Â¨ËœÃ­Å¡â€œ 
		cp++;
		*/
	}

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cMagicMastery[i];
		cp++;
	}

	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cSkillMastery[i];
		cp++;
	}

	// Ã¬Â©ÂÃ­Å¡Ë†?Ã­Å¡â€˜Ã­Å¡â€¡Ã­Å¡Â¤ Ã­Å¡ÂÃ¬Â§Å¡Ã¬Â¨ËœÃ¬Â¨Â ?Ã¬Â²Â´Ã¬Â©Å’Ã­Å¡Â¤ 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + 1 + iTotalItemA*44 + iTotalItemB*43 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Ã¬Â¨ÂÃ­Å¡Â§Ã¬Â©ÂÃ­Å¡â€Ã­Å¡ÂÃ¬Â²Â Ã¬Â¨ÂÃ¬Â§Â Ã¬Â¨ËœÃ¬Â¨ÂÃ¬Â¨â‚¬Ã¬Â©ÂÃ¬Â¨â€¹Ã¬Â§Â  Ã¬Â©â€Ã¬Â§â€¢Ã¬Â¨Å’Ã¬Â§Â±Ã¬Â§Â¸Ã¬Â§â€¢ Ã¬Â¨â€Ã­Å¡Â©Ã¬Â¨Â©Ã¬Â²ÂµÃ­Å¡â€°Ã­Å¡Â©Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨ÂÃ¬Â±â€¢ Ã­Å¡ÂÃ¬Â§ÂÃ¬Â§Â¸Ã­Å¡â€¡Ã­Å¡â€°Ã­Å¡â€”Ã¬Â¨Ë†Ã­Å¡Â¢.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	// Ã¬Â¨ÂÃ­Å¡Å½Ã¬Â¨â€°Ã¬Â§Å“?Ã­Å¡â€˜Ã­Å¡â€¡Ã­Å¡â€™Ã¬Â¨ÂÃ¬Â§Â ?Ã¬Â²Â´Ã¬Â©Å’Ã­Å¡Â¤Ã­Å¡â€°Ã­Å¡â€”Ã¬Â¨Ë†Ã­Å¡Â¢.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	// Ã­Å¡â€°Ã­Å¡â€Ã¬Â¨Å’Ã¬Â¨â€?Ã­Å¡â€˜Ã¬Â©ÂÃ¬Â±Â¤?Ã­Å¡â€° ?Ã¬Â§Â Ã­Å¡â€ Ã¬Â§â€¢Ã¬Â¨ÂÃ¬Â§Â Ã­Å¡Å Ã¬Â§Â°Ã­Å¡ÂÃ¬Â§Å¡Ã­Å¡â€°Ã­Å¡â€”Ã¬Â¨Ë†Ã­Å¡Â¢. v1.41 Ã¬Â§Â¸Ã¬Â²Â´Ã¬Â¨â€¹Ã¬Â²Â¨?Ã­Å¡Â£ Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦Ã¬Â¨â€¹Ã¬Â²ËœÃ¬Â¨ÂÃ¬Â±â€¢ Ã¬Â§Â¹Ã­Å¡Å¾?Ã¬Â§Â Ã­Å¡â€ Ã¬Â§â€¢ Ã¬Â§Â¹Ã­Å¡Å¾Ã¬Â¨Ë†Ã¬Â±ËœÃ¬Â¨Å’Ã­Å¡â€œ Ã¬Â¨â‚¬Ã¬Â²Å“Ã¬Â¨Ë†Ã­Å¡â€šÃ¬Â¨Ë†Ã­Å¡Â¢.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// ObjectID
	wp  = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	// ?Ã¬Â²Â´Ã¬Â©Å’Ã­Å¡Â¤Ã­Å¡â€°Ã­Å¡Ëœ Ã¬Â¨ÂÃ­Å¡Å½ Ã¬Â¨â€°Ã¬Â§Å“?Ã­Å¡â€˜Ã­Å¡â€¡Ã­Å¡â€™?Ã­Å¡â€° Ã¬Â§Â¹Ã¬Â°Â½Ã­Å¡ÂÃ­Å¡Â ?Ã¬Â§Â Ã­Å¡â€ Ã¬Â§â€¢. Ã­Å¡â€°Ã­Å¡â€Ã¬Â¨Å’Ã¬Â¨â€?Ã­Å¡â€˜Ã¬Â©ÂÃ¬Â±Â¤Ã¬Â¨Ë†Ã­Å¡â€š Ã¬Â§Â¹Ã¬Â°Â½Ã­Å¡ÂÃ­Å¡Â ?Ã¬Â§Â Ã­Å¡â€ Ã¬Â§â€¢ (x, y)Ã¬Â¨Å’Ã­Å¡â€œÃ¬Â¨ËœÃ­Å¡â€œÃ­Å¡â€¡Ã­Å¡â€™ (x+14, y+12)Ã¬Â©â€Ã¬Â§â€¢ ?Ã¬Â§Â Ã­Å¡â€ Ã¬Â§â€¢Ã­Å¡â€°Ã­Å¡â€”Ã¬Â¨Ë†Ã­Å¡Â¢.
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;

	ip  = (int *)cp; // v1.4
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;

	ip  = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iStatus;
	cp += 4;// Original : 2

	// (!) Ã­Å¡â€°Ã­Å¡â€Ã¬Â¨Å’Ã¬Â¨â€?Ã­Å¡â€˜Ã¬Â©ÂÃ¬Â±Â¤Ã¬Â§Â¸Ã¬Â§â€¢ ?Ã¬Â§Â Ã­Å¡â€ Ã¬Â§â€¢Ã­Å¡â€°Ã­Å¡â€¢Ã¬Â¨Ë†Ã­Å¡â€š Ã¬Â¨ÂÃ­Å¡Å½?Ã­Å¡â€˜Ã¬Â¨ÂÃ¬Â§Â ?Ã¬Â¨Â© Ã¬Â§Â¹Ã¬Â°Â½Ã¬Â¨Å’Ã­Å¡â€¢Ã­Å¡â€°Ã­Å¡â€”Ã¬Â¨Ë†Ã­Å¡Â¢.
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	// Ã¬Â¨ÂÃ¬Â±Â Ã­Å¡â€ Ã¬Â§Â§Ã¬Â¨Â©Ã¬Â²Ëœ?Ã­Å¡â€° Ã¬Â¨ÂÃ­Å¡Å½ ?Ã­Å¡â€˜Ã¬Â¨ÂÃ¬Â§Â ?Ã¬Â¨Â© ?Ã­Å¡Å¡Ã¬Â¨Å’Ã­Å¡â€šÃ­Å¡â€°Ã­Å¡â€”Ã¬Â¨Ë†Ã­Å¡Â¢. 
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	// Ã­Å¡ÂÃ­Å¡Å“Ã¬Â©ÂÃ­Å¡Â©Ã¬Â§Â¸Ã¬Â§â„¢ Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦Ã¬Â¨ÂÃ¬Â§Â Ã¬Â¨Â©Ã¬Â±Â¨?Ã­Å¡Å¡ 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		*cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	// Ã¬Â§Â¹Ã¬Â°Â½Ã¬Â¨Â©Ã¬Â²Ëœ Ã¬Â¨Â©Ã¬Â²ËœÃ­Å¡â€¡Ã­Å¡â€š Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦Ã¬Â¨ÂÃ¬Â§Â Ã¬Â¨Â©Ã¬Â±Â¨?Ã­Å¡Å¡ 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		*cp = NULL;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	// v1.4 Contribution
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;

	// @@@ Ã­Å¡â€°Ã­Å¡â€Ã¬Â¨Å’Ã¬Â¨â€?Ã­Å¡â€˜Ã¬Â©ÂÃ¬Â±Â¤Ã¬Â¨ÂÃ¬Â§Â Ã¬Â¨ÂÃ­Å¡Å½Ã¬Â¨Â©Ã¬Â²ËœÃ¬Â©â€Ã¬Â§â€¢ Ã­Å¡â€Ã­Å¡Å“Ã­Å¡â€Ã­Å¡Å½Ã¬Â¨Å’Ã­Å¡â€œ ?Ã¬Â§Â Ã­Å¡â€ Ã¬Â§â€¢Ã¬Â©ÂÃ­Å¡â€Ã­Å¡â€¡Ã¬Â§Â¼Ã¬Â¨Ë†Ã­Å¡Â¢.

	// v1.41 Ã¬Â©â€Ã¬Â§Â¤Ã¬Â§Â¹Ã¬Â°Â½Ã¬Â©Å’Ã¬Â§Â¯ Ã¬Â§Â¸Ã¬Â²Â´Ã¬Â¨â€¹Ã¬Â²Â¨?Ã­Å¡Â£ Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦Ã¬Â¨â€¹Ã¬Â²ËœÃ¬Â¨ÂÃ¬Â±â€¢ ?Ã¬Â§Â Ã­Å¡â€ Ã¬Â§â€¢Ã¬Â©ÂÃ­Å¡â€Ã­Å¡â€¡Ã¬Â§Â¸Ã­Å¡ÂÃ¬Â²Â  Ã¬Â©ÂÃ­Å¡Å½Ã¬Â¨Ë†Ã­Å¡â€šÃ¬Â¨Ë†Ã­Å¡Â¢. 
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, 
			DEF_OWNERTYPE_PLAYER, 
			m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY);
	}

	// v1.41
	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;
	// catches debug on player load up

	// v1.41 
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	// v1.44
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;

	//Unknown variable
	*cp = 0;
	cp++;

	// Ã¬Â¨ÂÃ­Å¡Å½?Ã­Å¡â€° Ã­Å¡ÂÃ¬Â§Å¡Ã¬Â¨ËœÃ¬Â¨ÂÃ¬Â¨ÂÃ¬Â§Â Ã­Å¡â€Ã­Å¡Â©Ã¬Â§Â¸Ã¬Â§â€¢Ã­Å¡â€°Ã­Å¡â€”Ã¬Â¨Ë†Ã­Å¡Â¢. 
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp );

	// Ã¬Â¨ÂÃ­Å¡Â§Ã¬Â©ÂÃ­Å¡â€Ã­Å¡ÂÃ¬Â²Â  ?Ã¬Â²Â´Ã¬Â©Å’Ã­Å¡Â¤ 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4+3); // Zabuza fix
	//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 59 + iSize +4 +4 +1 +4 +4); // v1.41
	//	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4); // v1.41
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Ã¬Â¨ÂÃ­Å¡Â§Ã¬Â©ÂÃ­Å¡â€Ã­Å¡ÂÃ¬Â²Â Ã¬Â¨ÂÃ¬Â§Â Ã¬Â¨ËœÃ¬Â¨ÂÃ¬Â¨â‚¬Ã¬Â©ÂÃ¬Â¨â€¹Ã¬Â§Â  Ã¬Â©â€Ã¬Â§â€¢Ã¬Â¨Å’Ã¬Â§Â±Ã¬Â§Â¸Ã¬Â§â€¢ Ã¬Â¨â€Ã­Å¡Â©Ã¬Â¨Â©Ã¬Â²ÂµÃ­Å¡â€°Ã­Å¡Â©Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨ÂÃ¬Â±â€¢ Ã­Å¡ÂÃ¬Â§ÂÃ¬Â§Â¸Ã­Å¡â€¡Ã­Å¡â€°Ã­Å¡â€”Ã¬Â¨Ë†Ã­Å¡Â¢.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	if(pBuffer != NULL) delete pBuffer;

	// Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨ÂÃ¬Â§Å“ Ã­Å¡â€¡Ã¬Â§Â­Ã¬Â¨â€¹Ã¬Â²Ëœ?Ã­Å¡â€˜Ã¬Â©ÂÃ¬Â±Â¨Ã­Å¡Ë†Ã¬Â§Â°Ã¬Â¨â€°Ã¬Â±â€¢Ã¬Â©â€Ã¬Â§â€¢Ã¬Â§Â¸Ã­Å¡Å¡ Ã¬Â¨Â©Ã¬Â²Å“ Ã­Å¡â€°Ã­Å¡â€Ã¬Â¨Å’Ã¬Â¨â€?Ã­Å¡â€˜Ã¬Â©ÂÃ¬Â±Â¤ Ã­Å¡ÂÃ¬Â§â€“Ã¬Â©Å’Ã­Å¡â„¢?Ã¬Â¨Â© Ã¬Â©ÂÃ­Å¡ÂÃ¬Â¨ÂÃ¬Â§Â¸Ã¬Â¨Ë†Ã­Å¡Â¢. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);

	// ÇÃ·¹ÀÌ¾î°¡ ´Ù¸¥ ¸Ê¿¡ µé¾î°¬´Ù. ¸¸¾à Àû±¹ÀÌ¶ó¸é ½Ã°£À» ¼³Á¤ÇÑ´Ù.
	// v2.13 ¿î¿µÀÚ´Â °­ÄİµÇÁö ¾Ê´Â´Ù. 
	if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		 && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) ) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		// v2.17 2002-7-15 °­Äİ ½Ã°£À» Á¶Àı ÇÒ ¼ö ÀÖ°Ô ¼öÁ¤ÇÑ´Ù.
		SetForceRecallTime(iClientH) ;
	}
	// v2.13 ¿î¿µÀÚ´Â °­ÄİµÇÁö ¾Ê´Â´Ù. 
	else if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		 && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// v2.17 2002-7-15 °­Äİ ½Ã°£À» Á¶Àı ÇÒ ¼ö ÀÖ°Ô ¼öÁ¤ÇÑ´Ù.
		SetForceRecallTime(iClientH) ;
	}
	else if (((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arejail", 7) == 0) || 
		   (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvjail", 7) == 0))
		      && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) { 
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();

		// v2.17 2002-7-15 
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ; 
		 // °­Äİ½Ã°£ÀÌ 5ºĞ º¸´Ù ±æ¸é 
		} else if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 20*5) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*5 ;  // 5ºĞ
		}

	}
	else if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) &&
		     (m_iFightzoneNoForceRecall == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) { 
		// ¿î¿µÀÚ°¡ °­Äİ¸ğµå¸¦ ¼³Á¤ÇÏÁö ¾Ê´Â°æ¿ì¿¡¸¸ °­ÄİÅ¸ÀÓÀÌ ¼³Á¤µÈ´Ù.
				
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// ³²¾ÆÀÖÀ» ¼ö ÀÖ´Â ÀÜÁ¸ ½Ã°£À» ¼³Á¤ÇØ ÁØ´Ù. 
		// 0 ½ÃºÎÅÍ 2½Ã°£ °£°İÀ¸·Î °è»êµÈ´Ù Áï 0½Ã¿¡ ÀÔÀåÇÏ¸é 2½Ã°£µ¿¾È ³²¾Æ ÀÖÀ»¼ö ÀÖ´Ù.
		// ¼­¹ö°£ÀÇ ½Ã°£ Â÷ÀÌ¸¦ °í·ÁÇÏ¿© ¿©À¯½Ã°£ 2ºĞ ÀÖ´Ù. Áï 2½Ã°£ µÇ±â 2ºĞÀüºÎÅÍ ¸®ÄİµÈ´Ù.
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20; 
	}
	else
	{
		m_pClientList[iClientH]->m_bIsWarLocation = FALSE;	
		// v1.42
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
		// 06/11/2004
		SetForceRecallTime(iClientH) ;
	}

	// v2.17 2002-7-15 °­Äİ ½Ã°£À» »ç¿ëÀÚ¿¡°Ô º¸¿©ÁØ´Ù.
	if ((m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) && (m_pClientList[iClientH]->m_bIsWarLocation == TRUE)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FORCERECALLTIME,  m_pClientList[iClientH]->m_iTimeLeft_ForceRecall , NULL, NULL, NULL);
		wsprintf(G_cTxt,"(!) Game Server Force Recall Time  %d (%d)min", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall/20) ;
		PutLogList(G_cTxt) ;
	}

	// No entering enemy shops
	int iMapside, iMapside2;

			iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
			if (iMapside > 3) iMapside2 = iMapside - 2;
			else iMapside2 = iMapside;
			m_pClientList[iClientH]->m_bIsInsideOwnTown = FALSE;
			if ((m_pClientList[iClientH]->m_cSide != iMapside2) && (iMapside != 0)) {
				if ((iMapside <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
					if (m_pClientList[iClientH]->m_cSide != 0) {
						m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
						m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
						m_pClientList[iClientH]->m_bIsInsideOwnTown = TRUE;
					}
				}
			}
			else{
				if (m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsFightZone == TRUE &&
					m_iFightzoneNoForceRecall == FALSE && 
					m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
						m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
						m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
						GetLocalTime(&SysTime);
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;
					}
				else{
					if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "arejail", 7) == 0 ||
						memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "elvjail", 7) == 0) {
							if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
								m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
								m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
								if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0)
									m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
								else if(m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 100)
									m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
							}
						}
				}
			}

			/*if ((m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0) && 
				(m_pClientList[iClientH]->m_bIsWarLocation == TRUE)) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FORCERECALLTIME, m_pClientList[iClientH]->m_iTimeLeft_ForceRecall, NULL, NULL, NULL);
			}*/

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);
			
			_SendQuestContents(iClientH);
			_CheckQuestEnvironment(iClientH);

			// v1.432
			if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
			}

			// Crusade Ã­Å¡â€°Ã¬Â²Â ?Ã¬Â±Å’ Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦ Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦?Ã­Å¡â€˜Ã¬Â§Â¸Ã¬Â±Â  Ã­Å¡â€°Ã­Å¡â€Ã¬Â¨Å’Ã¬Â¨â€?Ã­Å¡â€˜Ã¬Â©ÂÃ¬Â±Â¤?Ã­Å¡â€° CrusadeGUIDÃ¬Â§Â¸Ã¬Â§â€¢ 0 Ã­Å¡Å Ã¬Â§Å¡?Ã¬Â¨Ëœ Ã­Å¡â€°Ã¬Â²Â ?Ã¬Â±Å’Ã¬Â©â€Ã­Å¡â€™ Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨ÂÃ¬Â§â„¢Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨ÂÃ¬Â±â€¢ Ã­Å¡â€Ã¬Â¨â‚¬?Ã¬Â©Â Ã­Å¡â€°Ã­Å¡ËœÃ¬Â¨Ë†Ã¬Â±Å’Ã¬Â¨â€°Ã­Å¡â€°Ã¬Â¨Ë†Ã­Å¡â€š Ã¬Â§Â¸Ã­Å¡â€™?Ã­Å¡â€˜Ã¬Â¨Ë†Ã­Å¡Â¢. Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦ Ã¬Â©â€Ã¬Â§Â§Ã­Å¡â€°Ã­Å¡Ëœ Ã­Å¡â€Ã­Å¡Å½Ã¬Â§Â¹Ã¬Â°Â½Ã­Å¡Å Ã¬Â§Â¯.
			if (m_bIsCrusadeMode == TRUE) {
				if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
					// Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦?Ã­Å¡â€˜Ã¬Â§Â¸Ã¬Â±Â  Ã­Å¡â€°Ã­Å¡â€Ã¬Â¨Å’Ã¬Â¨â€?Ã­Å¡â€˜Ã¬Â©ÂÃ¬Â±Â¤?Ã­Å¡â€° GUIDÃ¬Â§Â¸Ã¬Â§â€¢ 0?Ã­Å¡â€˜Ã¬Â¨â€¹Ã¬Â²Å“ Ã¬Â§Â¸Ã­Å¡â€™?Ã¬Â¨Ëœ Ã­Å¡â€Ã¬Â¨â‚¬?Ã¬Â©Â Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦ Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦Ã¬Â©â€Ã¬Â§â€¢ Ã¬Â¨â€°Ã¬Â±â€¢Ã¬Â©ÂÃ¬Â±Â¤Ã¬Â©â€Ã­Å¡Å¡Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨Ë†Ã­Å¡â€š ?Ã­Å¡â€°Ã¬Â¨â€Ã­Å¡â€˜. Ã¬Â©â€Ã¬Â§Â§Ã­Å¡â€°Ã­Å¡Ëœ Ã­Å¡â€Ã­Å¡Å½Ã¬Â§Â¹Ã¬Â°Â½Ã­Å¡Å Ã¬Â§Â¯.
					m_pClientList[iClientH]->m_iCrusadeDuty = 0;
					m_pClientList[iClientH]->m_iConstructionPoint = 0;
					m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
				}
				else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
					// Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦?Ã­Å¡â€˜Ã¬Â§Â¸Ã¬Â±Â  Ã­Å¡â€°Ã­Å¡â€Ã¬Â¨Å’Ã¬Â¨â€?Ã­Å¡â€˜Ã¬Â©ÂÃ¬Â±Â¤?Ã­Å¡â€° GUIDÃ¬Â§Â¸Ã¬Â§â€¢ Ã­Å¡â€°Ã¬Â²Â ?Ã¬Â±Å’ Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦ Ã¬Â©ÂÃ­Å¡Ë†?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±Â¨Ã¬Â©â€Ã­Å¡â€™ Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨ÂÃ¬Â§â„¢Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨Ë†Ã­Å¡â€š Ã¬Â§Â¸Ã­Å¡â€™?Ã¬Â¨Ëœ ?Ã¬Â²Â¬Ã¬Â¨â€Ã¬Â²Â©Ã¬Â©â€Ã¬Â§â€¢ Ã¬Â¨â€Ã¬Â²Â¬Ã¬Â©ÂÃ¬Â±Â¤Ã­Å¡ÂÃ¬Â¨â‚¬Ã¬Â¨Ë†Ã¬Â²Â© Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦?Ã­Å¡â€° Ã¬Â§Â¸Ã¬Â°Â¼Ã¬Â§Â¸Ã¬Â²Â¬?Ã­Å¡â€˜Ã¬Â¨Ë†Ã­Å¡Â¢.
					// ?Ã­Å¡â€˜Ã¬Â¨Å’Ã¬Â§Â¹ Ã¬Â§Â¸Ã¬Â±Ë†Ã¬Â©â€Ã¬Â±â„¢ ?Ã¬Â²Â´Ã¬Â§Â¸Ã¬Â²Â©Ã¬Â©â€Ã¬Â§â€¢ Ã¬Â¨â€°Ã¬Â²Â­Ã¬Â¨ÂÃ¬Â§Å“ Ã­Å¡Ë†Ã¬Â²Â¨Ã¬Â¨Â©Ã¬Â²Ëœ?Ã¬Â¨Â© Ã­Å¡â€°Ã­Å¡Ëœ Ã¬Â©Å’Ã¬Â²Â  Ã¬Â©ÂÃ¬Â²Â©Ã¬Â¨Ë†Ã­Å¡Â¢. Ã­Å¡â€Ã­Å¡Å“Ã¬Â©Å’Ã­Å¡ËœÃ­Å¡â€°Ã­Å¡â€” Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦ Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦Ã¬Â§Â¸Ã¬Â§â€¢ Ã­Å¡ÂÃ¬Â©ÂÃ¬Â¨Å’Ã¬Â°Â¼Ã¬Â¨â€°Ã­Å¡Å  Ã¬Â¨Ë†Ã­Å¡Â¢?Ã¬Â©Â Ã¬Â¨Ë†Ã­Å¡Â¢?Ã¬Â©Â ?Ã¬Â²Â´Ã¬Â¨ÂÃ¬Â±â€¢?Ã¬Â²Â´?Ã­Å¡â€˜ Ã¬Â©ÂÃ­Å¡â€?Ã­Å¡Â¤Ã¬Â¨â€°Ã­Å¡â€°Ã¬Â§Â¹Ã¬Â°Â½ ?Ã¬Â²Â´Ã¬Â©â€Ã¬Â§â€¢ Ã­Å¡ÂÃ¬Â§â€“Ã¬Â©Å’Ã­Å¡â„¢?Ã¬Â¨Â© Ã­Å¡â€°Ã­Å¡Â Ã¬Â©ÂÃ­Å¡Â© Ã­Å¡Ë†Ã¬Â²Â¨Ã¬Â¨Â©Ã¬Â²Ëœ?Ã¬Â¨Â© Ã¬Â©ÂÃ¬Â±Âµ?Ã¬Â¨Â© Ã¬Â©Å’Ã¬Â²Â  ?Ã­Å¡Å“Ã¬Â¨Ë†Ã­Å¡Â¢.
					// ?Ã­Å¡â€˜?Ã¬Â²Â´Ã¬Â©â€Ã¬Â§â€¢ Ã­Å¡â€°Ã­Å¡ËœÃ¬Â¨Ë†Ã¬Â±Å’Ã¬Â¨â€°Ã­Å¡â€°Ã¬Â©ÂÃ¬Â²Â¬Ã¬Â¨Ë†Ã¬Â²Â© Ã¬Â©â€Ã¬Â§Â§Ã­Å¡â€°Ã­Å¡Ëœ, Ã¬Â§Â¸Ã­Å¡â€°Ã¬Â©Å’Ã¬Â¨â‚¬ Ã­Å¡Ë†Ã¬Â²Â¨?Ã­Å¡â€œÃ­Å¡Ë†Ã¬Â§Â°, ?Ã¬Â²Â´?Ã¬Â±Â¦ Ã¬Â§Â¸Ã¬Â²Â©Ã­Å¡â€°Ã¬Â±â€¦Ã¬Â¨â€°Ã¬Â¨â€° Ã­Å¡â€Ã­Å¡Å½Ã¬Â§Â¹Ã¬Â°Â½Ã­Å¡Å Ã¬Â§Â¯.
					m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
					m_pClientList[iClientH]->m_iConstructionPoint = 0;
					m_pClientList[iClientH]->m_iWarContribution   = 0;
					m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
					// Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦ GUIDÃ¬Â§Â¸Ã¬Â§â€¢ Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨ÂÃ¬Â§â„¢Ã¬Â¨Ë†Ã­Å¡Â¢. Ã­Å¡Ë†Ã¬Â²Â¨Ã¬Â¨Â©Ã¬Â²Ëœ Ã¬Â¨ËœÃ­Å¡ËœÃ¬Â§Â¸Ã¬Â§â€¢.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
				}
				m_pClientList[iClientH]->m_cVar = 1;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
			}
			else if (m_bIsHeldenianMode == TRUE) {
				sSummonPoints = m_pClientList[iClientH]->m_iCharisma*300;
				if (sSummonPoints > DEF_MAXSUMMONPOINTS) sSummonPoints = DEF_MAXSUMMONPOINTS;
				if (m_pClientList[iClientH]->m_dwHeldenianGUID == NULL) {
					m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
					m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
				}
				else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) {
					m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
					m_pClientList[iClientH]->m_iWarContribution = 0;
					m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
				}
				m_pClientList[iClientH]->m_cVar = 2;
				if (m_bIsHeldenianMode == TRUE) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, NULL, NULL, NULL, NULL);
					if (m_bHeldenianInitiated == FALSE) {
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL);
					}
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, NULL, NULL);
					UpdateHeldenianStatus();
				}
			}
			else if ((m_pClientList[iClientH]->m_cVar == 1) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
				m_pClientList[iClientH]->m_iCrusadeDuty = 0;
				m_pClientList[iClientH]->m_iConstructionPoint = 0;
			}
			else {
				if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
					if (m_pClientList[iClientH]->m_cVar == 1) {
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, NULL, NULL, -1);
					}
				}
				else {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
					m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
					m_pClientList[iClientH]->m_iWarContribution   = 0;
					m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
				}
			}

			// v1.42
			if (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) {
				wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
				PutLogEventFileList(G_cTxt);
			}

			if (m_bIsHeldenianMode == TRUE) SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, NULL, NULL, NULL, NULL, NULL);		
			if (m_bHeldenianInitiated == TRUE) SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL, NULL);		

			// Crusade
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);
			//Fix Sprite Bug
			//			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			//Gizon point lefT???
			//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

			if ((m_bIsApocalypseMode == TRUE) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsApocalypseMap == TRUE)) {
				RequestTeleportHandler(iClientH, "1   ");
			}

			if (m_bIsApocalypseMode == TRUE) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL, NULL);
			}
}

CGame::iComposeInitMapData(short sX, short sY, int iClientH, char * pData)
{
 register int * ip, ix, iy, iSize, iTileExists;
 class CTile * pTileSrc, * pTile;
 unsigned char ucHeader;
 short * sp, * pTotal;
 int     sTemp, sTemp2;
 WORD  * wp;
 char  * cp;

	if (m_pClientList[iClientH] == NULL) return 0;

	pTotal = (short *)pData;
	cp = (char *)(pData + 2);

	iSize = 2;
	iTileExists = 0;
	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		                       (sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
	
	for (iy = 0; iy < 16; iy++)
	for (ix = 0; ix < 21; ix++) {
		
		if (((sX + ix) == 100) && ((sY + iy) == 100))
			sX = sX;
 		
		pTile = (class CTile *)(pTileSrc + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

		//If player not same side and is invied (Beholder Hack)
		if ((m_pClientList[pTile->m_sOwner] != NULL) && (pTile->m_sOwner != iClientH))
			if ((m_pClientList[pTile->m_sOwner]->m_cSide != 0) &&
				(m_pClientList[pTile->m_sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) && 
				((m_pClientList[pTile->m_sOwner]->m_iStatus & 0x00000010) != 0)) {
				continue;
			}

		// @@@ !!! @@@ Ã€ÃŒÂ°Ã·Â¿Â¡ ÃÂ¶Â°Ã‡Ã€ÃŒ Ã€Ã”Â·Ã‚ÂµÃ‡Â¾ÃŸÂ¸Â¸ ÃÂ¤ÂºÂ¸Â°Â¡ Ã€Ã¼Â´ÃÂµÃˆÂ´Ã™!!!
		if ( (pTile->m_sOwner != NULL) || (pTile->m_sDeadOwner != NULL) || 
			 (pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL) ) {
			iTileExists++;
			// Ã€Â§Ã„Â¡ÃÂ¤ÂºÂ¸ Ã€Ã”Â·Ã‚ 
			sp = (short *)cp;
			*sp = ix;
			cp += 2;
			sp = (short *)cp;
			*sp = iy;
			cp += 2;
			iSize += 4;

			// Ã‡Ã¬Â´Ãµ ÃÂ¤ÂºÂ¸Â¸Â¦ Ã€Ã›Â¼ÂºÃ‡Ã‘Â´Ã™.
			ucHeader = 0;
			if (pTile->m_sOwner != NULL) {
				// Â°Â£ÃˆÂ¤ Ã‡ÃšÂµÃ©Ã€ÃŒ Ã€Ã–Â´Ã‚ÂµÂ¥ÂµÂµ NULLÃ€Ã Â°Ã¦Â¿Ã¬Â·Ã Â¿Â¡Â·Â¯Â¹ÃŸÂ»Ã½. Â¿Ã¸Ã€ÃÃ†Ã„Â¾Ã‡ÃÃŸ  Â¿Â¡Â·Â¯ ÂºÂ¸Â¿Ã Â±Ã¢Â´Ã‰ Â»Ã°Ã€Ã”. Â±Ã—Â·Â¯Â³Âª Â±Ã™ÂºÂ»Ã€Ã»Ã€Ã 
				// Â¿Ã¸Ã€ÃÃ€Â» Â¾Ã‹Â¾Ã†Â³Â»Â¾ÃŸ Ã‡Ã‘Â´Ã™.
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else {
						// ###debugcode
						wsprintf(G_cTxt, "Empty player handle: %d", pTile->m_sOwner);
						//PutLogFileList(G_cTxt);
						//
						pTile->m_sOwner = NULL;
					}
				}
			
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sOwner] != NULL ) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
			}
			if (pTile->m_sDeadOwner != NULL) {
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
				   	else pTile->m_sDeadOwner = NULL;
				}
			}
			if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;
			//
			*cp = ucHeader;
			cp++;
			iSize++;

			if ((ucHeader & 0x01) != 0) {
				switch (pTile->m_cOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number(Player) : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner;
					cp += 2;
					iSize += 2;
 					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					ip  = (int *)cp;
					
					// sStatusÃ€Ã‡ Â»Ã³Ã€Â§ 4ÂºÃ±Ã†Â®Â°Â¡ FOE Â°Ã¼Â°Ã¨Â¸Â¦ Â³ÂªÃ…Â¸Â³Â½Â´Ã™. 
					sTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
					sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp; // Â»Ã³Ã€Â§ 4ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã®
					sTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sOwner);
					sTemp  = (sTemp | (sTemp2 << 28));//Original : 12
					*ip = sTemp;
					//*sp = DEF_TEST;
					cp += 4;//Original 2
					iSize += 4;//Original 2
					// Name
					memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number(NPC) : 10000~
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appr2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					ip  = (int *)cp;
					
					sTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
					sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp; // Â»Ã³Ã€Â§ 4ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã®
					sTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 28));//Original : 12
					*ip = sTemp;
					//*sp = DEF_TEST;
					cp += 4;//Original 2
					iSize += 4;//Original 2
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}

			if ((ucHeader & 0x02) != 0) {
				// ÃÃ—Ã€Âº Ã„Â³Â¸Â¯Ã…Ã ÃÂ¤ÂºÂ¸ Â»Ã°Ã€Ã” 
				switch (pTile->m_cDeadOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					ip  = (int *)cp;
					
					// sStatusÃ€Ã‡ Â»Ã³Ã€Â§ 4ÂºÃ±Ã†Â®Â°Â¡ FOE Â°Ã¼Â°Ã¨Â¸Â¦ Â³ÂªÃ…Â¸Â³Â½Â´Ã™. 
					sTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
					sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp; // Â»Ã³Ã€Â§ 4ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã®
					sTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sDeadOwner);
					sTemp  = (sTemp | (sTemp2 << 28));//Original : 12
					*ip = sTemp;
					//*sp = DEF_TEST;
					cp += 4;//Original 2
					iSize += 4;//Original 2
					// Name
					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number : 10000	~
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appr2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					ip  = (int *)cp;
					
					sTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
					sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp; // Â»Ã³Ã€Â§ 4ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã®
					sTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 28));//Original : 12
					*ip = sTemp;
					//*sp = DEF_TEST;
					cp += 4;//Original 2
					iSize += 4;//Original 2
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}

			if (pTile->m_pItem[0] != NULL) {
				// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Â»Ã°Ã€Ã” 
				// Â½ÂºÃ‡ÃÂ¶Ã³Ã€ÃŒÃ†Â® 
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSprite;
				cp += 2;
				iSize += 2;
				// Â½ÂºÃ‡ÃÂ¶Ã³Ã€ÃŒÃ†Â® Ã‡ÃÂ·Â¹Ã€Ã“ 
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSpriteFrame;
				cp += 2;
				iSize += 2;
				// Â¾Ã†Ã€ÃŒÃ…Ã› Â»Ã¶ ÃƒÃŸÂ°Â¡ÂµÃŠ v1.4 
				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				iSize++;
			}

			if (pTile->m_sDynamicObjectType != NULL) {
				// ÂµÂ¿Ã€Ã» Â°Â´ÃƒÂ¼ ÃÂ¾Â·Ã¹ Ã‡Ã’Â´Ã§ 
				wp  = (WORD *)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				iSize += 2;
				
				sp  = (short *)cp;
				*sp	= pTile->m_sDynamicObjectType;
				cp += 2;
				iSize += 2;
			}
		} // Big if
	} // while(1)

	*pTotal = iTileExists;
	return iSize;
}

void CGame::DeleteClient(int iClientH, BOOL bSave, BOOL bNotify, BOOL bCountLogout, BOOL bForceCloseConn)
{
	int i, iExH;
	char * cp, cData[120], cTmpMap[30];
	DWORD * dwp;
	WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			wsprintf(G_cTxt, "Char(%s)-Exit(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
			PutLogEventFileList(G_cTxt);
		}

		if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}

		if ((m_pClientList[iClientH]->m_iAllocatedFish != NULL) && (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL)) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		if (bNotify == TRUE)
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

		RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex	== iClientH)) {
				m_pClientList[i]->m_iWhisperPlayerIndex = -1;
				SendNotifyMsg(NULL, i, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
			}

			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			*cp = GSM_DISCONNECT;
			cp++;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			bStockMsgToGateServer(cData, 11);

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER,
				m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY);

			bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, NULL);
	}

	if ((bSave == TRUE) && (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE)) {
		
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) {
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;

			strcpy(cTmpMap,m_pClientList[iClientH]->m_cMapName) ;

			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));

			if (m_pClientList[iClientH]->m_cSide == 0) {
				strcpy(m_pClientList[iClientH]->m_cMapName, "default");
			}
			else {
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
					if (m_bIsCrusadeMode == TRUE) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
							m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
						}
					}

					if (strcmp(cTmpMap, "elvine") == 0){
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ;
						memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					}else if (m_pClientList[iClientH]->m_iLevel > 80)
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
				}
				else {
					if (m_bIsCrusadeMode == TRUE) {
						if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
							ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
							strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
							m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
						}
						else {
							m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10;
						}
					}
					if (strcmp(cTmpMap, "aresden") == 0){
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ;
						memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);

					}else if (m_pClientList[iClientH]->m_iLevel > 80)
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
					else memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
				}
			}
		}
		else if (bForceCloseConn == TRUE) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, "bisle", 5);
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;

			ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
			strcpy(m_pClientList[iClientH]->m_cLockedMapName, "bisle");
			m_pClientList[iClientH]->m_iLockedMapTime = 10*60;
		}

		if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1,2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				switch (iDice(1,2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) {
			if (m_pClientList[iClientH]->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;

				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;

				wp = (WORD*)cp;
				*wp = 4;
				cp += 2;

				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}
			if (bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout) == FALSE) LocalSavePlayerData(iClientH);
		}
		else bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
	}
	else {
		if (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE) {
			if (m_pClientList[iClientH]->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;

				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;

				wp = (WORD*)cp;
				*wp = 4;
				cp += 2;

				wp = (WORD *)cp;
				*wp = iClientH;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}

			bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
		}
		else {
			if (m_pClientList[iClientH]->m_iPartyID != NULL) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;

				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;

				wp = (WORD*)cp;
				*wp = 7;
				cp += 2;

				wp = (WORD *)cp;
				*wp = NULL;
				cp += 2;

				memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
				cp += 10;

				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;

				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			}

			bSendMsgToLS(MSGID_REQUEST_SETACCOUNTWAITSTATUS, iClientH, FALSE); 
		}
	}

	if (m_pClientList[iClientH]->m_iPartyID != NULL) {
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;
				wsprintf(G_cTxt, "PartyID:%d member:%d Out(Delete) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto DC_LOOPBREAK1;
			}
DC_LOOPBREAK1:;
			for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
				if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] != 0)) {
					m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i]   = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1];
					m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] = 0;
				}
	}

	m_iTotalClients--;

	delete m_pClientList[iClientH];
	m_pClientList[iClientH] = NULL;

	RemoveClientShortCut(iClientH);
}



void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, DWORD dwMsgID, WORD wMsgType, short sV1, short sV2, short sV3)
{
	int * ip, i, iRet, iShortCutIndex;
	char  * cp_a, * cp_s, * cp_sv, cData_All[200], cData_Srt[200], cData_Srt_Av[200];
	DWORD * dwp;
	WORD  * wp;
	int * ipStatus,iDumm;
	short * sp, sRange, sX, sY;
	BOOL  bFlag, cOwnerSend;
	char cKey;
	int iTemp3,iTemp,iTemp2;				
	
	ZeroMemory(cData_All, sizeof(cData_All));
	ZeroMemory(cData_Srt, sizeof(cData_Srt));
	ZeroMemory(cData_Srt_Av, sizeof(cData_Srt_Av));
	ipStatus = (int *)&iDumm;
	cKey = (rand() % 255) + 1;

	dwp  = (DWORD *)(cData_All + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_All + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;

	dwp  = (DWORD *)(cData_Srt + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;

	dwp  = (DWORD *)(cData_Srt_Av + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;

	cp_a  = (char *)(cData_All + DEF_INDEX2_MSGTYPE + 2);
	cp_s  = (char *)(cData_Srt + DEF_INDEX2_MSGTYPE + 2);
	cp_sv = (char *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE + 2);


	if ((dwMsgID == MSGID_EVENT_LOG) || (wMsgType == DEF_OBJECTMOVE) || (wMsgType == DEF_OBJECTRUN) || 
		(wMsgType == DEF_OBJECTATTACKMOVE) || (wMsgType == DEF_OBJECTDAMAGEMOVE) || (wMsgType == DEF_OBJECTDYING))
		sRange = 1;
	else sRange = 0;


	if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sOwnerH] == NULL) return;

		switch(wMsgType){
			case DEF_OBJECTNULLACTION:
			case DEF_OBJECTDAMAGE:
			case DEF_OBJECTDYING:
			case DEF_MSGTYPE_CONFIRM:
				cOwnerSend = TRUE;
				break;
			default:
				cOwnerSend = FALSE;
				break;
		}

		wp  = (WORD *)cp_a;
		*wp = sOwnerH;
		cp_a += 2;

		sp  = (short *)cp_a;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;

		sp  = (short *)cp_a;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sType;
		cp_a += 2;

		*cp_a = m_pClientList[sOwnerH]->m_cDir;
		cp_a++;

		memcpy(cp_a, m_pClientList[sOwnerH]->m_cCharName, 10);
		cp_a += 10;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr1;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr2;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr3;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr4;
		cp_a += 2;

		ip = (int *)cp_a;
		*ip = m_pClientList[sOwnerH]->m_iApprColor;
		cp_a += 4;

		ip  = (int *)cp_a;
		ipStatus = ip;
		*ip = m_pClientList[sOwnerH]->m_iStatus;
		cp_a += 4;

		//iTemp += m_pClientList[sOwnerH]->m_iStatus & 0x0F0;
		iTemp3 = m_pClientList[sOwnerH]->m_iStatus & 0x0F0FFFF7F; //0F0FFFF7Fh

		if (wMsgType == DEF_OBJECTNULLACTION) {
			if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE)
				*cp_a = 1; 
			else *cp_a = 0; 
		}
		else *cp_a = 0;
		cp_a++;

		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 30000;
		cp_s += 2;

		*cp_s = m_pClientList[sOwnerH]->m_cDir;
		cp_s++;

		*cp_s = (unsigned char)sV1;
		cp_s++;

		*cp_s = (unsigned char)sV2;
		cp_s++;

		sp  = (short *)cp_s;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;

		sp  = (short *)cp_s;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;

		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 30000;
		cp_sv += 2;

		*cp_sv = m_pClientList[sOwnerH]->m_cDir;
		cp_sv++;

		*cp_sv = sV1 - sX;
		cp_sv++;

		*cp_sv = sV2 - sY;
		cp_sv++;

		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;

		bFlag = TRUE;
		iShortCutIndex = 0;

		while(bFlag){
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;
				
				if ((bFlag == TRUE) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))

				if ((m_pClientList[i]->m_cMapIndex == m_pClientList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 10 - sRange) &&
					(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 10 + sRange) &&
					(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 8 - sRange) &&
					(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 8 + sRange) ) {
						
					/*//If player not same side and is invied (Beholder Hack)
					if (m_pClientList[sOwnerH] != NULL && i != sOwnerH)
						if ((m_pClientList[i]->m_cSide != m_pClientList[sOwnerH]->m_cSide) &&
							((m_pClientList[sOwnerH]->m_iStatus & 0x00000010) != 0)) {
							if(wMsgType == DEF_OBJECTRUN || wMsgType == DEF_OBJECTMOVE || wMsgType == DEF_OBJECTSTOP || wMsgType == DEF_OBJECTGETITEM)
								if we filter attacking
								[KLKS] - http://xtremehb.com -> Play Abaddon (PRO ARESDEN) says:
								the poor guy who's being attacked wont know what hit him
						continue;
					}*/

						/*iTemp = *ipStatus;
						iTemp = 0x0FFFFFFF & iTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
						iTemp2 = (short)iGetPlayerABSStatus(sOwnerH, i); //(short)iGetPlayerRelationship_SendEvent(sOwnerH, i);
						iTemp  = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;*/
								
						if (m_pClientList[sOwnerH]->m_cSide != m_pClientList[i]->m_cSide) {
							if ( m_pClientList[i]->m_iAdminUserLevel > 0){	//Â¾Ã®ÂµÃ¥Â¹ÃÂ¿Â¡Â°Ã”Â´Ã‚ Â¹Â«ÃÂ¶Â°Ã‡ ÂºÂ¸Â³Â½Â´Ã™.
								iTemp = m_pClientList[sOwnerH]->m_iStatus;
							}
							else if (i != sOwnerH)	{	
								iTemp = iTemp3;
							}
							else {
								iTemp = m_pClientList[sOwnerH]->m_iStatus;
							}
						}
						else
						{
							iTemp = m_pClientList[sOwnerH]->m_iStatus;
							//iTemp = 0x0FFFFFFF;
						}

						//iTemp = m_pClientList[sOwnerH]->m_iStatus;
						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetPlayerABSStatus(sOwnerH, i);
						iTemp  = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;

						if ( (m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 9) &&
							(m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 9) &&
							(m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 7) &&
							(m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 7) ) {

								switch (wMsgType) {
									case DEF_MSGTYPE_CONFIRM:
									case DEF_MSGTYPE_REJECT:
									case DEF_OBJECTNULLACTION:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
										break;

									case DEF_OBJECTATTACK:
									case DEF_OBJECTATTACKMOVE:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
										break;

									case DEF_OBJECTMAGIC:
									case DEF_OBJECTDAMAGE:
									case DEF_OBJECTDAMAGEMOVE:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
										break;

									case DEF_OBJECTDYING:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
										break;

									default:
										if (cOwnerSend == TRUE) 
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
										else
											if (i != sOwnerH)
												iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
										break;
								} //Switch
							} // If 2
						else {
							switch (wMsgType) {
								case DEF_MSGTYPE_CONFIRM:
								case DEF_MSGTYPE_REJECT:
								case DEF_OBJECTNULLACTION:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									break;

								case DEF_OBJECTATTACK:
								case DEF_OBJECTATTACKMOVE:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
									break;

								case DEF_OBJECTMAGIC:
								case DEF_OBJECTDAMAGE:
								case DEF_OBJECTDAMAGEMOVE:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
									break;

								case DEF_OBJECTDYING:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
									break;

								default:
									if (cOwnerSend == TRUE) 
										iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									else
										if (i != sOwnerH)
											iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 43, cKey);
									break;
							} //Switch
						} //else
					} // If 1
		} //While finish
	} //Finish Player
	else {

		if (m_pNpcList[sOwnerH] == NULL) return;

		wp  = (WORD *)cp_a;
		*wp = sOwnerH + 10000;
		cp_a += 2;

		sp  = (short *)cp_a;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;

		sp  = (short *)cp_a;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;

		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sType;
		cp_a += 2;

		*cp_a = m_pNpcList[sOwnerH]->m_cDir;
		cp_a++;

		memcpy(cp_a, m_pNpcList[sOwnerH]->m_cName, 5);
		cp_a += 5;

		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sAppr2;
		cp_a += 2;

		ip  = (int *)cp_a;
		ipStatus = ip;
		*ip = m_pNpcList[sOwnerH]->m_iStatus;
		cp_a += 4;

		if (wMsgType == DEF_OBJECTNULLACTION) {
			if (m_pNpcList[sOwnerH]->m_bIsKilled == TRUE)
				*cp_a = 1; 
			else *cp_a = 0;
		}
		else *cp_a = 0;
		cp_a++;

		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 40000;
		cp_s += 2;

		*cp_s = m_pNpcList[sOwnerH]->m_cDir;
		cp_s++;

		*cp_s = (unsigned char)sV1;
		cp_s++;
		*cp_s = (unsigned char)sV2;
		cp_s++;

		sp  = (short *)cp_s;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp  = (short *)cp_s;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;

		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 40000;
		cp_sv += 2;
		*cp_sv = m_pNpcList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;

		bFlag = TRUE;
		iShortCutIndex = 0;

		while(bFlag){

			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;

			if ((bFlag == TRUE) && (m_pClientList[i] != NULL))

				if ( (m_pClientList[i]->m_cMapIndex == m_pNpcList[sOwnerH]->m_cMapIndex) &&
					(m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 10 - sRange) &&
					(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 10 + sRange) &&
					(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 8 - sRange) &&
					(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 8 + sRange) ) {

						iTemp = *ipStatus;
						iTemp = 0x0FFFFFFF & iTemp;
						iTemp2 = iGetNpcRelationship(sOwnerH, i);
						iTemp  = (iTemp | (iTemp2 << 28));
						*ipStatus = iTemp;

						if ( (m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 9) &&
							(m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 9) &&
							(m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 7) &&
							(m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 7) ) {
								switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27,cKey);
							break;

						case DEF_OBJECTDYING:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
							break;

						default:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9, cKey);
							break;

								} //Switch
							}
						else{
							switch (wMsgType) {
						case DEF_MSGTYPE_CONFIRM:
						case DEF_MSGTYPE_REJECT:
						case DEF_OBJECTNULLACTION:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27,cKey);
							break;

						case DEF_OBJECTDYING:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15, cKey);
							break;

						case DEF_OBJECTDAMAGE:
						case DEF_OBJECTDAMAGEMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11, cKey);
							break;

						case DEF_OBJECTATTACK:
						case DEF_OBJECTATTACKMOVE:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13, cKey);
							break;

						default:
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27, cKey);
							break;

							} //Switch
						}
					}
		}
	} // else - NPC
}

int CGame::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char * pData)
{
register int * ip, ix, iy, iSize, iTileExists, iIndex;
class CTile * pTileSrc, * pTile;
unsigned char ucHeader;
short * sp, * pTotal;
int iTemp, iTemp2;
WORD  * wp;
char  * cp;

	if (m_pClientList[iClientH] == NULL) return 0;

	pTotal = (short *)pData;
	cp = (char *)(pData + 2);

	iSize = 2;
	iTileExists = 0;

	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		(sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

	iIndex = 0;

	while (1) {
		ix = _tmp_iMoveLocX[cDir][iIndex];
		iy = _tmp_iMoveLocY[cDir][iIndex];
		if ((ix == -1) || (iy == -1)) break;

		iIndex++;

		pTile = (class CTile *)(pTileSrc + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

		//If player not same side and is invied (Beholder Hack)
		// there is another person on the tiles, and the owner is not the player
//xxxxxx
		if ((m_pClientList[pTile->m_sOwner] != NULL) && (pTile->m_sOwner != iClientH))
			if ((m_pClientList[pTile->m_sOwner]->m_cSide != 0) &&
				(m_pClientList[pTile->m_sOwner]->m_cSide != m_pClientList[iClientH]->m_cSide) &&
				((m_pClientList[pTile->m_sOwner]->m_iStatus & 0x00000010) != 0)) {
				continue;
			}

		if ( (pTile->m_sOwner != NULL) || (pTile->m_sDeadOwner != NULL) || 
			(pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL) ) {

				iTileExists++;

				sp = (short *)cp;
				*sp = ix;
				cp += 2;
				sp = (short *)cp;
				*sp = iy;
				cp += 2;
				iSize += 4;

				ucHeader = 0;

				if (pTile->m_sOwner != NULL) {
					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) { 
						if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
						else pTile->m_sOwner = NULL;
					}
					if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) {
						if (m_pNpcList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
						else pTile->m_sOwner = NULL;
					}
				}
				if (pTile->m_sDeadOwner != NULL) {
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) { 
						if (m_pClientList[pTile->m_sDeadOwner] != NULL)	ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = NULL;
					}
					if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) { 
						if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
						else pTile->m_sDeadOwner = NULL;
					}
				}

					if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
					if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;

					*cp = ucHeader;
					cp++;
					iSize++;

					if ((ucHeader & 0x01) != 0) {
					switch (pTile->m_cOwnerClass) {
						case DEF_OWNERTYPE_PLAYER:
								sp  = (short *)cp;
								*sp	= pTile->m_sOwner;
								cp += 2;
								iSize += 2;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
								cp += 2;
								iSize += 2;

								*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
								cp++;
								iSize++;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
								cp += 2;
								iSize += 2;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
								cp += 2;
								iSize += 2;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
								cp += 2;
								iSize += 2;

								sp  = (short *)cp;
								*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
								cp += 2;
								iSize += 2;

								ip = (int *)cp;
								*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
								cp += 4;
								iSize += 4;

								ip  = (int *)cp;

								if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sOwner]->m_cSide){
									if (iClientH != pTile->m_sOwner) {
										iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus & 0x0F0FFFF7F;
									}
									else {
										iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
									}
								}
								else {
									iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
								}

								//iTemp = m_pClientList[pTile->m_sOwner]->m_iStatus;
								iTemp = 0x0FFFFFFF & iTemp;
								iTemp2 = iGetPlayerABSStatus(pTile->m_sOwner, iClientH);
								iTemp  = (iTemp | (iTemp2 << 28));
								*ip = iTemp;
								cp += 4;
								iSize += 4;

								memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
								cp    += 10;
								iSize += 10;
								break;

						case DEF_OWNERTYPE_NPC:
							sp  = (short *)cp;
							*sp	= pTile->m_sOwner + 10000;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
							cp += 2;
							iSize += 2;

							*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
							cp++;
							iSize++;

							sp  = (short *)cp;
							*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;

							ip  = (int *)cp;
							iTemp = m_pNpcList[pTile->m_sOwner]->m_iStatus;
							iTemp = 0x0FFFFFFF & iTemp;
							iTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
							iTemp  = (iTemp | (iTemp2 << 28));
							*ip = iTemp;
							cp += 4;
							iSize += 4;

							memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
							cp    += 5;
							iSize += 5;
						}//end switch
					}// if ((ucHeader & 0x01) != 0)

					if ((ucHeader & 0x02) != 0) {
						switch (pTile->m_cDeadOwnerClass) {
						case DEF_OWNERTYPE_PLAYER:

							sp  = (short *)cp;
							*sp	= pTile->m_sDeadOwner;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
							cp += 2;
							iSize += 2;

							*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
							cp++;
							iSize++;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
							cp += 2;
							iSize += 2;

							ip = (int *)cp;
							*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
							cp += 4;
							iSize += 4;

							ip  = (int *)cp;
							
							if (m_pClientList[iClientH]->m_cSide != m_pClientList[pTile->m_sDeadOwner]->m_cSide){
								if (iClientH != pTile->m_sDeadOwner) {
									iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus & 0x0F0FFFF7F;
								}
								else {
									iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
								}
							}
							else {
								iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
							}

							//iTemp = m_pClientList[pTile->m_sDeadOwner]->m_iStatus;
							iTemp = 0x0FFFFFFF & iTemp;

							iTemp2 = iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH);
							iTemp  = (iTemp | (iTemp2 << 28));
							*ip = iTemp;
							cp += 4;
							iSize += 4;

							memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
							cp    += 10;
							iSize += 10;
							break;

						case DEF_OWNERTYPE_NPC:
							sp  = (short *)cp;
							*sp	= pTile->m_sDeadOwner + 10000;
							cp += 2;
							iSize += 2;

							sp  = (short *)cp;
							*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
							cp += 2;
							iSize += 2;

							*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
							cp++;
							iSize++;

							sp  = (short *)cp;
							*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
							cp += 2;
							iSize += 2;

							ip  = (int *)cp;

							iTemp = m_pNpcList[pTile->m_sDeadOwner]->m_iStatus;
							iTemp = 0x0FFFFFFF & iTemp;
							iTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
							iTemp  = (iTemp | (iTemp2 << 28));
							*ip = iTemp;

							cp += 4;
							iSize += 4;

							memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
							cp    += 5;
							iSize += 5;
							break;
						}//End Switch
					}// if ((ucHeader & 0x02) != 0)

					if (pTile->m_pItem[0] != NULL) {
						sp  = (short *)cp;
						*sp	= pTile->m_pItem[0]->m_sSprite;
						cp += 2;
						iSize += 2;

						sp  = (short *)cp;
						*sp	= pTile->m_pItem[0]->m_sSpriteFrame;
						cp += 2;
						iSize += 2;

						*cp = pTile->m_pItem[0]->m_cItemColor;
						cp++;
						iSize++;
					}

					if (pTile->m_sDynamicObjectType != NULL) {

						wp  = (WORD *)cp;
						*wp = pTile->m_wDynamicObjectID;
						cp += 2;
						iSize += 2;

						sp  = (short *)cp;
						*sp	= pTile->m_sDynamicObjectType;
						cp += 2;
						iSize += 2;
					} //(pTile->m_sDynamicObjectType != NULL)

				} //(pTile->m_sOwner != NULL)
		} // end While(1)
		*pTotal = iTileExists;
		return iSize;
}

void CGame::CheckClientResponseTime()
{
 register int i, iPlusTime, iMaxSuperAttack, iValue;
 short sTemp;
 DWORD dwTime;
 short sItemIndex;
 int iMapside, iMapside2;
 //SYSTEMTIME SysTime;

	/*
	// Â½ÃƒÂ°Â£Ã€Â» Â±Â¸Ã‡Ã‘Â´Ã™Ã€Â½ iWarPeriodÂ¸Â¦ Â±Â¸Ã‡Ã‘Â´Ã™.
	GetLocalTime(&SysTime);
	switch (SysTime.wDayOfWeek) {
	case 1:	iWarPeriod = 30; break; //Â¿Ã¹Â¿Ã¤Ã€Ã 
	case 2:	iWarPeriod = 30; break; //ÃˆÂ­Â¿Ã¤Ã€Ã 
	case 3:	iWarPeriod = 60; break; //Â¼Ã¶Â¿Ã¤Ã€Ã 
	case 4:	iWarPeriod = 60*2;  break; //Â¸Ã±Â¿Ã¤Ã€Ã 
	case 5:	iWarPeriod = 60*5;  break; //Â±ÃÂ¿Ã¤Ã€Ã 
	case 6:	iWarPeriod = 60*10; break; //Ã…Ã¤Â¿Ã¤Ã€Ã 
	case 0:	iWarPeriod = 60*20; break; //Ã€ÃÂ¿Ã¤Ã€Ã 
	}
	*/
	
   	dwTime = timeGetTime();
	
	// Ã€ÃÃÂ¤Â½ÃƒÂ°Â£ÂµÂ¿Â¾Ãˆ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»Â¿Ã€ÃÃ¶ Â¾ÃŠÂ´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â´Ã‚ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) {
			
			if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT ) {
				if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
					// Â°Ã”Ã€Ã“ÃÃŸÃ€Ã Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â°Â¡ Ã€Ã€Â´Ã¤Ã€ÃŒ Â¾Ã¸Ã€Â¸Â¹Ã‡Â·Ã Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
					//Testcode 
					wsprintf(G_cTxt, "Client Timeout: %s", m_pClientList[i]->m_cIPaddress);
					PutLogList(G_cTxt);

					DeleteClient(i, TRUE, TRUE);
				}
				else if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT) {
					// ÃƒÃŠÂ±Ã¢ÃˆÂ­ ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ°Ã­ Â´Ã«Â±Ã¢ÃÃŸÃ€Ã Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Ã€ÃŒÂ´Ã™. Ã€Ã¥Â½ÃƒÂ°Â£ÂµÂ¿Â¾Ãˆ ÃƒÂ³Â¸Â®Â°Â¡ ÃÃ¸Ã‡Ã ÂµÃ‡ÃÃ¶ Â¾ÃŠÃ€Â¸Â¸Ã© Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™. 
					DeleteClient(i, FALSE, FALSE); // ÃƒÃŠÂ±Ã¢ÃˆÂ­ ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Ã€Â¸Â¹Ã‡Â·Ã ÂµÂ¥Ã€ÃŒÃ…ÃÂ¸Â¦ Ã€ÃºÃ€Ã¥Ã‡Ã’ Ã‡ÃŠÂ¿Ã¤Â°Â¡ Â¾Ã¸Â´Ã™. 
				}
			}
			else if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Ã€Ã¼ÃƒÂ¼ ÃƒÂ¤Ã†Ãƒ ÂºÃ’Â°Â¡Â´Ã‰ ÃÃ¶Â¼Ã“Â½ÃƒÂ°Â£Ã€Â» ÃÃ™Ã€ÃÂ´Ã™. 
				m_pClientList[i]->m_iTimeLeft_ShutUp--;
				if (m_pClientList[i]->m_iTimeLeft_ShutUp < 0) m_pClientList[i]->m_iTimeLeft_ShutUp = 0;
				
				// Ã†Ã²Ã†Ã‡Ã€Â» Â³Â»Â¸Â± Â¼Ã¶ Ã€Ã–Â´Ã‚ Â½ÃƒÂ°Â£Ã€Â» ÃÃ™Ã€ÃÂ´Ã™.
				m_pClientList[i]->m_iTimeLeft_Rating--;
				if (m_pClientList[i]->m_iTimeLeft_Rating < 0) m_pClientList[i]->m_iTimeLeft_Rating = 0;
				
				// Â¹Ã¨Â°Ã­Ã†Ã„ÃÃº Â½ÃƒÂ°Â£Ã€ÃŒ ÂµÃ‡Â¸Ã© Ã„Â«Â¿Ã®Ã†Â®Â¸Â¦ Ã‡ÃÂ³Âª Â±Ã¯Â´Ã‚Â´Ã™.
				if (((dwTime - m_pClientList[i]->m_dwHungerTime) > DEF_HUNGERTIME) && (m_pClientList[i]->m_bIsKilled == FALSE)) {
					// Â½ÃƒÂ°Â£Ã€ÃŒ Â´Ã™ ÂµÃ‡Â¾ÃºÂ´Ã™.
					// v2.03 Â¿Ã®Â¿ÂµÃ€ÃšÂ´Ã‚ Â¹Ã¨Â°Ã­Ã†Ã„ÃÃ¶ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 
					if ((m_pClientList[i]->m_iLevel < DEF_LEVELLIMIT) || (m_pClientList[i]->m_iAdminUserLevel >= 1 )) {
						// Â·Â¹ÂºÂ§Ã€ÃŒ DEF_LEVELLIMITÃ€ÃŒÃ‡ÃÃ€ÃŒÂ¸Ã© Â¹Ã¨Â°Ã­Ã‡Ã„ ÃÃ¶Â¼Ã¶Â¸Â¦ Â±Ã¯ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
					}
					else m_pClientList[i]->m_iHungerStatus--;
					if (m_pClientList[i]->m_iHungerStatus <= 0) m_pClientList[i]->m_iHungerStatus = 0;
					m_pClientList[i]->m_dwHungerTime = dwTime;
					
					if ( (m_pClientList[i]->m_iHP > 0) && (m_pClientList[i]->m_iHungerStatus < 30) ) {
						// Â¹Ã¨Â°Ã­Ã‡Ã„Ã€Â» Â´Ã€Â³Â¢Â´Ã‚ Â»Ã³Ã…Ã‚Ã€ÃŒÂ´Ã™. Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™. 
						SendNotifyMsg(NULL, i, DEF_NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, NULL, NULL, NULL);
					}
				}
				
				if (_bCheckCharacterData(i) == FALSE) {
					DeleteClient(i, TRUE, TRUE);
					break;	
				}
				
				// Â¹Ã¨Â°Â¡ Â°Ã­Ã‡ÃÂ¸Ã© Â¿Ã€Â¸Â£Â´Ã‚ Â½ÃƒÂ°Â£Ã€ÃŒ Â±Ã¦Â¾Ã®ÃÃ¸Â´Ã™.
				if ((m_pClientList[i]->m_iHungerStatus <= 30) && (m_pClientList[i]->m_iHungerStatus >= 0)) 
					iPlusTime = (30 - m_pClientList[i]->m_iHungerStatus)*1000;
				else iPlusTime = 0;
				
				iPlusTime = abs(iPlusTime);

				// HPÂ°Â¡ Â¿ÃƒÂ¶Ã³Â°Â¥ Â½ÃƒÂ°Â£Ã€ÃŒ ÂµÃ‡Â¸Ã© Â¿ÃƒÂ¸Â°Â´Ã™.
				if ((dwTime - m_pClientList[i]->m_dwHPTime) > (DWORD)(DEF_HPUPTIME + iPlusTime)) {
					TimeHitPointsUp(i);
					m_pClientList[i]->m_dwHPTime = dwTime;
				}
				
				// MPÂ°Â¡ Â¿ÃƒÂ¶Ã³Â°Â¥ Â½ÃƒÂ°Â£Ã€ÃŒ ÂµÃ‡Â¸Ã© Â¿ÃƒÂ¸Â°Â´Ã™.
				if ((dwTime - m_pClientList[i]->m_dwMPTime) > (DWORD)(DEF_MPUPTIME + iPlusTime)) {
					TimeManaPointsUp(i);
					m_pClientList[i]->m_dwMPTime = dwTime;
				}
				
				// SPÂ°Â¡ Â¿ÃƒÂ¶Ã³Â°Â¥ Â½ÃƒÂ°Â£Ã€ÃŒ ÂµÃ‡Â¸Ã© Â¿ÃƒÂ¸Â°Â´Ã™.
				if ((dwTime - m_pClientList[i]->m_dwSPTime) > (DWORD)(DEF_SPUPTIME + iPlusTime)) {
					TimeStaminarPointsUp(i);
					m_pClientList[i]->m_dwSPTime = dwTime;
				}
				
				// ÃÃŸÂµÂ¶ ÃˆÂ¿Â°ÃºÂ¸Â¦ Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™.
				if ((m_pClientList[i]->m_bIsPoisoned == TRUE) && ((dwTime - m_pClientList[i]->m_dwPoisonTime) > DEF_POISONTIME)) {
					PoisonEffect(i, NULL);
					m_pClientList[i]->m_dwPoisonTime = dwTime;
				}
				
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFightZone == FALSE) &&
					((dwTime - m_pClientList[i]->m_dwAutoSaveTime) > (DWORD)DEF_AUTOSAVETIME)) {
					bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
					m_pClientList[i]->m_dwAutoSaveTime = dwTime;
				}
				
				// ExpStockÃ€Â» Â°Ã¨Â»ÃªÃ‡Ã’ Â½ÃƒÃÂ¡Ã€ÃŒÂ¸Ã© 
				if ((dwTime - m_pClientList[i]->m_dwExpStockTime) > (DWORD)DEF_EXPSTOCKTIME) {
					m_pClientList[i]->m_dwExpStockTime = dwTime;
					CalcExpStock(i);
					CheckUniqueItemEquipment(i);
					CheckCrusadeResultCalculation(i);
					//CheckHeldenianResultCalculation(i);
				}

				// AutoExe Â°Ã¨Â»Ãª Â½ÃƒÃÂ¡Ã€ÃŒÂ¸Ã© 
				if ((dwTime - m_pClientList[i]->m_dwAutoExpTime) > (DWORD)DEF_AUTOEXPTIME) {
					iValue = (m_pClientList[i]->m_iLevel/2);
					if (iValue <= 0) iValue = 1;
					if (m_pClientList[i]->m_iAutoExpAmount < iValue) {
						// Ã€ÃšÂµÂ¿ Â½ÃƒÂ°Â£ Â°Ã¨Â»Ãª Â°Ã¦Ã‡Ã¨Ã„Â¡Â·ÃÂ´Ã‚ Â·Â¹ÂºÂ§Ã€ÃŒ Â¿Ã€Â¸Â£ÃÃ¶ Â¾ÃŠÃ€Â¸Â¹Ã‡Â·Ã ÃƒÂ³Â¸Â®Ã‡Ã‘Â´Ã™.
						if ((m_pClientList[i]->m_iExp + iValue) < m_iLevelExpTable[m_pClientList[i]->m_iLevel+1]) {
							//m_pClientList[i]->m_iExpStock += iValue;
							GetExp(i, iValue, FALSE);
							CalcExpStock(i);
						}
					}
			
					m_pClientList[i]->m_iAutoExpAmount = 0;
					m_pClientList[i]->m_dwAutoExpTime = dwTime;
				}
						
				// v1.432 Ã†Â¯Â¼Ã¶ Â´Ã‰Â·Ã‚ Â»Ã§Â¿Ã« Â°Â¡Â´Ã‰ Â½ÃƒÂ°Â£Ã€Â» ÃÃ™Ã€ÃÂ´Ã™. 3Â¾Â¿ ÃÃ™Â¾Ã®ÂµÃ§Â´Ã™.
				if (m_pClientList[i]->m_iSpecialAbilityTime == 3) {
					// Â»Ã§Â¿Ã«Ã€ÃšÂ¿Â¡Â°Ã” Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
					// New 25/05/2004
					// After the time up, add magic back
					sItemIndex = m_pClientList[i]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
					if (sItemIndex != -1) {
						if ((m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[i]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
							if(m_pClientList[i]->m_iInt > 99 && m_pClientList[i]->m_iMag > 99){
								m_pClientList[i]->m_cMagicMastery[94] = TRUE;
								SendNotifyMsg(NULL, i, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
							}
						}
					}
				}
				m_pClientList[i]->m_iSpecialAbilityTime -= 3;
				if (m_pClientList[i]->m_iSpecialAbilityTime < 0) m_pClientList[i]->m_iSpecialAbilityTime = 0;
				
				// v1.432 Ã†Â¯Â¼Ã¶ Â´Ã‰Â·Ã‚ Â»Ã§Â¿Ã«ÃÃŸÃ€Ã Â½ÃƒÂ°Â£Ã€Â» ÃƒÂ¼Ã…Â© 
				if (m_pClientList[i]->m_bIsSpecialAbilityEnabled == TRUE) {
					if (((dwTime - m_pClientList[i]->m_dwSpecialAbilityStartTime)/1000) > m_pClientList[i]->m_iSpecialAbilityLastSec) {
						// Â»Ã§Â¿Ã«Â½ÃƒÂ°Â£Ã€ÃŒ Â´Ã™ ÂµÃ‡Â¾ÃºÂ´Ã™.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
						m_pClientList[i]->m_bIsSpecialAbilityEnabled = FALSE;
						// Â´Ã™Ã€Â½ Â»Ã§Â¿Ã« Â°Â¡Â´Ã‰ Â½ÃƒÂ°Â£Ã€Â» Ã€Ã”Â·Ã‚Ã‡Ã‘Â´Ã™.
						m_pClientList[i]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
						// ÃˆÂ¿Â°Ãº ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã®
						sTemp = m_pClientList[i]->m_sAppr4;
						sTemp = sTemp & 0xFF0F;
						m_pClientList[i]->m_sAppr4 = sTemp;
						// Â¿ÃœÃ‡Ã¼Ã€ÃŒ ÂºÂ¯Ã‡ÃŸÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
				}
				
				//Crusade
				m_pClientList[i]->m_iLockedMapTime -= 3;
				if (m_pClientList[i]->m_iLockedMapTime < 0) {
					// Â¸ÃŠ Â°Â¤ÃˆÃ» Â½ÃƒÂ°Â£ ÃÂ¾Â·Ã¡. Ã…Â¬Â¸Â®Â¾Ã®Ã‡Ã‘Â´Ã™.
					m_pClientList[i]->m_iLockedMapTime = 0;
					ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
					strcpy(m_pClientList[i]->m_cLockedMapName, "NONE");
				}
			
				// v2.04 Á×¾úÀ»¶§ Æä³ÎÆ¼ ½Ã°£ 
				m_pClientList[i]->m_iDeadPenaltyTime -= 3;
				if (m_pClientList[i]->m_iDeadPenaltyTime < 0) m_pClientList[i]->m_iDeadPenaltyTime = 0;
			
				if ( (m_pClientList[i]->m_bIsWarLocation == TRUE) ) {
					// Crusade
					if (m_bIsCrusadeMode == FALSE)
						if (m_pClientList[i]->m_bIsInsideOwnTown == TRUE)
							m_pClientList[i]->m_iTimeLeft_ForceRecall--;

					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						// ½Ã°£ÀÌ ´Ù µÇ¾ú´Ù. °­Á¦ ¸®ÄİÇÑ´Ù.
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_dwWarBeginTime = dwTime;
						m_pClientList[i]->m_bIsWarLocation = FALSE;
											
						// ¼ÒÈ¯µÈ´Ù´Â ¸Ş½ÃÁö¸¦ º¸³½´Ù.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "1   ");
					}
				}
				
				if ((m_bIsHeldenianMode == TRUE) && (m_pMapList[m_pClientList[i]->m_cMapIndex] != 0)) {
					if (bCheckHeldenianMap(i, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
						SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, TRUE);
					}
					else {
						SetHeroFlag(i, DEF_OWNERTYPE_PLAYER, FALSE);
					}
				}	

				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_iSkillMsgRecvCount >= 2) {
					// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¦Ã€Ã› Â¸Ã­Â·Ã‰Ã€ÃŒ 2Â°Â³ Ã€ÃŒÂ»Ã³ ÃÂ¢Â¼Ã¶ÂµÃ‡Â¾ÃºÂ´Ã™Â¸Ã© Ã€ÃŒÂ»Ã³Ã‡Ã‘ Â°ÃÃ€ÃŒÂ´Ã™. ÃÂ¤Â»Ã³Ã€Ã»Ã€ÃŒÂ¶Ã³Â¸Ã© 1Â°Â³ Â±Ã®ÃÃ¶ Â¿Ãƒ Â¼Ã¶ Ã€Ã–Â´Ã™.
					//wsprintf(G_cTxt, "(!) Ã‡Ã˜Ã…Â· Â¿Ã«Ã€Ã‡Ã€Ãš(%s) Â¼Ã“ÂµÂµ ÃÂ¶Ã€Ã›", m_pClientList[i]->m_cCharName);
					//PutLogFileList(G_cTxt);
					DeleteClient(i, TRUE, TRUE);
				}
				else {
					m_pClientList[i]->m_iSkillMsgRecvCount = 0;
				}

				// Â¼Ã“ÂµÂµÂ¹Ã¶Â±Ã— ÃƒÂ¼Ã…Â©Â¿Ã«. Â´ÃœÃ€Â§Â½ÃƒÂ°Â£Â´Ã§ ÃÃ¶Â³ÂªÃ„Â¡Â°Ã” Â¸Â¹Ã€Âº Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â¾Ã²Ã€Âº Ã„Â³Â¸Â¯Ã€Âº ÂºÃ­Â·ÃÂµÃˆÂ´Ã™.
				if (m_pClientList[i] == NULL) break;
				// Ã‡ÃÃ€Â§ Â·Â¹ÂºÂ§ ÃÂ¦Ã‡Ã‘Â¿Â¡ Â°Ã‰Â¸Â°Â´Ã™Â¸Ã© 
				//if (m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) {
				if ((m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 2) ) {
					// Â¼Ã’ÃˆÂ¯ÂµÃˆÂ´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»Â°Ã­ Â°Â­ÃÂ¦ Â¸Â®Ã„Ã.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

			if (m_pClientList[i] == NULL) break;
				// Â»Ã³Ã€Â§ Â·Â¹ÂºÂ§ ÃÂ¦Ã‡Ã‘Â¿Â¡ Â°Ã‰Â¸Â°Â´Ã™Â¸Ã© 
				//if ( (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
				//	 (m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) ) {
				if ( (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
					 (m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 2) ) {
					// Â¼Ã’ÃˆÂ¯ÂµÃˆÂ´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»Â°Ã­ Â°Â­ÃÂ¦ Â¸Â®Ã„Ã.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					if ((m_pClientList[i]->m_cSide == 1) && 
					(m_pClientList[i]->m_iAdminUserLevel == 0)) {
					  RequestTeleportHandler(i, "2   ", "aresden", -1, -1);
					}
					else if ((m_pClientList[i]->m_cSide == 2) && 
					(m_pClientList[i]->m_iAdminUserLevel == 0)) {
					  RequestTeleportHandler(i, "2   ", "elvine", -1, -1);
					}
				}

				if (m_pClientList[i] == NULL) break;
				if ((strcmp(m_pClientList[i]->m_cLocation, "elvine") != 0) && 
					(strcmp(m_pClientList[i]->m_cLocation, "elvhunter") != 0) && 
					(strcmp(m_pClientList[i]->m_cLocation, "arehunter") != 0) && 
					(strcmp(m_pClientList[i]->m_cLocation, "aresden") != 0) &&
					(m_pClientList[i]->m_iLevel >= 20) &&
					(m_pClientList[i]->m_iAdminUserLevel == 0)) {
					wsprintf(G_cTxt, "Traveller Hack: (%s) Player: (%s) is a traveller and is greater than level 19.", m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName);
					PutHackLogFileList(G_cTxt);
					DeleteClient(i, TRUE, TRUE);
				}

				if (m_pClientList[i] == NULL) break;
					if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsApocalypseMap == TRUE) && 
						(m_bIsApocalypseMode == FALSE) &&
						(m_pClientList[i]->m_iAdminUserLevel == 0)) {
								RequestTeleportHandler(i, "1   ");
					}


				if (m_pClientList[i] == NULL) break;
				if (((memcmp(m_pClientList[i]->m_cLocation, "aresden",7) == 0) || (memcmp(m_pClientList[i]->m_cLocation, "elvine",6) == 0)) &&
					(m_bIsCrusadeMode == TRUE)) {
					iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName);
					if (iMapside > 3) iMapside2 = iMapside - 2;
					else iMapside2 = iMapside;

					if ((m_pClientList[i]->m_cSide != iMapside2) && (iMapside != 0)) {
						if ((iMapside <= 2) && (m_pClientList[i]->m_iAdminUserLevel < 1)) {
							if (m_pClientList[i]->m_cSide != 0) {
								m_pClientList[i]->m_dwWarBeginTime = timeGetTime();
								m_pClientList[i]->m_bIsWarLocation = TRUE;
								m_pClientList[i]->m_iTimeLeft_ForceRecall = 1;
						
								RequestTeleportHandler(i, "1   ");
								SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
							}
						}
					}
				}

				if (m_pClientList[i] == NULL) break;
				if (((memcmp(m_pClientList[i]->m_cLocation, "arehunter",9) == 0) || (memcmp(m_pClientList[i]->m_cLocation, "elvhunter",9) == 0)) &&
					 ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "2ndmiddle") == 0) || (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middleland") == 0))) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "1   ");
				}

				if (m_bIsApocalypseMode == TRUE) {
					if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "abaddon", 7) == 0) 
						SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEOPEN, 167, 169, NULL, m_pClientList[i]->m_cMapName);
					else if (memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "icebound", 8) == 0)
						SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEOPEN, 89, 31, NULL, m_pClientList[i]->m_cMapName);
				}

				if (m_pClientList[i] == NULL) break;
				if ((m_bIsApocalypseMode == TRUE) &&
					(memcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "icebound", 8) == 0) &&
					((m_pClientList[i]->m_sX == 89 && m_pClientList[i]->m_sY == 31) ||
					(m_pClientList[i]->m_sX == 89 && m_pClientList[i]->m_sY == 32) ||
					(m_pClientList[i]->m_sX == 90 && m_pClientList[i]->m_sY == 31) ||
					(m_pClientList[i]->m_sX == 90 && m_pClientList[i]->m_sY == 32))) {
					  RequestTeleportHandler(i, "2   ", "druncncity", -1, -1);
				}
				
				if (m_pClientList[i] == NULL) break;
				// Â³Ã³Â°Ã¦ÃÃ¶Â¸ÃŠÂ¿Â¡ Ã€Ã»Ã€ÃŒ ÂµÃ©Â¾Ã®Â°Â¡Â¸Ã© Â¸Â®Ã„Ã
				if ((memcmp(m_pClientList[i]->m_cLocation, "are",3) == 0) &&
					(strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {
					// Â¼Ã’ÃˆÂ¯ÂµÃˆÂ´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»Â°Ã­ Â°Â­ÃÂ¦ Â¸Â®Ã„Ã.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == NULL) break;
				// Â³Ã³Â°Ã¦ÃÃ¶Â¸ÃŠÂ¿Â¡ Ã€Ã»Ã€ÃŒ ÂµÃ©Â¾Ã®Â°Â¡Â¸Ã© Â¸Â®Ã„Ã
				if ((memcmp(m_pClientList[i]->m_cLocation, "elv", 3) == 0) &&
					(strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "arefarm") == 0)) {
					// Â¼Ã’ÃˆÂ¯ÂµÃˆÂ´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»Â°Ã­ Â°Â­ÃÂ¦ Â¸Â®Ã„Ã.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == NULL) break;
				// ÃÃŸÂ¸Â³Ã€ÃŒ ÃÂ¢Â°Ã¦ÃÃ¶Â³Âª Â¹ÃŒÂµÃ©Â·Â£ÂµÃ¥Â¿Â¡ Ã€Ã–Â´Ã™Â¸Ã© Â¸Â®Ã„Ã 
				if ( (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middleland") == 0) 
					 && (strcmp(m_pClientList[i]->m_cLocation, "NONE") == 0) &&
					 (m_pClientList[i]->m_iAdminUserLevel < 1) ) {
					// ¼ÒÈ¯µÈ´Ù´Â ¸Ş½ÃÁö¸¦ º¸³»°í °­Á¦ ¸®Äİ.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}
				
				if (m_pClientList[i]->m_bInRecallImpossibleMap == TRUE) {
					m_pClientList[i]->m_iTimeLeft_ForceRecall--;
					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_bInRecallImpossibleMap = FALSE;
						SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "0   ");
					}
				}
					
				if (m_pClientList[i] == NULL) break;
				// Ã‡ÃŠÂ»Ã¬Â±Ã¢ Ã„Â«Â¿Ã®Ã†Â® ÃÃµÂ°Â¡ 
				m_pClientList[i]->m_iSuperAttackCount++;
				if (m_pClientList[i]->m_iSuperAttackCount > 12) { //39ÃƒÃŠÂ¸Â¶Â´Ã™ Ã‡Ã‘Â°Â³Â¾Â¿ ÃƒÃ Ã€Ã» ÂµÃˆÂ´Ã™.
					
					m_pClientList[i]->m_iSuperAttackCount = 0;
					// Ã‡ÃŠÂ»Ã¬Â±Ã¢Â´Ã‚ ÃƒÃ–Â´Ã« Level/10 Â°Â³ Â±Ã®ÃÃ¶ ÃƒÃ Ã€Ã»ÂµÃˆÂ´Ã™.
					iMaxSuperAttack = (m_pClientList[i]->m_iLevel / 10);
					if (m_pClientList[i]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[i]->m_iSuperAttackLeft++;
						
					// v1.12 Â¼Â­Â¹Ã¶Â¿Ã Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â°Â£Â¿Â¡ Ã„Â«Â¿Ã®Ã†Â®Â°Â¡ Ã€ÃÃ„Â¡Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚ Â°Ã¦Â¿Ã¬Â°Â¡ Ã€Ã–Ã€Â» Â¼Ã¶ Ã€Ã–Ã€Â¸Â¹Ã‡Â·Ã Â°Â¡Â°Â¨Â¿Â¡ Â»Ã³Â°Ã¼Â¾Ã¸Ã€ÃŒ ÂºÂ¸Â³Â½Â´Ã™.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
				}

				// v1.42 Â°Ã­ÃÂ¤ Â½ÂºÃ…Ã‚Â¹ÃŒÂ³ÃŠ Ã„Â«Â¿Ã®Ã†Â® Â°Â¨Â¼Ã’ 
				m_pClientList[i]->m_iTimeLeft_FirmStaminar--;
				if (m_pClientList[i]->m_iTimeLeft_FirmStaminar < 0) m_pClientList[i]->m_iTimeLeft_FirmStaminar = 0;

				// Crusade Â¸ÃŠÃÂ¤ÂºÂ¸Â¸Â¦ ÂºÂ¸Â³Â»Â´Ã‚ ÃÃŸÃ€ÃŒÂ¾ÃºÂ´Ã™Â¸Ã© Â°Ã¨Â¼Ã“ ÂºÂ¸Â³Â½Â´Ã™.
				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_bIsSendingMapStatus == TRUE) _SendMapStatus(i);

				if (m_pClientList[i]->m_iConstructionPoint > 0) {
					// Â´Â©Ã€Ã»ÂµÃˆ Â°Ã‡Â¼Â³ Ã†Ã·Ã€ÃÃ†Â®Â°Â¡ Ã€Ã–Â´Ã™.
					CheckCommanderConstructionPoint(i);
				}
			}
		}
	}
}

void CGame::OnMainLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 int   iRet;
	
	if (m_pMainLogSock == NULL) return;

	iRet = m_pMainLogSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// ·Î±×¼­¹ö·ÎÀÇ ¿¬°áÀÌ ÀÌ·ç¾î Á³À¸¹Ç·Î °ÔÀÓ¼­¹ö µî·Ï ¸Ş½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
		PutLogList("(!!!) Main-log-socket connected!");
		bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		// ¸Ş½ÃÁö°¡ ¼ö½ÅµÇ¾ú´Ù. 
		OnMainLogRead();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		PutLogList("(!!!) Main-log-socket BLOCKED!");
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		// È®ÀÎÄÚµå°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â´Ù. 
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		// ¼ö½ÅÇØ¾ß ÇÒ ¸Ş½ÃÁö Å©±â°¡ ¹öÆÛº¸´Ù Å©´Ù.	Á¾·áÇØ¾ß¸¸ ÇÑ´Ù.
	case DEF_XSOCKEVENT_SOCKETERROR:
		// ¼ÒÄÏ¿¡ ¿¡·¯°¡ ³µ´Ù.
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¼ÒÄÏÀÌ ´İÇû´Ù.
		delete m_pMainLogSock;
		m_pMainLogSock = NULL;
		PutLogList("(!!!) Main-log-socket connection lost!");
		m_bIsLogSockAvailable = FALSE;

		// ·Î±× ¼­¹ö¿ÍÀÇ ¿¬°áÀÌ ²÷°åÀ¸¹Ç·Î º¹±¸ÇÒ ¼ö ¾ø´Ù. ÀÚµ¿À¸·Î ¼­¹ö¸¦ ¼Ë´Ù¿îÇÑ´Ù.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 3;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ğÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù. 
			PutLogList("(!!!) GAME SERVER SHUTDOWN PROCESS BEGIN(by main-log-socket connection Lost)!!!");
		}
		break;
	}
}

void CGame::OnMainLogRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pMainLogSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		// Â¸ÃÂ½ÃƒÃÃ¶ Ã…Â¥Â¿Â¡ Ã€ÃŒÂ»Ã³Ã€ÃŒ Â»Ã½Â°Ã¥Â´Ã™. Ã„Â¡Â¸Ã­Ã€Ã»Ã€Ã Â¿Â¡Â·Â¯.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}


BOOL CGame::bSendMsgToLS(DWORD dwMsg, int iClientH, BOOL bFlag, char* pData)
{
 DWORD * dwp;
 WORD  * wp;
 int     iRet, i, iSize;
 char    cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;
 char    cGuildLoc[11], cTemp[120];
 int   * ip, iSendSize;
 

	/*
	// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾ Sub-log-socket Ã€ÃÂµÂ¦Â½Âº Ã€Ã¼ÃÃ¸ 
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;


	// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»Â±Ã¢Â¿Â¡ Ã€Ã»Â´Ã§Ã‡Ã‘ Sub-log-socketÃ€Â» ÃƒÂ£Â´Ã‚Â´Ã™.
	iCnt = 0;
	bLoopFlag = FALSE;
	while (bLoopFlag == FALSE) {
		if (m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) 
			 bLoopFlag = TRUE;
		else m_iCurSubLogSockIndex++;

		iCnt++;
		if (iCnt >= DEF_MAXSUBLOGSOCK) {
			// ÂºÂ¸Â³Â¾ Â¼Ã¶ Ã€Ã–Â´Ã‚ Sub-log-socketÃ€ÃŒ Ã‡ÃÂ³ÂªÂµÂµ Â¾Ã¸Â´Ã™. Â°Â­ÃÂ¦ Â¼Ã‹Â´Ã™Â¿Ã® Â¸Ã°ÂµÃ¥Â·Ã Ã€Ã¼ÃˆÂ¯ 
			if (m_bOnExitProcess == FALSE) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				// Â°Ã”Ã€Ã“ Â¼Â­Â¹Ã¶ Â¼Ã‹Â´Ã™Â¿Ã®Ã€ÃŒ Â½ÃƒÃ€Ã›ÂµÃ‡Â¸Ã© Â´ÃµÃ€ÃŒÂ»Ã³Ã€Ã‡ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® ÃÂ¢Â¼Ã“Ã€ÃŒ Â°Ã…ÂºÃÂµÃˆÂ´Ã™. 
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost)!!!");
			}
			return FALSE;
		}
	}
	*/
	

	// v1.41
	ZeroMemory(G_cData50000, sizeof(G_cData50000));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,   sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));
	ZeroMemory(cGuildLoc,  sizeof(cGuildLoc));

	switch (dwMsg) {
	// New 07/05/2004
	case MSGID_GAMEMASTERLOG:
		// Sub-log-socketÃ€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Ã¼Â¼Ã›Â¿Â¡Â¼Â­Â´Ã‚ Â¹ÃÂµÃ¥Â½Ãƒ ÃƒÂ¼Ã…Â©Ã‡Ã˜Â¾ÃŸ Ã‡ÃÂ´Ã‚ Â·Ã§Ã†Â¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (pData == NULL) return FALSE ;


		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMEMASTERLOG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;
		// v2.15 

	case MSGID_GAMEITEMLOG:
		// Sub-log-socketÃ€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Ã¼Â¼Ã›Â¿Â¡Â¼Â­Â´Ã‚ Â¹ÃÂµÃ¥Â½Ãƒ ÃƒÂ¼Ã…Â©Ã‡Ã˜Â¾ÃŸ Ã‡ÃÂ´Ã‚ Â·Ã§Ã†Â¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		//		if (m_pClientList[iClientH] == NULL) return FALSE;
		if (pData == NULL) return FALSE ;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMEITEMLOG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		iSize =  strlen(pData) ;
		memcpy((char *)cp, pData, iSize);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 6 + iSize);
		iSendSize = 6 + iSize;
		break;

	case MSGID_SENDSERVERSHUTDOWNMSG:
		if (m_pMainLogSock == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_SENDSERVERSHUTDOWNMSG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		// Ã€ÃŒ Â¸ÃÂ½ÃƒÃÃ¶Â´Ã‚ m_pMainLogSockÃ€Â¸Â·Ã ÂºÂ¸Â³Â»Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		break;
	
	case MSGID_GAMESERVERSHUTDOWNED:
		if (m_pMainLogSock == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERSHUTDOWNED;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		// Ã€ÃŒ Â¸ÃÂ½ÃƒÃÃ¶Â´Ã‚ m_pMainLogSockÃ€Â¸Â·Ã ÂºÂ¸Â³Â»Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		return TRUE;

	case MSGID_REQUEST_SETACCOUNTWAITSTATUS:
	case MSGID_REQUEST_SETACCOUNTINITSTATUS:
		// Sub-log-socketÃ€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Ã¼Â¼Ã›Â¿Â¡Â¼Â­Â´Ã‚ Â¹ÃÂµÃ¥Â½Ãƒ ÃƒÂ¼Ã…Â©Ã‡Ã˜Â¾ÃŸ Ã‡ÃÂ´Ã‚ Â·Ã§Ã†Â¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;
	
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 20);
		iSendSize = 16;
		break;

	case MSGID_ENTERGAMECONFIRM:
		
		// Sub-log-socketÃ€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Ã¼Â¼Ã›Â¿Â¡Â¼Â­Â´Ã‚ Â¹ÃÂµÃ¥Â½Ãƒ ÃƒÂ¼Ã…Â©Ã‡Ã˜Â¾ÃŸ Ã‡ÃÂ´Ã‚ Â·Ã§Ã†Â¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_ENTERGAMECONFIRM;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		memcpy(cp, m_pClientList[iClientH]->m_cAccountPassword, 10);
		cp += 10;

		memcpy(cp, m_cServerName, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt));
		m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTxt);
		memcpy(cp, cTxt, 16);
		cp += 16;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;

		//testcode
		wsprintf(G_cTxt, "Confirmed. Account: (%s) Name: (%s) Level: (%d)", m_pClientList[iClientH]->m_cAccountName, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iLevel);
		PutLogList(G_cTxt);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;
	
	case MSGID_REQUEST_REGISTERGAMESERVER:
		// Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â¿Â¡Â°Ã” Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶ ÂµÃ®Â·ÃÃ€Â» Â¿Ã¤ÃƒÂ»Ã‡Ã‘Â´Ã™.
		if (m_pMainLogSock == NULL) return FALSE;
				
		wsprintf(cTxt, "(!) Try to register game server(%s)", m_cServerName);
		PutLogList(cTxt);
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cAccountName, m_cServerName, 10);
		if (m_iGameServerMode == 1)
		{
			memcpy(cAddress, m_cGameServerAddrExternal, strlen(m_cGameServerAddrExternal));
		}
		if (m_iGameServerMode == 2)
		{
			memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
		}
		memcpy(cp, cAccountName, 10);
		cp += 10;

		memcpy(cp, cAddress, 16);
		cp += 16;

		wp  = (WORD *)cp;
		*wp = m_iGameServerPort;
		cp += 2;

		*cp = m_iTotalMaps;
		cp++;

		for (i = 0; i < m_iTotalMaps; i++) {
			memcpy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}

		// Ã€ÃŒ Â¸ÃÂ½ÃƒÃÃ¶Â´Ã‚ m_pMainLogSockÃ€Â¸Â·Ã ÂºÂ¸Â³Â»Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 35 + m_iTotalMaps*11); 

		return TRUE;

	case MSGID_REQUEST_PLAYERDATA:
		
		// Sub-log-socketÃ€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Ã¼Â¼Ã›Â¿Â¡Â¼Â­Â´Ã‚ Â¹ÃÂµÃ¥Â½Ãƒ ÃƒÂ¼Ã…Â©Ã‡Ã˜Â¾ÃŸ Ã‡ÃÂ´Ã‚ Â·Ã§Ã†Â¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		// Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â·Ã Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® ÂµÂ¥Ã€ÃŒÃ…ÃÂ¸Â¦ Â¿Ã¤ÃƒÂ»Ã‡Ã‘Â´Ã™.
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_PLAYERDATA;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//testcode
		if (strlen(m_pClientList[iClientH]->m_cCharName) == 0) PutLogList("(X) CharName NULL!");

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		ZeroMemory(cTemp, sizeof(cTemp));
		iRet = m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp);
		memcpy((char *)cp, cTemp, 15);
		cp += 15;
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 52);
		iSendSize = 52;
		break;

	case MSGID_REQUEST_SAVEPLAYERDATA_REPLY:
	case MSGID_REQUEST_SAVEPLAYERDATA:
	case MSGID_REQUEST_SAVEPLAYERDATALOGOUT:

		// Sub-log-socketÃ€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Ã¼Â¼Ã›Â¿Â¡Â¼Â­Â´Ã‚ Â¹ÃÂµÃ¥Â½Ãƒ ÃƒÂ¼Ã…Â©Ã‡Ã˜Â¾ÃŸ Ã‡ÃÂ´Ã‚ Â·Ã§Ã†Â¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		*cp = (char)bFlag; // Ã„Â«Â¿Ã®Ã†Ãƒ Ã‡ÃƒÂ·Â¡Â±Ã— 
		cp++;
		
		iSize = _iComposePlayerDataFileContents(iClientH, cp);
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37 + iSize);
		iSendSize = 37 + iSize;
		break;

	case MSGID_REQUEST_NOSAVELOGOUT:

		// Sub-log-socketÃ€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Ã¼Â¼Ã›Â¿Â¡Â¼Â­Â´Ã‚ Â¹ÃÂµÃ¥Â½Ãƒ ÃƒÂ¼Ã…Â©Ã‡Ã˜Â¾ÃŸ Ã‡ÃÂ´Ã‚ Â·Ã§Ã†Â¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_NOSAVELOGOUT;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;
		
		*cp = (char)bFlag; // Ã„Â«Â¿Ã®Ã†Ãƒ Ã‡ÃƒÂ·Â¡Â±Ã— 
		cp++;
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37);
		iSendSize = 37;
		break;
	
	case MSGID_REQUEST_CREATENEWGUILD:

		// Sub-log-socketÃ€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Ã¼Â¼Ã›Â¿Â¡Â¼Â­Â´Ã‚ Â¹ÃÂµÃ¥Â½Ãƒ ÃƒÂ¼Ã…Â©Ã‡Ã˜Â¾ÃŸ Ã‡ÃÂ´Ã‚ Â·Ã§Ã†Â¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_CREATENEWGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		memcpy(cGuildLoc, m_pClientList[iClientH]->m_cLocation, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		memcpy((char *)cp, cGuildLoc, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 75);
		iSendSize = 75;
		break;

	case MSGID_REQUEST_DISBANDGUILD:
		// Sub-log-socketÃ€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Ã¼Â¼Ã›Â¿Â¡Â¼Â­Â´Ã‚ Â¹ÃÂµÃ¥Â½Ãƒ ÃƒÂ¼Ã…Â©Ã‡Ã˜Â¾ÃŸ Ã‡ÃÂ´Ã‚ Â·Ã§Ã†Â¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_DISBANDGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;

	case MSGID_REQUEST_HELDENIAN_WINNER:
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_HELDENIAN_WINNER;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		if (m_cHeldenianVictoryType == 1)
			memcpy(cp, "aresden", 7);
		else if (m_cHeldenianVictoryType == 2)
			memcpy(cp, "elvine", 6);
		else 
			memcpy(cp, "draw", 4);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 21);
		iSendSize = 21;
		break;
	
	case MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN:

		// Sub-log-socketÃ€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Ã¼Â¼Ã›Â¿Â¡Â¼Â­Â´Ã‚ Â¹ÃÂµÃ¥Â½Ãƒ ÃƒÂ¼Ã…Â©Ã‡Ã˜Â¾ÃŸ Ã‡ÃÂ´Ã‚ Â·Ã§Ã†Â¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN:

		// Sub-log-socketÃ€Â» Â»Ã§Â¿Ã«Ã‡Ã‘ Ã€Ã¼Â¼Ã›Â¿Â¡Â¼Â­Â´Ã‚ Â¹ÃÂµÃ¥Â½Ãƒ ÃƒÂ¼Ã…Â©Ã‡Ã˜Â¾ÃŸ Ã‡ÃÂ´Ã‚ Â·Ã§Ã†Â¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Sub-log-socketÃ€Â» Â»Ã§Â¿Ã«Ã‡Ã˜Â¼Â­ Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â·Ã Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™.
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) send error!", m_iCurSubLogSockIndex);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);

		delete m_pSubLogSock[m_iCurSubLogSockIndex];
		m_pSubLogSock[m_iCurSubLogSockIndex] = NULL;
		m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = FALSE;
		m_iSubLogSockActiveCount--;
				
		// Â´Ã™Â½Ãƒ Â¿Â¬Â°Ã¡Ã€Â» Â½ÃƒÂµÂµ
		m_pSubLogSock[m_iCurSubLogSockIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[m_iCurSubLogSockIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iCurSubLogSockIndex + 1));
		m_pSubLogSock[m_iCurSubLogSockIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);

		wsprintf(G_cTxt, "(!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", m_iCurSubLogSockIndex, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);
		
		// v1.41 sub-log-socket Ã€Ã¼Â¼Ã› Â½Ã‡Ã†Ã Ã„Â«Â¿Ã®Ã†Â® ÃÃµÂ°Â¡ 
		m_iSubLogSockFailCount++;

		// v1.41 ÂºÂ¸Â³Â»Â·ÃÂ´Ã™ Â½Ã‡Ã†ÃÃ‡Ã‘ Â¸ÃÂ½ÃƒÃÃ¶Â´Ã‚ Â´Ã™Â¸Â¥ Â¼Ã’Ã„ÃÃ€Â» Â»Ã§Â¿Ã«Ã‡ÃÂ¿Â© Ã€Ã¼Â¼Ã›Ã‡Ã˜Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
		// Ã€ÃŒ Â¹Ã¦Â¹Ã½Ã€ÃŒ Â¸Ã°ÂµÃ§ Â¸ÃÂ½ÃƒÃÃ¶Ã€Ã‡ Ã€Ã¼Â¼Ã›Ã€Â» ÂºÂ¸Ã€Ã¥Ã‡ÃÃÃ¶Â´Ã‚ Â¾ÃŠÂ´Ã‚Â´Ã™. ÃƒÃ–Â¼Ã’Ã‡Ã‘Ã€Ã‡ Ã€Ã¥Ã„Â¡Ã€Ã Â¼Ã€.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);

		return FALSE;
	}

	return TRUE;
}

void CGame::ResponsePlayerDataHandler(char * pData, DWORD dwSize)
{
 WORD * wp;
 char * cp, cCharName[11], cTxt[120];
 int  i; 
 
 	// Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â·ÃÂºÃÃ…Ã Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® ÂµÂ¥Ã€ÃŒÃ…ÃÂ°Â¡ ÂµÂµÃ‚Ã¸Ã‡ÃŸÂ´Ã™. 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	// Ã€ÃŒÂ¸Â§Ã€ÃŒ Ã€ÃÃ„Â¡Ã‡ÃÂ´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â¹Ã¨Â¿Â­Ã€Â» Â°Ã‹Â»Ã¶Ã‡Ã‘Â´Ã™. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
			wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
			switch (*wp) {
			case DEF_LOGRESMSGTYPE_CONFIRM:
				// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® ÂµÂ¥Ã€ÃŒÃ…ÃÂ°Â¡ ÃÂ¤Â»Ã³Ã€Ã»Ã€Â¸Â·Ã Â¼Ã¶Â½Ã…ÂµÃ‡Â¾ÃºÂ´Ã™. 
				InitPlayerData(i, pData, dwSize); 
				break;
	
			case DEF_LOGRESMSGTYPE_REJECT:
				// Ã€ÃŒ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Ã€Ã‡ ÂµÂ¥Ã€ÃŒÃ…Ã ÃƒÃŠÂ±Ã¢ÃˆÂ­Â°Â¡ Â°Ã…ÂºÃÂµÃ‡Â¾ÃºÂ´Ã™. ÃÂ¢Â¼Ã“Ã€Â» Â²Ã·Â´Ã‚Â´Ã™.
				wsprintf(G_cTxt, "(HACK?) Not existing character(%s) data request! Rejected!", m_pClientList[i]->m_cCharName);
				PutLogList(G_cTxt);
				//PutLogFileList(G_cTxt); // v1.4

				DeleteClient(i, FALSE, FALSE);
				break;
			
			default:
				break;
			}				
			
			return;
		}	
	}

	// Ã€ÃŒÂ¸Â§Ã€ÃŒ Ã€ÃÃ„Â¡Ã‡ÃÂ´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¸Â¦ ÃƒÂ£Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server: CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::InitPlayerData(int iClientH, char * pData, DWORD dwSize)
{
	char  * cp, cName[11], cData[256], cTxt[256], cGuildStatus, cQuestRemain;
	DWORD * dwp;
	WORD  * wp;
	int     iRet, i, iTotalPoints;
	BOOL    bRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return; // Ã€ÃŒÂ¹ÃŒ ÃƒÃŠÂ±Ã¢ÃˆÂ­ ÂµÃˆ Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ ÂµÂ¥Ã€ÃŒÃ…ÃÃ€ÃŒÂ´Ã™. Ã€ÃŒÂ·Â±Ã€ÃÃ€ÃŒ Ã€Ã–Ã€Â» Â¼Ã¶ Ã€Ã–Ã€Â»Â±Ã®?

	// Log ServerÂ·ÃÂºÃÃ…ÃÃ€Ã‡ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÃÂ¼Â®Ã‡ÃÂ¿Â© Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ ÂµÂ¥Ã€ÃŒÃ…ÃÂ¸Â¦ ÃƒÃŠÂ±Ã¢ÃˆÂ­Ã‡Ã‘Â´Ã™. 
	// Â¸Â¸Â¾Ã  Â·ÃÂ±Ã—Â¼Â­Â¹Ã¶Â·ÃÂºÃÃ…ÃÃ€Ã‡ Â¸ÃÂ½ÃƒÃÃ¶Â°Â¡ Ã†Ã„Ã€ÃÂ¼Ã•Â»Ã³ÂµÃ®Ã€Ã‡ Ã€ÃŒÃ€Â¯Â·Ã Â³Â»Â¿Ã«Ã€ÃŒ ÃÂ¤ÃˆÂ®Ã‡ÃÂ°Ã” Â¸Ã‚ÃÃ¶ Â¾ÃŠÃ€Â¸Â¸Ã© ÃƒÃŠÂ±Ã¢ÃˆÂ­ Ã‡ÃÃÃ¶ Â¾ÃŠÂ°Ã­ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¸Â¦ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

	// Â°Ã¨ÃÂ¤ÃÂ¤ÂºÂ¸ Ã€ÃºÃ€Ã¥  v1.43	ÂºÃÃ…Ã Â´ÃµÃ€ÃŒÂ»Ã³Ã€Ã‡ Â°Ã¨ÃÂ¤ ÃÂ¤ÂºÂ¸Â´Ã‚ Ã‡ÃŠÂ¿Ã¤Â¾Ã¸Â´Ã™. 
	//m_pClientList[iClientH]->m_cAccountStatus = *cp;
	cp++;

	// Â±Ã¦ÂµÃ¥ ÃÂ¤ÂºÂ¸ Ã€ÃÂ´Ã‚Â´Ã™. Ã€ÃŒ Â°ÂªÃ€ÃŒ 0Ã€ÃŒÂ¸Ã© Â±Ã¦ÂµÃ¥Ã€ÃŒÂ¸Â§Â°Ãº Â·Â©Ã…Â©Â´Ã‚ Â¹Â«ÃˆÂ¿Â´Ã™.  
	cGuildStatus = *cp;
	cp++;

	// Â±Ã¢ÂºÂ» Â¸Ã­ÃÃŸÂ·Ã¼Ã€Âº 0%(Â¹Ã¦Â¾Ã®Â·Ã¼Â°ÃºÂ´Ã‚ Â¾Ã Â°Â£ Ã€Ã‡Â¹ÃŒÂ°Â¡ Â´Ã™Â¸Â§. Â¸Ã‡Â¼Ã•Â°Ã¸Â°ÃÂ½ÃƒÃ€Ã‡ Â¸Ã­ÃÃŸÂ·Ã¼Ã€Âº ÂµÃ»Â·Ã Â°Ã¨Â»ÃªÂµÃˆÂ´Ã™)
	m_pClientList[iClientH]->m_iHitRatio     = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = 0;
	m_pClientList[iClientH]->m_cSide         = 0;

	bRet = _bDecodePlayerDatafileContents(iClientH, cp, dwSize - 19);
	// Â¸Â®Ã…ÃÂ°ÂªÃ€ÃŒ FALSEÃ€ÃŒÂ¸Ã© Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® ÂµÂ¥Ã€ÃŒÃ…ÃÂ°Â¡ Â¹Â«Â¾Ã°Â°Â¡ Ã€ÃŸÂ¸Ã¸ÂµÃˆ Â°Ã. Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¸Â¦ Â»Ã¨ÃÂ¦Ã‡ÃÂ°Ã­ Â¸Â®Ã…ÃÃ‡Ã‘Â´Ã™.
	if (bRet == FALSE) {
		wsprintf(G_cTxt, "(HACK?) Character(%s) data error!", m_pClientList[iClientH]->m_cCharName);
		DeleteClient(iClientH, FALSE, TRUE); //!!!
		return;
	}

	// *******^^^^^^^^^^^^^^^^^^^^Ã†Â¯Â¼ÂºÃ„Â¡Â°Âª Â·ÃÂµÃ¹ Â¿ÃÂ·Ã¡^^^^^^^^^^^^^^^^^^^^^********
	//***************************************************************************

	// (!) Ã†Â¯Â¼ÂºÃ„Â¡Â¸Â¦ ÂºÂ¹Â±Â¸Ã‡Ã‘Â´Ã™. 
	___RestorePlayerCharacteristics(iClientH);

	// (!) Ã€ÃŸÂ¸Ã¸ÂµÃˆ Ã†Â¯Â¼ÂºÃ„Â¡Â¸Â¦ ÂºÂ¹Â±Â¸Ã‡Ã‘Â´Ã™. 
	___RestorePlayerRating(iClientH);

	if ((m_pClientList[iClientH]->m_sX == -1) && (m_pClientList[iClientH]->m_sY == -1)) {
		// ÃÃ‚Ã‡Â¥Â°Â¡ Â¸Ã°ÂµÃ -1Ã€ÃŒÂ¸Ã© Ã€Â§Ã„Â¡Ã‡Ã‘ Â¸ÃŠÃ€Ã‡ InitialPointÂ·Ã Â°Â£Â´Ã™.
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);
	}

	// New 17/05/2004
	SetPlayingStatus(iClientH);
	int iTemp, iTemp2;
	iTemp = m_pClientList[iClientH]->m_iStatus;
	iTemp = 0x0FFFFFFF & iTemp;
	iTemp2 = iGetPlayerABSStatus(iClientH);
	iTemp = iTemp | (iTemp2 << 28);
	m_pClientList[iClientH]->m_iStatus = iTemp;

	if (m_pClientList[iClientH]->m_iLevel > 100)
		if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
			ForceChangePlayMode(iClientH, FALSE);

	// Â´Ã™Ã€Â½ Â·Â¹ÂºÂ§Ã€Ã‡ Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â±Â¸Ã‡Ã‘Â´Ã™.
	m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);

	// Ã†Â¯Â¼ÂºÃ„Â¡ Ã€Ã§Â°Ã¨Â»Ãª.
	CalcTotalItemEffect(iClientH, -1, TRUE); //FALSE
	// Â¹Â«Â°Ã” Â°Ã¨Â»Ãª
	iCalcTotalWeight(iClientH);

	// New 23/05/2004
	//GM Invi comes here
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
	}
	
	if ((m_pClientList[iClientH]->m_iLevel > 2) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) && 
		(m_pClientList[iClientH]->m_iExp < iGetLevelExp(m_pClientList[iClientH]->m_iLevel-1)-3000)) {
		wsprintf(G_cTxt, "Data Error: (%s) Player: (%s) CurrentExp: %d --- Minimum Exp: %d", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iExp, (iGetLevelExp(m_pClientList[iClientH]->m_iLevel)-1));
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];
		if ((iTotalPoints-21 > m_sCharSkillLimit) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) - has more than allowed skill points (%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, iTotalPoints);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
		
	// Ã†Â¯Â¼Ã¶ Ã€ÃŒÂºÂ¥Ã†Â® Â°Ã¨Â»Ãª 
	CheckSpecialEvent(iClientH);
	bCheckMagicInt(iClientH);

	// GuildNameÃ€ÃŒ NONEÃ€ÃŒ Â¾Ã†Â´ÃÂ°Ã­ GuildStatusÂ°Â¡ 0Ã€ÃŒÂ¸Ã© ÃÂ¢Â¼Ã“ÃÃŸÃ€ÃŒ Â¾Ã†Â´Ã’Â¶Â§ Â±Ã¦ÂµÃ¥Â°Â¡ ÃÃ¶Â¿Ã¶ÃÂ³Â´Ã™Â´Ã‚ Ã€Ã‡Â¹ÃŒ.
	if ((cGuildStatus == 0) && (memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
		// Â±Ã¦ÂµÃ¥Â°Â¡ ÂºÃ±ÃÂ¢Â¼Ã“ÃÃŸÃ€ÃÂ¶Â§ Â»Ã§Â¶Ã³ÃÂ³Ã€Â¸Â¹Ã‡Â·Ã ÃÃ¶Â±Ã Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
		ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
		strcpy(m_pClientList[iClientH]->m_cGuildName, "NONE");
		m_pClientList[iClientH]->m_iGuildRank = -1;
		m_pClientList[iClientH]->m_iGuildGUID = -1;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cGuildName);
	}

	if (m_pClientList[iClientH]->m_iQuest != NULL) { 
			cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);
			_bCheckIsQuestCompleted(iClientH);
	}


	// Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã› ÂµÂµÃÃŸ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃÂ¿Â© Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â°Â¡ Â»Ã¨ÃÂ¦ÂµÃ‡Â¾ÃºÂ´Ã™Â¸Ã© ÃƒÂ³Â¸Â® ÃÂ¾Â·Ã¡ 
	if (m_pClientList[iClientH] == NULL) {
		wsprintf(cTxt, "<%d> InitPlayerData error - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITPLAYER;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	// ÂµÂ¥Ã€ÃŒÃ…Ã ÃƒÃŠÂ±Ã¢ÃˆÂ­ ÃˆÂ®Ã€Ã Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã›
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
		// ## BUG POINT!!! Â¸Ã•Ã€Ãº Â·ÃÂ±Ã— Â¸ÃÂ½ÃƒÃÃ¶ ÃƒÃ¢Â·Ã‚ÃˆÃ„ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
		wsprintf(cTxt, "<%d> InitPlayerData - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);

		DeleteClient(iClientH, FALSE, TRUE); //!!!!!
		return;
	}

	// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Ã€Ã‡ ÂµÂ¥Ã€ÃŒÃ…ÃÂ°Â¡ ÃƒÃŠÂ±Ã¢ÃˆÂ­ ÂµÃ‡Â¾ÃºÂ´Ã™. 
	m_pClientList[iClientH]->m_bIsInitComplete = TRUE;

	// Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â¿Â¡Â°Ã” Ã€ÃŒ Â°Ã¨ÃÂ¤Ã€Ã‡ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â°Ã”Ã€Ã“ÃÃŸÂ¿Â¡ ÂµÃ©Â¾Ã®Â¿Ã”Ã€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™. 
	bSendMsgToLS(MSGID_ENTERGAMECONFIRM, iClientH);

	// Â¼Â­Â¹Ã¶ Â´Ã™Â¿Ã®Ã€Â» Â¸Â·Â±Ã¢Ã€Â§Ã‡Ã‘ ÃƒÃ–ÃˆÃ„Ã€Ã‡ ÃÂ¶Ã„Â¡Ã€ÃŒÂ´Ã™.
	if (m_iTotalClients > DEF_MAXONESERVERUSERS) {
		switch (iDice(1,2)) {
		case 1: 
			RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
			break;
			case 2: 
				switch (m_pClientList[iClientH]->m_cSide) {
					case 0: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1); break;
					case 1: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1); break;
					case 2: RequestTeleportHandler(iClientH, "2   ", "resurr2", -1, -1); break;
				}
				break;
		}
	}

	return;
}

void CGame::GameProcess()
{
	NpcProcess();
	MsgProcess();
	DelayEventProcess();
}

BOOL CGame::bReadProgramConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadMode, cTxt[120], cGSMode[16] = "";
	char seps[] = "= \t\n";	
	class CStrTok * pStrTok;
	bool bGateDNS = false; // bGateDNS added by snaipperi
	bool bLogDNS = false; // bLogDNS added by snaipperi

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);//´ò¿ªGServer.cfgÎÄ¼ş
	dwFileSize = GetFileSize(hFile, NULL); //²âÊÔÎÄ¼ş´óĞ¡
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile); //´íÎó¾Í¹Ø±ÕÎÄ¼ş

	pFile = fopen(cFn, "rt"); //ÒÔ¡°¶ÁĞ´¡±µÄĞÎÊ½´ò¿ªÎÄ¼ş
	if (pFile == NULL) {

		//	PutLogList("(!) Cannot open configuration file.");
		return FALSE;
	}
	else {
		PutLogList("(!) ¶ÁÈ¡ÅäÖÃÎÄ¼şÖĞ...");//Ğ´ÈëÈÕÖ¾ÎÄ¼şÖĞ
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile); //°ÑÎÄ¼ş¶ÁÈëÄÚ´æ

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet(); //½âÎöÎÄ¼şĞÅÏ¢
		//token = strtok( cp, seps );   
		//µ±½âÎö³öÀ´µÄÖµºÍÏÂÃæµÄ×Ö·û´®±È½Ï ÏàÍ¬¾Í·µ»Ø¶ÔÓ¦µÄ cReadMode ¾ÍÊÇÏÂÃæ SwitchÓï¾äÑ¡Ôñ¶ÔÓ¦µÄcaseÓï¾ä
		/*
				if (memcmp(token, "game-server-name", 16) == 0)			cReadMode = 1;
				if (memcmp(token, "game-server-port", 16) == 0)			cReadMode = 2;
				if (memcmp(token, "log-server-address", 18) == 0)		cReadMode = 3;
				if (memcmp(token, "internal-log-server-port", 24) == 0) cReadMode = 4;
				if (memcmp(token, "game-server-map", 15) == 0)			cReadMode = 5;
				if (memcmp(token, "gate-server-address", 19) == 0)		cReadMode = 6;
				if (memcmp(token, "gate-server-port", 16) == 0)			cReadMode = 7;
				if (memcmp(token, "game-server-internal-address", 28) == 0)			cReadMode = 8;
				if (memcmp(token, "game-server-external-address", 28) == 0)			cReadMode = 9;
				if (memcmp(token, "game-server-address", 19) == 0)		cReadMode = 10;
				if (memcmp(token, "game-server-mode", 16) == 0)			cReadMode = 11;
				if (memcmp(token, "gate-server-dns", 15) == 0) cReadMode = 12;
				if (memcmp(token, "log-server-dns", 14) == 0) cReadMode = 13;*/
		while( token != NULL )   {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					ZeroMemory(m_cServerName, sizeof(m_cServerName));
					if (strlen(token) > 10) {
						// Â¼Â­Â¹Ã¶Ã€Ã‡ Ã€ÃŒÂ¸Â§Ã€ÃŒ Â³ÃŠÂ¹Â« Â±Ã¦Â´Ã™. 
						wsprintf(cTxt, "(!!!) Game server name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cServerName, token);
					wsprintf(cTxt, "(*) ·şÎñÆ÷Ãû³Æ : %s", m_cServerName);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 2:
					// v2.04 Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶ IP Ã€ÃšÂµÂ¿Ã€Â¸Â·Ã Ã€ÃÂ½Ã„ 
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					char ServerAddr[50];
					::gethostname(ServerAddr,50); 
					struct hostent *pHostEnt;
					pHostEnt = ::gethostbyname(ServerAddr);
					if( pHostEnt != NULL ){
						wsprintf(ServerAddr, "%d.%d.%d.%d",
							( pHostEnt->h_addr_list[0][0] & 0x00ff ),
							( pHostEnt->h_addr_list[0][1] & 0x00ff ),
							( pHostEnt->h_addr_list[0][2] & 0x00ff ),
							( pHostEnt->h_addr_list[0][3] & 0x00ff ) );
					}
					strcpy(m_cGameServerAddr,ServerAddr );

					wsprintf(cTxt, "(*) ·şÎñÆ÷µØÖ· : %s", m_cGameServerAddr);
					PutLogList(cTxt);

					m_iGameServerPort = atoi(token);
					wsprintf(cTxt, "(*) ·şÎñÆ÷¶Ë¿Ú : %d", m_iGameServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 3:
					ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));

					if (bLogDNS == true) { //bLogDNS by Snaipperi
						PutLogList(cTxt);
						char *cAddress = token;
						char cDnsResult[40];
						struct hostent *host_entry;

						host_entry = gethostbyname(cAddress);
						if (host_entry == NULL) {
							wsprintf(cTxt, "(!)DNS (%s) failed",token);
							PutLogList(cTxt);
							return FALSE;
						}

							wsprintf(cDnsResult, "%d.%d.%d.%d",
							( pHostEnt->h_addr_list[0][0] & 0x00ff ),
							( pHostEnt->h_addr_list[0][1] & 0x00ff ),
							( pHostEnt->h_addr_list[0][2] & 0x00ff ),
							( pHostEnt->h_addr_list[0][3] & 0x00ff ) );
				
							wsprintf(cTxt, "(!)DNS from (%s) to (%s) success!",token,cDnsResult);
							PutLogList(cTxt);
							strcpy(m_cLogServerAddr, cDnsResult);
							wsprintf(cTxt, "(*) ÈÕÖ¾·şÎñÆ÷µØÖ· : %s", m_cLogServerAddr);
							PutLogList(cTxt);
							cReadMode = 0;
							break;
					}

					if (strlen(token) > 20) {
						// ÁÖ¼Ò°¡ 15¹ÙÀÌÆ® ÀÌ»ó. ¿À·ù´Ù. 
						wsprintf(cTxt, "(!!!) ÈÕÖ¾·şÎñÆ÷µØÖ·(%s) must within 20 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cLogServerAddr, token);
					wsprintf(cTxt, "(*) ÈÕÖ¾·şÎñÆ÷µØÖ· : %s", m_cLogServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;


				case 4:
					m_iLogServerPort = atoi(token);
					wsprintf(cTxt, "(*) ÈÕÖ¾·şÎñÆ÷¶Ë¿Ú : %d", m_iLogServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 5:
					// Â¸ÃŠÃ€Â» ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
					if (strlen(token) > 10) {
						// Â¸ÃŠÃ€Ã‡ Ã€ÃŒÂ¸Â§Ã€ÃŒ Â³ÃŠÂ¹Â« Â±Ã¦Â´Ã™.
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					if (_bRegisterMap(token) == FALSE) {
						return FALSE;
					}
					cReadMode = 0;
					break;

				case 6:
					ZeroMemory(m_cGateServerAddr, sizeof(m_cGateServerAddr));
					if (bGateDNS == true) { //bGateDNS by Snaipperi
						PutLogList(cTxt);
						char *cAddress = token;
						char cDnsResult[40];
						struct hostent *host_entry;

						host_entry = gethostbyname(cAddress);
						if (host_entry == NULL) {
							wsprintf(cTxt, "(!)DNS (%s) failed",token);
							PutLogList(cTxt);
							return FALSE;
						}

							wsprintf(cDnsResult, "%d.%d.%d.%d",
							( host_entry->h_addr_list[0][0] & 0x00ff ),
							( host_entry->h_addr_list[0][1] & 0x00ff ),
							( host_entry->h_addr_list[0][2] & 0x00ff ),
							( host_entry->h_addr_list[0][3] & 0x00ff ) );
				
							wsprintf(cTxt, "(!)DNS from (%s) to (%s) success!",token,cDnsResult);
							PutLogList(cTxt);
							strcpy(m_cGateServerAddr, cDnsResult);
							wsprintf(cTxt, "(*) Íø¹Ø·şÎñÆ÷µØÖ· : %s", m_cGateServerAddr);
							PutLogList(cTxt);
							cReadMode = 0;
							break;
					}
				
					if (strlen(token) > 20) {
						// ÁÖ¼Ò°¡ 15¹ÙÀÌÆ® ÀÌ»ó. ¿À·ù´Ù. 
						wsprintf(cTxt, "(!!!) Gate server address(%s) must within 20 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGateServerAddr, token);
					wsprintf(cTxt, "(*) Íø¹Ø·şÎñÆ÷µØÖ· : %s", m_cGateServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
					break;

				case 7:
					m_iGateServerPort = atoi(token);
					wsprintf(cTxt, "(*) Íø¹Ø·şÎñÆ÷µØÖ· : %d", m_iGateServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 8:
					ZeroMemory(m_cGameServerAddrInternal, sizeof(m_cGameServerAddrInternal));
					if (strlen(token) > 15) {
						// ÃÃ–Â¼Ã’Â°Â¡ 15Â¹Ã™Ã€ÃŒÃ†Â® Ã€ÃŒÂ»Ã³. Â¿Ã€Â·Ã¹Â´Ã™. 
						wsprintf(cTxt, "(!!!) Internal (LAN) Game server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGameServerAddrInternal, token);
					wsprintf(cTxt, "(*) Internal (LAN) Game server address : %s", m_cGameServerAddrInternal);
					PutLogList(cTxt);
					cReadMode = 0;
					break;


				case 9:
					ZeroMemory(m_cGameServerAddrExternal, sizeof(m_cGameServerAddrExternal));
					if (strlen(token) > 15) {
						// ÃÃ–Â¼Ã’Â°Â¡ 15Â¹Ã™Ã€ÃŒÃ†Â® Ã€ÃŒÂ»Ã³. Â¿Ã€Â·Ã¹Â´Ã™. 
						wsprintf(cTxt, "(!!!) External (Internet) Game server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGameServerAddrExternal, token);
					wsprintf(cTxt, "(*) External (Internet) Game server address : %s", m_cGameServerAddrExternal);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 10:
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					if (strlen(token) > 15) {
						// ÃÃ–Â¼Ã’Â°Â¡ 15Â¹Ã™Ã€ÃŒÃ†Â® Ã€ÃŒÂ»Ã³. Â¿Ã€Â·Ã¹Â´Ã™. 
						wsprintf(cTxt, "(!!!) Game server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGameServerAddr, token);
					wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				case 11:
					if ((memcmp(token, "lan", 3) == 0) || (memcmp(token, "LAN", 3) == 0))
					{
						m_iGameServerMode = 1;
						memcpy(cGSMode, "LAN", 3);
					}
					if ((memcmp(token, "internet", 3) == 0) || (memcmp(token, "INTERNET", 3) == 0))
					{
						m_iGameServerMode = 2;
						memcpy(cGSMode, "INTERNET", 8);
					}
					if (m_iGameServerMode == 0)
					{
						wsprintf(cTxt, "(!!!) Game server mode(%s) must be either LAN/lan/INTERNET/internet", token);
						PutLogList(cTxt);
						return FALSE;
					}
					wsprintf(cTxt, "(*) Game server mode : %s", cGSMode);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
			
				case 12: //Gate DNS by SNaipperi
					if (memcmp(token, "true", 4) == 0) {
						bGateDNS = TRUE;
					}
					else bGateDNS = FALSE;
					wsprintf(cTxt, "Gate DNS is set to %i",bGateDNS);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 13: //Log DNS by Snaipperi
					if (memcmp(token, "true", 4) == 0) {
						bLogDNS = TRUE;
					}
					else bLogDNS = FALSE;
					wsprintf(cTxt, "Log DNS is set to %i",bLogDNS);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "game-server-name", 16) == 0)			cReadMode = 1;
				if (memcmp(token, "game-server-port", 16) == 0)			cReadMode = 2;
				if (memcmp(token, "log-server-address", 18) == 0)		cReadMode = 3;
				if (memcmp(token, "internal-log-server-port", 24) == 0) cReadMode = 4;
				if (memcmp(token, "game-server-map", 15) == 0)			cReadMode = 5;
				if (memcmp(token, "gate-server-address", 19) == 0)		cReadMode = 6;
				if (memcmp(token, "gate-server-port", 16) == 0)			cReadMode = 7;
				if (memcmp(token, "game-server-internal-address", 28) == 0)			cReadMode = 8;
				if (memcmp(token, "game-server-external-address", 28) == 0)			cReadMode = 9;
				if (memcmp(token, "game-server-address", 19) == 0)		cReadMode = 10;
				if (memcmp(token, "game-server-mode", 16) == 0)			cReadMode = 11;
				if (memcmp(token, "gate-server-dns", 15) == 0) cReadMode = 12;
				if (memcmp(token, "log-server-dns", 14) == 0) cReadMode = 13;

			}
			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	if (m_iGameServerMode == 0) {
		wsprintf(cTxt, "(!!!) Game server mode cannot be empty. It must be either LAN/lan/INTERNET/internet", token);
		PutLogList(cTxt);
		return FALSE;	
	}

	return TRUE;
}

BOOL CGame::bReadSettingsConfigFile(char * cFn) 
{ 
   FILE * pFile; 
   HANDLE hFile; 
   DWORD  dwFileSize; 
   char * cp, * token, cReadMode, cTxt[120], cGSMode[16] = "", len; 
   char seps[] = "= \t\n"; 
   class CStrTok * pStrTok; 

   cReadMode = 0; 

   hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL); 
   dwFileSize = GetFileSize(hFile, NULL); 
   if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile); 

   pFile = fopen(cFn, "rt"); 
   if (pFile == NULL) { 
      // Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶Ã€Ã‡ ÃƒÃŠÂ±Ã¢ÃˆÂ­ Ã†Ã„Ã€ÃÃ€Â» Ã€ÃÃ€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™. 
      //   PutLogList("(!) Cannot open configuration file."); 
      return FALSE; 
   } 
   else { 
      PutLogList("(!) Reading settings file..."); 
      cp = new char[dwFileSize+2]; 
      ZeroMemory(cp, dwFileSize+2); 
      fread(cp, dwFileSize, 1, pFile); 

      pStrTok = new class CStrTok(cp, seps); 
      token = pStrTok->pGet(); 
      //token = strtok( cp, seps );    
      while( token != NULL )   { 

         if (cReadMode != 0) { 
            switch (cReadMode) { 

            case 1: 
               if ((strlen(token) != 0) && (strlen(token) <= 10000) && (strlen(token) >= 1)) 
               { 
                  m_iPrimaryDropRate = atoi(token); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) Primary drop rate(%s) invalid must be between 1 to 10000", token); 
                  PutLogList(cTxt); 
               } 
               wsprintf(cTxt, "(*) Primary drop rate: (%d)", m_iPrimaryDropRate); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 2: 
               if ((strlen(token) != 0) && (strlen(token) <= 10000) && (strlen(token) >= 1)) 
               { 
                  m_iSecondaryDropRate = atoi(token); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) Secondary drop rate(%s) invalid must be between 1 to 10000", token); 
                  PutLogList(cTxt); 
               } 
               wsprintf(cTxt, "(*) Secondary drop rate: (%d)", m_iSecondaryDropRate); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 3: 
               if ((memcmp(token, "classic", 7) == 0) || (memcmp(token, "CLASSIC", 7) == 0)) 
               { 
                  m_bEnemyKillMode = FALSE; 
                  wsprintf(cTxt, "(*) Enemy Kill Mode: CLASSIC"); 
                  PutLogList(cTxt); 
               } 
               else if ((memcmp(token, "deathmatch", 10) == 0) || (memcmp(token, "DEATHMATCH", 10) == 0)) 
               { 
                  m_bEnemyKillMode = TRUE; 
                  wsprintf(cTxt, "(*) Enemy Kill Mode: DEATHMATCH"); 
                  PutLogList(cTxt); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) ENEMY-KILL-MODE: (%s) must be either DEATHMATCH or CLASSIC", token); 
                  PutLogList(cTxt); 
                  return FALSE; 
               } 
               cReadMode = 0; 
               break; 

            case 4: 
               if ((strlen(token) != 0) && (strlen(token) <= 100) && (strlen(token) >= 1)) 
               { 
                  m_iEnemyKillAdjust = atoi(token); 
               } 
               else 
               { 
                  wsprintf(cTxt, "(!!!) ENEMY-KILL-ADJUST: (%s) invalid must be between 1 to 100", token); 
                  PutLogList(cTxt); 
               } 
               wsprintf(cTxt, "(*) Player gains (%d) EK per enemy kill.", m_iEnemyKillAdjust); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 5: 
               if ((memcmp(token, "on", 2) == 0) || (memcmp(token, "ON", 2) == 0)) 
               { 
                  m_bAdminSecurity = TRUE; 
                  wsprintf(cTxt, "(*) Administator actions limited through security."); 
                  PutLogList(cTxt); 
               } 
               if ((memcmp(token, "off", 3) == 0) || (memcmp(token, "OFF", 3) == 0)) 
               { 
                  m_bAdminSecurity = FALSE; 
                  wsprintf(cTxt, "(*) Administator vulnerability ignored."); 
                  PutLogList(cTxt); 
               } 

               cReadMode = 0; 
               break; 

            case 6: 
               m_sRaidTimeMonday = atoi(token); 
               if (m_sRaidTimeMonday == 0) m_sRaidTimeMonday = 3; 
               wsprintf(cTxt, "(*) Monday Raid Time : (%d) minutes", m_sRaidTimeMonday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 7: 
               m_sRaidTimeTuesday = atoi(token); 
               if (m_sRaidTimeTuesday == 0) m_sRaidTimeTuesday = 3; 
               wsprintf(cTxt, "(*) Tuesday Raid Time : (%d) minutes", m_sRaidTimeTuesday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 8: 
               m_sRaidTimeWednesday = atoi(token); 
               if (m_sRaidTimeWednesday == 0) m_sRaidTimeWednesday = 3; 
               wsprintf(cTxt, "(*) Wednesday Raid Time : (%d) minutes", m_sRaidTimeWednesday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 9: 
               m_sRaidTimeThursday = atoi(token); 
               if (m_sRaidTimeThursday == 0) m_sRaidTimeThursday = 3; 
               wsprintf(cTxt, "(*) Thursday Raid Time : (%d) minutes", m_sRaidTimeThursday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 10: 
               m_sRaidTimeFriday = atoi(token); 
               if (m_sRaidTimeFriday == 0) m_sRaidTimeFriday = 10; 
               wsprintf(cTxt, "(*) Friday Raid Time : (%d) minutes", m_sRaidTimeFriday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 11: 
               m_sRaidTimeSaturday = atoi(token); 
               if (m_sRaidTimeSaturday == 0) m_sRaidTimeSaturday = 45; 
               wsprintf(cTxt, "(*) Saturday Raid Time : (%d) minutes", m_sRaidTimeSaturday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 

            case 12: 
               m_sRaidTimeSunday = atoi(token); 
               if (m_sRaidTimeSunday == 0) m_sRaidTimeSunday = 60; 
               wsprintf(cTxt, "(*) Sunday Raid Time : (%d) minutes", m_sRaidTimeSunday); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break; 
		
			case 13:
				if ((memcmp(token, "player", 6) == 0) || (memcmp(token, "PLAYER", 6) == 0))
				{
					m_bLogChatOption = 1;
					wsprintf(cTxt, "(*) Logging Player Chat.");
					PutLogList(cTxt);
				}
				if ((memcmp(token, "gm", 2) == 0) || (memcmp(token, "GM", 2) == 0))
				{
					m_bLogChatOption = 2;
					wsprintf(cTxt, "(*) Logging GM Chat.");
					PutLogList(cTxt);
				}
				if ((memcmp(token, "all", 3) == 0) || (memcmp(token, "ALL", 3) == 0))
				{
					m_bLogChatOption = 3;
					wsprintf(cTxt, "(*) Logging All Chat.");
					PutLogList(cTxt);
				}
				if ((memcmp(token, "none", 4) == 0) || (memcmp(token, "NONE", 4) == 0))
				{
					m_bLogChatOption = 4;
					wsprintf(cTxt, "(*) Not Logging Any Chat.");
					PutLogList(cTxt);
				}
				cReadMode = 0;
				break;

            case 14: 
               m_iSummonGuildCost = atoi(token); 
               wsprintf(cTxt, "(*) Summoning guild costs (%d) gold", m_iSummonGuildCost); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break;
 
			case 15: 
               m_sSlateSuccessRate = atoi(token); 
               wsprintf(cTxt, "(*) Slate Success Rate (%d) percent", m_sSlateSuccessRate); 
               PutLogList(cTxt); 
			   if (m_sSlateSuccessRate == 0) m_sSlateSuccessRate = 14; 
               cReadMode = 0; 
               break;

			case 16: 
               m_sCharStatLimit = atoi(token); 
               if (m_sCharStatLimit == 0) m_sCharStatLimit = 200; 
               cReadMode = 0;
               break;

			case 17: 
               m_sCharSkillLimit = atoi(token); 
               if (m_sCharSkillLimit == 0) m_sCharSkillLimit = 700; 
               cReadMode = 0;
               break;

			case 18: 
               m_cRepDropModifier = atoi(token); 
               wsprintf(cTxt, "(*) Rep<->Drop modifier: (%d)", m_cRepDropModifier); 
               PutLogList(cTxt); 
               if (m_cRepDropModifier < 0) m_cRepDropModifier = 0;
               cReadMode = 0; 
               break;

			case 19: 
               ZeroMemory(m_cSecurityNumber, sizeof(m_cSecurityNumber));
			   len = strlen(token);
			   if(len > 10) len = 10;
			   memcpy(m_cSecurityNumber, token, len);
               wsprintf(cTxt, "(*) Security number memorized!"); 
               PutLogList(cTxt); 
               cReadMode = 0; 
               break;

			case 20: 
               m_sMaxPlayerLevel = atoi(token); 
               if (m_sMaxPlayerLevel == 0) m_sMaxPlayerLevel = 180; 
               cReadMode = 0;
               break;
			
			}
         } 
         else { 
            if (memcmp(token, "primary-drop-rate"      , 17) == 0)   cReadMode = 1; 
            if (memcmp(token, "secondary-drop-rate"      , 19) == 0)   cReadMode = 2; 
            if (memcmp(token, "enemy-kill-mode"         , 15) == 0)   cReadMode = 3; 
            if (memcmp(token, "enemy-kill-adjust"      , 17) == 0)   cReadMode = 4; 
            if (memcmp(token, "admin-security"         , 14) == 0)   cReadMode = 5; 
            if (memcmp(token, "monday-raid-time"      , 16) == 0)   cReadMode = 6; 
            if (memcmp(token, "tuesday-raid-time"      , 17) == 0)   cReadMode = 7; 
            if (memcmp(token, "wednesday-raid-time"      , 19) == 0)   cReadMode = 8; 
            if (memcmp(token, "thursday-raid-time"      , 18) == 0)   cReadMode = 9; 
            if (memcmp(token, "friday-raid-time"      , 16) == 0)   cReadMode = 10; 
            if (memcmp(token, "saturday-raid-time"      , 18) == 0)   cReadMode = 11; 
            if (memcmp(token, "sunday-raid-time"      , 16) == 0)   cReadMode = 12; 
			if (memcmp(token, "log-chat-settings", 17) == 0)		cReadMode = 13;
			if (memcmp(token, "summonguild-cost", 16) == 0)		cReadMode = 14;
			if (memcmp(token, "slate-success-rate", 18) == 0)		cReadMode = 15;
			if (memcmp(token, "character-stat-limit", 20) == 0)		cReadMode = 16;
			if (memcmp(token, "character-skill-limit", 21) == 0)		cReadMode = 17;
			if (memcmp(token, "rep-drop-modifier", 17) == 0)		cReadMode = 18;
			if (memcmp(token, "admin-security-code", 19) == 0)		cReadMode = 19;
			if (memcmp(token, "max-player-level", 16) == 0)		cReadMode = 20;
         } 

         token = pStrTok->pGet(); 
         //token = strtok( NULL, seps ); 
      } 

      delete pStrTok; 
      delete cp; 
   } 
   if (pFile != NULL) fclose(pFile); 

   return TRUE; 
} 
 

BOOL CGame::bReadCrusadeStructureConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 int   iIndex;
 class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶Ã€Ã‡ ÃƒÃŠÂ±Ã¢ÃˆÂ­ Ã†Ã„Ã€ÃÃ€Â» Ã€ÃÃ€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.
		PutLogList("(!) Cannot open Crusade configuration file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Crusade configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL ) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:
						// Â½ÂºÃ†Â®Â·Â°ÃƒÃ„ Â¹Ã¸ÃˆÂ£
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format(1).");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						iIndex = atoi(token);

						if (m_stCrusadeStructures[iIndex].cType != NULL) {
							// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃˆ Â¹Ã¸ÃˆÂ£Â°Â¡ Ã€Ã–Â´Ã™. Â¿Â¡Â·Â¯Ã€ÃŒÂ´Ã™.
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Duplicate portion number.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						
						cReadModeB = 2;
						break;

					case 2:
						// Â¸ÃŠ Ã€ÃŒÂ¸Â§
						ZeroMemory(m_stCrusadeStructures[iIndex].cMapName, sizeof(m_stCrusadeStructures[iIndex].cMapName));
						memcpy(m_stCrusadeStructures[iIndex].cMapName, token, strlen(token));
						cReadModeB = 3;
						break;

					
					case 3:
						// ÃÂ¾Â·Ã¹
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].cType = atoi(token);
						cReadModeB = 4;
						break;

					case 4:
						// Ã€Â§Ã„Â¡
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dX = atoi(token);
						cReadModeB = 5;
						break;
	
					case 5:
						// Ã€Â§Ã„Â¡
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dY = atoi(token);
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				default: 
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-structure", 17) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			
			}
			token = pStrTok->pGet();
		}	

		delete pStrTok;
		delete cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			PutLogList("(!!!) CRITICAL ERROR! Crusade Structure configuration file contents error!");
			return FALSE;
		}
	}
	
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}

BOOL CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)
{
	char * pContents, * token, * pOriginContents, cTmpName[11], cTxt[120];
	char   seps[] = "= \t\n";
	char   cReadModeA, cReadModeB;
	int    i, iItemIndex, iItemInBankIndex, iTotalGold, iNotUsedItemPrice;
	class  CStrTok * pStrTok;
	short  sTmpType, sTmpAppr1;
	BOOL   bRet;
	int    iTemp;
	SYSTEMTIME SysTime;
	__int64 iDateSum1, iDateSum2;
	BOOL   bIsNotUsedItemFound = FALSE;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	// Â¼Ã’ÃÃ¶Ã‡Â° Â°Ã‹Â»Ã§Â¿Ã« 
	iTotalGold = 0;
	iItemIndex = 0;
	iItemInBankIndex  = 0;
	iNotUsedItemPrice = 0;

	cReadModeA = 0;
	cReadModeB = 0;

	pContents = new char[dwSize+2];
	ZeroMemory(pContents, dwSize+2);
	memcpy(pContents, pData, dwSize);

	pOriginContents = pContents;

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¼Ã“Ã‡Ã˜Ã€Ã–Â´Ã‚ Â¸ÃŠ Ã€ÃŒÂ¸Â§Ã€Â» Â¾Ã²Â´Ã‚Â´Ã™. 
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				strcpy(m_pClientList[iClientH]->m_cMapName, token);
				// Ã€ÃŒÃÂ¦ Ã€ÃŒ Â¸ÃŠÃ€Ã‡ Ã€ÃÂµÂ¦Â½ÂºÂ°ÂªÃ€Â» ÃƒÂ£Â¾Ã† Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™. 
				ZeroMemory(cTmpName, sizeof(cTmpName));
				strcpy(cTmpName, token);
				for (i = 0; i < DEF_MAXMAPS; i++)
					if ((m_pMapList[i] != NULL)	&& (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
						// Â¸ÃŠÃ€Ã‡ Ã€ÃÂµÂ¦Â½ÂºÂ´Ã‚ iÃ€ÃŒÂ´Ã™.
						m_pClientList[iClientH]->m_cMapIndex = (char)i;
					}

					if (m_pClientList[iClientH]->m_cMapIndex == -1) {
						// Â¸Â¸Â¾Ã  Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¼Ã“Ã‡Ã‘ Â¸ÃŠÃ€ÃŒ ÃÂ¸Ã€Ã§Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™Â¸Ã© (Ã€ÃŒÂ·Â± Â°Ã¦Â¿Ã¬Â´Ã‚ Â¹ÃŸÂ»Ã½Ã‡ÃÂ±Ã¢ ÃˆÃ»ÂµÃ©Â´Ã™. Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â¿Â¡Â¼Â­ Â¸Ã•Ã€Ãº Â°Ã‹Â»Ã¶Ã‡Ã‘ ÃˆÃ„ ÃÂ¢Â¼Ã“Ã‡ÃÂ±Ã¢ Â¶Â§Â¹Â®)
						wsprintf(cTxt, "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, cTmpName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeA = 0;
					break;

			case 2:
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Â¸ÃŠÂ»Ã³Ã€Ã‡ Ã€Â§Ã„Â¡ X
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_sX = atoi(token);
				cReadModeA = 0;
				break;

			case 3:
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Â¸ÃŠÂ»Ã³Ã€Ã‡ Ã€Â§Ã„Â¡ Y
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_sY = atoi(token);
				cReadModeA = 0;
				break;

			case 4:
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Â°Ã¨ÃÂ¤ Â»Ã³Ã…Ã‚Â¸Â¦ Â¾Ã²Â´Ã‚Â´Ã™. <- Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Âº Ã‡Ã¶Ã€Ã§ Â¾Â²ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. Â°Ã¨ÃÂ¤ÃÂ¤ÂºÂ¸Â´Ã‚ ÂºÂ°ÂµÂµÂ·Ã Ã€Ã¼Â´ÃÂµÃ‡Â¹Ã‡Â·Ã 
				/*
				if (_bGetIsStringIsNumber(token) == FALSE) {
				wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
				PutLogList(cTxt);
				delete pContents;
				delete pStrTok;
				return FALSE;
				}
				m_pClientList[iClientH]->m_cAccountStatus = atoi(token);
				*/
				cReadModeA = 0;
				break;

			case 5:
				// Â¼Ã’ÃÃ¶Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸Â¸Â¦ Ã€ÃÂ¾Ã® ÃƒÃŠÂ±Ã¢ÃˆÂ­ Ã‡Ã‘Â´Ã™.
				switch(cReadModeB) {
			case 1:
				// New 07/05/2004
				// v2.12
				if (iItemIndex >= DEF_MAXITEMS) {
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				// tokenÂ°ÂªÃ€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Ã€ÃŒÂ¸Â§. Ã€ÃŒ Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Ã†Â¯Â¼ÂºÃ€Â» m_pItemConfigListÂ¿Â¡Â¼Â­ ÃƒÂ£Â¾Ã† Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™.
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], token) == FALSE) {
					// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¼Ã’ÃÃ¶Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¸Â®Â½ÂºÃ†Â®Â¿Â¡ Â¾Ã¸Â´Ã™. Â¿Â¡Â·Â¯
					wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
					PutLogList(cTxt);

					// Debug code @@@@@@@@@@@@@@@
					HANDLE hFile;
					DWORD  nWrite;
					hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
					WriteFile(hFile, (char *)pContents, dwSize+2, &nWrite, NULL);
					CloseHandle(hFile);
					///////////// @@@@@@@@@@@@@@@

					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				cReadModeB = 2;
				break;

			case 2:
				// m_dwCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				// Â°Â¹Â¼Ã¶Â°Â¡ Â¸Â¶Ã€ÃŒÂ³ÃŠÂ½ÂºÃ€ÃŒÂ¸Ã© 1Ã€Â¸Â·Ã Â¼Â¼Ã†ÃƒÂµÃˆÂ´Ã™.
				iTemp = atoi(token);
				if (iTemp < 0) iTemp = 1;
				//Â¸Â¸Â¾Ã  ÃÃŸÂ·Â®Ã€ÃŒ ÃƒÃŠÂ°ÃºÂµÃ‡Â¾ÃºÂ´Ã™Â¸Ã© 1Â°Â³Â·Ã ÃÃ™Ã€ÃÂ´Ã™.
				if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
					iTemp = 1;
					wsprintf(G_cTxt, "(!) Player(%s) Item (%s) too heavy for player to carry", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName);
					PutLogFileList(G_cTxt);
					PutLogList(G_cTxt);
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = (DWORD)iTemp;
				cReadModeB = 3;

				// v1.3 Â¼Ã’ÃÃ¶Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Â°Ã±ÂµÃ¥Ã€Ã‡ ÃƒÃ‘ Ã‡Ã•Ã€Â» Â°Ã‹Â»Ã§Ã‡Ã‘Â´Ã™. 
				if (memcmp(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, "Gold", 4) == 0)
					iTotalGold += iTemp;
				break;

			case 3:
				// m_sTouchEffectType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// m_sTouchEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// m_sTouchEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// m_sTouchEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				// m_cItemColor
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				// m_sItemSpecEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// m_sItemSpecEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				// m_sItemSpecEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3 = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				// m_wCurLifeSpan
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = atoi(token);

				cReadModeB = 12;
				break;

			case 12:
				// m_dwAttribute
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = atoi(token);

				// v1.4 Â°Â³Ã€Ã Â°Ã­Ã€Â¯ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃˆÂ®Ã€ÃÃ‡Ã‘Â´Ã™. 
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) {
					if ( (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3) ) {
							// Ã€ÃšÂ½Ã…Ã€Ã‡ Â°ÃÃ€ÃŒ Â¾Ã†Â´Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â°Â®Â°Ã­ Ã€Ã–Â´Ã™. 
							wsprintf(cTxt, "(!) Â´Ã™Â¸Â¥ Â»Ã§Â¶Ã·Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã› Â¼Ã’ÃÃ¶: Player(%s) Item(%s) %d %d %d - %d %d %d", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1,
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2,
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3,
								m_pClientList[iClientH]->m_sCharIDnum1,
								m_pClientList[iClientH]->m_sCharIDnum2,
								m_pClientList[iClientH]->m_sCharIDnum3); 
							PutLogList(cTxt);
							//PutLogFileList(cTxt);
						}
				}

				cReadModeA = 0;
				cReadModeB = 0;

				// v1.41 Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Custom-MadeÂ¶Ã³Â¸Ã© Â¼Â³ÃÂ¤Ã„Â¡Â¸Â¦ Ã€Ã§ÃÂ¶ÃÂ¤Ã‡Ã‘Â´Ã™. 
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001 ) != NULL) {
					// ÃƒÃ–Â´Ã« Â¼Ã¶Â¸Ã­Ã€ÃŒ ItemSpecialEffectValue1
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
					// Â¹Â«Â±Ã¢Â³Âª Â¹Ã¦Â¾Ã®Â±Â¸Ã€Ã‡ Â°Ã¦Â¿Ã¬ Â°Â¡ÃÃŸÃ„Â¡ ItemSpecialEffectValue2
				}

				// v1.42 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã› Ã‡ÃƒÂ·Â¡Â±Ã—Â°Â¡ Â¼Â³ÃÂ¤ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™Â¸Ã© ÃƒÃ–Â´Ã« Â¼Ã¶Â¸Ã­, Â½ÂºÃ‡Ã‡ÂµÃ¥, Â¹Â«Â°Ã” ÂµÃ®Ã€Â» Ã€Ã§Â¼Â³ÃÂ¤ Ã‡Ã˜Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
				_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemList[iItemIndex]);

				// v1.41 Ã‡Ã¶Ã€Ã§ Â¼Ã¶Â¸Ã­ ÃƒÃ–Â´Ã« Â¼Ã¶Â¸Ã­Ã€Â» Â´Ã‰Â°Â¡Ã‡ÃÂ¸Ã© Â¹Ã¶Â±Ã—Ã€ÃŒÂ¹Ã‡Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan)
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

				// v1.433
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan == 0) && 
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
						// Â·ÃÂ±Ã— Â³Â²Â±Ã¤Â´Ã™. 
						wsprintf(G_cTxt, "(!) Ã„Â³Â¸Â¯Ã…Ã(%s) Â¼Ã¶Â¸Ã­ 0Ã‚Â¥Â¸Â® ÃˆÃ±Â»Ã½Â¼Â® Â¼Ã’ÃÃ¶!", m_pClientList[iClientH]->m_cCharName);
						PutLogFileList(G_cTxt);
						// Â¼Ã¶Â¸Ã­ 1Â·Ã ÃˆÂ¯Â¿Ã¸ 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = 1;
					}

					// v2.05 +Â´Ã«Â¹ÃŒÃÃ¶Â·Ã¹ Â¾Ã†Ã€ÃŒÃ…Ã› Ã†Â¯Â¼ÂºÃ„Â¡Â·Ã ÃÂ¤ÂºÂ¸ ÂºÂ¯Â°Ã¦, ÂºÂ¯ÃˆÂ¯ 
					bCheckAndConvertPlusWeaponItem(iClientH, iItemIndex);

					// v1.4 Ã€ÃŒÃÂ¦ Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Ã‡Ã¶Ã€Ã§ Â»Ã§Â¿Ã«Ã€ÃŒ Ã€ÃÃÂ¤ÂµÃˆ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃÂ°Â¡Â¸Â¦ ÃƒÂ£Â´Ã‚Â´Ã™. 
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

						// v1.41
						bIsNotUsedItemFound = TRUE;
					}
					else
						if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemList[iItemIndex]) == TRUE) {
							// v1.42 ÂºÂ¹ÃÂ¦ÂµÃˆ Â¾Ã†Ã€ÃŒÃ…Ã›ÂµÃ©Ã€Â» Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
							_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

							iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
							delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
							m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
						}
						else iItemIndex++;
						break;
				}
				break;

			case 6:
				// Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ Â¼ÂºÂºÂ° 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSex = atoi(token);
				cReadModeA = 0;
				break;

			case 7:
				// Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ Ã‡Ã‡ÂºÃÂ»Ã¶ 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSkin = atoi(token);
				cReadModeA = 0;
				break;

			case 8:
				// Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ Ã‡Ã¬Â¾Ã® Â½ÂºÃ…Â¸Ã€Ã 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cHairStyle = atoi(token);
				cReadModeA = 0;
				break;

			case 9:
				// Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ Â¸Ã“Â¸Â®Â»Ã¶ 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cHairColor = atoi(token);
				cReadModeA = 0;
				break;

			case 10:
				// Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ Â¼Ã“Â¿ÃŠÂ»Ã¶
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cUnderwear = atoi(token);
				cReadModeA = 0;
				break;

			case 11:
				// Â¾Ã†Ã€ÃŒÃ…Ã› Ã€Ã¥Ã‚Ã¸ Â»Ã³Ã…Ã‚Â°Â¡ Â¹ÃÂµÃ¥Â½Ãƒ Â¸Â¶ÃÃ¶Â¸Â·Ã€ÃŒÂ¾Ã®Â¾ÃŸ Ã‡Ã‘Â´Ã™!!!!!

				// Â¾Ã†Ã€ÃŒÃ…Ã› Ã€Ã¥Ã‚Ã¸ Â»Ã³Ã…Ã‚ ÃƒÃŠÂ±Ã¢ÃˆÂ­Ã‡Ã‘ ÃˆÃ„ Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™.
				for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) 
					m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;

				// Â¾Ã†Ã€ÃŒÃ…Ã› Ã€Ã¥Ã‚Ã¸Â»Ã³Ã…Ã‚Â¸Â¦ ÃƒÃŠÂ±Ã¢ÃˆÂ­Ã‡Ã‘Â´Ã™.
				for (i = 0; i < DEF_MAXITEMS; i++) 
					m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

				// v1.41 Â»Ã§Â¿Ã«Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Ã’ÃÃ¶Ã‡ÃÂ°Ã­ Ã€Ã–Â¾ÃºÂ´Ã™Â¸Ã© Ã€Ã¥Ã‚Ã¸Â»Ã³Ã…Ã‚Â¸Â¦ Â¸Ã°ÂµÃ Â¹Â«Â½Ãƒ. 
				if (bIsNotUsedItemFound == FALSE) {
					for (i = 0; i < DEF_MAXITEMS; i++) {
						wsprintf(cTxt, "%d", token[i]);
						if ((token[i] == '1') && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
							// Ã€Ã¥Ã‚Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Â´Ã‚ Â¼ÂºÃÃºÃ€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¶Ã³Â¸Ã© Ã€Ã¥Ã‚Ã¸ 
							if (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP) 
								m_pClientList[iClientH]->m_bIsItemEquipped[i] = TRUE;
							else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
						}
						else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

						if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE)) {
							// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™Â¸Ã© Ã€Ã¥Ã‚Ã¸ ÃˆÂ¿Â°ÃºÂ¸Â¦ Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™.
							if (bEquipItemHandler(iClientH, i) == FALSE) // FALSE
								m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE; // Â¸Â¸Â¾Ã  Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÂ¯ÂµÂ¿Ã€Â¸Â·Ã Ã€Ã¥Ã‚Ã¸ÂµÃˆ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã†Â¾ÃŸ Ã‡Ã‘Â´Ã™Â¸Ã© Ã€Ã¥Ã‚Ã¸ Â¾ÃˆÃ‡Ã‘Â°ÃÃ€Â» Ã‡Â¥Â½Ãƒ 
						}
					}
				}

				cReadModeA = 0;
				break;

			case 12:
				// Â¼Ã’Â¼Ã“ Â±Ã¦ÂµÃ¥Ã€ÃŒÂ¸Â§Ã€Â» ÃƒÃŠÂ±Ã¢ÃˆÂ­Ã‡Ã‘Â´Ã™.
				// Â±Ã¦ÂµÃ¥ Ã€ÃŒÂ¸Â§Ã€Âº ÃƒÃ–Â´Ã« 20Ã€Ãš 
				ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
				strcpy(m_pClientList[iClientH]->m_cGuildName, token);
				cReadModeA = 0;
				break;

			case 13:
				// Â±Ã¦ÂµÃ¥ Â·Â©Ã…Â© 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iGuildRank = atoi(token);
				cReadModeA = 0;
				break;

			case 14:
				// HP 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iHP = atoi(token);
				cReadModeA = 0;
				break;

			case 15:
				// DefenseRatio Â»Ã§Â¿Ã«Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. Â¹Â«Ã€Ã‡Â¹ÃŒÃ‡Ã˜ ÃÃ¼ 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				//m_pClientList[iClientH]->m_iOriginDefenseRatio = atoi(token);
				//m_pClientList[iClientH]->m_iCurDefenseRatio = m_pClientList[iClientH]->m_iOriginDefenseRatio;
				cReadModeA = 0;
				break;

			case 16:
				// HitRatio  Â»Ã§Â¿Ã«Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. Â¹Â«Ã€Ã‡Â¹ÃŒÃ‡Ã˜ ÃÃ¼ 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				//m_pClientList[iClientH]->m_iOriginHitRatio = atoi(token);
				//m_pClientList[iClientH]->m_iCurHitRatio = m_pClientList[iClientH]->m_iOriginHitRatio;
				cReadModeA = 0;
				break;

			case 17:
				// Level  
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLevel = atoi(token);
				cReadModeA = 0;
				break;

			case 18:
				// Str 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iStr = atoi(token);
				cReadModeA = 0;
				break;

			case 19:
				// Int 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iInt = atoi(token);
				cReadModeA = 0;
				break;

			case 20:
				// Vit 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iVit = atoi(token);
				cReadModeA = 0;
				break;

			case 21:
				// Dex 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDex = atoi(token);
				cReadModeA = 0;
				break;

			case 22:
				// Mag 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iMag = atoi(token);
				cReadModeA = 0;
				break;

			case 23:
				// Charisma 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iCharisma = atoi(token);
				cReadModeA = 0;
				break;

			case 24:
				// Luck 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLuck = atoi(token);
				cReadModeA = 0;
				break;

			case 25:
				// Exp 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iExp = atoi(token);
				cReadModeA = 0;
				break;

			case 26:
				// Magic-Mastery Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™. // 0Ã€ÃŒÂ¸Ã© Â»Ã§Â¿Ã« ÂºÃ’Â°Â¡. 1Ã€ÃŒÂ¸Ã© Â¹Ã¨Â¿Ã® Â»Ã³Ã…Ã‚.
				for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
					m_pClientList[iClientH]->m_cMagicMastery[i] = token[i] - 48;
				}
				cReadModeA = 0;
				break;

			case 27:
				// Skill-Mastery Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSkillMastery[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;
				//
			case 28:
				// WarehouseÂ¿Â¡ Â¸ÃƒÂ°ÃœÂ³Ã­ Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸Â¸Â¦ Ã€ÃÂ¾Ã® ÃƒÃŠÂ±Ã¢ÃˆÂ­ Ã‡Ã‘Â´Ã™.
				switch(cReadModeB) {
			case 1:
				if (iItemInBankIndex >= DEF_MAXBANKITEMS) {
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				// tokenÂ°ÂªÃ€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Ã€ÃŒÂ¸Â§. Ã€ÃŒ Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Ã†Â¯Â¼ÂºÃ€Â» m_pItemConfigListÂ¿Â¡Â¼Â­ ÃƒÂ£Â¾Ã† Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™.
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], token) == FALSE) {
					// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Ã€ÃºÃ€Ã¥Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¸Â®Â½ÂºÃ†Â®Â¿Â¡ Â¾Ã¸Â´Ã™. Â¿Â¡Â·Â¯
					wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
					PutLogList(cTxt);

					// Debug code @@@@@@@@@@@@@@@
					HANDLE hFile;
					DWORD  nWrite;
					hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
					WriteFile(hFile, (char *)pOriginContents, dwSize+2, &nWrite, NULL);
					CloseHandle(hFile);
					///////////// @@@@@@@@@@@@@@@

					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				cReadModeB = 2;
				break;

			case 2:
				// m_dwCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				// Â°Â¹Â¼Ã¶Â°Â¡ Â¸Â¶Ã€ÃŒÂ³ÃŠÂ½ÂºÃ€ÃŒÂ¸Ã© 1Ã€Â¸Â·Ã Â¼Â¼Ã†ÃƒÂµÃˆÂ´Ã™.
				iTemp = atoi(token);
				if (iTemp < 0) iTemp = 1;

				// Â¸Â¸Â¾Ã  Â°Â¡ÃÃº Â¼Ã¶ Ã€Ã–Â´Ã‚ ÃÃŸÂ·Â®Ã€ÃŒ ÃƒÃŠÂ°ÃºÂµÃˆ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© 1Â°Â³Â·Ã ÃÃ™Ã€ÃÂ´Ã™.
				if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
					iTemp = 1;
					wsprintf(G_cTxt, "(!) Ã„Â³Â¸Â¯Ã…Ã(%s) Â¾Ã†Ã€ÃŒÃ…Ã›(%s) Â°Â³Â¼Ã¶ Â¿Ã€Â¹Ã¶Ã‡ÃƒÂ·ÃÂ¿Ã¬", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName);
					PutLogFileList(G_cTxt);
					PutLogList(G_cTxt);
				}

				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwCount = (DWORD)iTemp;
				cReadModeB = 3;

				// v1.3 Â¼Ã’ÃÃ¶Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Â°Ã±ÂµÃ¥Ã€Ã‡ ÃƒÃ‘ Ã‡Ã•Ã€Â» Â°Ã‹Â»Ã§Ã‡Ã‘Â´Ã™. 
				if (memcmp(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName, "Gold", 4) == 0)
					iTotalGold += iTemp;
				break;

			case 3:
				// m_sTouchEffectType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectType = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// m_sTouchEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue1 = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// m_sTouchEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue2 = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// m_sTouchEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue3 = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				// m_cItemColor
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemColor = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				// m_sItemSpecEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1 = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// m_sItemSpecEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue2 = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				// m_sItemSpecEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue3 = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				// m_wCurLifeSpan
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = atoi(token);

				cReadModeB = 12;
				break;


			case 12:
				// m_dwAttribute
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;

				// v1.41 Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Custom-MadeÂ¶Ã³Â¸Ã© Â¼Â³ÃÂ¤Ã„Â¡Â¸Â¦ Ã€Ã§ÃÂ¶ÃÂ¤Ã‡Ã‘Â´Ã™. 
				if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0x00000001) != NULL) {
					// ÃƒÃ–Â´Ã« Â¼Ã¶Â¸Ã­Ã€ÃŒ ItemSpecialEffectValue1
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
					// Â¹Â«Â±Ã¢Â³Âª Â¹Ã¦Â¾Ã®Â±Â¸Ã€Ã‡ Â°Ã¦Â¿Ã¬ Â°Â¡ÃÃŸÃ„Â¡ ItemSpecialEffectValue2

				}

				// v2.16 2002-5-21 Â°Ã­Â±Â¤Ã‡Ã¶Â¼Ã¶ÃÂ¤ 
				int iValue = (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0xF0000000) >> 28;
				if (iValue > 0) {
					// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÂµÃˆ Â¾Ã†Ã€ÃŒÃ…Ã›. Â¹Ã¦Â¾Ã®Â±Â¸Â³Âª Â¹Ã¦Ã†ÃÂ¶Ã³Â¸Ã© ÃƒÃ–Â´Ã« Â¼Ã¶Â¸Ã­Ã€Â» ItemSpecialEffectValue1Â·Ã Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™.
					switch (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cCategory) {
			case 5: // Â¹Ã¦Ã†Ã 
			case 6: // Â¹Ã¦Â¾Ã®Â±Â¸ 
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
				break;
					}
				}

				// v1.42 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã› Ã‡ÃƒÂ·Â¡Â±Ã—Â°Â¡ Â¼Â³ÃÂ¤ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™Â¸Ã© ÃƒÃ–Â´Ã« Â¼Ã¶Â¸Ã­, Â½ÂºÃ‡Ã‡ÂµÃ¥, Â¹Â«Â°Ã” ÂµÃ®Ã€Â» Ã€Ã§Â¼Â³ÃÂ¤ Ã‡Ã˜Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
				_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

				// v1.41 Â¼Ã¶Â¸Ã­Ã€ÃŒ ÃƒÃ–Â´Ã«Â¼Ã¶Â¸Ã­Ã€Â» ÃƒÃŠÂ°ÃºÃ‡Ã‘Â´Ã™Â¸Ã© Â¹Ã¶Â±Ã—Ã€ÃŒÂ¹Ã‡Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan)
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan;
				

				// v1.433
				if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan == 0) && 
					(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
						// Â·ÃÂ±Ã— Â³Â²Â±Ã¤Â´Ã™. 
						wsprintf(G_cTxt, "(!) Ã„Â³Â¸Â¯Ã…Ã(%s) Â¼Ã¶Â¸Ã­ 0Ã‚Â¥Â¸Â® ÃˆÃ±Â»Ã½Â¼Â® Â¼Ã’ÃÃ¶!", m_pClientList[iClientH]->m_cCharName);
						PutLogFileList(G_cTxt);
						// Â¼Ã¶Â¸Ã­ 1Â·Ã ÃˆÂ¯Â¿Ã¸ 
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = 1;
					}

					// v1.4 Ã€ÃŒÃÂ¦ Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Ã‡Ã¶Ã€Ã§ Â»Ã§Â¿Ã«Ã€ÃŒ Ã€ÃÃÂ¤ÂµÃˆ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃÂ°Â¡Â¸Â¦ ÃƒÂ£Â´Ã‚Â´Ã™. 
					if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;
					}
					else 
						if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]) == TRUE) {
							// v1.42 ÂºÂ¹ÃÂ¦ÂµÃˆ Â¾Ã†Ã€ÃŒÃ…Ã›ÂµÃ©Ã€Â» Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
							_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

							iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
							delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;		
						}
						else iItemInBankIndex++;
						break;
				}
				break;
				//

			case 29:
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® Â¼Ã’Â¼Ã“Ã€Ã‡ Â¸Â¶Ã€Â»Ã€Â» ÃƒÃŠÂ±Ã¢ÃˆÂ­Ã‡Ã‘Â´Ã™.
				ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
				strcpy(m_pClientList[iClientH]->m_cLocation, token);
				if (memcmp(m_pClientList[iClientH]->m_cLocation+3,"hunter",6) == 0)
					m_pClientList[iClientH]->m_bIsPlayerCivil = TRUE;
				cReadModeA = 0;
				break;

/* 2.03 Code - Fixed by KLKS
			case 29:
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® Â¼Ã’Â¼Ã“Ã€Ã‡ Â¸Â¶Ã€Â»Ã€Â» ÃƒÃŠÂ±Ã¢ÃˆÂ­Ã‡Ã‘Â´Ã™.
				ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
				strcpy(m_pClientList[iClientH]->m_cLocation, token);
				cReadModeA = 0;
				break;
*/
			case 30:
				// m_iMP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iMP = atoi(token);
				cReadModeA = 0;
				break;

			case 31:
				// m_iSP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSP = atoi(token);
				cReadModeA = 0;
				break;

			case 32:
				// m_cLU_Pool
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLU_Pool = atoi(token);
				cReadModeA = 0;
				break;
			/*
			case 33:
				// m_cLU_Vit
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Vit = atoi(token);
				cReadModeA = 0;
				break;

			case 34:
				// m_cLU_Dex
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Dex = atoi(token);
				cReadModeA = 0;
				break;

			case 35:
				// m_cLU_Int
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Int = atoi(token);
				cReadModeA = 0;
				break;

			case 36:
				// m_cLU_Mag
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Mag = atoi(token);
				cReadModeA = 0;
				break;

			case 37:
				// m_cLU_Char
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Char = atoi(token);
				cReadModeA = 0;
				break;
*/
			case 38:
				// m_iEnemyKillCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iEnemyKillCount = atoi(token);
				cReadModeA = 0;
				break;

			case 39:
				// m_iPKCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPKCount = atoi(token);
				cReadModeA = 0;
				break;

			case 40:
				// m_iRewardGold
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iRewardGold = atoi(token);
				cReadModeA = 0;
				break;

			case 41:
				// Skill-SSN Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSkillSSN[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 42:
				if (token != NULL) {
					ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
					strcpy(m_pClientList[iClientH]->m_cProfile, token);
				}
				cReadModeA = 0;
				break;

			case 43:
				// Hunger-Status Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iHungerStatus = atoi(token);
				cReadModeA = 0;
				break;

				case 44:
				// AdminUserLevel
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iAdminUserLevel = 0; //Default it to 0
				if (atoi(token) > 0) {
				for (i = 0; i < DEF_MAXADMINS; i++) {
					if(strlen(m_stAdminList[i].m_cGMName) == 0) break; //No more GM's on list
						if ((strlen(m_stAdminList[i].m_cGMName)) == (strlen(m_pClientList[iClientH]->m_cCharName))) {
							if(memcmp(m_stAdminList[i].m_cGMName,m_pClientList[iClientH]->m_cCharName,strlen(m_pClientList[iClientH]->m_cCharName)) == 0){
								m_pClientList[iClientH]->m_iAdminUserLevel = atoi(token);
								break; //Break goes to cReadModeA = 0;, so no need to do it again
							}
						}
					}
				}
				cReadModeA = 0;
				break;
				
				/*case 44:
				// AdminUserLevel
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				for (i = 0; i < DEF_MAXADMINS; i++) {
					if (atoi(token) > 0) {
						if ((strlen(m_stAdminList[i].m_cGMName)) == (strlen(m_pClientList[iClientH]->m_cCharName))) {
							m_pClientList[iClientH]->m_iAdminUserLevel = atoi(token);
							cReadModeA = 0;
							break;
						}
						else {
							m_pClientList[iClientH]->m_iAdminUserLevel = 0;
						}
					else m_pClientList[iClientH]->m_iAdminUserLevel = 0;
					}
				}
				cReadModeA = 0;
				break;*/

			case 45:
				// TimeLeft_ShutUp
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_ShutUp = atoi(token);
				cReadModeA = 0;
				break;

			case 46:
				// TimeLeft_Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_Rating = atoi(token);
				cReadModeA = 0;
				break;

			case 47:
				// Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iRating = atoi(token);
				cReadModeA = 0;
				break;

			case 48:
				// Guild GUID: Ã€ÃŒÃ€Ã¼Â¿Â¡ Â»Ã½Â¼ÂºÂµÃ‡Â¾ÃºÂ´Ã¸ Â±Ã¦ÂµÃ¥ÂµÃ©Ã€Âº Â¸Ã°ÂµÃ -1Ã€ÃŒ ÂµÃ‡ Â¹Ã¶Â¸Â± Â°ÃÃ€ÃŒÂ´Ã™.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iGuildGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 49:
				// Down Skill Index
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDownSkillIndex = atoi(token);
				cReadModeA = 0;
				break;

			case 50:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].x = atoi(token);
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 51:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = atoi(token);
				// v1.3 Ã€ÃŸÂ¸Ã¸ÂµÃˆ Ã€Â§Ã„Â¡Â°ÂªÃ€Â» ÂºÂ¸ÃÂ¤Ã‡Ã‘Â´Ã™. 
				if (m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y < -10) m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = -10;
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 52:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_sCharIDnum1 = atoi(token);
				cReadModeA = 0;
				break;

			case 53:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_sCharIDnum2 = atoi(token);
				cReadModeA = 0;
				break;

			case 54:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_sCharIDnum3 = atoi(token);
				cReadModeA = 0;
				break;

			case 55:
				switch (cReadModeB) {
			case 1:
				// Penalty Block Year
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockYear = atoi(token);

				cReadModeB = 2;
				break;

			case 2:
				// Penalty Block Month
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockMonth = atoi(token);

				cReadModeB = 3;
				break;

			case 3:
				// Penalty Block day
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockDay = atoi(token);

				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}
				break;

			case 56:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iQuest = atoi(token);
				cReadModeA = 0;
				break;

			case 57:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iCurQuestCount = atoi(token);
				cReadModeA = 0;
				break;

			case 58:
				cReadModeA = 0;
				break;

			case 59:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iQuestRewardType = atoi(token);
				cReadModeA = 0;
				break;

			case 60:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iQuestRewardAmount = atoi(token);
				cReadModeA = 0;
				break;

			case 61:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 62:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iQuestID = atoi(token);
				cReadModeA = 0;
				break;

			case 63:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_bIsQuestCompleted = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 64:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 65:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 66:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iSpecialEventID = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

				// v1.4311-3 ÃƒÃŸÂ°Â¡ Â»Ã§Ã…ÃµÃ€Ã¥ Â¿Â¹Â¾Ã Â¿Â¡ Â°Ã¼Â°Ã¨ÂµÃˆ Ã†Ã„Ã€Ã Â³Â»Â¿Ã« Ã€ÃÂ±Ã¢ 
			case 67:
				switch (cReadModeB) {
			case 1:
				// FightZone Number
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iFightzoneNumber = atoi(token);

				cReadModeB = 2;
				break;

			case 2:
				// Â¿Â¹Â¾Ã Ã‡Ã‘ Â½ÃƒÂ°Â£ 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iReserveTime = atoi(token);


				cReadModeB = 3;
				break;
			case 3:
				// Â³Â²Ã€Âº Ã†Â¼Ã„ÃÂ¼Ã½Ã€Ãš 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iFightZoneTicketNumber = atoi(token);

				cReadModeA = 0;
				cReadModeB = 0;
				break;

				}
				break;

			case 70:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iSuperAttackLeft = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 71:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iSpecialAbilityTime = atoi(token);
				cReadModeA = 0;
				break;

			case 72:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iWarContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 73:
				if (strlen(token) > 10) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
				strcpy(m_pClientList[iClientH]->m_cLockedMapName, token);
				cReadModeA = 0;
				break;

			case 74:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iLockedMapTime = atoi(token);
				cReadModeA = 0;
				break;

			case 75:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iCrusadeDuty = atoi(token);
				cReadModeA = 0;
				break;

			case 76:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iConstructionPoint = atoi(token);
				cReadModeA = 0;
				break;

			case 77:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_dwCrusadeGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 78:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iDeadPenaltyTime = atoi(token);
				cReadModeA = 0;
				break;

			case 79: // v2.06 12-4
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iPartyID = atoi(token);
				if (m_pClientList[iClientH]->m_iPartyID != NULL) m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
				cReadModeA = 0;
				break;

			case 80: // v2.15 ÃÃ¶ÃÂ¸Â¾Ã†Ã€ÃŒÃ…Ã›Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft = atoi(token);
				cReadModeA = 0;
				break;
			}
		}
		else {
			if (memcmp(token, "character-loc-map", 17) == 0)		 cReadModeA = 1;
			if (memcmp(token, "character-loc-x", 15) == 0)			 cReadModeA = 2;
			if (memcmp(token, "character-loc-y", 15) == 0)			 cReadModeA = 3;
			if (memcmp(token, "character-account-status", 21) == 0)  cReadModeA = 4;
			if (memcmp(token, "character-item", 14) == 0) {
				cReadModeA = 5;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
			}

			if (memcmp(token, "character-bank-item", 18) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = new class CItem;
			}

			if (memcmp(token, "sex-status", 10) == 0)        cReadModeA = 6;
			if (memcmp(token, "skin-status", 11) == 0)       cReadModeA = 7;
			if (memcmp(token, "hairstyle-status", 16) == 0)  cReadModeA = 8;
			if (memcmp(token, "haircolor-status", 16) == 0)  cReadModeA = 9;
			if (memcmp(token, "underwear-status", 16) == 0)  cReadModeA = 10;

			if (memcmp(token, "item-equip-status", 17) == 0)    cReadModeA = 11;
			if (memcmp(token, "character-guild-name", 20) == 0) cReadModeA = 12;
			if (memcmp(token, "character-guild-rank", 20) == 0) cReadModeA = 13;
			if (memcmp(token, "character-HP", 12) == 0)         cReadModeA = 14;
			if (memcmp(token, "character-DefenseRatio",22)==0)  cReadModeA = 15;
			if (memcmp(token, "character-HitRatio", 18) == 0)   cReadModeA = 16;
			if (memcmp(token, "character-LEVEL", 15) == 0)      cReadModeA = 17;
			if (memcmp(token, "character-STR", 13) == 0)        cReadModeA = 18;
			if (memcmp(token, "character-INT", 13) == 0)        cReadModeA = 19;
			if (memcmp(token, "character-VIT", 13) == 0)        cReadModeA = 20;
			if (memcmp(token, "character-DEX", 13) == 0)        cReadModeA = 21;
			if (memcmp(token, "character-MAG", 13) == 0)        cReadModeA = 22;
			if (memcmp(token, "character-CHARISMA", 18) == 0)   cReadModeA = 23;
			if (memcmp(token, "character-LUCK", 14) == 0)       cReadModeA = 24;
			if (memcmp(token, "character-EXP", 13) == 0)        cReadModeA = 25;
			if (memcmp(token, "magic-mastery", 13) == 0)        cReadModeA = 26;

			if (memcmp(token, "skill-mastery", 13) == 0) {
				cReadModeA = 27;
				cReadModeB = 0;
			}

			if (memcmp(token, "character-location", 18) == 0)   cReadModeA = 29;

			if (memcmp(token, "character-MP", 12) == 0)         cReadModeA = 30;
			if (memcmp(token, "character-SP", 12) == 0)         cReadModeA = 31;

			if (memcmp(token, "character-LU_Pool", 17) == 0)     cReadModeA = 32;

			/*
			if (memcmp(token, "character-LU_Str", 16) == 0)     cReadModeA = 32;
			if (memcmp(token, "character-LU_Vit", 16) == 0)     cReadModeA = 33;
			if (memcmp(token, "character-LU_Dex", 16) == 0)     cReadModeA = 34;
			if (memcmp(token, "character-LU_Int", 16) == 0)     cReadModeA = 35;
			if (memcmp(token, "character-LU_Mag", 16) == 0)     cReadModeA = 36;
			if (memcmp(token, "character-LU_Char",17) == 0)     cReadModeA = 37;
			*/

			if (memcmp(token, "character-EK-Count",18) == 0)    cReadModeA = 38;
			if (memcmp(token, "character-PK-Count",18) == 0)    cReadModeA = 39;

			if (memcmp(token, "character-reward-gold",21) == 0) cReadModeA = 40;
			if (memcmp(token, "skill-SSN", 9) == 0) 			cReadModeA = 41;
			if (memcmp(token, "character-profile", 17) == 0)	cReadModeA = 42;

			if (memcmp(token, "hunger-status", 13) == 0) 		cReadModeA = 43;
			if (memcmp(token, "admin-user-level", 16) == 0) 	cReadModeA = 44;
			if (memcmp(token, "timeleft-shutup", 15) == 0) 		cReadModeA = 45;
			if (memcmp(token, "timeleft-rating", 15) == 0) 		cReadModeA = 46;
			if (memcmp(token, "character-RATING", 16) == 0)	    cReadModeA = 47;

			if (memcmp(token, "character-guild-GUID", 20) == 0) cReadModeA = 48;

			if (memcmp(token, "character-downskillindex", 24) == 0) cReadModeA = 49;
			if (memcmp(token, "item-position-x", 16) == 0) {
				cReadModeA = 50;
				cReadModeB = 1;
			}
			if (memcmp(token, "item-position-y", 16) == 0) {
				cReadModeA = 51;
				cReadModeB = 1;
			}
			if (memcmp(token, "character-IDnum1",16) == 0)		cReadModeA = 52;
			if (memcmp(token, "character-IDnum2",16) == 0)		cReadModeA = 53;
			if (memcmp(token, "character-IDnum3",16) == 0)		cReadModeA = 54;
			if (memcmp(token, "penalty-block-date",18) == 0) {
				cReadModeA = 55;
				cReadModeB = 1;
			}

			if (memcmp(token, "character-quest-number",22) == 0) cReadModeA = 56;
			if (memcmp(token, "current-quest-count",19) == 0)	 cReadModeA = 57;

			if (memcmp(token, "quest-reward-type", 17) == 0)    cReadModeA = 59;
			if (memcmp(token, "quest-reward-amount", 19) == 0)  cReadModeA = 60;

			if (memcmp(token, "character-contribution", 22) == 0)   cReadModeA = 61;
			if (memcmp(token, "character-quest-ID",18) == 0)        cReadModeA = 62;
			if (memcmp(token, "character-quest-completed",25) == 0) cReadModeA = 63;

			if (memcmp(token, "timeleft-force-recall", 21) == 0)	cReadModeA = 64;
			if (memcmp(token, "timeleft-firm-staminar", 22) == 0)	cReadModeA = 65;
			if (memcmp(token, "special-event-id", 16) == 0)			cReadModeA = 66;
			if (memcmp(token, "super-attack-left", 17) == 0)		cReadModeA = 70;

			// v1.4311-3 ÃƒÃŸÂ°Â¡ Â¿Ã¹ÂµÃ¥ Â¼Â­Â¹Ã¶Â·Ã ÂºÃÃ…ÃÂ¿Ã‚ Â¸ÃÂ¼Â¼ÃÃ¶Â·ÃÂºÃÃ…Ã Â¿Â¹Â¾Ã ÂµÃˆ Â»Ã§Ã…ÃµÃ€Ã¥Â¿Â¡ Â°Ã¼Ã‡Ã‘ Â°Âª Ã€ÃÂ±Ã¢ reserved-fightzone-id
			if (memcmp(token, "reserved-fightzone-id", 21) == 0)	{
				cReadModeA = 67;
				cReadModeB = 1;
			}

			if (memcmp(token, "special-ability-time", 20) == 0)       cReadModeA = 71; 
			if (memcmp(token, "character-war-contribution", 26) == 0) cReadModeA = 72; 

			if (memcmp(token, "locked-map-name", 15) == 0) cReadModeA = 73;
			if (memcmp(token, "locked-map-time", 15) == 0) cReadModeA = 74;
			if (memcmp(token, "crusade-job", 11) == 0)     cReadModeA = 75;
			if (memcmp(token, "construct-point", 15) == 0) cReadModeA = 76;
			if (memcmp(token, "crusade-GUID", 12) == 0)    cReadModeA = 77;

			if (memcmp(token, "dead-penalty-time", 17) == 0) cReadModeA = 78;
			if (memcmp(token, "party-id", 8) == 0)           cReadModeA = 79; // v2.06 12-4
			if (memcmp(token, "gizon-item-upgade-left", 22) == 0) cReadModeA = 80; // v2.15 ÃÃ¶ÃÂ¸Â¾Ã†Ã€ÃŒÃ…Ã›Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥

			if (memcmp(token, "[EOF]", 5) == 0) goto DPDC_STOP_DECODING;
		}

		token = pStrTok->pGet();
		//token = strtok( NULL, seps );							    
	}													  

DPDC_STOP_DECODING:;	

	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		wsprintf(cTxt, "(!!!) Player(%s) data file contents error(%d %d)! Connection closed.", m_pClientList[iClientH]->m_cCharName, cReadModeA, cReadModeB);
		PutLogList(cTxt);

		// Debug code @@@@@@@@@@@@@@@
		HANDLE hFile2;
		DWORD  nWrite2;
		hFile2 = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
		WriteFile(hFile2, (char *)pOriginContents, dwSize+2, &nWrite2, NULL);
		CloseHandle(hFile2);
		///////////// @@@@@@@@@@@@@@@

		return FALSE;
	}

	// Ã€ÃÃ‡Ã´ÃÃ¸ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® ÂµÂ¥Ã€ÃŒÃ…ÃÂ¸Â¦ Â°Ã‹Â»Ã§Ã‡Ã˜Â¼Â­ Â¿Ã€Â·Ã¹Â°Â¡ Â¾Ã¸Â´Ã‚ÃÃ¶Â¸Â¦ ÃˆÂ®Ã€ÃÃ‡ÃÂ¿Â© Â¸Â®Ã…ÃÂ°ÂªÃ€Â» Â°Ã¡ÃÂ¤Ã‡Ã‘Â´Ã™.
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bIsValidLoc(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (bRet == FALSE) {
		if ((m_pClientList[iClientH]->m_sX != -1) || (m_pClientList[iClientH]->m_sY != -1)) {
			wsprintf(cTxt, "Invalid location error! %s (%d, %d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY); 
			PutLogList(cTxt);
			return FALSE;
		}
	}

	// Ã†Â¯Â¼ÂºÃ„Â¡ Â°ÂªÂ¿Â¡ Â¿Ã€Â·Ã¹Â°Â¡ Ã€Ã–Â´Ã‚ÃÃ¶ Â°Ã‹Â»Ã§ ==========================================================================
	/*	if ((m_pClientList[iClientH]->m_cLU_Str > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Str < 0)) 
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Vit > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Vit < 0)) 
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Dex > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Dex < 0)) 
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Int > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Int < 0)) 
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Mag > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Mag < 0)) 
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Char > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Char < 0)) 
	return FALSE;
	*/
	//	if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
	//  		  m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) > DEF_TOTALLEVELUPPOINT) 
	if ((m_pClientList[iClientH]->m_iLU_Pool < 0) || (m_pClientList[iClientH]->m_iLU_Pool > DEF_CHARPOINTLIMIT))
		return FALSE;	

	if ((m_pClientList[iClientH]->m_iStr < 10) || (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iDex < 10) || (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iVit < 10) || (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iInt < 10) || (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iMag < 10) || (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iCharisma < 10) || (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT))
		return FALSE;

	//Ã†Â¯Â¼ÂºÃ„Â¡Ã€Ã‡ ÃƒÃ‘ Ã‡Ã•Ã€ÃŒ Â¸Ã‚ÃÃ¶ Â¾ÃŠÂ´Ã™Â¸Ã© Â¿ÂªÂ½Ãƒ ÃÂ¢Â¼Ã“ ÂºÃ’Â°Â¡. 
	//	if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit + 
	//		 m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma) 
	//		 !=	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) return FALSE;


	// ÃƒÂ¼Ã‡Ã¨Ã†Ã‡ Â»Ã§Â¿Ã«Ã€ÃšÃ€Ã‡ ÂµÂ¥Ã€ÃŒÃ…ÃÃ€ÃÂµÂ¥ ÃÂ¦Ã‡Ã‘ Â·Â¹ÂºÂ§ Ã€ÃŒÂ»Ã³Ã€ÃŒÂ´Ã™. ÃÂ¢Â¼Ã“Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰. v1.43ÂºÃÃ…Ã Â»Ã§Â¿Ã«Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
	//if ((m_pClientList[iClientH]->m_cAccountStatus != 2) && (m_pClientList[iClientH]->m_iLevel > DEF_LEVELLIMIT)) 
	//	return FALSE;

	// v1.4 Â°Ã¨ÃÂ¤Ã€ÃŒÂ¸Â§Ã€ÃŒÂ³Âª Ã„Â³Â¸Â¯Ã…Ã Ã€ÃŒÂ¸Â§Â¿Â¡ Ã€ÃŸÂ¸Ã¸ÂµÃˆ Ã„ÃšÂµÃ¥Â°Â¡ ÂµÃ©Â¾Ã®Â°Â¡ Ã€Ã–Â´Ã™Â¸Ã© ÃÂ¢Â¼Ã“ ÂºÃ’Â°Â¡.
	if ((m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cCharName) == FALSE) || (m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cAccountName) == FALSE)) 
		return FALSE;

	// v1.4 Ã‚Â¡Â°Ã¨ Â¸Ã”Ã€Âº Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ Ã‚Â¡Â°Ã¨Â±Ã¢Â°Â£ Â¾ÃˆÃ€ÃŒÂ¸Ã© ÃÂ¢Â¼Ã“ ÂºÃ’Â°Â¡
	if (m_pClientList[iClientH]->m_iPenaltyBlockYear != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)(m_pClientList[iClientH]->m_iPenaltyBlockYear*10000 + m_pClientList[iClientH]->m_iPenaltyBlockMonth*100 + m_pClientList[iClientH]->m_iPenaltyBlockDay);
		iDateSum2 = (__int64)(SysTime.wYear*10000 + SysTime.wMonth*100 + SysTime.wDay);
		if (iDateSum1 >= iDateSum2) return FALSE;
	}

	// v1.4311-3 ÃƒÃŸÂ°Â¡ Ã€Â¯ÃˆÂ¿Ã‡ÃÃÃ¶ Â¾ÃŠÃ€Âº Â»Ã§Ã…ÃµÃ€Ã¥ Â¿Â¹Â¾Ã Ã€Â» Â°Â¡ÃÃ¶Â°Ã­ Ã€Ã–Ã€Â¸Â¸Ã© ÃƒÃŠÂ±Ã¢ÃˆÂ­ 
	if (m_pClientList[iClientH]->m_iReserveTime != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)m_pClientList[iClientH]->m_iReserveTime;
		iDateSum2 = (__int64)(SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour);
		if (iDateSum2 >= iDateSum1) {
			// Â¿Â¹Â¾Ã Ã€ÃŒ ÃƒÃ«Â¼Ã’ÂµÃŠ 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_iFightzoneNumber = 0; 
			m_pClientList[iClientH]->m_iReserveTime = 0;
			m_pClientList[iClientH]->m_iFightZoneTicketNumber = 0;
		}
	}

	// v1.42 Ã€ÃŸÂ¸Ã¸ Ã€Ã”Â·Ã‚ÂµÃˆ Â¿Ã®Â¿ÂµÃ€Ãš Â·Â¹ÂºÂ§ Â°ÂªÃ€Â» Ã…Â¬Â¸Â®Â¾Ã® 
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 0) m_pClientList[iClientH]->m_iAdminUserLevel = 0;

	// ============================================================================================================


	// Â³Â»Â¿Ã«Ã€Â» Â¹Ã™Ã…ÃÃ€Â¸Â·Ã AppearanceÂ¸Â¦ Â°Ã¨Â»Ãª, Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™.
	if (m_pClientList[iClientH]->m_cSex == 1) {
		// Â³Â²Ã€ÃšÃ€ÃŒÂ´Ã™. 
		sTmpType = 1;
	}
	else if (m_pClientList[iClientH]->m_cSex == 2) {
		// Â¿Â©Ã€ÃšÃ€ÃŒÂ´Ã™.
		sTmpType = 4; 
	}

	switch (m_pClientList[iClientH]->m_cSkin) {
	case 1:
		// Â¹Ã©Ã€ÃÃ€ÃŒÂ¸Ã© Â±Ã—Â´Ã«Â·Ã.
		break;
	case 2:
		sTmpType += 1;
		break;
	case 3:
		sTmpType += 2;
		break;
	}

	// v1.41 Â¿Ã®Â¿ÂµÃ€Ãš Â¾ÃÃ‡Ã Â¿Ã« 
	if (m_pClientList[iClientH]->m_iAdminUserLevel >= 10) 
		sTmpType = m_pClientList[iClientH]->m_iAdminUserLevel;

	sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);

	m_pClientList[iClientH]->m_sType  = sTmpType;
	m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;

	// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â®Â°Ã¨Â»Ãª 
	iCalcTotalWeight(iClientH);

	// v1.3 ÃÃ¶Â³ÂªÃ„Â¡Â°Ã” Â¸Â¹Ã€Âº ÂµÂ·Ã€Â» Â¼Ã’ÃÃ¶Ã‡Ã‘ Ã„Â³Â¸Â¯Ã…Ã Ã€ÃŒÂ¸Â§Ã€Â» Ã€Ã»Â´Ã‚Â´Ã™. 
	//if (iTotalGold > 800000) {
	//	wsprintf(G_cTxt, "(!) Ã‡Ã˜Ã…Â· Â¿Ã«Ã€Ã‡Ã€Ãš(%s) Gold(%d)", m_pClientList[iClientH]->m_cCharName, iTotalGold);
	//PutLogFileList(G_cTxt);
	//}

	// v.135 
	/*
	if ((m_pClientList[iClientH]->m_cSkillMastery[0] >= 70) || (m_pClientList[iClientH]->m_cSkillMastery[1] >= 70) ||
	(m_pClientList[iClientH]->m_cSkillMastery[12] >= 70)) {
	wsprintf(G_cTxt, "(!) Ã‡Ã˜Ã…Â· Â¿Ã«Ã€Ã‡Ã€Ãš(%s) Â³Ã´Ã€Âº Â½ÂºÃ…Â³ (%d %d %d)", m_pClientList[iClientH]->m_cCharName, 
	m_pClientList[iClientH]->m_cSkillMastery[0], m_pClientList[iClientH]->m_cSkillMastery[1],
	m_pClientList[iClientH]->m_cSkillMastery[12]);
	PutLogFileList(G_cTxt);
	}
	*/

	if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
		// v1.3 Ã€ÃŒ Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ ID Â¹Ã¸ÃˆÂ£Â°Â¡ ÂºÃÂ¿Â©ÂµÃ‡ÃÃ¶ Â¾ÃŠÃ€Âº Â»Ã³Ã…Ã‚Ã€ÃŒÂ´Ã™. Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™. 
		int _i, _iTemp1, _iTemp2;
		short _sID1, _sID2, _sID3;

		_iTemp1 = 1;
		_iTemp2 = 1;
		for (_i = 0; _i < 10; _i++) {
			_iTemp1 += m_pClientList[iClientH]->m_cCharName[_i];
			_iTemp2 += abs(m_pClientList[iClientH]->m_cCharName[_i] ^ m_pClientList[iClientH]->m_cCharName[_i]);
		}

		_sID1 = (short)timeGetTime(); 
		_sID2 = (short)_iTemp1; 
		_sID3 = (short)_iTemp2; 

		m_pClientList[iClientH]->m_sCharIDnum1 = _sID1;
		m_pClientList[iClientH]->m_sCharIDnum2 = _sID2;
		m_pClientList[iClientH]->m_sCharIDnum3 = _sID3;
	}

	// v1.4 Â¾Ã¸Â¾Ã®ÃÃ¸ Â¾Ã†Ã€ÃŒÃ…Ã›Â¿Â¡ Â´Ã«Ã‡Ã‘ ÂºÂ¸Â»Ã³Â±ÃÃ€Â» ÃÃ¶Â±Ã. 
	m_pClientList[iClientH]->m_iRewardGold += iNotUsedItemPrice;

	// 
	m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;

	// v1.41 
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) m_pClientList[iClientH]->m_bIsNeutral = TRUE;

	return TRUE;
}

int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData)
{
 SYSTEMTIME SysTime;
 char  cTxt[120], cTmp[21];
 POINT TempItemPosList[DEF_MAXITEMS];
 int   i, iPos;

	if (m_pClientList[iClientH] == NULL) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");
	
	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n");
		
	// Ã€ÃŒÂ¸Â§ Ã€ÃºÃ€Ã¥
	strcat(pData, "[NAME-ACCOUNT]\n\n");
	strcat(pData, "character-name     = ");
	strcat(pData, m_pClientList[iClientH]->m_cCharName);
	strcat(pData, "\n");
	strcat(pData, "account-name       = ");
	strcat(pData, m_pClientList[iClientH]->m_cAccountName);
	strcat(pData, "\n\n");

	strcat(pData, "[STATUS]\n\n");
	// Ã„Â³Â¸Â¯Ã…Ã Ã‡ÃÂ·ÃÃ‡ÃŠ 
	strcat(pData, "character-profile 	=");
	if (strlen(m_pClientList[iClientH]->m_cProfile) == 0) {
		// Ã„Â³Â¸Â¯Ã…Ã Ã‡ÃÂ·ÃÃ‡ÃŠÃ€ÃŒ Â¼Â³ÃÂ¤ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™Â¸Ã© 
		strcat(pData, "__________");
	}
	else strcat(pData, m_pClientList[iClientH]->m_cProfile);
	strcat(pData, "\n");

	// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® Â¼Ã’Â¼Ã“ Ã€Â§Ã„Â¡
	strcat(pData, "character-location   = ");
	strcat(pData, m_pClientList[iClientH]->m_cLocation);
	strcat(pData, "\n");

	/// Â±Ã¦ÂµÃ¥ Â»Ã³Ã…Ã‚ 
	strcat(pData, "character-guild-name = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRankÂ°Â¡ -1Ã€ÃŒÂ¸Ã© Â±Ã¦ÂµÃ¥Ã€ÃŒÂ¸Â§Ã€Âº Â¹Â«Ã€Ã‡Â¹ÃŒÃ‡ÃÂ´Ã™.
		strcat(pData, m_pClientList[iClientH]->m_cGuildName);
	}
	else strcat(pData, "NONE");
	strcat(pData, "\n");
	
	// Â±Ã¦ÂµÃ¥ GUID 
	strcat(pData, "character-guild-GUID = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRankÂ°Â¡ -1Ã€ÃŒÂ¸Ã© Â±Ã¦ÂµÃ¥GUIDÂ´Ã‚ Â¹Â«Ã€Ã‡Â¹ÃŒÃ‡ÃÂ´Ã™.
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d", m_pClientList[iClientH]->m_iGuildGUID);
		strcat(pData, cTxt);
	}
	else strcat(pData, "-1");
	strcat(pData, "\n");
		
	// Â±Ã¦ÂµÃ¥ Â¼Ã¸Ã€Â§
	strcat(pData, "character-guild-rank = ");
	itoa( m_pClientList[iClientH]->m_iGuildRank, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	strcat(pData, "character-loc-map = ");
	strcat(pData, m_pClientList[iClientH]->m_cMapName);
	strcat(pData, "\n");
	// XÃÃ‚Ã‡Â¥ Ã€ÃºÃ€Ã¥ 
	strcat(pData, "character-loc-x   = ");
	itoa( m_pClientList[iClientH]->m_sX, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// YÃÃ‚Ã‡Â¥ Ã€ÃºÃ€Ã¥ 
	strcat(pData, "character-loc-y   = ");
	itoa( m_pClientList[iClientH]->m_sY, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	//
	if (m_pClientList[iClientH]->m_iHP <= 0)  
		m_pClientList[iClientH]->m_iHP = 30;

	wsprintf(cTxt, "character-HP       = %d", m_pClientList[iClientH]->m_iHP);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-MP       = %d",  m_pClientList[iClientH]->m_iMP);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	if (m_pClientList[iClientH]->m_iSP < 0) m_pClientList[iClientH]->m_iSP = 0; // v1.1
	wsprintf(cTxt, "character-SP       = %d",  m_pClientList[iClientH]->m_iSP);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-LEVEL    = %d", m_pClientList[iClientH]->m_iLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-RATING   = %d", m_pClientList[iClientH]->m_iRating);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-STR      = %d", m_pClientList[iClientH]->m_iStr);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-INT      = %d", m_pClientList[iClientH]->m_iInt);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-VIT      = %d", m_pClientList[iClientH]->m_iVit);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-DEX      = %d", m_pClientList[iClientH]->m_iDex);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-MAG      = %d", m_pClientList[iClientH]->m_iMag);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-CHARISMA = %d", m_pClientList[iClientH]->m_iCharisma);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LUCK     = %d", m_pClientList[iClientH]->m_iLuck);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-EXP      = %d", m_pClientList[iClientH]->m_iExp);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Pool  = %d", m_pClientList[iClientH]->m_iLU_Pool);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	/*	
	wsprintf(cTxt, "character-LU_Str   = %d", m_pClientList[iClientH]->m_cLU_Str);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Vit   = %d", m_pClientList[iClientH]->m_cLU_Vit);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Dex   = %d", m_pClientList[iClientH]->m_cLU_Dex);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Int   = %d", m_pClientList[iClientH]->m_cLU_Int);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Mag   = %d", m_pClientList[iClientH]->m_cLU_Mag);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Char  = %d", m_pClientList[iClientH]->m_cLU_Char);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	*/
	wsprintf(cTxt, "character-EK-Count = %d", m_pClientList[iClientH]->m_iEnemyKillCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-PK-Count = %d", m_pClientList[iClientH]->m_iPKCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-reward-gold = %d", m_pClientList[iClientH]->m_iRewardGold);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-downskillindex = %d", m_pClientList[iClientH]->m_iDownSkillIndex);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-IDnum1 = %d", m_pClientList[iClientH]->m_sCharIDnum1);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-IDnum2 = %d", m_pClientList[iClientH]->m_sCharIDnum2);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-IDnum3 = %d", m_pClientList[iClientH]->m_sCharIDnum3);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	/*
	wsprintf(cTxt, "party-rank = %d", m_pClientList[iClientH]->m_iPartyRank);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum1 = %d", m_pClientList[iClientH]->m_sPartyIDnum1);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum2 = %d", m_pClientList[iClientH]->m_sPartyIDnum2);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum3 = %d", m_pClientList[iClientH]->m_sPartyIDnum3);
	strcat(pData, cTxt);
	strcat(pData,"\n\n");
	*/

	//
	// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® Ã†Â¯Â¼ÂºÃ„Â¡ Ã€Ã”Â·Ã‚ 
	strcat(pData, "sex-status       = ");
	itoa( m_pClientList[iClientH]->m_cSex, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "skin-status      = ");
	itoa( m_pClientList[iClientH]->m_cSkin, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "hairstyle-status = ");
	itoa( m_pClientList[iClientH]->m_cHairStyle, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "haircolor-status = ");
	itoa( m_pClientList[iClientH]->m_cHairColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "underwear-status = ");
	itoa( m_pClientList[iClientH]->m_cUnderwear, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "hunger-status    = %d", m_pClientList[iClientH]->m_iHungerStatus);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-shutup  = %d", m_pClientList[iClientH]->m_iTimeLeft_ShutUp);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-rating  = %d", m_pClientList[iClientH]->m_iTimeLeft_Rating);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-force-recall  = %d", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-firm-staminar = %d", m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "admin-user-level = %d", m_pClientList[iClientH]->m_iAdminUserLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "penalty-block-date = %d %d %d", m_pClientList[iClientH]->m_iPenaltyBlockYear, m_pClientList[iClientH]->m_iPenaltyBlockMonth, m_pClientList[iClientH]->m_iPenaltyBlockDay);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-number = %d", m_pClientList[iClientH]->m_iQuest);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-ID     = %d", m_pClientList[iClientH]->m_iQuestID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "current-quest-count    = %d", m_pClientList[iClientH]->m_iCurQuestCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "quest-reward-type      = %d", m_pClientList[iClientH]->m_iQuestRewardType);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "quest-reward-amount    = %d", m_pClientList[iClientH]->m_iQuestRewardAmount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-contribution = %d", m_pClientList[iClientH]->m_iContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-war-contribution = %d", m_pClientList[iClientH]->m_iWarContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-completed = %d", (int)m_pClientList[iClientH]->m_bIsQuestCompleted);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "special-event-id = %d", (int)m_pClientList[iClientH]->m_iSpecialEventID);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "super-attack-left = %d", (int)m_pClientList[iClientH]->m_iSuperAttackLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v1.4311-3 ÃƒÃŸÂ°Â¡ Â¿Ã¹ÂµÃ¥Â¼Â­Â¹Ã¶Â¿Â¡ Â»Ã§Ã…ÃµÃ€Ã¥ Â°Ã¼Â·Ãƒ ÂºÂ¯Â¼Ã¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
	// Â»Ã§Ã…ÃµÃ€Ã¥ Â¿Â¹Â¾Ã  Â°Ã¼Â·ÃƒÂµÃˆ Â³Â»Â¿Ã« Ã€ÃºÃ€Ã¥ reserved-fightzone-id Â¿Â¹Â¾Ã ÂµÃˆ Â»Ã§Ã…ÃµÃ€Ã¥Â¹Ã¸ÃˆÂ£/Â³Â¯Ã‚Â¥Â¹Ã—Â½ÃƒÂ°Â£/Â³Â²Ã€ÂºÃ†Â¼Ã„ÃÂ°Â¹Â¼Ã¶
	wsprintf(cTxt, "reserved-fightzone-id = %d %d %d", m_pClientList[iClientH]->m_iFightzoneNumber, m_pClientList[iClientH]->m_iReserveTime,m_pClientList[iClientH]->m_iFightZoneTicketNumber  );
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// Ã†Â¯Â¼Ã¶ Â´Ã‰Â·Ã‚ Â¹ÃŸÃˆÃ–Â¿Ã« Â³Â²Ã€Âº Â½ÃƒÂ°Â£
	wsprintf(cTxt, "special-ability-time = %d", m_pClientList[iClientH]->m_iSpecialAbilityTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// Ã€Ã¡Â±Ã¤ Â¸ÃŠ Ã€ÃŒÂ¸Â§
	wsprintf(cTxt, "locked-map-name = %s", m_pClientList[iClientH]->m_cLockedMapName);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// Ã€Ã¡Â±Ã¤ Â¸ÃŠ Â½ÃƒÂ°Â£
	wsprintf(cTxt, "locked-map-time = %d", m_pClientList[iClientH]->m_iLockedMapTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥Â¿Â¡Â¼Â­ Â¸ÃƒÃ€Âº ÃÃ·ÃƒÂ¥.
	wsprintf(cTxt, "crusade-job = %d", m_pClientList[iClientH]->m_iCrusadeDuty);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â°Ã­Ã€Â¯ Â¾Ã†Ã€ÃŒÂµÃ° 
	wsprintf(cTxt, "crusade-GUID = %d", m_pClientList[iClientH]->m_dwCrusadeGUID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "construct-point = %d", m_pClientList[iClientH]->m_iConstructionPoint);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.04 Â»Ã§Â¸ÃÂ½Ãƒ Ã†Ã¤Â³ÃÃ†Â¼ Ã…Â¸Ã€Ã“ 
	wsprintf(cTxt, "dead-penalty-time = %d", m_pClientList[iClientH]->m_iDeadPenaltyTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.06 12-4 Ã†Ã„Ã†Â¼ Â¾Ã†Ã€ÃŒÂµÃ°
	wsprintf(cTxt, "party-id = %d", m_pClientList[iClientH]->m_iPartyID);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v2.15 ÃÃ¶ÃÂ¸Â¾Ã†Ã€ÃŒÃ…Ã›Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥
	wsprintf(cTxt, "gizon-item-upgade-left = %d", m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	/*wsprintf(cTxt, "gizon-item-upgade-left = %d", m_pClientList[iClientH]->m_iGizonItemUpgradeLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");*/

	strcat(pData,"\n\n");

	// Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ Â¿ÃœÃ‡Ã¼Ã‡Â¥Ã‡Ã¶ Appr4Â°Â³Â¸Â¦ Ã€ÃºÃ€Ã¥Ã‡Ã‘Â´Ã™. Ã€ÃŒÂ°ÃÃ€Âº Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶Â¿Â¡Â¼Â­Â´Ã‚ Â»Ã§Â¿Ã«Ã‡ÃÃÃ¶ Â¾ÃŠÃ€Â¸Â¸Ã§ Â·ÃÂ±Ã—Â¼Â­Â¹Ã¶->Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â°Â£Â¿Â¡ Â»Ã§Â¿Ã«ÂµÃˆÂ´Ã™.
	strcat(pData, "appr1 = ");
	itoa( m_pClientList[iClientH]->m_sAppr1, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr2 = ");
	// Ã€Ã¼Ã…ÃµÂ¸Ã°ÂµÃ¥ Ã‡ÃƒÂ·Â¡Â±Ã—Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®Ã‡Ã‘Â´Ã™.
	//m_pClientList[iClientH]->m_sAppr2 = m_pClientList[iClientH]->m_sAppr2 & 0x0FFF;
	itoa( m_pClientList[iClientH]->m_sAppr2, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr3 = ");
	itoa( m_pClientList[iClientH]->m_sAppr3, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr4 = ");
	itoa( m_pClientList[iClientH]->m_sAppr4, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// v1.4 ApprColor
	strcat(pData, "appr-color = ");
	itoa( m_pClientList[iClientH]->m_iApprColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");

	// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€ÃºÃ€Ã¥ 
	strcat(pData, "[ITEMLIST]\n\n");

	for (i = 0; i < DEF_MAXITEMS; i++) { // v1.4
		TempItemPosList[i].x = 40;
		TempItemPosList[i].y = 30;
	}
	iPos = 0;

	// Â°Â¢Â°Â¢Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€ÃºÃ€Ã¥Ã‡Ã‘Â´Ã™.
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		// v1.4 Â¾Ã†Ã€ÃŒÃ…Ã› Â¼Ã¸Â¼Â­Â¸Â¦ Ã€Ã§Â¹Ã¨Ã„Â¡Ã‡Ã‘Â´Ã™. 
		TempItemPosList[iPos].x = m_pClientList[iClientH]->m_ItemPosList[i].x;
		TempItemPosList[iPos].y = m_pClientList[iClientH]->m_ItemPosList[i].y;
		iPos++;
		
		strcat(pData, "character-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemList[i]->m_cName)] = (char)' ';
		cTmp[20] = NULL;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");

	// v1.4 Ã€Ã§ Â°Ã¨Â»ÃªÂµÃˆ Â¾Ã†Ã€ÃŒÃ…Ã› Ã€Â§Ã„Â¡ Â±Ã¢Â¾Ã¯ 
	for (i = 0; i < DEF_MAXITEMS; i++) {
		m_pClientList[iClientH]->m_ItemPosList[i].x = TempItemPosList[i].x; 
		m_pClientList[iClientH]->m_ItemPosList[i].y = TempItemPosList[i].y;
	}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) {
		strcat(pData, "character-bank-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName)] = (char)' ';
		cTmp[20] = NULL;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");

	
	strcat(pData, "[MAGIC-SKILL-MASTERY]\n\n");

	strcat(pData, "//------------------012345678901234567890123456789012345678901234567890");
	strcat(pData,"\n");

	strcat(pData, "magic-mastery     = ");
	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		wsprintf(cTxt,"%d", (int)m_pClientList[iClientH]->m_cMagicMastery[i]);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");
	
	strcat(pData, "skill-mastery     = ");
			
	
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_cSkillMastery[i]);

		strcat(pData, cTxt); // ÃƒÃŠÂ±Ã¢Â°Âª Ã€Ã”Â·Ã‚
	}
	strcat(pData,"\n");
			
	strcat(pData, "skill-SSN     = ");
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_iSkillSSN[i]);

		strcat(pData, cTxt); // ÃƒÃŠÂ±Ã¢Â°Âª Ã€Ã”Â·Ã‚
	}
	strcat(pData,"\n");
	
	// Â¾Ã†Ã€ÃŒÃ…Ã› Ã€Ã¥Ã‚Ã¸ Â»Ã³Ã…Ã‚Â¸Â¦ Ã€ÃºÃ€Ã¥Ã‡Ã‘Â´Ã™. Â¹ÃÂµÃ¥Â½Ãƒ Â¸Ã‡ Â¸Â¶ÃÃ¶Â¸Â·Â¿Â¡ Ã€Ã–Â¾Ã®Â¾ÃŸ Ã‡Ã”.
	strcat(pData, "[ITEM-EQUIP-STATUS]\n\n");
	strcat(pData, "item-equip-status = ");
	
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "00000000000000000000000000000000000000000000000000");
	              
	int iEP = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		if ((m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) && 
			(m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP)) {
			 cTxt[iEP] = '1';
		}
		iEP++;
	}
	strcat(pData, cTxt);
	strcat(pData, "\n");

	
	strcat(pData, "item-position-x = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].x);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");
	
	strcat(pData, "item-position-y = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].y);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n\n");
	
	strcat(pData, "[EOF]");
	strcat(pData, "\n\n\n\n");

	return strlen(pData);
}

BOOL CGame::_bDecodeItemConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iItemConfigListIndex, iTemp;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok( pContents, seps );   
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemIDnumber");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iItemConfigListIndex = atoi(token);
					
					//testcode
					if (iItemConfigListIndex == 490)
						iItemConfigListIndex = atoi(token);
					
					// Â¸Â¸Â¾Ã  Ã€ÃŒÂ¹ÃŒ Ã€ÃŒÂ·Â± Â¾Ã†Ã€ÃŒ Â°ÂªÃ€Â» Â°Â¡ÃÃ¸ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ ÃÂ¤Ã€Ã‡ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™Â¸Ã© Â¿Â¡Â·Â¯Ã€ÃŒÂ´Ã™.
					if (m_pItemConfigList[iItemConfigListIndex] != NULL) {
						// Ã€ÃŒÂ¹ÃŒ Â°Â°Ã€Âº Â°Ã­Ã€Â¯Â¹Ã¸ÃˆÂ£Â¸Â¦ Â°Â¡ÃÃ¸ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ ÃÂ¤Ã€Ã‡ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™. ÃÃŸÂºÂ¹ ÃÂ¤Ã€Ã‡ Â¿Â¡Â·Â¯!
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Duplicate ItemIDnum(%d)", iItemConfigListIndex);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex] = new class CItem;
					m_pItemConfigList[iItemConfigListIndex]->m_sIDnum = iItemConfigListIndex;
					cReadModeB = 2;
					break;
				case 2:
					// m_cName 
					ZeroMemory(m_pItemConfigList[iItemConfigListIndex]->m_cName, sizeof(m_pItemConfigList[iItemConfigListIndex]->m_cName));
					memcpy(m_pItemConfigList[iItemConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;
				case 3:
					// m_cItemType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemType");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemType = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_cEquipPos
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - EquipPos");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cEquipPos = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_sItemEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectType");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectType = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_sItemEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue1");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue1 = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_sItemEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue2");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue2 = atoi(token);
					cReadModeB = 8;
					break;
				case 8:
					// m_sItemEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue3");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue3 = atoi(token);
					cReadModeB = 9;
					break;
				case 9:
					// m_sItemEffectValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue4");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue4 = atoi(token);
					cReadModeB = 10;
					break;
				case 10:
					// m_sItemEffectValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue5");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue5 = atoi(token);
					cReadModeB = 11;
					break;
				case 11:
					// m_sItemEffectValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue6");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue6 = atoi(token);
					cReadModeB = 12;
					break;
				case 12:
					// m_wMaxLifeSpan
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxLifeSpan");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wMaxLifeSpan = (WORD)atoi(token);
					cReadModeB = 13;
					break;
				case 13:
					// m_sSpecialEffect
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxFixCount");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffect = atoi(token);
					cReadModeB = 14;
					break;
				case 14:
					// m_sSprite
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Sprite");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSprite = atoi(token);
					cReadModeB = 15;
					break;
				case 15:
					// m_sSpriteFrame
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SpriteFrame");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpriteFrame = atoi(token);
					cReadModeB = 16;
					break;
				case 16:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Price");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iTemp = atoi(token);
					if (iTemp < 0) 
						 m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = FALSE;
					else m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = TRUE;
					
					m_pItemConfigList[iItemConfigListIndex]->m_wPrice = abs(iTemp);
					cReadModeB = 17;
					break;
				case 17:
					// m_wWeight
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Weight");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wWeight = atoi(token);
					cReadModeB = 18;
					break;
				case 18:
					// Appr Value
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ApprValue");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cApprValue = atoi(token);
					cReadModeB = 19;
					break;
				case 19:
					// m_cSpeed
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Speed");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cSpeed = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// m_sLevelLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - LevelLimit");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sLevelLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_cGederLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - GenderLimit");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cGenderLimit = atoi(token);
					cReadModeB = 22;
					break;
				
				case 22:
					// m_sSpecialEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SM_HitRatio");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue1 = atoi(token);
					cReadModeB = 23;
					break;

				case 23:
					// m_sSpecialEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - L_HitRatio");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue2 = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					// m_sRelatedSkill
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - RelatedSkill");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sRelatedSkill = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					// m_cItemColor
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemColor = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Item", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "[ENDITEMLIST]", 13) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto DICFC_STOPDECODING;
			}
		}
		token = pStrTok->pGet();
		//token = strtok( NULL, seps );
	}
	
DICFC_STOPDECODING:;

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) ITEM(Total:%d) configuration - success!", iItemConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}


BOOL CGame::_bInitItemAttr(class CItem * pItem, char * pItemName)
{
 register int i;
 char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMTYPES; i++) 
	if (m_pItemConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pItemConfigList[i]->m_cName, 20) == 0) {
			// Â°Â°Ã€Âº Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ Â¾Ã†Ã€ÃŒÃ…Ã› Â¼Â³ÃÂ¤Ã€Â» ÃƒÂ£Â¾Ã’Â´Ã™. Â¼Â³ÃÂ¤Â°ÂªÃ€Â» ÂºÂ¹Â»Ã§Ã‡Ã‘Â´Ã™.
			ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
			strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
			pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
			pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
			pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
			pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
			pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
			pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
			pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
			pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
			pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
			pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
			pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;					// ÃƒÃ–ÃƒÃŠÂ·Ã Â»Ã½Â¼ÂºÂµÃˆ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Ã­Ã€Âº ÃƒÃ–Â´Ã«Ã„Â¡Ã€ÃŒÂ´Ã™.
			pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;
			
			pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
			pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
			pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
			pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
			pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
			pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
			pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
			pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;
			
			pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
			pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

			pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
			pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
			pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;

			pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
			pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;
	
			return TRUE;
		}
	}

	// Â¾Ã†Ã€ÃŒÃ…Ã›Â¸Â®Â½ÂºÃ†Â®Â¸Â¦ Â¸Ã°ÂµÃ Â°Ã‹Â»Ã¶Ã‡ÃŸÃ€Â½Â¿Â¡ÂµÂµ Â¹ÃŸÂ°ÃŸÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™. 
 	return FALSE;
}


BOOL CGame::_bGetIsStringIsNumber(char * pStr)
{
 int i;
	for (i = 0; i < (int)strlen(pStr); i++)
	if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return FALSE;
	
	return TRUE;
}


BOOL CGame::_bReadMapInfoFiles(int iMapIndex)
{
	if (__bReadMapInfo(iMapIndex) == FALSE) {
		return FALSE;
	}

	return TRUE;
}

BOOL CGame::bSetNpcFollowMode(char * pName, char * pFollowName, char cFollowOwnerType)
{
 register int i, iIndex, iMapIndex, iFollowIndex;
 char cTmpName[11], cFollowSide;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	iMapIndex    = -1;
	iFollowIndex = -1;

	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pName, 5) == 0) ) {
		iIndex = i;
		iMapIndex = m_pNpcList[i]->m_cMapIndex;
		goto NEXT_STEP_SNFM1;
	}

NEXT_STEP_SNFM1:;

	switch (cFollowOwnerType) {
	case DEF_OWNERTYPE_NPC:
		for (i = 1; i < DEF_MAXNPCS; i++)
		if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pFollowName, 5) == 0) ) {
			// ÂµÃ»Â¶Ã³Â´Ã™Â´Ã’ Â´Ã«Â»Ã³Ã€Â» Â¹ÃŸÂ°ÃŸÃ‡ÃŸÂ´Ã™.
			// Â´Ã™Â¸Â¥ Â¸ÃŠÂ¿Â¡ ÃÂ¸Ã€Ã§Ã‡ÃÂ´Ã‚ Â´Ã«Â»Ã³Ã€Âº ÂµÃ»Â¶Ã³Â´Ã™Â´Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
			if (m_pNpcList[i]->m_cMapIndex != iMapIndex) return FALSE;
			iFollowIndex = i;
			cFollowSide = m_pNpcList[i]->m_cSide;
			goto NEXT_STEP_SNFM2;
		}
		break;
	
	case DEF_OWNERTYPE_PLAYER:
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pFollowName, 10) == 0) ) {
			// ÂµÃ»Â¶Ã³Â´Ã™Â´Ã’ Â´Ã«Â»Ã³Ã€Â» Â¹ÃŸÂ°ÃŸÃ‡ÃŸÂ´Ã™.
			// Â´Ã™Â¸Â¥ Â¸ÃŠÂ¿Â¡ ÃÂ¸Ã€Ã§Ã‡ÃÂ´Ã‚ Â´Ã«Â»Ã³Ã€Âº ÂµÃ»Â¶Ã³Â´Ã™Â´Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
			if (m_pClientList[i]->m_cMapIndex != iMapIndex) return FALSE;
			iFollowIndex = i;
			cFollowSide = m_pClientList[i]->m_cSide;
			goto NEXT_STEP_SNFM2;
		}
		break;
	}

NEXT_STEP_SNFM2:;

	if ((iIndex == -1) || (iFollowIndex == -1)) return FALSE;

	m_pNpcList[iIndex]->m_cMoveType = DEF_MOVETYPE_FOLLOW;
	m_pNpcList[iIndex]->m_cFollowOwnerType  = cFollowOwnerType;
	m_pNpcList[iIndex]->m_iFollowOwnerIndex = iFollowIndex;
	m_pNpcList[iIndex]->m_cSide             = cFollowSide;


	return TRUE;
}


int CGame::bCreateNewNpc(char * pNpcName, char * pName, char * pMapName, short sClass, char cSA, char cMoveType, int * poX, int * poY, char * pWaypointList, RECT * pArea, int iSpotMobIndex, char cChangeSide, BOOL bHideGenMode, BOOL bIsSummoned, BOOL bFirmBerserk, BOOL bIsMaster, int iGuildGUID)
{
 register int i, t, j, k, iMapIndex;
 char  cTmpName[11], cTxt[120];
 short sX, sY, sRange;
 BOOL  bFlag;
 SYSTEMTIME SysTime;

	if (strlen(pName) == 0)   return FALSE;
	if (strlen(pNpcName) == 0) return FALSE;
	GetLocalTime(&SysTime);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);
	iMapIndex = -1;

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {
		if (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0) 
			iMapIndex = i;
	}
	
	if (iMapIndex == -1) return FALSE;
	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] == NULL) {
		m_pNpcList[i] = new class CNpc(pName);
		if (_bInitNpcAttr(m_pNpcList[i], pNpcName, sClass, cSA) == FALSE) {
			wsprintf(cTxt, "(!) Not existing NPC creation request! (%s) Ignored.", pNpcName);
			PutLogList(cTxt);
			
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;	
		}

		if (m_pNpcList[i]->m_cDayOfWeekLimit < 10) {
			if (m_pNpcList[i]->m_cDayOfWeekLimit != SysTime.wDayOfWeek)	{
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;	
			}
		}

		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
		case DEF_MOVETYPE_RANDOM:
			if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) {
				sX = *poX;
				sY = *poY;
			}
			else {
				for ( j = 0; j <= 30; j++) {
					// Â¸Â¸ÂµÃ© Â¼Ã¶ Ã€Ã–Â´Ã‚ ÃÃ‚Ã‡Â¥Â°Â¡ Â³ÂªÂ¿ÃƒÂ¶Â§ Â±Ã®ÃÃ¶ 30Â¹Ã¸ Â¹ÃÂºÂ¹ 
					sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
					sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

					bFlag = TRUE;
					for (k = 0; k < DEF_MAXMGAR; k++)
					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left != -1) {
						// Ã‡Ã‡Ã‡Ã˜Â¾ÃŸ Ã‡Ã’ ÃÃ‚Ã‡Â¥Â°Â¡ Ã€Ã–Â´Ã™. 
						if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left) &&
							(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].right) &&
							(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].top) &&
							(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].bottom)) {
							// Avoid RectÂ¾ÃˆÃ€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒ Ã€Â§Ã„Â¡Â¿Â¡Â´Ã‚ Â»Ã½Â¼ÂºÂ½ÃƒÃ…Â³ Â¼Ã¶ Â¾Ã¸Â´Ã™.	
							bFlag = FALSE;
						}
					}
					if (bFlag == TRUE) goto GET_VALIDLOC_SUCCESS;

				}
				// Â½Ã‡Ã†Ã!
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;

GET_VALIDLOC_SUCCESS:;
				// sX, sYÂ¿Â¡ Â»Ã½Â¼Âº Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™.
			}
			break;

		case DEF_MOVETYPE_RANDOMAREA:
			// pArea Â¿ÂµÂ¿Âª Â¾ÃˆÂ¿Â¡Â¼Â­ Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™. 
			sRange = (short)(pArea->right - pArea->left);
			sX     = (short)((rand() % sRange) + pArea->left);
			sRange = (short)(pArea->bottom - pArea->top);
			sY     = (short)((rand() % sRange) + pArea->top);
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:
			// 10Â°Â³Ã€Ã‡ Â»Ã½Â¼ÂºÃ€Â§Ã„Â¡ÃÃŸ Ã‡Ã‘Â°Ã·Ã€Â» Â·Â£Â´Ã½Ã‡ÃÂ°Ã” Â¼Â±Ã…Ãƒ 
			sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].x;
			sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].y;
			break;

		default:
			// poX, poYÂ°Â¡ NULLÃ€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© WaypointList 0Â¹Ã¸Ã€ÃŒ Â½ÃƒÃ€Ã›Ã€Â§Ã„Â¡ 
			if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) {
				// Ã†Ã·Ã€ÃÃ…ÃÂµÂµ NULLÃ€ÃŒ Â¾Ã†Â´ÃÂ°Ã­ Â±Ã— Â°ÂªÂµÂµ NULLÃ€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© Â½ÃƒÃ€Ã› Ã€Â§Ã„Â¡Â¸Â¦ Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™.
				sX = *poX;
				sY = *poY;
			}
			else {
				sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].x;
				sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].y;
			}
			break;
		}
		
		// Ã€Â§Ã„Â¡Â½ÃƒÃ…Â³Â¸Â¸Ã‡Ã‘ ÃÃ‚Ã‡Â¥Â¸Â¦ Â±Â¸Ã‡Ã‘Â´Ã™. Ã€Â§Ã„Â¡Â½ÃƒÃ…Â³ Â¼Ã¶ Â¾Ã¸Â´Ã™Â¸Ã© Â¸Â¸ÂµÃ©ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
		if (bGetEmptyPosition(&sX, &sY, iMapIndex) == FALSE) {
			
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;
		}

		if ( (bHideGenMode == TRUE) && (_iGetPlayerNumberOnSpot(sX, sY, iMapIndex, 7) != 0) ) {
			// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Ã€Ã–Â´Ã‚ Ã€ÃšÂ¸Â®Â¿Â¡Â¼Â­Â´Ã‚ Â»Ã½Â¼ÂºÂµÃ‡ÃÃ¶ Â¾ÃŠÂ´Ã‚ Â¸Ã°ÂµÃ¥Â¶Ã³Â¸Ã© 
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;	
		}

		if ((poX != NULL) && (poY != NULL)) {
			// Ã†Ã·Ã€ÃÃ…ÃÂ°Â¡ NULLÃ€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© Â»Ã½Â¼ÂºÃÃ‚Ã‡Â¥Â¸Â¦ Ã€Ã”Â·Ã‚Ã‡Ã‘Â´Ã™.
			*poX = sX;
			*poY = sY;
		}

		m_pNpcList[i]->m_sX = sX;
		m_pNpcList[i]->m_sY = sY;
		
		// ÃÂ¦Ã€ÃšÂ¸Â®Â¿Â¡Â¼Â­ Â¸Ã‰ÂµÂ¹Â°Ã­ Ã€Ã–Â´Ã‚ÃÃ¶Â¸Â¦ ÃˆÂ®Ã€ÃÃ‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã‘ ÃÃ‚Ã‡Â¥ ÂºÂ¯Â¼Ã¶ 
		m_pNpcList[i]->m_vX = sX;
		m_pNpcList[i]->m_vY = sY;

		// WaypointIndexÂ¸Â¦ Ã„Â«Ã‡Ã‡Ã‡Ã‘Â´Ã™.
		for (t = 0; t < 10; t++)
			m_pNpcList[i]->m_iWayPointIndex[t] = pWaypointList[t];

		// ÃƒÃ‘ WaypointIndexÃ€Ã‡ Â¼Ã¶Â¸Â¦ Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™.
		m_pNpcList[i]->m_cTotalWaypoint = 0;
		for (t = 0; t < 10; t++)
		if (m_pNpcList[i]->m_iWayPointIndex[t] != -1) m_pNpcList[i]->m_cTotalWaypoint++;

		if (pArea != NULL) {
			// RANDOMAREA Copy
			SetRect(&m_pNpcList[i]->m_rcRandomArea, pArea->left, pArea->top, pArea->right, pArea->bottom);
		}

		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
			m_pNpcList[i]->m_dX = m_pNpcList[i]->m_sX;
			m_pNpcList[i]->m_dY = m_pNpcList[i]->m_sY;
			break;
		
		case DEF_MOVETYPE_SEQWAYPOINT: 
			m_pNpcList[i]->m_cCurWaypoint = 1;
			
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:
			m_pNpcList[i]->m_cCurWaypoint = (rand() % (m_pNpcList[i]->m_cTotalWaypoint - 1)) + 1;
			
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
			break;

		case DEF_MOVETYPE_RANDOMAREA:
			m_pNpcList[i]->m_cCurWaypoint = 0;
			
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.right - m_pNpcList[i]->m_rcRandomArea.left);
			m_pNpcList[i]->m_dX = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.left);
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.bottom - m_pNpcList[i]->m_rcRandomArea.top);
			m_pNpcList[i]->m_dY = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.top);
			break;

		case DEF_MOVETYPE_RANDOM:
			m_pNpcList[i]->m_dX = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15);
			m_pNpcList[i]->m_dY = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15);
			break;
		}

		m_pNpcList[i]->m_tmp_iError  = 0;

		m_pNpcList[i]->m_cMoveType          = cMoveType;

		switch (m_pNpcList[i]->m_cActionLimit) {
		case 2:
		case 3:
		case 5:
			// ÃÂ¦Ã€ÃšÂ¸Â®Â¿Â¡Â¼Â­ Â¿ÃÃ€Ã¼ STOPÃ‡Ã‘ Â»Ã³Ã…Ã‚Ã€Ã‡ NPC 
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_STOP;
			
			switch (m_pNpcList[i]->m_sType) {
			case 15: // ShopKeeper-W
			case 19: // Gandlf
			case 20: // Howard
			case 24: // Tom
			case 25: // William
			case 26: // Kennedy
				m_pNpcList[i]->m_cDir      = 4 + iDice(1,3) -1;
				break;

			default:
				m_pNpcList[i]->m_cDir      = iDice(1,8);
				break;
			}
			break;

		default: 
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
			m_pNpcList[i]->m_cDir      = 5;
			break;
		}

		m_pNpcList[i]->m_iFollowOwnerIndex  = NULL;
		m_pNpcList[i]->m_iTargetIndex	    = NULL;
		m_pNpcList[i]->m_cTurn              = (rand() % 2);
		
		switch (m_pNpcList[i]->m_sType) {
			case 1:
			case 2:
			case 3:
			case 4:
			case 5:
			case 6:
				// Ã€ÃÂ°Â£Ã‡Ã¼ NPCÂ¶Ã³Â¸Ã© Ã€Ã¼Ã…ÃµÂ¸Ã°ÂµÃ¥, Â¹Â«Â±Ã¢, Â¹Ã¦Ã†Ã Ã‡ÃƒÂ·Â¡Â±Ã—Â¸Â¦ Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™.
				m_pNpcList[i]->m_sAppr2 = 0xF000;
				m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | ((rand() % 13) << 4); // Â¹Â«Â±Ã¢
				m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | (rand() % 9); // Â¹Ã¦Ã†Ã 
				break;

			case 36: // AGT-Aresden/AGT-Elvine
			case 37: // CGT-Aresden/CGT-Elvine
			case 38: // MS-Aresden/MS-Elvine
			case 39: // DT-Aresden/DT-Elvine
				m_pNpcList[i]->m_sAppr2 = 3;
			break;
			
		//case 64: // Crop
		//	// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥Â¿Ã« Â°Ã‡ÃƒÃ Â¹Â°Ã€ÃŒÂ¶Ã³Â¸Ã© 3Â´ÃœÂ°Ã¨Â·Ã Â¿ÃÂ¼ÂºÂµÃˆÂ´Ã™.
		//	m_pNpcList[i]->m_sAppr2 = 1;
		//	break;
		// appr2 = 2 seems to be enemy detection for crusade

		/*case 91: // gate
			// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥Â¿Ã« Â°Ã‡ÃƒÃ Â¹Â°Ã€ÃŒÂ¶Ã³Â¸Ã© 3Â´ÃœÂ°Ã¨Â·Ã Â¿ÃÂ¼ÂºÂµÃˆÂ´Ã™.
			m_pNpcList[i]->m_sAppr2 = 0xF000; // 10 aura no sphere 13 no name movable with magic (crash) test to 29
			break;*/
		
		case 64: // Crop
			m_pNpcList[i]->m_sAppr2 = 1; // 1 bud; 2 grown; 3 large 
			break;
	
		// case 66: // Wyvern
		//	m_pNpcList[i]->m_iStatus = 0x00000010; 
		//	// m_pNpcList[i]->m_cSide = 2;
		//	break;

		default:
			m_pNpcList[i]->m_sAppr2 = 0;
			break;
		}
		
		m_pNpcList[i]->m_cMapIndex          = (char)iMapIndex;
		m_pNpcList[i]->m_dwTime             = timeGetTime() + (rand() % 10000);
		m_pNpcList[i]->m_dwActionTime      += (rand() % 300);
		m_pNpcList[i]->m_dwMPupTime			= timeGetTime();
		m_pNpcList[i]->m_dwHPupTime			= m_pNpcList[i]->m_dwMPupTime;
		m_pNpcList[i]->m_sBehaviorTurnCount	= 0;
		m_pNpcList[i]->m_bIsSummoned        = bIsSummoned;
		m_pNpcList[i]->m_bIsMaster          = bIsMaster;
		// Â¼Ã’ÃˆÂ¯Â¸Ã· Â»Ã½Â¼Âº Â½ÃƒÂ°Â£Ã€Â» Â±Ã¢Â·ÃÃ‡Ã‘Â´Ã™.
		if (bIsSummoned == TRUE) 
			m_pNpcList[i]->m_dwSummonedTime = timeGetTime();

		// Â°Ã­ÃÂ¤ Berserk Â»Ã³Ã…Ã‚ ÃƒÃŸÂ°Â¡.
		if (bFirmBerserk == TRUE) {
			m_pNpcList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = 1;
			m_pNpcList[i]->m_iStatus = m_pNpcList[i]->m_iStatus | 0x20;
			// Â°Ã­ÃÂ¤ Berserk Â»Ã³Ã…Ã‚Ã€Ã‡ Â¸Ã·Ã€Âº Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ 2Â¹Ã¨ Â´Ãµ Â¸Â¹Ã€ÃŒ Â°Â®Â´Ã‚Â´Ã™. 
			//iExpRoll = iDice(m_pNpcList[i]->m_iExpDiceMin, m_pNpcList[i]->m_iExpDiceMax);
			//iExpRoll *= 2;
		}

		// !!!
		if (cChangeSide != -1) m_pNpcList[i]->m_cSide = cChangeSide;

		m_pNpcList[i]->m_cBravery = (rand() % 3) + m_pNpcList[i]->m_iMinBravery;
		m_pNpcList[i]->m_iSpotMobIndex		= iSpotMobIndex;
		m_pNpcList[i]->m_iGuildGUID         = iGuildGUID;
		//testcode
		if (iGuildGUID != 0) {
			wsprintf(G_cTxt, "Summon War Unit(%d) GUID(%d)", m_pNpcList[i]->m_sType, iGuildGUID);
			PutLogList(G_cTxt);
		}
		
		m_pMapList[iMapIndex]->SetOwner(i, DEF_OWNERTYPE_NPC, sX, sY);
		m_pMapList[iMapIndex]->m_iTotalActiveObject++;
		m_pMapList[iMapIndex]->m_iTotalAliveObject++;

		// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥Â¿Ã« Â°Ã‡ÃƒÃ Â¹Â°Ã€ÃŒÂ¶Ã³Â¸Ã© ÃÃ¶ÃˆÃ–Â°Ã¼ Ã…Ã«ÂºÂ¸Â¿Ã« Â°Ã‡ÃƒÃ Â¹Â° Â¸Â®Â½ÂºÃ†Â®Â¸Â¦ Ã€Ã›Â¼ÂºÃ‡Ã‘Â´Ã™.
		switch (m_pNpcList[i]->m_sType) {
		case 36: // AGT-Aresden/AGT-Elvine
		case 37: // CGT-Aresden/CGT-Elvine
		case 38: // MS-Aresden/MS-Elvine
		case 39: // DT-Aresden/DT-Elvine
		case 42: // ManaStone
			m_pMapList[iMapIndex]->bAddCrusadeStructureInfo(m_pNpcList[i]->m_sType, sX, sY, m_pNpcList[i]->m_cSide);
			break;

		case 64:
			m_pMapList[iMapIndex]->bAddCropsTotalSum();
			break;
		}
		
		// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã‹Â¸Â°Â´Ã™.
		SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
		return TRUE;
	}

	return FALSE;
}

void CGame::NpcProcess()
{
 register int i, iMaxHP;
 DWORD dwTime, dwActionTime;

	dwTime = timeGetTime();

	for (i = 1; i < DEF_MAXNPCS; i++) { 
		
		if (m_pNpcList[i] != NULL) {
			// Â¼Ã“ÂµÂµÂ¸Â¦ ÃÂ¶ÃÂ¤Ã‡Ã‘Â´Ã™. Â°Ã¸Â°ÃÂ½ÃƒÂ¿Â¡Â´Ã‚ Â¸Ã³Â½ÂºÃ…ÃÂµÃ©Ã€Ã‡ Â¼Ã“ÂµÂµÂ°Â¡ Â»Â¡Â¶Ã³ÃÃ¸Â´Ã™.
			if (m_pNpcList[i]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
				switch (iDice(1,7)) {
				case 1: dwActionTime = m_pNpcList[i]->m_dwActionTime; break;
				case 2: dwActionTime = m_pNpcList[i]->m_dwActionTime - 100; break;
				case 3: dwActionTime = m_pNpcList[i]->m_dwActionTime - 200; break;
				case 4: dwActionTime = m_pNpcList[i]->m_dwActionTime - 300; break;
				case 5: dwActionTime = m_pNpcList[i]->m_dwActionTime - 400; break;
				case 6: dwActionTime = m_pNpcList[i]->m_dwActionTime - 600; break;
				case 7: dwActionTime = m_pNpcList[i]->m_dwActionTime - 700; break;
				}
				if (dwActionTime < 600) dwActionTime = 600;
			}
			else dwActionTime = m_pNpcList[i]->m_dwActionTime; 		

			// v1.42 Â³ÃƒÂµÂ¿ Â»Ã³Ã…Ã‚Â¶Ã³Â¸Ã© Â¿Ã²ÃÃ·Ã€Ã“Ã€ÃŒ 50% Â´Ã€Â·ÃÃÃ¸Â´Ã™.
			if (m_pNpcList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] != 0) 
				dwActionTime += (dwActionTime/2);
		}
		
		if ((m_pNpcList[i] != NULL) && ((dwTime - m_pNpcList[i]->m_dwTime) > dwActionTime)) {
			// Â½ÃƒÂ°Â£ Ã€ÃºÃ€Ã¥.
			m_pNpcList[i]->m_dwTime = dwTime;
			
			if (abs(m_pNpcList[i]->m_cMagicLevel) > 0) {
				// Â¸Â¶Â³ÂªÂ¸Â¦ Â¿ÃƒÂ¸Â± Â½ÃƒÂ°Â£Ã€ÃŒ ÂµÃ‡Â¾ÃºÃ€Â¸Â¸Ã© Â¿ÃƒÂ¸Â°Â´Ã™. 
				if ((dwTime - m_pNpcList[i]->m_dwMPupTime) > DEF_MPUPTIME) {
					m_pNpcList[i]->m_dwMPupTime = dwTime;	
					
					//if (m_pNpcList[i]->m_bIsSummoned == FALSE) // Â¼Ã’ÃˆÂ¯ÂµÃˆ Â¸Ã³Â½ÂºÃ…ÃÂ´Ã‚ MPÂ°Â¡ Â¿ÃƒÂ¶Ã³Â°Â¡ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 
					m_pNpcList[i]->m_iMana += iDice(1, (m_pNpcList[i]->m_iMaxMana/5));
					
					if (m_pNpcList[i]->m_iMana > m_pNpcList[i]->m_iMaxMana)
						m_pNpcList[i]->m_iMana = m_pNpcList[i]->m_iMaxMana;
				}
			}
			
			// HPÂ¸Â¦ Â¿ÃƒÂ¸Â± Â½ÃƒÂ°Â£Ã€ÃŒ ÂµÃ‡Â¾ÃºÃ€Â¸Â¸Ã© Â¿ÃƒÂ¸Â°Â´Ã™. 
			if (((dwTime - m_pNpcList[i]->m_dwHPupTime) > DEF_HPUPTIME) && (m_pNpcList[i]->m_bIsKilled == FALSE)) {
				// Â½ÃƒÂ°Â£ Ã€Ã§ Â°Â»Â½Ã… 
				m_pNpcList[i]->m_dwHPupTime = dwTime;	
				
				iMaxHP = iDice(m_pNpcList[i]->m_iHitDice, 8) + m_pNpcList[i]->m_iHitDice;
				if (m_pNpcList[i]->m_iHP < iMaxHP) {
					
					if (m_pNpcList[i]->m_bIsSummoned == FALSE) // Â¼Ã’ÃˆÂ¯ÂµÃˆ Â¸Ã³Â½ÂºÃ…ÃÂ´Ã‚ HPÂ°Â¡ Â¿ÃƒÂ¶Ã³Â°Â¡ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 
						m_pNpcList[i]->m_iHP += iDice(1, m_pNpcList[i]->m_iHitDice); // Hit PointÂ´Ã‚ 17ÃƒÃŠÂ¸Â¶Â´Ã™ 1D3Â¾Â¿ Â¿ÃƒÂ¶Ã³Â°Â£Â´Ã™.
					
					if (m_pNpcList[i]->m_iHP > iMaxHP) m_pNpcList[i]->m_iHP = iMaxHP;
					if (m_pNpcList[i]->m_iHP <= 0)     m_pNpcList[i]->m_iHP = 1;
				}
			}
			
			switch (m_pNpcList[i]->m_cBehavior) {
			case DEF_BEHAVIOR_DEAD:
				NpcBehavior_Dead(i);
				break;
			case DEF_BEHAVIOR_STOP:
				NpcBehavior_Stop(i);
				break;
			case DEF_BEHAVIOR_MOVE:
				NpcBehavior_Move(i);
				break;
			case DEF_BEHAVIOR_ATTACK:
				NpcBehavior_Attack(i);
				break;
			case DEF_BEHAVIOR_FLEE:
				NpcBehavior_Flee(i);
				break;
			}

			// !!! m_pNpcListÂ´Ã‚ NULLÃ€Ã Â¼Ã¶ Ã€Ã–Â´Ã™. 
			if ((m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_iHP != 0) && (m_pNpcList[i]->m_bIsSummoned == TRUE)) {
				// Â¸Ã³Â½ÂºÃ…ÃÃ€Ã‡ ÃÂ¾Â·Ã¹Â¿Â¡ ÂµÃ»Â¶Ã³ Â¼Ã’ÃˆÂ¯ Â½ÃƒÂ°Â£Ã€ÃŒ Â´ÃÂ¶Ã³ÃÃ¸Â´Ã™. 
				switch (m_pNpcList[i]->m_sType) {
				case 29: // Â¿Ã€Â¿Ã¬Â°Ã…: 1ÂºÃ 30ÃƒÃŠ  
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000*90) 
						NpcKilledHandler(NULL, NULL, i, 0);
					break;
				
				default: // Ã€ÃÂ¹ÃÃ€Ã»Ã€Ã Â°Ã¦Â¿Ã¬: Â¼Ã’ÃˆÂ¯Â¸Ã·Ã€ÃŒ Â½ÃƒÂ°Â£Ã€ÃŒ Â´Ã™ ÂµÃ‡Â¾Ã® Â»Ã§Â¶Ã³ÃÂ®Â¾ÃŸ Ã‡Ã‘Â´Ã™.
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > DEF_SUMMONTIME) 
						NpcKilledHandler(NULL, NULL, i, 0);
					break;
				}
			}
		}
	}
}

// 05/29/2004 - Hypnotoad - GM chat tweak
void CGame::ChatMsgHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 register int i, iRet;
 WORD * wp;
 int  * ip;
 char * cp, * cp2;
 char   cBuffer[256], cTemp[256], cSendMode = NULL;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (dwMsgSize > 83 +30) return;
 
	// v1.41 ShutUp TimeÃ€ÃŒ Â°Ã‰Â·Ã Ã€Ã–Ã€Â¸Â¸Ã© Â¿ÃÃ€Ã¼ÃˆÃ· Â¸Â»Ã€Â» Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. Â°Â­Â·Ã‚ ÃÂ¦Ã€Ã§ 
	if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) return;
	
	// ÂºÂ»Ã€ÃÃ€Ã‡ Ã€ÃŒÂ¸Â§Ã€ÃŒ Â±Ã¢Ã€Ã”ÂµÃ‡Â¾Ã® Ã€Ã–ÃÃ¶ Â¾ÃŠÂ´Ã™Â¸Ã© Â¸Â®Ã…Ã
	if (memcmp((pData + 10), m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) != 0) return;
 
	// Â°Ã¼Â¶Ã·Ã€ÃšÂ¶Ã³Â¸Ã© ÃƒÂ¤Ã†ÃƒÃ€Â» Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
	if ((m_pClientList[iClientH]->m_bIsObserverMode == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;
 
	// v1.432-2 Â¸ÃŠ Â¼Â½Ã…Ã ÃÂ¤ÂºÂ¸Â¸Â¦ Â°Â»Â½Ã…Ã‡Ã‘Â´Ã™. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
	 
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	// ÃƒÂ¤Ã†Ãƒ Â¸ÃÂ½ÃƒÃÃ¶Ã€Ã‡ Â½ÃƒÃ€Ã› Ã€Â§Ã„Â¡. ()
	cp = (char *)(pData + 21);

	switch (m_bLogChatOption) {
		// Chat Logs of only players
		case 1:
			if (m_pClientList[iClientH]->m_iAdminUserLevel == 0){
			ZeroMemory(cTemp,sizeof(cTemp));
			pData[dwMsgSize-1] = 0;
			wsprintf(cTemp,"Loc(%s) IP(%s) PC(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
		}
		break;
		// Chat Logs of only GM
		case 2:
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 0){
			ZeroMemory(cTemp,sizeof(cTemp));
			pData[dwMsgSize-1] = 0;
			wsprintf(cTemp,"Loc(%s) IP(%s) GM(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
		}
		break;
		// Chat logs of all
		case 3:
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0){
			ZeroMemory(cTemp,sizeof(cTemp));
			pData[dwMsgSize-1] = 0;
			wsprintf(cTemp,"Loc(%s) IP(%s) GM(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
		}
		else{
			ZeroMemory(cTemp,sizeof(cTemp));
			pData[dwMsgSize-1] = 0;
			wsprintf(cTemp,"Loc(%s) IP(%s) PC(%s):\"%s\"",m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_cIPaddress,m_pClientList[iClientH]->m_cCharName,cp);
			bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
		}	
		break;
		// Chat logs of none
		case 4:
			
		break;
	}

	/*	// New 08/05/2004
	// Log GM Chats
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0){
		ZeroMemory(cTemp,sizeof(cTemp));
		pData[dwMsgSize-1] = 0;
		wsprintf(cTemp,"GM Chat(%s):\"%s\"",m_pClientList[iClientH]->m_cCharName,cp);
		bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
	}*/

	// Â¸ÃÂ½ÃƒÃÃ¶Â¿Â¡ Â¸Ã­Â·Ã‰Â¾Ã®Â°Â¡ Â¼Â¯Â¿Â© Ã€Ã–Â´Ã‚ÃÃ¶ Â°Ã‹Â»Ã§Ã‡Ã‘Â´Ã™. 
	switch (*cp) {
	case '@':
		// Â°Â°Ã€Âº Â±Ã¦ÂµÃ¥Â¿Â¡Â°Ã” ÂºÂ¸Â³Â»Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ 
		*cp = 32;
		
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank == 0)) {
			// Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Â¿Â¡ Â±Ã¦ÂµÃ¥ Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã› 
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 1; // Â±Ã¦ÂµÃ¥ Â¸ÃÂ½ÃƒÃÃ¶
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}
				
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) && 
			 (m_pClientList[iClientH]->m_iSP >= 3) ) {
			// Â½ÂºÃ…Ã—Â¹ÃŒÂ³ÃŠÂ°Â¡ ÃƒÃ¦ÂºÃÃ‡ÃÂ¸Ã© Ã€Ã¼ÃƒÂ¼ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™. 
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 1;
		}
		else cSendMode = NULL;
		
		// Ã€Ã¼ÃƒÂ¼ ÃƒÂ¤Ã†Ãƒ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â°Ã¦Â¿Ã¬Â¶Ã³Â¸Ã© 
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		break;

	// New 08/05/2004
	// Party chat
	case '$':
		*cp = 32;

		if ((m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iSP >= 3)){
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL,iClientH,DEF_NOTIFY_SP,NULL,NULL,NULL,NULL);
			}
			cSendMode = 4;
		}
		else{
			cSendMode = NULL;
		}

		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0){
			cSendMode = NULL;
		}
		break;

	case '^':
		// Ã€Ã¼ÃƒÂ¼ Â»Ã§Â¿Ã«Ã€ÃšÂ¿Â¡Â°Ã” Ã€Ã¼Â´ÃÂµÃ‡Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Ã€ÃŒÂ´Ã™.
		// Â¸Â¸Â¾Ã  Â°Ã¼Â¸Â®Â±Ã‡Ã‡Ã‘Ã€ÃŒ Ã€Ã–Â°Ã…Â³Âª Â±Ã¦ÂµÃ¥Â¸Â¶Â½ÂºÃ…ÃÃ€ÃÂ°Ã¦Â¿Ã¬ Ã€Ã¼ÃƒÂ¼Â¼Â­Â¹Ã¶Â¿Â¡ ÂºÂ¸Â³Â»Â´Ã‚ Â¸ÃÂ¼Â¼ÃÃ¶ 
		*cp = 32;

		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) {
			// Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Â¿Â¡ Â±Ã¦ÂµÃ¥ Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã› 
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 10; // Â°Ã¸ÃÃ¶ Â¸ÃÂ½ÃƒÃÃ¶
			cp2++;
			ip = (int *)cp2;
			*ip = NULL;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}

		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
			// Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Â¿Â¡ Â±Ã¦ÂµÃ¥ Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã› 
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 1;
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}

		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) && 
			(m_pClientList[iClientH]->m_iSP > 5) && m_pClientList[iClientH]->m_iGuildRank != -1) {
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP -= 3;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
				}
				cSendMode = 1;
			}
		else cSendMode = NULL;

		// Ã€Ã¼ÃƒÂ¼ ÃƒÂ¤Ã†Ãƒ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â°Ã¦Â¿Ã¬Â¶Ã³Â¸Ã© 
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		
		// v1.4334 Ã€Ã¼ÃƒÂ¼ Â¿ÃœÃ„Â¡Â±Ã¢ Â¸Â·Â±Ã¢
		if (m_pClientList[iClientH]->m_iHP < 0) cSendMode = NULL;

		// Â¸Â¸Â¾Ã  Â°Ã¼Â¸Â®Â±Ã‡Ã‡Ã‘Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© 
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		break;

	case '!':
		// Ã€Ã¼ÃƒÂ¼ Â»Ã§Â¿Ã«Ã€ÃšÂ¿Â¡Â°Ã” Ã€Ã¼Â´ÃÂµÃ‡Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Ã€ÃŒÂ´Ã™.
		// Â°Â°Ã€Âº Â±Ã¦ÂµÃ¥Â¿Â¡Â°Ã” ÂºÂ¸Â³Â»Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ 
		*cp = 32;
		
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) {
			// Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Â¿Â¡ Â±Ã¦ÂµÃ¥ Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã› 
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 10; // Â°Ã¸ÃÃ¶ Â¸ÃÂ½ÃƒÃÃ¶
			cp2++;
			ip = (int *)cp2;
			*ip = NULL;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}

		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) && 
			 (m_pClientList[iClientH]->m_iSP >= 5) ) {
			// Â½ÂºÃ…Ã—Â¹ÃŒÂ³ÃŠÂ°Â¡ ÃƒÃ¦ÂºÃÃ‡ÃÂ¸Ã© Ã€Ã¼ÃƒÂ¼ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™. 
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 5;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 2;	// Â¸ÃÂ½ÃƒÃÃ¶ ÃƒÂ¢Â¿Â¡ Â¶Ã§Â¿Ã®Â´Ã™.
		}
		else cSendMode = NULL;
		
		// Ã€Ã¼ÃƒÂ¼ ÃƒÂ¤Ã†Ãƒ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â°Ã¦Â¿Ã¬Â¶Ã³Â¸Ã© 
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		
		// v1.4334 Ã€Ã¼ÃƒÂ¼ Â¿ÃœÃ„Â¡Â±Ã¢ Â¸Â·Â±Ã¢
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;

		// Â¸Â¸Â¾Ã  Â°Ã¼Â¸Â®Â±Ã‡Ã‡Ã‘Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© 
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		break;

	case '~':
		// Â°Â°Ã€Âº Ã†Ã­Â¿Â¡Â°Ã” ÂºÂ¸Â³Â»Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶
		*cp = 32;
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) && 
			 (m_pClientList[iClientH]->m_iSP >= 3) ) {
			// Â½ÂºÃ…Ã—Â¹ÃŒÂ³ÃŠÂ°Â¡ ÃƒÃ¦ÂºÃÃ‡ÃÂ¸Ã© Ã€Ã¼ÃƒÂ¼ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™. 
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 3;
		}
		else cSendMode = NULL;
		
		// Ã€Ã¼ÃƒÂ¼ ÃƒÂ¤Ã†Ãƒ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â°Ã¦Â¿Ã¬Â¶Ã³Â¸Ã© 
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		// v1.4334 Ã€Ã¼ÃƒÂ¼ Â¿ÃœÃ„Â¡Â±Ã¢ Â¸Â·Â±Ã¢
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;
		break;

	case '/':
		// Â¸Ã­Â·Ã‰Â¾Ã®Ã€ÃŒÂ´Ã™. 
		ZeroMemory(cBuffer, sizeof(cBuffer));
		memcpy(cBuffer, cp, dwMsgSize - 21);
		cp = (char *)(cBuffer);
		
		// New 19/05/2004
		if (memcmp(cp, "/version", 8) == 0) {
			ShowVersion(iClientH);
			return;
		}

		// New 10/05/2004
		if (memcmp(cp, "/begincrusadetotalwar", 21) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) {
				GlobalStartCrusadeMode();
				wsprintf(cTemp, "(%s) GM Order(%s): begincrusadetotalwar", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			}
			return;
		}
		
		if (memcmp(cp, "/endcrusadetotalwar", 19) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) {
				ManualEndCrusadeMode(0);
				wsprintf(cTemp, "(%s) GM Order(%s): endcrusadetotalwar", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			}
			return;
		}

		// New 08/05/2004
		if (memcmp(cp, "/goto ", 6) == 0) {
			AdminOrder_GoTo(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/unsummonboss", 13) == 0) {
			AdminOrder_UnsummonBoss(iClientH);
			return;
		}

		if (memcmp(cp, "/clearnpc", 9) == 0) {
			AdminOrder_ClearNpc(iClientH);
			return;
		}

		if (memcmp(cp, "/clearmap", 9) == 0) {
			AdminOrder_CleanMap(iClientH, cp, dwMsgSize);
			return;
		}

		if (memcmp(cp, "/setforcerecalltime ", 20) == 0) {
			AdminOrder_SetForceRecallTime(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/enableadmincommand ", 20) == 0) {
			AdminOrder_EnableAdminCommand(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/monstercount", 13) == 0) {
			AdminOrder_MonsterCount(iClientH,cp,dwMsgSize - 21);
			return;
		}

		// New 07/05/2004
		if (memcmp(cp, "/createparty", 12) == 0) {
			RequestCreatePartyHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/joinparty ", 11) == 0) {
			RequestJoinPartyHandler(iClientH,cp,dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/dismissparty", 13) == 0) {
			RequestDismissPartyHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/blueball", 9) == 0) {
			Command_BlueBall(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/redball", 8) == 0) {
			Command_RedBall(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/yellowball ", 12) == 0) {
			Command_YellowBall(iClientH, cp, dwMsgSize - 21);
			return;
		}
		
		if (memcmp(cp, "/getpartyinfo", 13) == 0) {
			GetPartyInfoHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/deleteparty", 12) == 0) {
			RequestDeletePartyHandler(iClientH);
			return;
		}

		if (memcmp(cp, "/who", 4) == 0) {
			// New 08/05/2003
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelWho) {
				// Ã€Ã¼ÃƒÂ¼ Â»Ã§Â¿Ã«Ã€Ãš Â¼Ã¶Â¸Â¦ Â¹Â¯Â´Ã‚ Â°ÃÃ€ÃŒÂ´Ã™.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TOTALUSERS, NULL, NULL, NULL, NULL);
			}
			return;
		}

		if (memcmp(cp, "/fi ", 4) == 0) {
			// Ã†Â¯ÃÂ¤ Â»Ã§Â¿Ã«Ã€ÃšÂ°Â¡ ÃÂ¢Â¼Ã“ÃÃŸÃ€ÃÃÃ¶Â¸Â¦ Â¹Â¯Â´Ã‚ Â°ÃÃ€ÃŒÂ´Ã™. 
			CheckAndNotifyPlayerConnection(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/to", 3) == 0) {
			// Â±Ã“Â¼Ã“Â¸Â»Ã€Â» Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™.
			ToggleWhisperPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setpf ", 7) == 0) {
			// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® Ã‡ÃÂ·ÃÃ‡ÃŠÃ€Â» Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™. 
			SetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;
		}

		//ArchAngel Addition
		if (memcmp(cp, "/weather", 8) == 0) { 
			AdminOrder_Weather(iClientH, cp, dwMsgSize - 21); 
			return; 
		}

		if (memcmp(cp, "/pf ", 4) == 0) {
			// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Ã‡ÃÂ·ÃÃ‡ÃŠÃ€Â» ÂºÂ¸Â°Ã­Ã€Ãš Ã‡Ã‘Â´Ã™. 
			GetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/shutup ", 8) == 0) {
			// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Ã€Ã¼ÃƒÂ¼ ÃƒÂ¤Ã†ÃƒÂ±Ã¢Â´Ã‰Ã€Â» Â¸Â·Â´Ã‚Â´Ã™. 
			ShutUpPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/rep+ ", 6) == 0) {
			// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ ÃÃÃ€Âº Ã†Ã²Â°Â¡Â¸Â¦ Â³Â»Â¸Â°Â´Ã™. 
			SetPlayerReputation(iClientH, cp, 1, dwMsgSize - 21);
			return;
		}

		
		if (memcmp(cp,"/time ", 6) == 0) {
			AdminOrder_Time(iClientH, cp, dwMsgSize - 21);
				return;
		}

		if (memcmp(cp, "/checkrep", 9) == 0) {
			AdminOrder_CheckRep(iClientH,cp, dwMsgSize - 21);
			return;
		}		

		if (memcmp(cp, "/checkstatus ", 13) == 0) {
			AdminOrder_CheckStats(iClientH,cp, dwMsgSize - 21);
			return;
		}

        if (memcmp(cp, "/send ", 5) == 0) {
			AdminOrder_Pushplayer(iClientH, cp, dwMsgSize -21);
			return;
		}

		if (memcmp(cp, "/rep- ", 6) == 0) {
			// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Â³ÂªÂ»Ã› Ã†Ã²Â°Â¡Â¸Â¦ Â³Â»Â¸Â°Â´Ã™. 
			SetPlayerReputation(iClientH, cp, 0, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/hold", 5) == 0) {
			SetSummonMobAction(iClientH, 1, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/tgt ", 5) == 0) {
			SetSummonMobAction(iClientH, 2, dwMsgSize - 21, cp);
			return;
		}

		if (memcmp(cp, "/free", 5) == 0) {
			SetSummonMobAction(iClientH, 0, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summonall ", 11) == 0) {
			AdminOrder_SummonAll(iClientH, cp, dwMsgSize - 21);
			return;
		}

/*		if (memcmp(cp, "/summonguild ", 13) == 0) {
			AdminOrder_SummonGuild(iClientH, cp, dwMsgSize - 21);
			return;
		}*/

		if (memcmp(cp, "/summonplayer ", 14) == 0) {
			AdminOrder_SummonPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/storm ", 7) == 0) {
			AdminOrder_SummonStorm(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summondeath ", 13) == 0) {
			AdminOrder_SummonDeath(iClientH);
			return;
		}

		if (memcmp(cp, "/kill ", 6) == 0) {
			AdminOrder_Kill(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/revive ", 8) == 0) {
			AdminOrder_Revive(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/closeconn ", 11) == 0) {
			// Â°Ã¦ÂºÃ±Â¸Â¦ Â¼Ã’ÃˆÂ¯Ã‡ÃÂ¿Â© Â°Ã¸Â°ÃÃ‡Ã‘Â´Ã™. 
			AdminOrder_CloseConn(iClientH, cp, dwMsgSize - 21);
			return;
		}

		// v1.4311-3 ÂºÂ¯Â°Ã¦ expire -> ban
		if (memcmp(cp, "/ban", 4) == 0) {
			UserCommand_BanGuildsman(iClientH, cp, dwMsgSize - 21);
			return;
		}

		// v1.4311-3 ÃƒÃŸÂ°Â¡ reservefightzone Â¿Ã®Â¿ÂµÃ€ÃšÂ°Â¡ Â»Ã§Ã…ÃµÃ€Ã¥Ã€Â» Â¿Â¹Â¾Ã Ã‡Ã˜ Â³ÃµÂ´Ã‚Â´Ã™.
		if (memcmp(cp, "/reservefightzone", 17) == 0) {
			AdminOrder_ReserveFightzone(iClientH, cp, dwMsgSize - 21);
			return;
		}
		
		if (memcmp(cp, "/dissmiss ", 9) == 0) {
			UserCommand_DissmissGuild(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/attack ", 8) == 0) {
			// Â°Ã¦ÂºÃ±Â¸Â¦ Â¼Ã’ÃˆÂ¯Ã‡ÃÂ¿Â© Â°Ã¸Â°ÃÃ‡Ã‘Â´Ã™. 
			AdminOrder_CallGuard(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/createfish ", 12) == 0) {
			AdminOrder_CreateFish(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/teleport ", 10) == 0 || memcmp(cp, "/tp ", 4) == 0) {
			AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summondemon ", 13) == 0) {
			AdminOrder_SummonDemon(iClientH);
			return;
		}

		if (memcmp(cp, "/unsummonall ", 13) == 0) {
			AdminOrder_UnsummonAll(iClientH);
			return;			
		}

		if (memcmp(cp, "/unsummondemon ", 15) == 0) {
			AdminOrder_UnsummonDemon(iClientH);
			return;			
		}

		if (memcmp(cp, "/checkip ", 9) == 0) {
			AdminOrder_CheckIP(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/polymorph ", 11) == 0) {
			AdminOrder_Polymorph(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setinvi ", 9) == 0) {
			AdminOrder_SetInvi(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/gns ", 4) == 0) {
			AdminOrder_GetNpcStatus(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/setattackmode ", 15) == 0) {
			AdminOrder_SetAttackMode(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/summon ", 8) == 0) {
			AdminOrder_Summon(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setzerk ", 9) == 0) {
			AdminOrder_SetZerk(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/setfreeze ", 11) == 0) {
			AdminOrder_SetFreeze(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/setstatus ", 11) == 0) {
			AdminOrder_SetStatus(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/disconnectall ", 15) == 0) {
			AdminOrder_DisconnectAll(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/createitem ", 12) == 0) {
			AdminOrder_CreateItem(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/energysphere ", 14) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelEnergySphere) EnergySphereProcessor(TRUE, iClientH);
			return;
		}

		if ((memcmp(cp, "/shutdownthisserverrightnow ", 28) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelShutdown)) {
			// Ã„Â¿Â¸Ã‡ÂµÃ¥Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Â¼Â­Â¹Ã¶ Â¼Ã‹Â´Ã™Â¿Ã® Â¸Ã­Â·Ã‰ ÂºÃ±Â»Ã³Â»Ã§Ã…Ã‚Â¿Â¡ Â´Ã«ÂºÃ±Ã‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã”Ã€ÃŒÂ´Ã™.
			m_cShutDownCode      = 2;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// Â°Ã”Ã€Ã“ Â¼Â­Â¹Ã¶ Â¼Ã‹Â´Ã™Â¿Ã®Ã€ÃŒ Â½ÃƒÃ€Ã›ÂµÃ‡Â¸Ã© Â´ÃµÃ€ÃŒÂ»Ã³Ã€Ã‡ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® ÃÂ¢Â¼Ã“Ã€ÃŒ Â°Ã…ÂºÃÂµÃˆÂ´Ã™. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Admin-Command)!!!");
			// Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â¿Â¡Â°Ã” Ã‡Ã¶Ã€Ã§ Â¼Â­Â¹Ã¶Â°Â¡ Â¼Ã‹Â´Ã™Â¿Ã® ÃÃŸÃ€Ã“Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
			bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
			// OccupyFlag ÂµÂ¥Ã€ÃŒÃ…Ã Ã€ÃºÃ€Ã¥ 
			if (m_iMiddlelandMapIndex > 0) {
				// Crusade
				SaveOccupyFlagData();
				//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
				//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
			}
			return;
		}

		if ((memcmp(cp, "/setobservermode ", 17) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= m_iAdminLevelObserver)) {
			// Â°Ã¼Â¶Ã·Ã€Ãš Â¸Ã°ÂµÃ¥Â·Ã Ã€Ã¼ÃˆÂ¯
			AdminOrder_SetObserverMode(iClientH);
			return;
		}
		
		if ((memcmp(cp, "/getticket ", 11) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= 2)) {
			AdminOrder_GetFightzoneTicket(iClientH);
			return;
		}

		/*if (memcmp(cp, "/beginapocalypse ", 17) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 2) {
				GlobalStartApocalypseMode(iClientH, cp, dwMsgSize - 21);
			}
			return;
		}

		if (memcmp(cp, "/endapocalypse", 14) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) {
				GlobalEndApocalypseMode();
				wsprintf(cTemp, "(%s) GM Order(%s): endapocalypse", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
			}
			return;
		}*/
		
		if (memcmp(cp, "/beginheldenian ", 16) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 2) {
				ManualStartHeldenianMode(iClientH, cp, dwMsgSize - 21);
			}
			return;
		}
		
		if (memcmp(cp, "/endheldenian ", 14) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel > 2) {
				ManualEndHeldenianMode(iClientH, cp, dwMsgSize - 21);
			}
			return;
		}

		return;
	}

	// Â¸Ã•Ã€Ãº Â½ÂºÃ†Â®Â¸ÂµÃ€Ã‡ Â³Â¡Â¿Â¡ NULL Â´Ã™Â½Ãƒ ÃÃ½Â¾Ã® Â³Ã–Â¾Ã® ÃˆÂ®Ã€ÃÃ‡Ã‘Â´Ã™.
	pData[dwMsgSize-1] = NULL;
		
	if ((m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] == 1) && (iDice(1,3) != 2)) {
		// Confuse LanguageÂ¿Â¡ Â°Ã‰Â¸Â° Â»Ã³Ã…Ã‚. Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Â¿Ã–Â°Ã®Â½ÃƒÃ…Â²Â´Ã™. 
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);
		
		while (*cp != NULL) {
			if ((cp[0] != NULL) && (cp[0] != ' ') && (cp[1] != NULL) && (cp[1] != ' ')) {
				switch (iDice(1,3)) {
				case 1:	memcpy(cp, "Â¿Ã¶", 2); break;
				case 2:	memcpy(cp, "Â¿Ã¬", 2); break;
				case 3:	memcpy(cp, "Â¿Ã¹", 2); break;
				}
				cp += 2;
			}
			else cp++; 
		}
	}
		
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);
	
	if ((cSendMode == NULL) && (m_pClientList[iClientH]->m_iWhisperPlayerIndex != -1)) {
		// Ã€ÃÂ¹Ã Â¸ÃÂ½ÃƒÃÃ¶Ã€ÃŒÂ°Ã­ Â±Ã“Â¼Ã“Â¸Â» Â¸Ã°ÂµÃ¥Â¶Ã³Â¸Ã© ÂºÂ»Ã€ÃÂ°Ãº Â»Ã³Â´Ã«Â¹Ã¦Â¿Â¡Â°Ã”Â¸Â¸ Ã€Ã¼Â¼Ã›Ã‡Ã‘Â´Ã™.
		cSendMode = 20;
		
		// Â±Ã“Â¼Ã“Â¸Â» Ã…Â»Ã„Ã° Ã„ÃšÂµÃ¥Â°Â¡ Ã€Ã–Â´Ã™Â¸Ã© Ã€ÃÂ¹Ã Â´Ã«ÃˆÂ­Â°Â¡ ÂµÃˆÂ´Ã™.
		if (*cp == '#') cSendMode = NULL;

		// Ã€Ã¼ÃƒÂ¼ ÃƒÂ¤Ã†Ãƒ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â°Ã¦Â¿Ã¬Â¶Ã³Â¸Ã© Â±Ã“Â¼Ã“Â¸Â» Â¶Ã‡Ã‡Ã‘ Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
	}

	// ÃƒÂ¤Ã†Ãƒ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Â±Ã—Â´Ã«Â·Ã Ã€ÃÃÂ¢Ã‡Ã‘ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®ÂµÃ©Â¿Â¡Â°Ã” Â¹ÃŸÂ¼Ã›Ã‡Ã‘Â´Ã™.
	// Â´Ãœ, MSGTYPEÃ€Â§Ã„Â¡Â¿Â¡ Â¿Ã€ÂºÃªÃÂ§Ã†Â® Â¾Ã†Ã€ÃŒÂµÃ°Â¸Â¦ Ã€Ã”Â·Ã‚Ã‡Ã‘Â´Ã™. 
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	*wp = (WORD)iClientH;
	// Â±Ã—Â¸Â®Â°Ã­ Â¸ÃÂ½ÃƒÃÃ¶ Ã…Â¸Ã€Ã”Ã€Â» Ã€Ã”Â·Ã‚Ã‡Ã‘Â´Ã™.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 16);
	*cp = cSendMode;

	if (cSendMode != 20) {
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			switch (cSendMode) {
			case NULL:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				
				if ( (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) &&
					 (m_pClientList[i]->m_sX > m_pClientList[iClientH]->m_sX - 10) &&
					 (m_pClientList[i]->m_sX < m_pClientList[iClientH]->m_sX + 10) &&
					 (m_pClientList[i]->m_sY > m_pClientList[iClientH]->m_sY - 7) &&
					 (m_pClientList[i]->m_sY < m_pClientList[iClientH]->m_sY + 7) ) {
					
					// Crusade
					if (m_bIsCrusadeMode == TRUE) {
						if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
							 (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
							// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â¸Ã°ÂµÃ¥Â¿Â¡Â¼Â­Â´Ã‚ Â¼Â­Â·Ã Ã†Ã­Ã€ÃŒ Â´Ã™Â¸Â£Â¸Ã© Â¸Â»Ã€Â» Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;
					
			case 1:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;

				if ( (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) &&
					 (memcmp(m_pClientList[i]->m_cGuildName, "NONE", 4) != 0) ) {
					
					// Crusade
					if (m_bIsCrusadeMode == TRUE) {
						if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
							 (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
							// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â¸Ã°ÂµÃ¥Â¿Â¡Â¼Â­Â´Ã‚ Â¼Â­Â·Ã Ã†Ã­Ã€ÃŒ Â´Ã™Â¸Â£Â¸Ã© Â¸Â»Ã€Â» Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;
					
			case 2:
			case 10:
				// Crusade
				if (m_bIsCrusadeMode == TRUE) {
					if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
						 (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
						// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â¸Ã°ÂµÃ¥Â¿Â¡Â¼Â­Â´Ã‚ Â¼Â­Â·Ã Ã†Ã­Ã€ÃŒ Â´Ã™Â¸Â£Â¸Ã© Â¸Â»Ã€Â» Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
					
			case 3:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;

				if ( (m_pClientList[i]->m_cSide == m_pClientList[iClientH]->m_cSide) ) 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;

			case 4:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				if ( (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == m_pClientList[iClientH]->m_iPartyID) ) 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
			}
				
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
				// ÃÂ¦Â°Ã…Ã‡ÃÃÃ¶ Â¾ÃŠÂ°Ã­ Â³Ã€ÂµÃÂ´Ã™. Time OutÃ€Â¸Â·Ã ÃÂ¦Â°Ã…ÂµÃ‡Â´Ã‚ Â°ÃÃ€Â» Ã€Â¯ÂµÂµ. 
				//DeleteClient(i, TRUE, TRUE);
				break;
			}
		}
	}
	else {
		// New 16/05/2004
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pData, dwMsgSize);	
		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == 10000) {
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp = (char *)cBuffer;
			*cp = GSM_WHISFERMSG;
			cp++;
			memcpy(cp, m_pClientList[iClientH]->m_cWhisperPlayerName, 10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = (WORD)dwMsgSize;
			cp += 2;
			memcpy(cp, pData, dwMsgSize);
			cp += dwMsgSize;
			bStockMsgToGateServer(cBuffer, dwMsgSize+13);

			//testcode
			//wsprintf(G_cTxt, "Sending Whisper Msg: %s %d", m_pClientList[iClientH]->m_cWhisperPlayerName, (13 +dwMsgSize));
			//PutLogList(G_cTxt);
		}
		else{
			if (m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ] != NULL &&
				strcmp(m_pClientList[iClientH]->m_cWhisperPlayerName, m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ]->m_cCharName) == 0){
					iRet = m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_pXSock->iSendMsg(pData, dwMsgSize);	
					switch (m_bLogChatOption){

						case 1:
							if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel == 0){
								ZeroMemory(cTemp,sizeof(cTemp));
								wsprintf(cTemp,"GM Whisper   (%s):\"%s\"\tto Player(%s)",m_pClientList[iClientH]->m_cCharName, pData+21, m_pClientList[iClientH]->m_cWhisperPlayerName);
								bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
						}
						break;

						case 2:
							if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0){
								ZeroMemory(cTemp,sizeof(cTemp));
								wsprintf(cTemp,"GM Whisper   (%s):\"%s\"\tto GM(%s)",m_pClientList[iClientH]->m_cCharName, pData+21, m_pClientList[iClientH]->m_cWhisperPlayerName);
								bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
						}
						break;

						case 3:
							if (m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_iAdminUserLevel > 0){
								ZeroMemory(cTemp,sizeof(cTemp));
								wsprintf(cTemp,"GM Whisper   (%s):\"%s\"\tto GM(%s)",m_pClientList[iClientH]->m_cCharName, pData+21, m_pClientList[iClientH]->m_cWhisperPlayerName);
								bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
						}
						else{
								ZeroMemory(cTemp,sizeof(cTemp));
								wsprintf(cTemp,"Player Whisper   (%s):\"%s\"\tto Player(%s)",m_pClientList[iClientH]->m_cCharName, pData+21, m_pClientList[iClientH]->m_cWhisperPlayerName);
								bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH, FALSE,cTemp);
						}
						break;

						case 4:
							break;
						}
				}
		}

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
			// ÃÂ¦Â°Ã…Ã‡ÃÃÃ¶ Â¾ÃŠÂ°Ã­ Â³Ã€ÂµÃÂ´Ã™. Time OutÃ€Â¸Â·Ã ÃÂ¦Â°Ã…ÂµÃ‡Â´Ã‚ Â°ÃÃ€Â» Ã€Â¯ÂµÂµ. 
			//DeleteClient(i, TRUE, TRUE);
			break;
		}
	}
}


void CGame::ChatMsgHandlerGSM(int iMsgType, int iV1, char * pName, char * pData, DWORD dwMsgSize)
{
 register int i, iRet;
 DWORD * dwp;
 WORD * wp;
 short * sp;
 char * cp, cTemp[256], cSendMode = NULL;

	ZeroMemory(cTemp, sizeof(cTemp));
	
	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;
	
	wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;
	
	memcpy(cp, pName, 10);
	cp += 10;

	*cp = (char)iMsgType;
	cp++;

	memcpy(cp, pData, dwMsgSize);
	cp += dwMsgSize;

	switch (iMsgType) {
	case 1:	// Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Â¿Â¡Â¼Â­ Â¿Ã‚ Â±Ã¦ÂµÃ¥ Â¸ÃÂ½ÃƒÃÃ¶
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
			if ( (m_pClientList[i]->m_iGuildGUID == iV1) && (m_pClientList[i]->m_iGuildGUID != 0)) {
				// Â°Â°Ã€Âº Â±Ã¦ÂµÃ¥ Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã› 			
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
			}
		}
		break;

	case 2: // Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Â¿Â¡Â¼Â­ Â¿Ã‚ Ã€Ã¼ÃƒÂ¼ Â¸ÃÂ½ÃƒÃÃ¶
	case 10: // Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Â¿Â¡Â¼Â­ Â¿Ã‚ Â°Ã¸ÃÃ¶ Â¸ÃÂ½ÃƒÃÃ¶ 
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
		}
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, BOOL bResponse, BOOL bIsDash)
//  description			:: controls player attack
//	return value		:: int
//  last updated		:: October 29, 2004; 8:06 PM; Hypnotoad
//  commentary			:: - contains attack hack detection
//						   - added checks for Firebow and Directionbow to see if player is m_bIsInsideWarehouse, m_bIsInsideWizardTower, m_bIsInsideOwnTown 
//						   - added ability to attack moving object
//						   - fixed attack unmoving object
/////////////////////////////////////////////////////////////////////////////////////
// Incomplete: 
//			- Direction Bow damage disabled
//
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, BOOL bResponse, BOOL bIsDash)
{
 char cData[100];
 DWORD * dwp, dwTime;
 WORD  * wp;
 int     iRet, iExp, tdX = 0, tdY = 0, i;
 short   sOwner, sAbsX, sAbsY;
 char    cOwnerType;
 BOOL    bNearAttack = FALSE, var_AC = FALSE;
 short sItemIndex;
 int tX, tY, iErr, iStX, iStY;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;

	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;
	m_pClientList[iClientH]->m_iAttackMsgRecvCount++;
	if (m_pClientList[iClientH]->m_iAttackMsgRecvCount >= 7) {
		if (m_pClientList[iClientH]->m_dwAttackLAT != 0) {
			if ((dwTime - m_pClientList[iClientH]->m_dwAttackLAT) < (3500)) {		
				DeleteClient(iClientH, TRUE, TRUE, TRUE);
				return 0;
			}
		}
		m_pClientList[iClientH]->m_dwAttackLAT = dwTime;
		m_pClientList[iClientH]->m_iAttackMsgRecvCount = 0;
	}

	if ((wTargetObjectID != NULL) && (wType != 2)) {
		if (wTargetObjectID < DEF_MAXCLIENTS) {
			if (m_pClientList[wTargetObjectID] != NULL) {
				tdX = m_pClientList[wTargetObjectID]->m_sX;
				tdY = m_pClientList[wTargetObjectID]->m_sY;
			}
		}
		else if ( (wTargetObjectID > 10000) && (wTargetObjectID < (10000 + DEF_MAXNPCS)) ) {
			if (m_pNpcList[wTargetObjectID - 10000] != NULL) {
				tdX = m_pNpcList[wTargetObjectID - 10000]->m_sX;
				tdY = m_pNpcList[wTargetObjectID - 10000]->m_sY;
			}
		}

		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwner, &cOwnerType, dX, dY);
		if(sOwner == (wTargetObjectID - 10000)){
			tdX = m_pNpcList[sOwner]->m_sX;
			dX = tdX;
			tdY = m_pNpcList[sOwner]->m_sY;
			dY = tdY;
			bNearAttack = FALSE;
			var_AC = TRUE;
		}
		if (var_AC != TRUE) {
			if ((tdX == dX) && (tdY == dY)) {
				bNearAttack = FALSE;	
			}
			else if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
				dX = tdX;
				dY = tdY;
				bNearAttack = TRUE;
			}
		}
	}

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	sAbsX = abs(sX - dX);
	sAbsY = abs(sY - dY);
	if ((wType != 2) && (wType < 20)) {
		if (var_AC == FALSE) {
			sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
			if (sItemIndex != -1) {
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return 0;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
					if ((sAbsX > 4) || (sAbsY > 4)) wType = 0;
				}
				else{
					if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
				}
			}
			else{
				if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
			}
		}
		else{
			cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bCheckFlySpaceAvailable(sX, sY, cDir, sOwner)) != FALSE)
				wType = 0;
		}
	}

	ClearSkillUsingStatus(iClientH);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	m_pClientList[iClientH]->m_cDir = cDir;

	iExp = 0;
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
		
	if (sOwner != NULL) {
		if ((wType != 0) && ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) > 100)) { 
			if ((m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) && (m_pClientList[iClientH]->m_bIsInsideWarehouse == FALSE) 
				&& (m_pClientList[iClientH]->m_bIsInsideWizardTower == FALSE) && (m_pClientList[iClientH]->m_bIsInsideOwnTown == FALSE)) {
				sItemIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if (sItemIndex != -1 && m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
					if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 874){ // Directional bow
						for(i = 2; i < 10; i++){
							iErr = 0;
							m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, tX, tY);
							//iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, tX, tY, wType, bNearAttack, bIsDash, TRUE); // 1
							if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
								//iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
							}
						}
					}
					else if(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 873){ // Firebow
						if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) != 0) {
							if (m_bHeldenianInitiated != 1) {
								iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE3, m_pClientList[iClientH]->m_cMapIndex, dX, dY, (iDice(1,7)+3)*1000, 8);
							}
							iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
						}
					}
					else{
						iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
					}
				}
				else{
					iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
				}
			}
			else{
				iExp += iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack, bIsDash, FALSE); // 0
			}
			if (m_pClientList[iClientH] == NULL) return 0;
			m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
		}
	}
	else _CheckMiningAction(iClientH, dX, dY);

	if (iExp != 0) {
		GetExp(iClientH, iExp, TRUE);
	}

	if (bResponse == TRUE) {
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOTION_ATTACK_CONFIRM;
	
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}

	return 1;
}

char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int * pError)
{
 register char  cDir, cTmpDir;
 register int   aX, aY, dX, dY;
 register int   i, iResX, iResY;

	if ((sX == dstX) && (sY == dstY)) return 0;

	dX = sX;
	dY = sY;
 
	if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
		iResX = dstX;
		iResY = dstY;
	}
	else m_Misc.GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);

	cDir = m_Misc.cGetNextMoveDir(dX, dY, iResX, iResY);

	if (cTurn == 0)
	for (i = cDir; i <= cDir + 7;i++) {
		cTmpDir = i;
		if (cTmpDir > 8) cTmpDir -= 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
	}

	if (cTurn == 1)
	for (i = cDir; i >= cDir - 7;i--) {
		cTmpDir = i;
		if (cTmpDir < 1) cTmpDir += 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
	}

	return 0;
}


char _tmp_cEmptyPosX[] = { 0, 1, 1, 0, -1, -1, -1, 0 ,1, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2 };
char _tmp_cEmptyPosY[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2 };

BOOL CGame::bGetEmptyPosition(short * pX, short * pY, char cMapIndex)
{
 register int i;
 short sX, sY;	
	// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â³Âª NPCÂ°Â¡ Ã€Â§Ã„Â¡Ã‡Ã’ Â¼Ã¶ Ã€Ã–Â´Ã‚ Â¿ÂµÂ¿ÂªÃ€Â» ÃƒÂ£Â´Ã‚Â´Ã™.
	
	for (i = 0; i < 25; i++) 
	if ( (m_pMapList[cMapIndex]->bGetMoveable(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == TRUE) &&
		 (m_pMapList[cMapIndex]->bGetIsTeleport(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == FALSE) ) {
		sX = *pX + _tmp_cEmptyPosX[i];
		sY = *pY + _tmp_cEmptyPosY[i];	
		*pX = sX;
		*pY = sY;
		return TRUE;
	}

	// Ã€Â§Ã„Â¡Â½ÃƒÃ…Â³Â¸Â¸Ã‡Ã‘ Â¿ÂµÂ¿ÂªÃ€ÃŒ Â¾Ã¸Ã€Â¸Â¹Ã‡Â·Ã Ã‡Ã˜Â´Ã§ Â¸ÃŠÃ€Ã‡ InitPointÂ¿Â¡ Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™.
	
	GetMapInitialPoint(cMapIndex, &sX, &sY);
	*pX = sX;
	*pY = sY;

	return FALSE;
}

void CGame::NpcBehavior_Move(int iNpcH)
{
 char  cDir;
 short sX, sY, dX, dY, absX, absY;
 short sTarget, sDistance;
 char  cTargetType;
	
	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;
	// ¼ÒÈ¯¸÷ÀÇ Á¦¾î »óÅÂ°¡ Hold¶ó¸é ÀÌµ¿ÇÏÁö ¾Ê´Â´Ù.
	if ((m_pNpcList[iNpcH]->m_bIsSummoned == TRUE) && 
		(m_pNpcList[iNpcH]->m_iSummonControlMode == 1)) return;
	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	
	// ÀÌµ¿ÇÒ ¼ö ¾ø´Â NPC´Â ¸®ÅÏ
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 2:
	case 3:
	case 5:
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_STOP;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		return;
	}
	
	// v1.432-2 ¸Ê ¼½ÅÍ Á¤º¸¸¦ °»½ÅÇÑ´Ù. 
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}

	// ÅÏ Ä«¿îÆ® Áõ°¡. 
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		// ¸ÕÀú ÅÏ Ä«¿îÆ® Å¬¸®¾î.
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		
		// Á¦ÀÚ¸®¿¡¼­ °è¼Ó ¸Éµ¹°í ÀÖ´ÂÁö ÆÇ´ÜÇÑ´Ù. 
		absX = abs(m_pNpcList[iNpcH]->m_vX - m_pNpcList[iNpcH]->m_sX);
		absY = abs(m_pNpcList[iNpcH]->m_vY - m_pNpcList[iNpcH]->m_sY);
		
		if ((absX <= 2)	&& (absY <= 2)) {
			// Á¦ÀÚ¸®¿¡ ¸Éµ¹°í ÀÖ´Ù. ´ÙÀ½ WayPoint·Î ¸ñÀûÁö¸¦ ¹Ù²Û´Ù. 
			CalcNextWayPointDestination(iNpcH);
		}

		m_pNpcList[iNpcH]->m_vX = m_pNpcList[iNpcH]->m_sX;
		m_pNpcList[iNpcH]->m_vY = m_pNpcList[iNpcH]->m_sY;
	}

	// °ø°İÇÒ ´ë»óÀ» °Ë»öÇÑ´Ù.
	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if (sTarget != NULL) {
		// °ø°İ¸ñÇ¥ ¹ß°ß. 
		if (m_pNpcList[iNpcH]->m_dwActionTime < 1000) {
			// ¾×¼Ç ½ºÇÇµå 1000ms ¹Ì¸¸ÀÇ NPC´Â 33% È®·ü·Î ¸ñÇ¥¸¦ È¹µæÇÑ´Ù.
			if (iDice(1,3) == 3) {
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
				m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
				// ¿©±â¼­ Ç¥È¿ µ¿ÀÛ°°Àº°ÍÀ» À§ÇÑ ¸Ş½ÃÁö ¹ß¼Û. 
				return;
			}
		}
		else {
			// ¾×¼Ç ½ºÇÇµå 1000ms ÀÌ»óÀÇ NPC´Â ¸ñÇ¥¹°ÀÌ ¹ß°ßµÇ¸é ¹«Á¶°Ç ÇÒ´çÇÑ´Ù.
			m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
			m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
			m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
			// ¿©±â¼­ Ç¥È¿ µ¿ÀÛ°°Àº°ÍÀ» À§ÇÑ ¸Ş½ÃÁö ¹ß¼Û. 
			return;
		}
	}
	
	// ¸¶½ºÅÍ ¸÷Àº ÀÌµ¿ ¼Óµµ°¡ ´À¸®´Ù.
	if ((m_pNpcList[iNpcH]->m_bIsMaster == TRUE) && (iDice(1,3) == 2)) return;
	
	if (m_pNpcList[iNpcH]->m_cMoveType == DEF_MOVETYPE_FOLLOW) {
		// µû¸£´Â °´Ã¼ÀÇ À§Ä¡¿¡ µû¶ó ÀÌµ¿À» °áÁ¤ÇÑ´Ù. 
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
		switch (m_pNpcList[iNpcH]->m_cFollowOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			// µû¶ó´Ù´Ï´ø °³Ã¼°¡ Á×À¸¸é ·£´ıÀÌµ¿À¸·Î ÀüÈ¯.
			if (m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				return;
			}

			dX = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;
		case DEF_OWNERTYPE_NPC:
			// µû¶ó´Ù´Ï´ø °³Ã¼°¡ Á×À¸¸é ·£´ıÀÌµ¿À¸·Î ÀüÈ¯. -> 01-12-19 ÁÖº¯ÀÇ ´Ù¸¥ µ¿±Ş ¸ó½ºÅÍ¸¦ ¸¶½ºÅÍ·Î ¼±ÅÃÇÑ´Ù. Ã£À» ¼ö ¾ø¾ú´Ù¸é ·£´ı ¹«ºê
			if (m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				m_pNpcList[iNpcH]->m_iFollowOwnerIndex = NULL;
				//bSerchMaster(iNpcH);
				return;
			}
			
			dX = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;
		}

		if (abs(sX - dX) >= abs(sY - dY)) 
			 sDistance = abs(sX - dX);
		else sDistance = abs(sY - dY);

		if (sDistance >= 3) {
			// µû¸£´Â ´ë»óÀÌ ÀÓ°èÄ¡ ÀÌ»ó ¶³¾îÁ® ÀÖÀ¸¸é ÀÌµ¿ÇÑ´Ù. 
			cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			if (cDir == 0) {
				// ÀÌµ¿ÇÒ ¼ö ¾ø´Ù.
			}
			else {
				dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
				dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
				// ¿¹Àü À§Ä¡¿¡¼­ Áö¿î´Ù. 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(3, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
				// »õ À§Ä¡¿¡ Ç¥½ÃÇÑ´Ù. 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
				m_pNpcList[iNpcH]->m_sX   = dX;
				m_pNpcList[iNpcH]->m_sY   = dY;
				m_pNpcList[iNpcH]->m_cDir = cDir;
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
			}
		}
	}
	else 
	{
		// ´ÙÀ½ ÀÌµ¿ ¹æÇâÀ» ±¸ÇÑ´Ù.
		cDir = cGetNextMoveDir(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 
			                   m_pNpcList[iNpcH]->m_dX, m_pNpcList[iNpcH]->m_dY, 
				     	       m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
						
		if (cDir == 0) {
			// ´ÙÀ½ ÀÌµ¿Á¡À» ±¸ÇÑ´Ù. ·£´ı°ªÀ» ÁØ °ÍÀº Á¦ÀÚ¸®¿¡¼­ Àá½Ã ¸Ó¹°±â À§ÇÔ 		
			if (iDice(1,10) == 3) CalcNextWayPointDestination(iNpcH);
		}
		else {
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			// ¿¹Àü À§Ä¡¿¡¼­ Áö¿î´Ù. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(4, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			// »õ À§Ä¡¿¡ Ç¥½ÃÇÑ´Ù. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[iNpcH]->m_sX   = dX;
			m_pNpcList[iNpcH]->m_sY   = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
	}
}

void CGame::TargetSearch(int iNpcH, short * pTarget, char * pTargetType)
{
 register int ix, iy, iPKCount;
 register short sX, sY, rX, rY, dX, dY;
 short sOwner, sTargetOwner, sDistance, sTempDistance;
 char  cOwnerType, cTargetType, cTargetSide;
 int   iInv;

	sTargetOwner = NULL;
	cTargetType  = NULL;
	sDistance    = 100;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	// Ã€ÃÂµÂ¦Â½Âº iNpcHÂ¿Â¡ Ã‡Ã˜Â´Ã§Ã‡ÃÂ´Ã‚ NPCÂ°Â¡ Â°Ã¸Â°ÃÂ´Ã«Â»Ã³Ã€Â» ÃƒÂ£Â´Ã‚Â´Ã™. 
	rX = m_pNpcList[iNpcH]->m_sX - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	rY = m_pNpcList[iNpcH]->m_sY - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	
	for (ix = rX; ix < rX + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; ix++)
	for (iy = rY; iy < rY + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; iy++) {
		
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
		if (sOwner != NULL) {
			// Â¹Â«Â¾Ã°Â°Â¡ Â¹ÃŸÂ°ÃŸÂµÃ‡Â¾ÃºÂ´Ã™. 
			if ((sOwner == iNpcH) && (cOwnerType == DEF_OWNERTYPE_NPC)) break; // Ã€ÃšÂ±Ã¢ Ã€ÃšÂ½Ã…Ã€ÃŒÂ¸Ã© Â¹Â«Â½Ãƒ 
			
			// Â¸Ã±Ã‡Â¥ Â¼Â³ÃÂ¤
			// Ã€Â§Ã„Â¡Â¸Â¦ Â±Â¸Ã‡Ã‘Â´Ã™.
			iPKCount = 0;
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwner] == NULL) {
					// Ã€ÃŸÂ¸Ã¸ÂµÃˆ Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ Â°Â¡ÃÃ¸ Â°ÂªÃ€ÃŒÂ´Ã™. Ã…Â¬Â¸Â®Â¾Ã®Ã‡Ã‘Â´Ã™.	
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(5, sOwner, DEF_OWNERTYPE_PLAYER, ix, iy);
				}
				else {
					if (m_pClientList[sOwner]->m_iAdminUserLevel > 0) goto SKIP_SEARCH;

					dX = m_pClientList[sOwner]->m_sX;
					dY = m_pClientList[sOwner]->m_sY;
					cTargetSide = m_pClientList[sOwner]->m_cSide;
					iPKCount    = m_pClientList[sOwner]->m_iPKCount;
					iInv        = m_pClientList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwner] == NULL) {
					// Ã€ÃŸÂ¸Ã¸ÂµÃˆ Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ Â°Â¡ÃÃ¸ Â°ÂªÃ€ÃŒÂ´Ã™. Ã…Â¬Â¸Â®Â¾Ã®Ã‡Ã‘Â´Ã™.	
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(6, sOwner, DEF_OWNERTYPE_NPC, ix, iy);
				}
				else {
					dX = m_pNpcList[sOwner]->m_sX;
					dY = m_pNpcList[sOwner]->m_sY;
					cTargetSide = m_pNpcList[sOwner]->m_cSide;
					iPKCount    = 0;
					iInv        = m_pNpcList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];

					if (m_pNpcList[iNpcH]->m_sType == 21) {
						// Â¸Â¸Â¾Ã  Â°Ã¦ÂºÃ±Â°Â¡ NPCÂ¸Â¦ Â¸Ã±Ã‡Â¥Â¹Â°Ã€Â» ÃƒÂ£Â´Ã‚ Â°ÃÃ€ÃŒÂ¶Ã³Â¸Ã© NPCÃÃ–Ã€Â§Â¿Â¡ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¸Â¹Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© Â°Ã¸Â°ÃÃ‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 
						if (_iCalcPlayerNum(m_pNpcList[sOwner]->m_cMapIndex, dX, dY, 2) != 0) {
							sOwner     = NULL;
							cOwnerType = NULL;
						}
					}
				}
				break;
			}
			
			if (m_pNpcList[iNpcH]->m_cSide < 10) {
				// NPCÃ€Ã‡ SideÂ°Â¡ 10ÂºÂ¸Â´Ã™ Ã€Ã›Â´Ã™Â´Ã‚ Â°ÃÃ€Âº NPCÂ°Â¡ Ã‡Ã‘ Â¸Â¶Ã€Â»Â¿Â¡ Â¼Ã’Â¼Ã“ÂµÃ‡Â¾ÃºÂ´Ã™Â´Ã‚ Â¶Ã¦.  Ex: Guard ÃˆÂ¤Ã€Âº Â¼Ã’ÃˆÂ¯Â¸Ã·  
				if (cTargetSide == 0) {
					// Â¸Ã±Ã‡Â¥Â¹Â°Ã€ÃŒ ÃÃŸÂ¸Â³Ã€ÃŒÂ´Ã™. PKÂ°Â¡ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© Â°Ã¸Â°ÃÃ‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 
					if (iPKCount == 0) goto SKIP_SEARCH;
				}
				else {
					// Â¸Ã±Ã‡Â¥Â¹Â°Ã€ÃŒ Â¸Â¶Ã€Â» Â¼Ã’Â¼Ã“Ã€ÃŒÂ´Ã™. SideÂ°Â¡ Â´Ã™Â¸Â£Â´Ã™Â¸Ã© Â°Ã¸Â°ÃÃ‡Ã‘Â´Ã™. v1.12
					if ((iPKCount == 0) && (cTargetSide == m_pNpcList[iNpcH]->m_cSide)) goto SKIP_SEARCH;
					// ÃÃŸÂ¸Â³Â¸Ã·Ã€Âº Â¸Â¶Ã€Â» Â¼Ã’Â¼Ã“ Â¸Ã±Ã‡Â¥Â¹Â°Ã€Â» Â°Ã¸Â°ÃÃ‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. v1.12
					if (m_pNpcList[iNpcH]->m_cSide == 0) goto SKIP_SEARCH;
				}
			}
			else {
				// Ã€ÃÂ¹Ã Â¸Ã³Â½ÂºÃ…ÃÂµÃ©Ã€ÃŒÂ´Ã™. Ã€ÃšÂ±Ã¢Â¿Ã SideÂ°Â¡ Â°Â°Ã€Â¸Â¸Ã© Â¹Â«Â½Ãƒ.
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 0)) goto SKIP_SEARCH;
				if (cTargetSide == m_pNpcList[iNpcH]->m_cSide) goto SKIP_SEARCH;
			}

			// Â¸Â¸Â¾Ã  INVISIBILITYÂ°Â¡ ÂµÃ‡Â¾Ã® Ã€Ã–Â°Ã­ Ã…ÃµÂ¸Ã­ Ã…Â½ÃÃ¶ Â´Ã‰Â·Ã‚Ã€ÃŒ Â¾Ã¸Â´Ã™Â¸Ã© 
			if ((iInv != 0) && (m_pNpcList[iNpcH]->m_cSpecialAbility != 1)) goto SKIP_SEARCH;

			if (abs(sX - dX) >= abs(sY - dY)) 
				 sTempDistance = abs(sX - dX);
			else sTempDistance = abs(sY - dY);

			if (sTempDistance <	sDistance) {
				sDistance = sTempDistance;
				sTargetOwner = sOwner;
				cTargetType  = cOwnerType;
			}
SKIP_SEARCH:;
		}
	}

	*pTarget     = sTargetOwner;
	*pTargetType = cTargetType;
	return;
}

void CGame::NpcBehavior_Attack(int iNpcH)
{
 int   iMagicType;
 short sX, sY, dX, dY;
 char  cDir;
 DWORD dwTime = timeGetTime();

	if (m_pNpcList[iNpcH] == NULL) return;
 	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;
	
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 1:
	case 2:
	case 3:
	case 4:
		return;

	case 5:
		if (m_pNpcList[iNpcH]->m_iBuildCount > 0) return;
	}
	
	// v1.432-2 ¸Ê ¼½ÅÍ Á¤º¸¸¦ °»½ÅÇÑ´Ù. 
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}

	// ¿¬¼Ó °ø°İ Ä«¿îÆ® ÃÊ±âÈ­ 
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount == 0) 
		m_pNpcList[iNpcH]->m_iAttackCount = 0;

	// ÅÏ Ä«¿îÆ® Áõ°¡. 
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 20) {
		// 20È¸ ÀÌ»ó °ø°İµ¿ÀÛÀ» ¼öÇàÇÏ¸é ´Ù½Ã ÀÌµ¿¸ğµå·Î µé¾î°£´Ù. ´Ü ¿µ±¸ °ø°İ ¸ğµå°¡ ¾Æ´Ï¶ó¸é 
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE))
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;

		// ¿©±â¼­ Ç¥È¿µ¿ÀÛÀÌ³ª ¿©À¯µ¿ÀÛÀ» ÃëÇÏ±â À§ÇÑ ¸Ş½ÃÁö¸¦ ¹ß¼ÛÇÒ ¼öµµ ÀÖ´Ù.
		return;
	}

	// À§Ä¡¸¦ ±¸ÇÑ´Ù.
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
			// ¸ñÇ¥¹°ÀÌ »ç¶óÁ³´Ù. 
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
			// ¸ñÇ¥¹°ÀÌ »ç¶óÁ³´Ù. 
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}

	// ¸ñÇ¥¹° ÁÖÀ§¿¡ ÀûÀÌ ¸¹À¸¸é µµ¸ÁÄ£´Ù. ´Ü °ÇÃà¹°(5)´Â ¿¹¿Ü
	if ( (iGetDangerValue(iNpcH, dX, dY) > m_pNpcList[iNpcH]->m_cBravery) && 
		 (m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
		 (m_pNpcList[iNpcH]->m_cActionLimit != 5)) {
		
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}

	// ¿¡³ÊÁö°¡ ³·°í Bravery°¡ ³·À¸¸é µµ¸ÁÄ£´Ù. ´Ü °ÇÃà¹°(5)´Â ¿¹¿Ü
	if ( (m_pNpcList[iNpcH]->m_iHP <= 2) && (iDice(1,m_pNpcList[iNpcH]->m_cBravery) <= 3) &&
		 (m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
		 (m_pNpcList[iNpcH]->m_cActionLimit != 5)) {

		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}

	// ¸ñÇ¥¹°ÀÇ »óÅÂ¸¦ ÆÇ´ÜÇÑ´Ù. 
	if ((abs(sX - dX) <= 1) && (abs(sY - dY) <= 1)) {
		// ÀÎÁ¢ÇØ ÀÖ´Ù.	±Ù°Å¸® ¹«±â¸¦ ÀåÂøÇÏ°í ÀÖ´Ù¸é °ø°İ°¡´É.
		
		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		// ¹æÇâÀ» ¹Ù²Ù°í °ø°İµ¿ÀÛ 
		m_pNpcList[iNpcH]->m_cDir = cDir;				  

		if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
			// ÀüÀï¿ë °Ç¹°ÀÎ °æ¿ì 
			switch (m_pNpcList[iNpcH]->m_sType) {
			case 89:
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
				m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
				NpcMagicHandler(iNpcH, dX, dY, 61);
				break;

			case 87:
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); 
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
				break;
				
			case 36: // Crossbow Guard Tower: È° °ø°İ
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 2); // È°
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2, FALSE, FALSE, FALSE);
				break;

			case 37: // Cannon Guard Tower: 
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
				m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
				NpcMagicHandler(iNpcH, dX, dY, 61);
				break;
			}
		}
		else {
			// ÀÏ¹İ NPCÀÎ °æ¿ì
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : Ä®µîÀÇ ±ÙÁ¢¹«±â·Î °ø°İÇÏ´Â ÀÇ¹Ì 
			iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 1, FALSE, FALSE); // °ø°İ¿¡ ´ëÇÑ È¿°ú¸¦ °è»êÇÑ´Ù. 
		}
		// ¿¬¼Ó °ø°İ Ä«¿îÆ® Áõ°¡.
		m_pNpcList[iNpcH]->m_iAttackCount++;

		// °ø°İ Áö´É Å¸ÀÔ¿¡ µû¸¥ ÀÌÈÄ Çàµ¿. °íÁ¤ °ø°İ ¸ğµå¿¡´Â ÇØ´çµÇÁö ¾Ê´Â´Ù.  
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
			switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
			case DEF_ATTACKAI_EXCHANGEATTACK:
				// °ø°İ -> ÈÄÅğ -> °ø°İ -> ÈÄÅğ -> ...
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				break;

			case DEF_ATTACKAI_TWOBYONEATTACK:
				// °ø°İ -> °ø°İ -> ÈÄÅğ -> °ø°İ -> °ø°İ -> ÈÄÅğ -> ...
				if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				}
				break;
			}
		}
	}
	else {
		// ¶³¾îÁ® ÀÖ´Ù.  
		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		m_pNpcList[iNpcH]->m_cDir = cDir;				  
			
		// ¸¶¹ı ´É·ÂÀÌ ÀÖ¾î¾ß ÇÏ°í »çÁ¤°Å¸® ³»¿©¾ß ÇÑ´Ù.
		if ((m_pNpcList[iNpcH]->m_cMagicLevel > 0) && (iDice(1,2) == 1) &&
			(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			switch (m_pNpcList[iNpcH]->m_cMagicLevel) { // °¢ ½áÅ¬º°·Î ¸¶¹ı »ç¿ëÀÌ °¡´ÉÇÑÁö ÆÇ´ÜÈÄ Ã³¸®. 
			case 1:
				if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0;
				break;

			case 2:
				if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0;
				break;

			case 3: // Orc-Mage
				if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;

			case 4:
				if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;

			case 5: // Rudolph, Cannibal-Plant, Cyclops
				if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;

			case 6: // Tentocle, Liche
				if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;

			case 7: // Barlog, Fire-Wyvern, MasterMage-Orc , LightWarBeatle, GHK, GHKABS, TK, BG
				    // Sor, Gagoyle, Demon
				if ((m_pMagicConfigList[70]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,5) == 3)) 
					iMagicType = 70;
				else if (m_pMagicConfigList[61]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 61;
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60;
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				break;

			case 8: // Unicorn, Centaurus
				if ((m_pMagicConfigList[35]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 35;
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60;
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				break;

			case 9: // Tigerworm
				if ((m_pMagicConfigList[74]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 74; // Lightning-Strike
				break;
			
			case 10: // Frost, Nizie
				break;

			case 11: // Ice-Golem
				break;

			case 12: // Wyvern
				if ((m_pMagicConfigList[91]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 91; // Blizzard
				else if (m_pMagicConfigList[63]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 63; // Mass-Chill-Wind
				break;

			case 13: // Abaddon
				if ((m_pMagicConfigList[96]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 96; // Earth Shock Wave
				else if (m_pMagicConfigList[81]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 81; // Metoer Strike
				break;

			}

			if (iMagicType != -1) {
				
				// ¸ó½ºÅÍÀÇ AI°¡ 2ÀÌ»óÀÌ°í ¸¶¹ı °ø°İ »ó´ë°¡ ¸¶¹ı º¸È£°¡ °É·Á ÀÖ´Ù¸é °ø°İÇÏÁö ¾Ê´Â´Ù. 
				if (m_pNpcList[iNpcH]->m_iAILevel >= 2) {
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
							// ¸¶¹ı º¸È£°¡ °É·ÁÀÖÀ½ °ø°İÇÏÁö ¾ÊÀ¸¸ç Ãß°İÇÏ°Å³ª ÀÌµ¿¸ğµå·Î ÀüÈ¯, »õ·Î¿î ¸ñÇ¥¹°À» °Ë»ö
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}
							else goto NBA_CHASE;
						}
						// ÆĞ·²¸¶¹ıÀÎµ¥ ¸ñÇ¥¹°ÀÌ ÀÌ¹Ì ÆĞ·²»óÅÂ¶ó¸é ¸¶¹ı »ç¿ë ¾ÈÇÔ.
						if ((iMagicType == 35) && (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
							// ¸¶¹ı º¸È£°¡ °É·ÁÀÖÀ½ °ø°İÇÏÁö ¾ÊÀ¸¸ç Ãß°İÇÏÁö ¾Ê°í ÀÌµ¿¸ğµå·Î ÀüÈ¯, »õ·Î¿î ¸ñÇ¥¹°À» °Ë»ö
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}
							else goto NBA_CHASE;
						}
						// ÆĞ·²¸¶¹ıÀÎµ¥ ¸ñÇ¥¹°ÀÌ ÀÌ¹Ì ÆĞ·²»óÅÂ¶ó¸é ¸¶¹ı »ç¿ë ¾ÈÇÔ.
						if ((iMagicType == 35) && (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;
					}
				}
				
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : Ä®µîÀÇ ±ÙÁ¢¹«±â·Î °ø°İÇÏ´Â ÀÇ¹Ì 
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
			}
		}

		// ±¤¹üÀ§ ¸¶¹ı »ç¿ëÀÌ ±İÁöµÈ °æ¿ì (MagicLevelÀÌ À½¼öÀÎ °æ¿ì)
		if ((m_pNpcList[iNpcH]->m_cMagicLevel < 0) && (iDice(1,2) == 1) &&
			(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 43;
			else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 37;
			else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 0;

			if (iMagicType != -1) {
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : Ä®µîÀÇ ±ÙÁ¢¹«±â·Î °ø°İÇÏ´Â ÀÇ¹Ì 
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
			}
		}

		// v1.41 ¸¶¹ı ´É·ÂÀÌ ¾øÁö¸¸ ¿ø°Å¸® °ø°İÀÌ °¡´ÉÇÏ´Ù¸é 
		if ((m_pNpcList[iNpcH]->m_iAttackRange > 1) && 
			(abs(sX - dX) <= m_pNpcList[iNpcH]->m_iAttackRange) && (abs(sY - dY) <= m_pNpcList[iNpcH]->m_iAttackRange)) {
						
			cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if (cDir == 0) return;
			// ¹æÇâÀ» ¹Ù²Ù°í °ø°İµ¿ÀÛ 
			m_pNpcList[iNpcH]->m_cDir = cDir;				  
			
			if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
				switch (m_pNpcList[iNpcH]->m_sType) {
				case 36: // Crossbow Guard Tower
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
					break;

				case 37: // Cannon Guard Tower: ¸Å½º ÆÄÀÌ¾î ½ºÆ®¶óÀÌÅ© °ø°İ
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;
				}
			}
			else {
				switch (m_pNpcList[iNpcH]->m_sType) {
				case 51: // v2.05 Catapult: ¸Å½º ÆÄÀÌ¾î ½ºÆ®¶óÀÌÅ© °ø°İ 
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;

				case 54: // Dark Elf: È° °ø°İÀ» ÇÑ´Ù.
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); // 2: È°°ø°İ 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
					break;
				
				case 63: // Frost
				case 79: // Nizie
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
							NpcMagicHandler(iNpcH, dX, dY, 57);
						// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆĞÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
						if ((m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
							if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, TRUE);
								// È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ıÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
									                m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
								// ´ë»óÀÌ ÇÃ·¹ÀÌ¾îÀÎ °æ¿ì ¾Ë·ÁÁØ´Ù.
								SendNotifyMsg(NULL, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if ((m_pMagicConfigList[57]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
						NpcMagicHandler(iNpcH, dX, dY, 57);
						if ((m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
							if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, TRUE);
								// È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ıÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
								                    m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}	
				case 53: //Beholder: ³Ãµ¿ °ø°İÀ» ÇÑ´Ù.
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						// Å¸°ÙÀÌ »ì¾ÆÀÖ°í ¾óÀ½ ÀúÇ×¿¡ ½ÇÆĞÇß´Ù¸é ¾ó¾îºÙ´Â´Ù.
						if ((m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
							if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, TRUE);
								// È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ıÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
									                m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
								// ´ë»óÀÌ ÇÃ·¹ÀÌ¾îÀÎ °æ¿ì ¾Ë·ÁÁØ´Ù.
								SendNotifyMsg(NULL, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) goto NBA_BREAK1;
						if ((m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_iHP > 0) && 
							(bCheckResistingIceSuccess(m_pNpcList[iNpcH]->m_cDir, m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_iMagicHitRatio) == FALSE)) {
							if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, TRUE);
								// È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ıÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (5*1000), 
								                    m_pNpcList[iNpcH]->m_iTargetIndex, DEF_OWNERTYPE_NPC, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
NBA_BREAK1:;
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: ÇÊ»ì±â
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
					break;
							
				default:
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: ÇÊ»ì±â 
					// °ø°İ¿¡ ´ëÇÑ È¿°ú¸¦ °è»êÇÑ´Ù. 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
					break;
				}
			}
			// ¿¬¼Ó °ø°İ Ä«¿îÆ® Áõ°¡.
			m_pNpcList[iNpcH]->m_iAttackCount++;
			
			// °ø°İ Áö´É Å¸ÀÔ¿¡ µû¸¥ ÀÌÈÄ Çàµ¿. °íÁ¤ °ø°İ ¸ğµå¿¡´Â ÇØ´çµÇÁö ¾Ê´Â´Ù.  
			if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
				switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
				case DEF_ATTACKAI_EXCHANGEATTACK:
					// °ø°İ -> ÈÄÅğ -> °ø°İ -> ÈÄÅğ -> ...
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
					break;
			
				case DEF_ATTACKAI_TWOBYONEATTACK:
					// °ø°İ -> °ø°İ -> ÈÄÅğ -> °ø°İ -> °ø°İ -> ÈÄÅğ -> ...
					if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
					}
					break;
				}
			}
			return;
		}

		// ¸¶¹ıÀ» »ç¿ëÇÏÁö ¾Ê¾Ò´Ù¸é Ãß°İÇÑ´Ù.
NBA_CHASE:;		

		if (m_pNpcList[iNpcH]->m_cActionLimit != 0) return;

		// ¿¬¼Ó °ø°İ Ä«¿îÆ® ÃÊ±âÈ­ 
		m_pNpcList[iNpcH]->m_iAttackCount = 0;

		{
			// ÀÌµ¿¸ğµå°¡ Follow°¡ ¾Æ´Ï¶ó¸é °ø°İ¸ñÇ¥¸¦ ¹«Á¶°Ç Ãß°İÇÑ´Ù.	¿òÁ÷ÀÓ¿¡ Á¦ÇÑÀÌ ¾ø´Ù.
			cDir = cGetNextMoveDir(sX, sY, dX, dY,m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			if (cDir == 0) {
				return;
			}
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			// ¿¹Àü À§Ä¡¿¡¼­ Áö¿î´Ù. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(9, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			// »õ À§Ä¡¿¡ Ç¥½ÃÇÑ´Ù. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[iNpcH]->m_sX   = dX;
			m_pNpcList[iNpcH]->m_sY   = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
	}
}

void CGame::RemoveFromTarget(short sTargetH, char cTargetType, int iCode)
{
 register int i;
 DWORD dwTime = timeGetTime();

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		// Crusade Â¸Â¸Â¾Ã  ÃÃ¶ÃˆÃ–Â°Ã¼Ã€ÃŒ Â»Ã§Â¸ÃÃ‡Ã‘ Â°Ã¦Â¿Ã¬ ÃÃ¶ÃˆÃ–Â°Ã¼ Â»ÃªÃ‡Ã NPCÂµÃ©Ã€Âº Â¼Ã’ÃˆÂ¯Â¸Ã· Â¸Ã°ÂµÃ¥Â·Ã Ã€Ã¼ÃˆÂ¯ÂµÃ‡Â¾Ã® Ã€ÃÃÂ¤Â½ÃƒÂ°Â£ 
		// Ã€ÃŒÃˆÃ„Â¿Â¡ Ã€ÃšÂµÂ¿ Ã†Ã¸Ã†Ã„ÂµÃˆÂ´Ã™. Â¸Ã·Ã€ÃŒ Â³Ã‘ÃƒÃ„Â³ÂªÂ´Ã‚ Â°ÃÃ€Â» Â¸Â·Â±Ã¢ Ã€Â§Ã‡Ã”.
		if ((m_pNpcList[i]->m_iGuildGUID != NULL) && (cTargetType == DEF_OWNERTYPE_PLAYER) &&
			(m_pClientList[sTargetH]->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) {
			
			if (m_pNpcList[i]->m_cActionLimit == 0) {
				// Ã€ÃŒÂµÂ¿ Â°Â¡Â´Ã‰Ã‡Ã‘ NPCÂ¸Â¸ Â¼Ã’ÃˆÂ¯ Â¸Ã°ÂµÃ¥Â·Ã Ã€Ã¼ÃˆÂ¯
				m_pNpcList[i]->m_bIsSummoned = TRUE;
				m_pNpcList[i]->m_dwSummonedTime = dwTime;
			}
		}
		
		if ((m_pNpcList[i]->m_iTargetIndex == sTargetH) && 
			(m_pNpcList[i]->m_cTargetType == cTargetType)) {
			
			switch (iCode) {
			case DEF_MAGICTYPE_INVISIBILITY:
				if (m_pNpcList[i]->m_cSpecialAbility == 1) {
					// Ã…ÃµÂ¸Ã­ Ã…Â½ÃÃ¶ Â´Ã‰Â·Ã‚Ã€ÃŒ Ã€Ã–Â´Ã‚ Â¸Ã³Â½ÂºÃ…ÃÂ´Ã‚ Â¸Ã±Ã‡Â¥Â¸Â¦ Â³ÃµÃ„Â¡ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 
				}
				else {
					m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
					m_pNpcList[i]->m_iTargetIndex = NULL;
					m_pNpcList[i]->m_cTargetType  = NULL;
				}
				break;

			default:
				m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_iTargetIndex = NULL;
				m_pNpcList[i]->m_cTargetType  = NULL;
				break;
			}
		}
	}
}

void CGame::NpcKilledHandler(short sAttackerH, char cAttackerType, int iNpcH, short sDamage)
{
 short  sAttackerWeapon;
 int    * ip, i, iQuestIndex, iExp, iConstructionPoint, iWarContribution, iMapIndex;
 double dTmp1, dTmp2, dTmp3;
 char   * cp, cData[120], cQuestRemain;

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	m_pNpcList[iNpcH]->m_bIsKilled = TRUE;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = sDamage;

	// Â¸ÃŠÃ€Ã‡ Â»Ã¬Â¾Ã†Ã€Ã–Â´Ã‚ Â°Â´ÃƒÂ¼Â¼Ã¶Â¸Â¦ ÃÃ™Ã€ÃÂ´Ã™. 
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

	// Ã‡Ã¶Ã€Ã§ Ã€ÃŒ NPCÂ¸Â¦ Â°Ã¸Â°ÃÂ´Ã«Â»Ã³Ã€Â¸Â·Ã Â»Ã¯Â°Ã­Ã€Ã–Â´Ã‚ Â°Â´ÃƒÂ¼ÂµÃ©Ã€Â» Ã‡Ã˜ÃÂ¦Ã‡Ã‘Â´Ã™.
	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);

	// Ã‡Ã¶Ã€Ã§ Ã€ÃŒ NPCÂ¸Â¦ ÂµÃ»Â¸Â£Â°Ã­ Ã€Ã–Â´Ã¸ NPCÂµÃ©Ã€Ã‡ Ã€ÃŒÂµÂ¿Â¹Ã¦Â½Ã„Ã€Â» ÂºÂ¯Â°Ã¦Ã‡Ã‘Â´Ã™. 
	ReleaseFollowMode(iNpcH, DEF_OWNERTYPE_NPC); 

	// Ã‡Ã¶Ã€Ã§ Â¸Ã±Ã‡Â¥Â·Ã Â»Ã¯Â°Ã­ Ã€Ã–Â´Ã¸ Â°Â´ÃƒÂ¼Â¸Â¦ Ã‡Ã˜ÃÂ¦Ã‡Ã‘Â´Ã™.
	m_pNpcList[iNpcH]->m_iTargetIndex = NULL;
	m_pNpcList[iNpcH]->m_cTargetType  = NULL;
	// ÃÃ—Â´Ã‚ ÂµÂ¿Ã€Ã› Ã€Ã¼Â¼Ã›.
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	}
	else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
	// ÃÂ¤Â»Ã³ Ã€Â§Ã„Â¡Â¿Â¡Â¼Â­ ÃÃ¶Â¿Ã®Â´Ã™.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	// ÃÃ—Ã€Âº Ã€Â§Ã„Â¡ Ã‡Â¥Â½ÃƒÂ¸Â¦ Ã‡Ã‘Â´Ã™.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	// ÃÃ—Ã€Âº NPCÂ´Ã‚ Ã€ÃŒÂµÂ¿Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
	m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_DEAD;
	
	// Ã…Ã Ã„Â«Â¿Ã®Ã†Â® ÃƒÃŠÂ±Ã¢ÃˆÂ­.
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	// ÃÃ—Ã€Âº Â½ÃƒÂ°Â£ Â±Ã¢Â·Ã 
	m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();

	// Ã†Ã·Â»Ã³Ã€ÃŒ Â¾Ã¸Â´Ã‚ Â¸ÃŠÃ€ÃŒÂ¶Ã³Â¸Ã© Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â»Ã½Â¼ÂºÂ½ÃƒÃ…Â°ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
	
	// v1.42 Â¾Ã†Ã€ÃŒÃ…Ã› ÂµÃ¥Â·Ã“Ã€Â» Â°Ã¼Ã€Ã¥Ã‡Ã‘Â´Ã™.
	NpcDeadItemGenerator(iNpcH, sAttackerH, cAttackerType);

	// Â»ÃµÂ·ÃÂ¿Ã® Â°Ã¦Ã‡Ã¨Ã„Â¡ Â¹Ã¨ÂºÃ Â°Ã¸Â½Ã„.
	// NPCÂ¿Â¡ Â´Ã«Ã‡Ã‘ Â°Ã¸Â°ÃÃ€ÃŒ Â¼ÂºÂ°Ã¸Ã‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â°Ã¸Â°ÃÃ€ÃšÂ°Â¡ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¶Ã³Â¸Ã© Ã€Ã”ÃˆÃ¹ Â´Ã«Â¹ÃŒÃÃ¶ Â¸Â¸Ã…Â­Ã€Ã‡ Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â°Ã¸Â°ÃÃ€ÃšÂ¿Â¡Â°Ã” ÃÃ˜Â´Ã™. 
	if ( (m_pNpcList[iNpcH]->m_bIsSummoned != TRUE) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && 
		 (m_pClientList[sAttackerH] != NULL) ) {
		// NPCÂ°Â¡ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Â°Ã¸Â°ÃÂ¿Â¡ ÃÃ—Â¾ÃºÂ´Ã™Â¸Ã© ExpStockÃ€Â» Â¿ÃƒÂ¸Â°Â´Ã™. 
		// Â´Ãœ Â¼Ã’ÃˆÂ¯Â¸Ã·Ã€Ã Â°Ã¦Â¿Ã¬ Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â¿ÃƒÂ¸Â®ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.	 Â³ÂªÂ¸Ã“ÃÃ¶ Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â¿ÃƒÂ¸Â°Â´Ã™.
		iExp = (m_pNpcList[iNpcH]->m_iExp/3);
		if (m_pNpcList[iNpcH]->m_iNoDieRemainExp > 0)
			iExp += m_pNpcList[iNpcH]->m_iNoDieRemainExp;

		//v1.42 Â°Ã¦Ã‡Ã¨Ã„Â¡ ÃÃµÂ°Â¡ 
		if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
			dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
			dTmp2 = (double)iExp;
			dTmp3 = (dTmp1/100.0f)*dTmp2;
			iExp += (int)dTmp3;
		}

		if (m_pNpcList[iNpcH]->m_sType == 81) {
			for (i = 1; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] != NULL) {		
				SendNotifyMsg(sAttackerH, i, DEF_NOTIFY_ABADDONKILLED, NULL, NULL, NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL, NULL);		
				}
			}
		}

		// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â¸Ã°ÂµÃ¥Ã€ÃÂ¶Â§ Â¸Ã³Â½ÂºÃ…ÃÂ¸Â¦ ÃÃ—Â¿Â©Â¼Â­ Â¾Ã²Ã€Â» Â¼Ã¶ Ã€Ã–Â´Ã‚ Â°Ã¦Ã‡Ã¨Ã„Â¡Â´Ã‚ 1/3
		if (m_bIsCrusadeMode == TRUE) {
			if (iExp > 10) iExp = iExp/3;
		}

		// New 09/05/2004
		//m_pClientList[sAttackerH]->m_iExpStock += iExp;
		GetExp(sAttackerH, iExp, TRUE);

		// Quest Â¿Â©ÂºÃÂ¸Â¦ Ã†Ã‡Â´ÃœÃ‡Ã‘Â´Ã™.
		iQuestIndex = m_pClientList[sAttackerH]->m_iQuest;
		if (iQuestIndex != NULL) {
			if (m_pQuestConfigList[iQuestIndex] != NULL) {
				switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
				case DEF_QUESTTYPE_MONSTERHUNT:
					if ( (m_pClientList[sAttackerH]->m_bQuestMatchFlag_Loc == TRUE) &&
						 (m_pQuestConfigList[iQuestIndex]->m_iTargetType == m_pNpcList[iNpcH]->m_sType) ) {
						// ÃÂ¶Â°Ã‡Â¿Â¡ Ã‡Ã•Â´Ã§Ã‡ÃÂ´Ã™. Ã„Â«Â¿Ã®Ã†Â® ÃÃµÂ°Â¡ÃˆÃ„ Ã†Ã‡Â´Ãœ.
						m_pClientList[sAttackerH]->m_iCurQuestCount++;
						cQuestRemain = (m_pQuestConfigList[m_pClientList[sAttackerH]->m_iQuest]->m_iMaxCount - m_pClientList[sAttackerH]->m_iCurQuestCount);
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);
						_bCheckIsQuestCompleted(sAttackerH);
					}
					break;
				}
			}
		}
	}

	// v1.41 Ã†Â¯Â¼Ã¶Â¸Ã³Â½ÂºÃ…ÃÂ°Â¡ ÃÃ—Â¾ÃºÃ€Â» Â°Ã¦Â¿Ã¬Ã€Ã‡ ÃƒÂ³Â¸Â® 
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		switch (m_pNpcList[iNpcH]->m_sType) {
		case 32:
			// Ã€Â¯Â´ÃÃ„ÃœÃ€ÃŒ ÃÃ—Â¾ÃºÂ´Ã™. ÃÃ—Ã€Ã Ã€ÃšÂ¿Â¡Â°Ã” Ã†Ã¤Â³ÃÃ†Â¼Â¸Â¦ Â¹Â°Â¸Â°Â´Ã™. 
			m_pClientList[sAttackerH]->m_iRating -= 5;
			if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = 0;
			if (m_pClientList[sAttackerH]->m_iRating >  10000) m_pClientList[sAttackerH]->m_iRating = 0;
			break;

		case 33:
			break;
		}
	}

	// Crusade
	iConstructionPoint = 0;
	switch (m_pNpcList[iNpcH]->m_sType) {
	// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥Â¿Ã« Ã€Â¯Â´ÃÃ†Â®ÂµÃ©Ã€ÃŒÂ´Ã™. Â°Ã‡Â¼Â³ Ã†Ã·Ã€ÃÃ†Â®, ÂºÂ¸Â³ÃŠÂ½Âº Â°Ã¦Ã‡Ã¨Ã„Â¡ Â°Ã¨Â»Ãª
	case 1:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 2:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 3:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 4:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 5:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 6:  iConstructionPoint = 50; iWarContribution = 100; break;	// Â¸Ã“Â¼Â­Â³ÃŠÂ¸Â®
	case 36: iConstructionPoint = 700; iWarContribution = 4000; break;	// Â¾Ã–Â·ÃÂ¿Ã¬ Â°Â¡ÂµÃ¥ Ã…Â¸Â¿Ã¶ 
	case 37: iConstructionPoint = 700; iWarContribution = 4000; break;	// Ã„Â³Â³Ã­ Â°Â¡ÂµÃ¥ Ã…Â¸Â¿Ã¶
	case 38: iConstructionPoint = 500; iWarContribution = 2000; break;	// Â¸Â¶Â³Âª Ã„ÃÂ·ÂºÃ…Ã
	case 39: iConstructionPoint = 500; iWarContribution = 2000; break;	// ÂµÃ°Ã…Ã˜Ã…Ã
	case 40: iConstructionPoint = 1500; iWarContribution = 5000; break;	// Â¿Â¡Â³ÃŠÃÃ¶ Â½Ã‡ÂµÃ¥ ÃÂ¦Â³Ã—Â·Â¹Ã€ÃŒÃ…Ã
	case 41: iConstructionPoint = 5000; iWarContribution = 10000; break;	// Â±Ã—Â·Â£ÂµÃ¥ Â¸Ã…ÃÃ· ÃÂ¦Â³Ã—Â·Â¹Ã€ÃŒÃ…Ã
	case 43: iConstructionPoint =  500; iWarContribution = 1000; break;	// Â¶Ã³Ã€ÃŒÃ†Â® Â¿Ã¶ ÂºÃ±Ã†Â²
	case 44: iConstructionPoint = 1000; iWarContribution = 2000; break;	// Â°Ã­ÃÃ® Ã‡ÃšÂµÃ¥ Â³ÂªÃ€ÃŒÃ†Â®
	case 45: iConstructionPoint = 1500; iWarContribution = 3000; break;	// Â°Ã­ÃÃ® Ã‡ÃšÂµÃ¥ Â±Ã¢ÂºÂ´
	case 46: iConstructionPoint = 1000; iWarContribution = 2000; break;	// Ã…Ã›Ã‡Ãƒ Â³ÂªÃ€ÃŒÃ†Â®
	case 47: iConstructionPoint = 1500; iWarContribution = 3000; break;	// Â¹Ã¨Ã†Â² Â°Ã±Â·Â½
	case 64: m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum(); break;

	}
	
	// Crusade
	if (iConstructionPoint != NULL) {
		switch (cAttackerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
				// Â»Ã§Ã€ÃŒÂµÃ¥Â°Â¡ Â´ÃÂ¶Ã³Â¾ÃŸÂ¸Â¸ Â°Ã‡Â¼Â³ Ã†Ã·Ã€ÃÃ†Â®Â°Â¡ Â°Ã¨Â»ÃªÂµÃˆÂ´Ã™.
				m_pClientList[sAttackerH]->m_iConstructionPoint += iConstructionPoint;

				if (m_pClientList[sAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[sAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
				if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				//testcode
				wsprintf(G_cTxt, "Enemy Npc Killed by player! Construction: +%d WarContribution: +%d", iConstructionPoint, iWarContribution);
				PutLogList(G_cTxt);

				SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
			}
			else {
				// Â°Â°Ã€ÂºÃ†Ã­ NPCÂ¸Â¦ ÃÃ—Ã€ÃŒÂ¸Ã© Ã€Ã¼Ã€Ã¯ Â°Ã¸Ã‡Ã¥ÂµÂµÂ°Â¡ 2Â¹Ã¨Â·Ã Â¶Â³Â¾Ã®ÃÃ¸Â´Ã™.
				m_pClientList[sAttackerH]->m_iWarContribution   -= (iWarContribution*2);
				if (m_pClientList[sAttackerH]->m_iWarContribution < 0)
					m_pClientList[sAttackerH]->m_iWarContribution = 0;

				//testcode
				wsprintf(G_cTxt, "Friendly Npc Killed by player! WarContribution: -%d", iWarContribution);
				PutLogList(G_cTxt);

				SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
			}
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sAttackerH]->m_iGuildGUID != NULL) {
				if (m_pNpcList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
					// Ã€Ã¼Ã€Ã¯Â¿Ã« Â±Â¸ÃÂ¶Â¹Â° ÃˆÂ¤Ã€Âº Ã€Â¯Â´ÃÃ†Â®Â°Â¡ Ã€Ã» NPCÂ¸Â¦ ÃÃ—Â¿Â´Â´Ã™. Â¹Ã™Â·Ã Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™.
					// Ã‡Ã¶Ã€Ã§ Â¼Â­Â¹Ã¶Â¿Â¡ ÃÃ¶ÃˆÃ–Â°Ã¼Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© Â°Ã°Â¹Ã™Â·Ã Ã…Ã«ÂºÂ¸. Â¾Ã¸Ã€Â¸Â¸Ã© Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Â·Ã Â¾Ã‹Â·ÃÃÃœ.
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[sAttackerH]->m_iGuildGUID) &&
						(m_pClientList[i]->m_iCrusadeDuty == 3)) {
						
						m_pClientList[i]->m_iConstructionPoint += iConstructionPoint;
						if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
							m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

						//testcode
						wsprintf(G_cTxt, "Enemy Npc Killed by Npc! Construct point +%d", iConstructionPoint);
						PutLogList(G_cTxt);
						// ÃÃ¶ÃˆÃ–Â°Ã¼Â¿Â¡Â°Ã” Â¹Ã™Â·Ã Ã…Ã«ÂºÂ¸.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
						goto NKH_GOTOPOINT1;
					}
				
					// Ã‡Ã¶Ã€Ã§ Â¼Â­Â¹Ã¶Â¿Â¡ Â¾Ã¸Â´Ã™. Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Ã€Ã‡ ÃÃ¶ÃˆÃ–Â°Ã¼Â¿Â¡Â°Ã” Â¾Ã‹Â·ÃÂ¾ÃŸ Ã‡Ã‘Â´Ã™.
					ZeroMemory(cData, sizeof(cData));
					cp = (char *)cData;
					*cp = GSM_CONSTRUCTIONPOINT;
					cp++;
					ip = (int*)cp;
					*ip = m_pNpcList[sAttackerH]->m_iGuildGUID;
					cp += 4;
					ip = (int*)cp;
					*ip = iConstructionPoint;
					cp += 4;
					bStockMsgToGateServer(cData, 9);
				}
			}
			break;
		}
	}

NKH_GOTOPOINT1:;

	// v1.411 Â¸Â¸Â¾Ã  ExplosiveÃ‡Ã‘ Â¸Ã³Â½ÂºÃ…ÃÂ°Â¡ ÃÃ—Ã€Âº Â°Ã…Â¶Ã³Â¸Ã© Explosive
	if (m_pNpcList[iNpcH]->m_cSpecialAbility == 7) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 30); 
	}
	else if (m_pNpcList[iNpcH]->m_cSpecialAbility == 8) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 61); 
	}

	/*if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject == 0) && (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iApocalypseMobGenType  == 2) {
		//sub_428CD0
	}

	if (m_pNpcList[]->m_bIsApocalypseBoss == TRUE) {
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		var_BC = m_pNpcList[iNpcH]->m_cMapIndex;
		if (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (var_BC >= 0) && (var_BC < DEF_MAXMAPS) {
			if ((m_pMapList[var_BC] != NULL) && (m_pMapList[var_BC]->m_bRecallImpossible == TRUE)) {
				m_pClientList[]->m_iTimeLeft_ForceRecall = 200;
				m_pClientList[i]->m_bIsImpossibleZone = TRUE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FORCERECALLTIME,  m_pClientList[iClientH]->m_iTimeLeft_ForceRecall , NULL, NULL, NULL);
			}
		}
	}*/

	if ((m_bIsHeldenianMode == TRUE) && (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) && (m_cHeldenianModeType == 1)) {
		iMapIndex = 0;
		iMapIndex = m_pNpcList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cMapIndex;
		if ((m_pNpcList[iNpcH]->m_sType == 87) || (m_pNpcList[iNpcH]->m_sType == 89)) {
			if (m_pNpcList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cSide == 1) {
				m_iHeldenianAresdenLeftTower--;
				wsprintf(G_cTxt, "Aresden Tower Broken, Left TOWER %d", m_iHeldenianAresdenLeftTower);
			}
			else if (m_pNpcList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cSide == 2) {
				m_iHeldenianElvineLeftTower--;
				wsprintf(G_cTxt, "Elvine Tower Broken, Left TOWER %d", m_iHeldenianElvineLeftTower);
			}
			PutLogList(G_cTxt);
			UpdateHeldenianStatus();
		}
		if ((m_iHeldenianElvineLeftTower == 0) || (m_iHeldenianAresdenLeftTower == 0)) {
			GlobalEndHeldenianMode();
		}
	}
}

int CGame::iGetDangerValue(int iNpcH, short dX, short dY)
{
 register int ix, iy, iDangerValue;
 short sOwner, sDOType;
 char  cOwnerType;
 DWORD dwRegisterTime;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;

	iDangerValue = 0;

	for (ix = dX - 2; ix <= dX + 2; ix++)
	for (iy = dY - 2; iy <= dY + 2; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);	
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bGetDynamicObject( ix, iy, &sDOType, &dwRegisterTime );
		
		if (sDOType == 1) iDangerValue++;

		switch (cOwnerType) {
		case NULL:
			break;
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwner] == NULL) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;
		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwner] == NULL) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pNpcList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;
		}
	}

	return iDangerValue;
}

void CGame::NpcBehavior_Flee(int iNpcH)
{
 char cDir;
 short sX, sY, dX, dY;
 short sTarget;
 char  cTargetType;

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	// ÅÏ Ä«¿îÆ® Áõ°¡. 
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

	// °ø°İ ÀÎ°øÁö´É¿¡ ´ëÇÑ È¿°ú°è»ê.
	switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
	case DEF_ATTACKAI_EXCHANGEATTACK: // °ø°İ -> ÈÄÅğ -> ... 
	case DEF_ATTACKAI_TWOBYONEATTACK: // °ø°İ -> °ø°İ -> ÈÄÅğ -> ...
		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 2) {
			// ´Ù½Ã °ø°İ ¸ğµå·Î ÀüÈ¯.
			m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			return;
		}
		break;
	
	default:
		if (iDice(1,2) == 1) NpcRequestAssistance(iNpcH);
		break;
	}

	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 10) {
		// 10¹øÀÇ ÅÏ¸¸ µµ¸ÁÇÑ ÈÄ ´Ù½Ã ÀÌµ¿¸ğµå·Î º¯È¯.
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
		m_pNpcList[iNpcH]->m_tmp_iError         = 0;
		if (m_pNpcList[iNpcH]->m_iHP <= 3) {
			m_pNpcList[iNpcH]->m_iHP += iDice(1, m_pNpcList[iNpcH]->m_iHitDice); // ! ¿¡³ÊÁö ºÎÁ·À¸·Î µµ¸ÁÃÆÀ»¶§ ¼º°øÀûÀ¸·Î µµ¸ÁÃÆÀ¸¹Ç·Î ¿¡³ÊÁö Áõ°¡.
			if (m_pNpcList[iNpcH]->m_iHP <= 0) m_pNpcList[iNpcH]->m_iHP = 1;
		}
		return;
	}

	// µµ¸ÁÄ¡´Âµ¥ À§ÇùÀÌ µÇ´Â °¡±î¿î ¸ñÇ¥¹°À» °Ë»öÇÑ´Ù.
	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if (sTarget != NULL) {
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
	}

	// ¸ñÇ¥¹°°ú ÀÚ½ÅÀÇ À§Ä¡¸¦ ±¸ÇÑ´Ù. ¹İ´ë¹æÇâÀ¸·Î µµ¸ÁÄ¡±â À§ÇÔ.
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	case DEF_OWNERTYPE_NPC:
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}
	dX = sX - (dX - sX);
	dY = sY - (dY - sY);

	cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
	if (cDir == 0) {
		// ÀÌµ¿ÇÒ ¼ö ¾ø´Ù. 
	}
	else {
		dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
		dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
		// ¿¹Àü À§Ä¡¿¡¼­ Áö¿î´Ù. 
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		// »õ À§Ä¡¿¡ Ç¥½ÃÇÑ´Ù. 
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
		m_pNpcList[iNpcH]->m_sX   = dX;
		m_pNpcList[iNpcH]->m_sY   = dY;
		m_pNpcList[iNpcH]->m_cDir = cDir;
		SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
	}
}

void CGame::MsgProcess()
{
 char   * pData, cFrom, cKey;
 DWORD    dwMsgSize, * dwpMsgID;
 WORD   * wpMsgType, * wp;
 int      i, iClientH;
 char   m_msgBuff[1000];
	
	if ((m_bF5pressed == TRUE) && (m_bF1pressed == TRUE)) {
		PutLogList("(XXX) RELOADING CONFIGS MANUALY...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
				}
				bInit();
		}

	if ((m_bF1pressed == TRUE) && (m_bF4pressed == TRUE) && (m_bOnExitProcess == FALSE)) {
		// Â¸Ã°ÂµÃ§ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Ã€Ã‡ ÂµÂ¥Ã€ÃŒÃ…ÃÂ¸Â¦ Ã€ÃºÃ€Ã¥Ã‡Ã‘ ÃˆÃ„ Ã‡ÃÂ·ÃÂ±Ã—Â·Â¥Ã€Â» ÃÂ¾Â·Ã¡Ã‡Ã˜Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
		m_cShutDownCode      = 2;
		m_bOnExitProcess     = TRUE;
		m_dwExitProcessTime  = timeGetTime();
		// Â°Ã”Ã€Ã“ Â¼Â­Â¹Ã¶ Â¼Ã‹Â´Ã™Â¿Ã®Ã€ÃŒ Â½ÃƒÃ€Ã›ÂµÃ‡Â¸Ã© Â´ÃµÃ€ÃŒÂ»Ã³Ã€Ã‡ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® ÃÂ¢Â¼Ã“Ã€ÃŒ Â°Ã…ÂºÃÂµÃˆÂ´Ã™. 
		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Local command)!!!");
		// Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â¿Â¡Â°Ã” Ã‡Ã¶Ã€Ã§ Â¼Â­Â¹Ã¶Â°Â¡ Â¼Ã‹Â´Ã™Â¿Ã® ÃÃŸÃ€Ã“Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
		bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
		// OccupyFlag ÂµÂ¥Ã€ÃŒÃ…Ã Ã€ÃºÃ€Ã¥ 
		if (m_iMiddlelandMapIndex > 0) {
			// Crusade
			SaveOccupyFlagData();
			//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
			//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
		}
		
		return;
	}
	
	ZeroMemory(m_pMsgBuffer, DEF_MSGBUFFERSIZE+1);
	pData = (char *)m_pMsgBuffer;

	m_iCurMsgs = 0;
	while (bGetMsgQuene(&cFrom, pData, &dwMsgSize, &iClientH, &cKey) == TRUE) {
		
		//v1.31 ÃƒÂ³Â¸Â®Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ Â°Â¹Â¼Ã¶Â¸Â¦ Ã„Â«Â¿Ã®Ã†Â®Ã‡Ã‘Â´Ã™.
		m_iCurMsgs++;
		if (m_iCurMsgs > m_iMaxMsgs) m_iMaxMsgs = m_iCurMsgs;

		switch (cFrom) {
		case DEF_MSGFROM_GATESERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

			switch (*dwpMsgID) {
			// New 07/05/2004
			case MSGID_PARTYOPERATION:
				PartyOperationResultHandler(pData);
				break;

			case MSGID_SERVERSTOCKMSG:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_SERVERSTOCKMSG");
				ServerStockMsgHandler(pData);
				break;
									
			case MSGID_SENDSERVERSHUTDOWNMSG:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_SENDSERVERSHUTDOWNMSG");
				// Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶ Â¼Ã‹Â´Ã™Â¿Ã®Ã‡Ã‘Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ Â¼Ã¶Â½Ã…ÂµÃ‡Â¾ÃºÂ´Ã™. 
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				switch (*wp) {
				case 1:
					PutLogList("(!) Send server shutdown announcement - 1.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
					}
					break;
				
				case 2:
					PutLogList("(!) Send server shutdown announcement - 2.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
					}
					break;
				}

				// WLSÂ·Ã Â¼Ã‹Â´Ã™Â¿Ã®Ã‡Ã‘Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶. Ã€ÃŒ Â¸ÃÂ½ÃƒÃÃ¶Â°Â¡ Ã€Ã¼Â´ÃÂµÃ‡Â¸Ã© Ã‡Ã˜Â´Ã§ WLS Ã€Ã¼ÃƒÂ¼Ã€Ã‡ Â»Ãµ Â»Ã§Â¿Ã«Ã€ÃšÂ¿Â¡ Â´Ã«Ã‡Ã‘ ÃÂ¢Â¼Ã“Ã€ÃŒ Â°Ã…ÂºÃÂµÃˆÂ´Ã™. Ã€ÃŒ Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶Â¸Â¸ Â¹ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â°ÃÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™.
				bSendMsgToLS(MSGID_SENDSERVERSHUTDOWNMSG, NULL, NULL); 
				break;
			
			case MSGID_GAMESERVERSHUTDOWNED:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_GAMESERVERSHUTDOWNED");
				// Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶Â¸Â¦ Â¼Ã‹Â´Ã™Â¿Ã®Â½ÃƒÃ…Â°Â¶Ã³Â´Ã‚ Â±Ã›Â·ÃÂ¹Ãº Â¸Ã­Â·Ã‰Ã€ÃŒ Â¼Ã¶Â½Ã…ÂµÃ‡Â¾ÃºÂ´Ã™. 
				m_cShutDownCode      = 1;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				// Â°Ã”Ã€Ã“ Â¼Â­Â¹Ã¶ Â¼Ã‹Â´Ã™Â¿Ã®Ã€ÃŒ Â½ÃƒÃ€Ã›ÂµÃ‡Â¸Ã© Â´ÃµÃ€ÃŒÂ»Ã³Ã€Ã‡ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® ÃÂ¢Â¼Ã“Ã€ÃŒ Â°Ã…ÂºÃÂµÃˆÂ´Ã™. 
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Global command)!!!");
				// Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â¿Â¡Â°Ã” Ã‡Ã¶Ã€Ã§ Â¼Â­Â¹Ã¶Â°Â¡ Â¼Ã‹Â´Ã™Â¿Ã® ÃÃŸÃ€Ã“Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
				bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
				// OccupyFlag ÂµÂ¥Ã€ÃŒÃ…Ã Ã€ÃºÃ€Ã¥ 
				if (m_iMiddlelandMapIndex > 0) {
					// Crusade
					SaveOccupyFlagData();
					//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
					//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
				}
				break;
			
			case MSGID_TOTALGAMESERVERCLIENTS:
				// Ã‡Ã¶Ã€Ã§ ÂºÃÂ»Ãª Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶Ã€Ã‡ ÃƒÃ‘ Â»Ã§Â¿Ã«Ã€Ãš Â¼Ã¶Ã€ÃŒÂ´Ã™. 
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				m_iTotalGameServerClients = (int)*wp;
				if (m_iTotalGameServerClients > m_iTotalGameServerMaxClients) 
					m_iTotalGameServerMaxClients = m_iTotalGameServerClients;
				break;
			
			case MSGID_RESPONSE_REGISTERGAMESERVER:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER");
				switch (*wpMsgType) {
				case DEF_MSGTYPE_CONFIRM:
					//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_CONFIRM");
					PutLogList("(!) Game Server registration to Gate Server - Success!");
					m_bIsGateSockAvailable = TRUE;
					break;

				case DEF_MSGTYPE_REJECT:
					//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_REJECT");
					PutLogList("(!) Game Server registration to Gate Server - Fail!");
					PutLogList(" ");
					PutLogList("(!!!) STOPPED!");
					break;
				}
				
				//wsprintf(G_cTxt, "%d %d %d %d %d %d %d", (int)m_bIsGameStarted, (int)m_bIsItemAvailable, m_bIsNpcAvailable, (int)m_bIsGateSockAvailable, (int)m_bIsLogSockAvailable, (int)m_bIsMagicAvailable, (int)m_bIsSkillAvailable);
				//PutLogList(G_cTxt);

				/*
				if ((m_bIsGameStarted == FALSE) && (m_bIsItemAvailable == TRUE) && 
					(m_bIsNpcAvailable == TRUE) && (m_bIsGateSockAvailable == TRUE) &&
					(m_bIsLogSockAvailable == TRUE) && (m_bIsMagicAvailable == TRUE) &&
					(m_bIsSkillAvailable == TRUE) && (m_bIsPortionAvailable == TRUE) &&
					(m_bIsQuestAvailable == TRUE) ) {
					// Â°Ã”Ã€Ã“Ã€Â» Â½ÃƒÃ€Ã›Ã‡Ã’ ÃÃ˜ÂºÃ±Â°Â¡ ÂµÃ‡Â¾ÃºÂ´Ã™. Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
					SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL); 
					m_bIsGameStarted = TRUE;
				}
				*/
				break;
			}
			break;
		
		case DEF_MSGFROM_CLIENT:
			/*m_pClientList[iClientH]->m_cConnectionCheck++;
			if (m_pClientList[iClientH]->m_cConnectionCheck > 3) {
				wsprintf(G_cTxt, "Client Hex Edit: (%s) Player: (%s) - has removed 3203203 (check connection handler).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				PutHackLogFileList(G_cTxt);
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}*/

			dwpMsgID = (DWORD *)(pData + DEF_INDEX4_MSGID);
			switch (*dwpMsgID) { // 84148741
						
			case DEF_REQUEST_RESURRECTPLAYER_YES:
				RequestResurrectPlayer(iClientH, TRUE);
				break;

			case DEF_REQUEST_RESURRECTPLAYER_NO:
				RequestResurrectPlayer(iClientH, FALSE);
				break;

			case MSGID_REQUEST_SELLITEMLIST:
				RequestSellItemListHandler(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RESTART:
				RequestRestartHandler(iClientH);
				break;

			case MSGID_REQUEST_PANNING:
				iRequestPanningMapDataRequest(iClientH, pData);
				break;

			case MSGID_REQUEST_NOTICEMENT:
				RequestNoticementHandler(iClientH, pData);
				break;
			
			case MSGID_BWM_COMMAND_SHUTUP:
				_BWM_Command_Shutup(pData);
				break;
			
			case MSGID_BWM_INIT:
				_BWM_Init(iClientH, pData);
				break;
			
			case MSGID_REQUEST_SETITEMPOS:
				_SetItemPos(iClientH, pData);
				break;
			
			case MSGID_ADMINUSER:
				RequestAdminUserMode(iClientH, pData);
				break;
			
			case MSGID_REQUEST_FULLOBJECTDATA:
				RequestFullObjectData(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RETRIEVEITEM:
				RequestRetrieveItemHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_CIVILRIGHT:
				RequestCivilRightHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_TELEPORT:
				RequestTeleportHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_INITPLAYER:
				RequestInitPlayerHandler(iClientH, pData, cKey);
				break;

			case MSGID_REQUEST_INITDATA:
				RequestInitDataHandler(iClientH, pData, cKey);
				break;

			case MSGID_COMMAND_COMMON:
				ClientCommonHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_MOTION:
				ClientMotionHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_CHECKCONNECTION:
				CheckConnectionHandler(iClientH, pData);
				break;

			case MSGID_COMMAND_CHATMSG:
				ChatMsgHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_CREATENEWGUILD:
				RequestCreateNewGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_DISBANDGUILD:
				RequestDisbandGuildHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_FIGHTZONE_RESERVE:
				FightzoneReserveHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_LEVELUPSETTINGS:
				LevelUpSettingsHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_STATECHANGEPOINT:
				StateChangeHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_REQUEST_HELDENIANTELEPORT:
				RequestHeldenianTeleport(iClientH, pData, dwMsgSize);
				break;


			case MSGID_REQUEST_CITYHALLTELEPORT:
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden",7) == 0 ) {
					  RequestTeleportHandler(iClientH, "2   ", "dglv2", 263, 258);
				}
				else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine",6) == 0 ) {
				  RequestTeleportHandler(iClientH, "2   ", "dglv2", 209, 258);
				}
			break;

			default:
				wsprintf(m_msgBuff,"Unknown message received! (0x%.8X) Delete Client",*dwpMsgID);
				PutLogList(m_msgBuff);
				DeleteClient(iClientH, TRUE, TRUE); // v1.4
				break;
			}	
			break;

		case DEF_MSGFROM_LOGSERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

			switch (*dwpMsgID) {
			case MSGID_REQUEST_CHECKACCOUNTPASSWORD:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_REQUEST_CHECKACCOUNTPASSWORD");
				// Â°Ã¨ÃÂ¤Ã€Ã‡ Ã†ÃÂ½ÂºÂ¿Ã¶ÂµÃ¥Â¸Â¦ ÂºÃ±Â±Â³ 
				RequestCheckAccountPasswordHandler(pData, dwMsgSize);
				break;
			
			case MSGID_REQUEST_FORCEDISCONECTACCOUNT:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_REQUEST_FORCEDISCONECTACCOUNT");
				// Â°Â­ÃÂ¦ Â°Ã¨ÃÂ¤ ÃÂ¢Â¼Ã“ ÃÂ¾Â·Ã¡. ÂµÂ¥Ã€ÃŒÃ…ÃÂ¸Â¦ Ã€ÃºÃ€Ã¥Ã‡ÃÂ°Ã­ ÃÂ¢Â¼Ã“Ã€Â» ÃÂ¾Â·Ã¡Â½ÃƒÃ…Â²Â´Ã™. 
				wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
				ForceDisconnectAccount((char *)(pData + DEF_INDEX2_MSGTYPE + 2), *wpMsgType);
				break;
			
			case MSGID_RESPONSE_SAVEPLAYERDATA_REPLY:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_SAVEPLAYERDATA_REPLY");
				// Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ ÂµÂ¥Ã€ÃŒÃ…ÃÂ°Â¡ Ã€ÃºÃ€Ã¥ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â¸Â®Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ 
				ResponseSavePlayerDataReplyHandler(pData, dwMsgSize);
				break;
			
			case MSGID_GUILDNOTIFY:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_GUILDNOTIFY");
				// Â´Ã™Â¸Â¥ Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶Â¿Â¡Â¼Â­ Â¹ÃŸÂ»Ã½Ã‡Ã‘ Â±Ã¦ÂµÃ¥ Ã€ÃŒÂºÂ¥Ã†Â®Â¿Â¡ Â´Ã«Ã‡Ã‘ Ã…Ã«ÂºÂ¸(Â±Ã¦ÂµÃ¥Â¿Ã¸ Â°Â¡Ã€Ã”, Â±Ã¦ÂµÃ¥Â¿Ã¸ Ã…Â»Ã…Ã°, Â±Ã¦ÂµÃ¥ Ã‡Ã˜Â»Ãª ÂµÃ®)
				GuildNotifyHandler(pData, dwMsgSize);
				break;
			
			case MSGID_RESPONSE_DISBANDGUILD:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_DISBANDGUILD");
				// Â±Ã¦ÂµÃ¥ Ã‡Ã˜Â»ÃªÂ¿Ã¤Â±Â¸Â¿Â¡ Â´Ã«Ã‡Ã‘ Ã€Ã€Â´Ã¤ 
				ResponseDisbandGuildHandler(pData, dwMsgSize);
				break;

			case MSGID_RESPONSE_CREATENEWGUILD:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_CREATENEWGUILD");
				// Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ Â±Ã¦ÂµÃ¥Â»Ã½Â¼Âº Â¿Ã¤Â±Â¸Â¿Â¡ Â´Ã«Ã‡Ã‘ Ã€Ã€Â´Ã¤. 
				ResponseCreateNewGuildHandler(pData, dwMsgSize);
				break;
			
			case MSGID_RESPONSE_REGISTERGAMESERVER:
				switch (*wpMsgType) {
				case DEF_MSGTYPE_CONFIRM:
					//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_CONFIRM");
					PutLogList("(!) Game Server registration to Log Server - Success!");
					m_bIsLogSockAvailable = TRUE;
					break;

				case DEF_MSGTYPE_REJECT:
					//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_REJECT");
					PutLogList("(!) Game Server registration to Log Server - Fail!");
					break;
				}
		
				if (m_bIsBuildItemAvailable == FALSE) {
					// Â¸Â¸Â¾Ã  ÂºÃ´ÂµÃ¥Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤Ã€Ã‡ ÃˆÂ­Ã€ÃÂ¿Â¡Â¼Â­ Â¿Â¡Â·Â¯Â°Â¡ Ã€Ã–Â¾ÃºÂ´Ã™Â¸Ã© Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶ ÂµÃ®Â·ÃÂ¿Â¡ Â»Ã³Â°Ã¼Â¾Ã¸Ã€ÃŒ ÂµÂ¿Ã€Ã› ÂºÃ’Â°Â¡Â´Ã‰.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Build-Item configuration error.");
				}
								
				if (m_bIsItemAvailable == FALSE) {
					// Â¸Â¸Â¾Ã  Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤Ã€Ã‡ ÃˆÂ­Ã€ÃÂ¿Â¡Â¼Â­ Â¿Â¡Â·Â¯Â°Â¡ Ã€Ã–Â¾ÃºÂ´Ã™Â¸Ã© Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶ ÂµÃ®Â·ÃÂ¿Â¡ Â»Ã³Â°Ã¼Â¾Ã¸Ã€ÃŒ ÂµÂ¿Ã€Ã› ÂºÃ’Â°Â¡Â´Ã‰.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Item configuration error.");
				}
				
				if (m_bIsNpcAvailable == FALSE) {
					// Â¸Â¸Â¾Ã  Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤Ã€Ã‡ ÃˆÂ­Ã€ÃÂ¿Â¡Â¼Â­ Â¿Â¡Â·Â¯Â°Â¡ Ã€Ã–Â¾ÃºÂ´Ã™Â¸Ã© Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶ ÂµÃ®Â·ÃÂ¿Â¡ Â»Ã³Â°Ã¼Â¾Ã¸Ã€ÃŒ ÂµÂ¿Ã€Ã› ÂºÃ’Â°Â¡Â´Ã‰.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Npc configuration error.");
				}

				if (m_bIsMagicAvailable == FALSE) {
					// Â¸Â¸Â¾Ã  MAGIC ÃÂ¤Ã€Ã‡ ÃˆÂ­Ã€ÃÂ¿Â¡Â¼Â­ Â¿Â¡Â·Â¯Â°Â¡ Ã€Ã–Â¾ÃºÂ´Ã™Â¸Ã© Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶ ÂµÃ®Â·ÃÂ¿Â¡ Â»Ã³Â°Ã¼Â¾Ã¸Ã€ÃŒ ÂµÂ¿Ã€Ã› ÂºÃ’Â°Â¡Â´Ã‰.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! MAGIC configuration error.");
				}

				if (m_bIsSkillAvailable == FALSE) {
					// Â¸Â¸Â¾Ã  SKILL ÃÂ¤Ã€Ã‡ ÃˆÂ­Ã€ÃÂ¿Â¡Â¼Â­ Â¿Â¡Â·Â¯Â°Â¡ Ã€Ã–Â¾ÃºÂ´Ã™Â¸Ã© Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶ ÂµÃ®Â·ÃÂ¿Â¡ Â»Ã³Â°Ã¼Â¾Ã¸Ã€ÃŒ ÂµÂ¿Ã€Ã› ÂºÃ’Â°Â¡Â´Ã‰.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! SKILL configuration error.");
				}

				if (m_bIsQuestAvailable == FALSE) {
					// Â¸Â¸Â¾Ã  SKILL ÃÂ¤Ã€Ã‡ ÃˆÂ­Ã€ÃÂ¿Â¡Â¼Â­ Â¿Â¡Â·Â¯Â°Â¡ Ã€Ã–Â¾ÃºÂ´Ã™Â¸Ã© Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶ ÂµÃ®Â·ÃÂ¿Â¡ Â»Ã³Â°Ã¼Â¾Ã¸Ã€ÃŒ ÂµÂ¿Ã€Ã› ÂºÃ’Â°Â¡Â´Ã‰.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! QUEST configuration error.");
				}

				if (m_bIsPortionAvailable == FALSE) {
					// Â¸Â¸Â¾Ã  Portion ÃÂ¤Ã€Ã‡ ÃˆÂ­Ã€ÃÂ¿Â¡Â¼Â­ Â¿Â¡Â·Â¯Â°Â¡ Ã€Ã–Â¾ÃºÂ´Ã™Â¸Ã© Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶ ÂµÃ®Â·ÃÂ¿Â¡ Â»Ã³Â°Ã¼Â¾Ã¸Ã€ÃŒ ÂµÂ¿Ã€Ã› ÂºÃ’Â°Â¡Â´Ã‰.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! PORTION configuration error.");
				}

				//wsprintf(G_cTxt, "%d %d %d %d %d %d %d", (int)m_bIsGameStarted, (int)m_bIsItemAvailable, m_bIsNpcAvailable, (int)m_bIsGateSockAvailable, (int)m_bIsLogSockAvailable, (int)m_bIsMagicAvailable, (int)m_bIsSkillAvailable);
				//PutLogList(G_cTxt);

				/*
				if ((m_bIsGameStarted == FALSE) && (m_bIsItemAvailable == TRUE) && 
					(m_bIsNpcAvailable == TRUE) && (m_bIsGateSockAvailable == TRUE) &&
					(m_bIsLogSockAvailable == TRUE) && (m_bIsMagicAvailable == TRUE) &&
					(m_bIsSkillAvailable == TRUE) && (m_bIsPortionAvailable == TRUE) &&
					(m_bIsQuestAvailable == TRUE) ) {
					// Â°Ã”Ã€Ã“Ã€Â» Â½ÃƒÃ€Ã›Ã‡Ã’ ÃÃ˜ÂºÃ±Â°Â¡ ÂµÃ‡Â¾ÃºÂ´Ã™. Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
					SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL); 
					m_bIsGameStarted = TRUE;
				}
				*/
				break;

			case MSGID_RESPONSE_PLAYERDATA:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_PLAYERDATA");
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® ÂµÂ¥Ã€ÃŒÃ…ÃÂ°Â¡ ÂµÂµÃ‚Ã¸Ã‡ÃŸÂ´Ã™. 
				ResponsePlayerDataHandler(pData, dwMsgSize);
				break;

			case MSGID_BUILDITEMCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_BUILDITEMCONFIGURATIONCONTENTS");
				// Build Item contents
				PutLogList("(!) BUILD-ITEM configuration contents received. Now decoding...");
				m_bIsBuildItemAvailable = _bDecodeBuildItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			
			case MSGID_ITEMCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_ITEMCONFIGURATIONCONTENTS");
				// Â·ÃÂ±Ã—Â¼Â­Â¹Ã¶Â·ÃÂºÃÃ…Ã Â¾Ã†Ã€ÃŒÃ…Ã› Ã„ÃÃ‡Ã‡Â±Ã”Â·Â¹Ã€ÃŒÂ¼Ã‡ ÂµÂ¥Ã€ÃŒÃ…ÃÂ°Â¡ ÂµÂµÃ‚Ã¸Ã‡ÃŸÂ´Ã™.
				PutLogList("(!) ITEM configuration contents received. Now decoding...");
				m_bIsItemAvailable = _bDecodeItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NPCCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_NPCCONFIGURATIONCONTENTS");
				// NPC Ã„ÃÃ‡Ã‡Â±Ã”Â·Â¹Ã€ÃŒÂ¼Ã‡ ÂµÂ¥Ã€ÃŒÃ…ÃÂ°Â¡ ÂµÂµÃ‚Ã¸Ã‡ÃŸÂ´Ã™. 
				PutLogList("(!) NPC configuration contents received. Now decoding...");
				m_bIsNpcAvailable = _bDecodeNpcConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			
			case MSGID_MAGICCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_MAGICCONFIGURATIONCONTENTS");
				PutLogList("(!) MAGIC configuration contents received. Now decoding...");
				m_bIsMagicAvailable = _bDecodeMagicConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_SKILLCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_SKILLCONFIGURATIONCONTENTS");
				PutLogList("(!) SKILL configuration contents received. Now decoding...");
				m_bIsSkillAvailable = _bDecodeSkillConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_QUESTCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_QUESTCONFIGURATIONCONTENTS");
				PutLogList("(!) QUEST configuration contents received. Now decoding...");
				m_bIsQuestAvailable = _bDecodeQuestConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_PORTIONCONFIGURATIONCONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_PORTIONCONFIGURATIONCONTENTS");
				PutLogList("(!) PORTION configuration contents received. Now decoding...");
				m_bIsPortionAvailable = _bDecodePortionConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			// Crusade
			//case MSGID_ARESDENOCCUPYFLAGSAVEFILECONTENTS:
				//PutLogList("(!) Aresden OccupyFlag save file contents received. Now decoding...");
				//_bDecodeOccupyFlagSaveFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize, 1);
				//break;

			// Crusade
			//case MSGID_ELVINEOCCUPYFLAGSAVEFILECONTENTS:
				//PutLogList("(!) Elvine OccupyFlag save file contents received. Now decoding...");
				//_bDecodeOccupyFlagSaveFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize, 2);
				//break;

			case MSGID_DUPITEMIDFILECONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_DUPITEMIDFILECONTENTS");
				PutLogList("(!) DupItemID file contents received. Now decoding...");
				_bDecodeDupItemIDFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NOTICEMENTFILECONTENTS:
				//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_NOTICEMENTFILECONTENTS");
				PutLogList("(!) Noticement file contents received. Now decoding...");
				_bDecodeNoticementFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			// v2.17 2002-8-7 // 2002-09-06 #1
			/*case MSGID_NPCITEMCONFIGCONTENTS:
				PutLogList("(!) NpcItemConfig file contents received. Now decoding...");
				_bDecodeNpcItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;*/

			}
			break;
		}
	}

}


BOOL CGame::bPutMsgQuene(char cFrom, char * pData, DWORD dwMsgSize, int iIndex, char cKey)
{
	/*
	HANDLE hMutex;
	
	hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, m_cServerName);
	if (hMutex != NULL) return FALSE; // Â¹Ã‚Ã…Ã˜Â½ÂºÂ°Â¡ Â»Ã½Â¼ÂºÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™. Â¾Ã®ÂµÃ°Â¼Â±Â°Â¡ Ã…Â¥Â¸Â¦ ÃÂ¶Ã€Ã›ÃÃŸÃ€ÃŒÂ´Ã™. Â±Ã—Â³Ã‰ Â¸Â®Ã…Ã 

	hMutex = CreateMutex(NULL, FALSE, m_cServerName);
	*/
	// Â¸ÃÂ½ÃƒÃÃ¶ Ã…Â¥Â°Â¡ Â´Ã™ ÃƒÂ¡Â´Ã™Â¸Ã© Â¿Â¡Â·Â¯ 
	if (m_pMsgQuene[m_iQueneTail] != NULL) return FALSE;

	// Â¸ÃÂ¸Ã°Â¸Â® Ã‡Ã’Â´Ã§Ã€ÃŒ Ã€ÃŸÂ¸Ã¸ÂµÃ‡Â¾Ã®ÂµÂµ Â¿Â¡Â·Â¯ 
	m_pMsgQuene[m_iQueneTail] = new class CMsg;
	if (m_pMsgQuene[m_iQueneTail] == NULL) return FALSE;

	if (m_pMsgQuene[m_iQueneTail]->bPut(cFrom, pData, dwMsgSize, iIndex, cKey) == FALSE) return FALSE;

	m_iQueneTail++;
	if (m_iQueneTail >= DEF_MSGQUENESIZE) m_iQueneTail = 0;

	// Â¹Ã‚Ã…Ã˜Â½Âº Â¹ÃÃˆÂ¯
	//ReleaseMutex(hMutex);

	return TRUE;
}


BOOL CGame::bGetMsgQuene(char * pFrom, char * pData, DWORD * pMsgSize, int * pIndex, char * pKey)
{
	/*
	HANDLE hMutex;
	
	hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, m_cServerName);
	if (hMutex != NULL) return FALSE; // Â¹Ã‚Ã…Ã˜Â½ÂºÂ°Â¡ Â»Ã½Â¼ÂºÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™. Â¾Ã®ÂµÃ°Â¼Â±Â°Â¡ Ã…Â¥Â¸Â¦ ÃÂ¶Ã€Ã›ÃÃŸÃ€ÃŒÂ´Ã™. Â±Ã—Â³Ã‰ Â¸Â®Ã…Ã 

	hMutex = CreateMutex(NULL, FALSE, m_cServerName);
	*/
	// Â°Â¡ÃÂ®Â°Â¥ Â¸ÃÂ½ÃƒÃÃ¶Â°Â¡ Â¾Ã¸Ã€Â¸Â¸Ã© Â¿Â¡Â·Â¯  
	if (m_pMsgQuene[m_iQueneHead] == NULL) return FALSE;

	m_pMsgQuene[m_iQueneHead]->Get(pFrom, pData, pMsgSize, pIndex, pKey);

	delete m_pMsgQuene[m_iQueneHead];
	m_pMsgQuene[m_iQueneHead] = NULL;

	m_iQueneHead++;
	if (m_iQueneHead >= DEF_MSGQUENESIZE) m_iQueneHead = 0;

	// Â¹Ã‚Ã…Ã˜Â½Âº Â¹ÃÃˆÂ¯
	//ReleaseMutex(hMutex);

	return TRUE;
}


void CGame::ClientCommonHandler(int iClientH, char * pData)
{
 WORD * wp, wCommand;
 short * sp, sX, sY; 
 int   * ip, iV1, iV2, iV3, iV4;
 char  * cp, cDir, * pString;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;
 
	ip = (int *)cp;
	iV1 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV2 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV3 = *ip;
	cp += 4;

	pString = cp;
	cp += 30;
	
	ip = (int *)cp;
	iV4 = *ip;
	cp += 4;
	
	switch (wCommand) {

	// New 15/05/2004
	case DEF_COMMONTYPE_REQ_CREATESLATE:
		ReqCreateSlateHandler(iClientH, pData);
		break;

// 2.06 - by KLKS
	case DEF_COMMONTYPE_REQ_CHANGEPLAYMODE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> MSGID_REQUEST_CIVILRIGHT");
		RequestChangePlayMode(iClientH);
		break;
//

	case DEF_COMMONTYPE_SETGUILDTELEPORTLOC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETGUILDTELEPORTLOC");
		RequestSetGuildTeleportLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, "middleland");
		break;

	case DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC");
		RequestSetGuildConstructLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;
	
	case DEF_COMMONTYPE_GUILDTELEPORT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GUILDTELEPORT");
		RequestGuildTeleportHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_SUMMONWARUNIT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SUMMONWARUNIT");
		RequestSummonWarUnitHandler(iClientH, sX, sY, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQUEST_HELP:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_HELP");
		RequestHelpHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_MAPSTATUS:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_MAPSTATUS");
		MapStatusHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY");
		SelectCrusadeDutyHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQUEST_CANCELQUEST:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_CANCELQUEST");
		CancelQuestHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY");
		ActivateSpecialAbilityHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_JOINPARTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_JOINPARTY");
		JoinPartyHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_GETMAGICABILITY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GETMAGICABILITY");
		GetMagicAbilityHandler(iClientH);
		break;

	case DEF_COMMONTYPE_BUILDITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_BUILDITEM");
		BuildItemHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_QUESTACCEPTED:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_QUESTACCEPTED");
		QuestAcceptedHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_CANCELEXCHANGEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_CANCELEXCHANGEITEM");
		CancelExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_CONFIRMEXCHANGEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_CONFIRMEXCHANGEITEM");
		ConfirmExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_SETEXCHANGEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETEXCHANGEITEM");
		SetExchangeItem(iClientH, iV1, iV2);
		break;
	
	case DEF_COMMONTYPE_REQ_GETHEROMANTLE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETHEROMANTLE");
		GetHeroMantleHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_GETOCCUPYFLAG:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETOCCUPYFLAG");
		GetOccupyFlagHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX");
		SetDownSkillIndexHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_TALKTONPC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TALKTONPC");
		// works for client, but for npc it returns middleland
		// if ((m_pMapList[m_pNpcList[iV1]->m_cMapIndex]->m_cName) != (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) break;
		NpcTalkHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQ_CREATEPORTION:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_CREATEPORTION");
		ReqCreatePortionHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_REQ_GETFISHTHISTIME:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETFISHTHISTIME");
		ReqGetFishThisTimeHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM");
		ReqRepairItemCofirmHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_REPAIRITEM");
		ReqRepairItemHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEMCONFIRM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SELLITEMCONFIRM");
		ReqSellItemConfirmHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SELLITEM");
		ReqSellItemHandler(iClientH, iV1, iV2, iV3, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_USESKILL:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_USESKILL");
		UseSkillHandler(iClientH, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQ_USEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_USEITEM");
		UseItemHandler(iClientH, iV1, iV2, iV3, iV4);
		break;
	
	case DEF_COMMONTYPE_REQ_GETREWARDMONEY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETREWARDMONEY");
		GetRewardMoneyHandler(iClientH);
		break;

	case DEF_COMMONTYPE_ITEMDROP:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_ITEMDROP");
		DropItemHandler(iClientH, iV1, iV2, pString, TRUE);
		break;
	
	case DEF_COMMONTYPE_EQUIPITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_EQUIPITEM");
		// Â¿Â©Â±Ã¢Â¼Â­Â´Ã‚ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÂ¯ÃˆÂ­Â¸Â¸Ã€Â» Â´Ã™Â·Ã©Â´Ã™.
		bEquipItemHandler(iClientH, iV1);
		// Â¹Ã™Â²Ã¯ Â¿ÃœÃ‡Ã¼Â¿Â¡ Â´Ã«Ã‡Ã‘ ÃÂ¤ÂºÂ¸Â¸Â¦ Â¿Â©Â±Ã¢Â¼Â­ Ã€Ã¼Â¼Ã›Ã‡Ã‘Â´Ã™.
		// .....
		break;

	case DEF_COMMONTYPE_REQ_PURCHASEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_PURCHASEITEM");
		// Â¾Ã†Ã€ÃŒÃ…Ã› Â±Â¸Ã€Ã” Â¿Ã¤Â±Â¸. Â»Ã§Â½Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Âº Ã€Ã¥Â¼Ã’Â¿Â¡ Â»Ã³Â°Ã¼Â¾Ã¸Ã€ÃŒ Â¾Ã®ÂµÃ°Â¼Â­Â¶Ã³ÂµÂµ Â±Â¸Ã€Ã”Ã‡Ã’ Â¼Ã¶ Ã€Ã–Â´Ã™.
		RequestPurchaseItemHandler(iClientH, pString, iV1);
		break;

	case DEF_COMMONTYPE_REQ_STUDYMAGIC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_STUDYMAGIC");
		// Â¸Â¶Â¹Ã½Ã€Â» Â¹Ã¨Â¿Ã®Â´Ã™ 
		RequestStudyMagicHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_REQ_TRAINSKILL:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_TRAINSKILL");
		//RequestTrainSkillHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_GIVEITEMTOCHAR:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GIVEITEMTOCHAR");
		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â´Ã™Â¸Â¥ Ã„Â³Â¸Â¯Ã…ÃÂ¿Â¡Â°Ã” Ã€Ã¼Â´ÃÃ‡Ã‘Â´Ã™.
		GiveItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_EXCHANGEITEMTOCHAR:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_EXCHANGEITEMTOCHAR");
		ExchangeItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_JOINGUILDAPPROVE");
		JoinGuildApproveHandler(iClientH, pString);
		break;
	
	case DEF_COMMONTYPE_JOINGUILDREJECT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_JOINGUILDREJECT");
		JoinGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_DISMISSGUILDAPPROVE");
		DismissGuildApproveHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_DISMISSGUILDREJECT");
		DismissGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_RELEASEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_RELEASEITEM");
		// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â°Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃˆ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã‡Ã˜ÃÂ¦Ã‡ÃŸÂ´Ã™.
		ReleaseItemHandler(iClientH, iV1, TRUE);
		break;

	case DEF_COMMONTYPE_TOGGLECOMBATMODE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TOGGLECOMBATMODE");
		ToggleCombatModeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_MAGIC:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_MAGIC");
		PlayerMagicHandler(iClientH, iV1, iV2, (iV3 - 100));
		break;

	case DEF_COMMONTYPE_TOGGLESAFEATTACKMODE:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TOGGLESAFEATTACKMODE");
		ToggleSafeAttackModeHandler(iClientH);
		break;

	// v1.4311-3 ÃƒÃŸÂ°Â¡ Ã€Ã”Ã€Ã¥Â±Ã‡ Â¹ÃÂ±Ã¢  case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
	case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET");
		GetFightzoneTicketHandler(iClientH);
		break;

	// Upgrade Item
	case DEF_COMMONTYPE_UPGRADEITEM:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_UPGRADEITEM");
		RequestItemUpgradeHandler(iClientH,iV1);
		break;

	case DEF_COMMONTYPE_REQGUILDNAME:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQGUILDNAME");
		RequestGuildNameHandler(iClientH, iV1, iV2);
			break;

	case DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY:
		//DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_ACCEPTJOINPARTY");
		RequestAcceptJoinPartyHandler(iClientH, iV1);
		break;

	default:
		wsprintf(G_cTxt,"Unknown message received! (0x%.8X)",wCommand);
		PutLogList(G_cTxt);
		break;
	}
}

// New 07/05/2004
void CGame::DropItemHandler(int iClientH, short sItemIndex, int iAmount, char * pItemName, BOOL bByPlayer)
{
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((iAmount != -1) && (iAmount < 0)) return;

	// AmountÂ°Â¡ -1Ã€ÃŒÂ°Ã­ Â¼Ã’Â¸Ã°Ã‡Â°Ã€ÃŒÂ¸Ã© Â¼Ã¶Â·Â®Ã€Ã‡ Ã€Ã¼ÂºÃÂ¸Â¦ Â¶Â³Â¾Ã®Â¶ÃŸÂ¸Â°Â´Ã™.
	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		(iAmount == -1) ) 
		iAmount = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount;


	// Â¾Ã†Ã€ÃŒÃ…Ã› Ã€ÃŒÂ¸Â§Ã€ÃŒ Ã€ÃÃ„Â¡Ã‡ÃÃÃ¶ Â¾ÃŠÂ¾Ã†ÂµÂµ Â¹Â«Â½Ãƒ 
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) return;

	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		(((int)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount - iAmount) > 0) ) {
			// Â¼Ã’ÂºÃ±Â¼Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¾ÃºÂ°Ã­ Â¼Ã¶Â·Â®Â¸Â¸Ã…Â­ Â°Â¨Â¼Ã’Â½ÃƒÃ…Â°Â°Ã­ Â³Â²Ã€Âº Â°Ã” Ã€Ã–Â´Ã™Â¸Ã© 
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
				// ÂºÃÃ‡Ã’Ã‡ÃÂ°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¸Â®Â½ÂºÃ†Â®Â¿Â¡ Â¾Ã¸Â´Ã‚ Â°Ã…Â´Ã™. Ã€ÃŒÂ·Â± Ã€ÃÃ€Âº Ã€ÃÂ¾Ã®Â³Â¯ Â¼Ã¶Â°Â¡ Â¾Ã¸ÃÃ¶Â¸Â¸ 
				delete pItem;
				return;
			}
			else {
				if (iAmount <= 0) {
					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â·Â®Ã€ÃŒ 0ÂºÂ¸Â´Ã™ Ã€Ã›Ã€Â¸Â¸Ã© Â¿Â¡Â·Â¯Â»Ã³ÃˆÂ². Â¸Â®Ã…Ã 
					delete pItem;
					return;
				}
				pItem->m_dwCount = (DWORD)iAmount;
			}

			// Â¼Ã¶Â·Â® Â°Â¨Â¼Ã’ 

			// Â¿Â¡Â·Â¯. Â°Â¨Â¼Ã’Â½ÃƒÃ…Â°Â°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Â¾Ã§Ã€ÃŒ Â´Ãµ Â¸Â¹Â´Ã™. 
			if ((DWORD)iAmount > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount) {
				delete pItem;
				return;
			}

			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

			// ÂºÂ¯Â°Ã¦ÂµÃˆ Â¼Ã¶Â·Â®Ã€Â» Â¼Â³ÃÂ¤Ã‡ÃÂ°Ã­ Â¾Ã‹Â¸Â°Â´Ã™.
			// v1.41 !!!
			SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);

			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â¸Â°Â´Ã™. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, pItem);

			// v1.411 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€ÃÃÃ¶ ÃƒÂ¼Ã…Â©  
			// v2.17 2002-7-31 Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ ÃÃ—Â¾Ã®Â¼Â­ Â¶Â³Â¾Ã®ÃÃ¸Â°Ã‡ Â¸Ã°ÂµÃ§ Â·ÃÂ±Ã—Â°Â¡ Â³Â²Â´Ã‚Â´Ã™. 
			if ( bByPlayer == TRUE )
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);
			else 
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem, TRUE);

			// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, NULL);
		}
	else {
		// Ã€ÃÂ¹Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ³Âª Â¼Ã’ÂºÃ±Â¼Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¸Ã°ÂµÃ Â¹Ã¶Â·ÃˆÂ´Ã™.

		// Â¸Ã•Ã€Ãº Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™Â¸Ã© Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.

		ReleaseItemHandler(iClientH, sItemIndex, TRUE);

		// v2.17 Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Ã€Â¸Â¸Ã© Ã‡Ã˜ÃÂ¦Ã‡Ã‘Â´Ã™.
		if ( m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);

		// v1.432
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) && 
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0)) {
				// ÃˆÃ±Â»Ã½Ã€Ã‡ ÂµÂ¹Ã€Ã Â°Ã¦Â¿Ã¬ Â¼Ã¶Â¸Ã­Ã€ÃŒ 0Ã€Ã Â»Ã³Ã…Ã‚Â·Ã Â¶Â³Â¾Ã®ÃÃ¶Â¸Ã© Â»Ã§Â¶Ã³ÃÃ¸Â´Ã™.
				delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
				m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
			}
		else {
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â¸Â°Â´Ã™. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
				m_pClientList[iClientH]->m_sY, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			// v1.41 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¶Â³Â¾Ã®Â¶ÃŸÂ¸Â° Â°ÃÃ€ÃŒÂ¶Ã³Â¸Ã© Â·ÃÂ±Ã—Â¸Â¦ Â³Â²Â±Ã¤Â´Ã™. 
			// v2.17 2002-7-31 Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ ÃÃ—Â¾Ã®Â¼Â­ Â¶Â³Â¾Ã®ÃÃ¸Â°Ã‡ Â¸Ã°ÂµÃ§ Â·ÃÂ±Ã—Â°Â¡ Â³Â²Â´Ã‚Â´Ã™. 
			if ( bByPlayer == TRUE )
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			else 
				_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[sItemIndex], TRUE);

			// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); //v1.4 color
		}

		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» deleteÃ‡ÃÃÃ¶ Â¾ÃŠÂ°Ã­ NULLÂ·Ã Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™. delete Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚ Ã€ÃŒÃ€Â¯Â´Ã‚ Â¹Ã™Â´ÃšÂ¿Â¡ Â¶Â³Â¾Ã®ÃÂ® Ã€Ã–Â±Ã¢ Â¶Â§Â¹Â® 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

		// Ã€ÃŒÃÂ¦ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¸Â®Â½ÂºÃ†Â®Â¿Â¡Â¼Â­ Â»Ã¨ÃÂ¦Ã‡Ã’Â°ÃÃ€Â» Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);

		// Ã€ÃÂµÂ¦Â½ÂºÂ°Â¡ Â¹Ã™Â²Ã®Â¾ÃºÃ€Â¸Â¹Ã‡Â·Ã Ã€Ã§Ã‡Ã’Â´Ã§
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
	iCalcTotalWeight(iClientH);
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: check if player is dropping item or picking up item
//  last updated		:: October 29, 2004; 7:12 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp, sRemainItemSprite, sRemainItemSpriteFrame;
 char  cRemainItemColor, cData[100];
 int   iRet, iEraseReq;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(sX, sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
	if (pItem != NULL) {
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {

			_bItemLog(DEF_ITEMLOG_GET, iClientH, NULL, pItem);

			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;
			
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			*cp = 1;
			cp++;

			memcpy(cp, pItem->m_cName, 20);
			cp += 20;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0;
			cp++;

			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;
			 
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

			*cp = (char)pItem->m_sItemSpecEffectValue2;
			cp++;
			
			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			if (iEraseReq == 1) delete pItem;

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				                        sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);						
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
		else 
		{
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);
			
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
	}

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

BOOL CGame::_bAddClientItemList(int iClientH, class CItem * pItem, int * pDelReq)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;
	
	// ÃÃ½Ã€Â» Â¾Ã†Ã€ÃŒÃ…Ã› ÃÃŸÂ·Â®Â°Ã¨Â»Ãª  
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		// Â¼Ã¶Â·Â®Â°Â³Â³Ã¤Ã€ÃŒ Ã€Ã–Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã› 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
	}
	else {
		// Â¼Ã¶Â·Â® Â°Â³Â³Ã¤Ã€ÃŒ Â¾Ã¸Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã› 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, 1)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
  	}
	
	// Â¼Ã’ÂºÃ±Â¼Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€ÃŒÂ¹ÃŒ Â¼Ã’ÃÃ¶Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã™Â¸Ã© Â¼Ã¶Â·Â®Â¸Â¸ ÃÃµÂ°Â¡Â½ÃƒÃ…Â²Â´Ã™. 
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
			 (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, pItem->m_cName, 20) == 0) ) {
			// Â°Â°Ã€Âº Ã€ÃŒÂ¸Â§Ã€Â» ÃƒÂ£Â¾Ã’Â´Ã™. 
			m_pClientList[iClientH]->m_pItemList[i]->m_dwCount += pItem->m_dwCount;
			//delete pItem;
			*pDelReq = 1;
			
			// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
			iCalcTotalWeight(iClientH);
			
			return TRUE;
		}
	}
	
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
		
		m_pClientList[iClientH]->m_pItemList[i] = pItem;
		// v1.3 Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Ã€Â§Ã„Â¡Â´Ã‚ Â¹Â«ÃÂ¶Â°Ã‡ 100, 100
		m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
		m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

		*pDelReq = 0;

		// Â¸Â¸Â¾Ã  ÃˆÂ­Â»Ã¬Â·Ã¹ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¶Ã³Â¸Ã© ÃˆÂ­Â»Ã¬Ã€Â» Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™. 
		if (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)
			m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

		// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
		iCalcTotalWeight(iClientH);
		
		return TRUE;
	}

	// Â´ÃµÃ€ÃŒÂ»Ã³ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃ½Ã€Â» Â°Ã¸Â°Â£Ã€ÃŒ Â¾Ã¸Â´Ã™.
	return FALSE;
}

BOOL CGame::bEquipItemHandler(int iClientH, short sItemIndex, BOOL bNotify)
{
	char  cEquipPos, cHeroArmorType;
	short   sSpeed;
	short sTemp;
	int iTemp;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return FALSE;

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0) return FALSE;

	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) == NULL)  &&
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel)) return FALSE;


	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 0) {
		switch (m_pClientList[iClientH]->m_sType) {
		case 1:
		case 2:
		case 3:
			// Â³Â²Â¼ÂºÃ€ÃŒÂ´Ã™.
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 1) return FALSE;
			break;
		case 4:
		case 5:
		case 6:
			// Â¿Â©Â¼ÂºÃ€ÃŒÂ´Ã™.
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 2) return FALSE;
			break;
		}
	}

	if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[sItemIndex], 1) > m_pClientList[iClientH]->m_iStr*100) return FALSE;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

	if ((cEquipPos == DEF_EQUIPPOS_BODY) || (cEquipPos == DEF_EQUIPPOS_LEGGINGS) ||
		(cEquipPos == DEF_EQUIPPOS_ARMS) || (cEquipPos == DEF_EQUIPPOS_HEAD)) {
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4) {
				case 10: // Str ÃÂ¦Ã‡Ã‘ 
					if (m_pClientList[iClientH]->m_iStr < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â»Ã³Â¿Â¡Â¼Â­Â´Ã‚ Ã‚Ã¸Â¿Ã«ÂµÃˆ Â»Ã³Ã…Ã‚Ã€ÃŒÂ¹Ã‡Â·Ã Â¹Ã¾Â°ÃœÂ¾ÃŸ Ã‡Ã‘Â´Ã™. Ã‚Ã¸Â¿Ã«Ã€ÃŒ Ã‡Ã˜ÃÂ¦ÂµÃˆÂ´Ã™.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						// Ã‡Ã˜Â´Ã§ Ã‚Ã¸Â¿Ã« ÂºÃÃ€Â§Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›ÃˆÂ¿Â°ÃºÂ¸Â¦ ÃÂ¦Â°Ã….
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
						return FALSE;
					}
					break;
				case 11: // Dex
					if (m_pClientList[iClientH]->m_iDex < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â»Ã³Â¿Â¡Â¼Â­Â´Ã‚ Ã‚Ã¸Â¿Ã«ÂµÃˆ Â»Ã³Ã…Ã‚Ã€ÃŒÂ¹Ã‡Â·Ã Â¹Ã¾Â°ÃœÂ¾ÃŸ Ã‡Ã‘Â´Ã™. Ã‚Ã¸Â¿Ã«Ã€ÃŒ Ã‡Ã˜ÃÂ¦ÂµÃˆÂ´Ã™.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						// Ã‡Ã˜Â´Ã§ Ã‚Ã¸Â¿Ã« ÂºÃÃ€Â§Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›ÃˆÂ¿Â°ÃºÂ¸Â¦ ÃÂ¦Â°Ã….
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
						return FALSE;
					}
					break;
				case 12: // Vit
					if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â»Ã³Â¿Â¡Â¼Â­Â´Ã‚ Ã‚Ã¸Â¿Ã«ÂµÃˆ Â»Ã³Ã…Ã‚Ã€ÃŒÂ¹Ã‡Â·Ã Â¹Ã¾Â°ÃœÂ¾ÃŸ Ã‡Ã‘Â´Ã™. Ã‚Ã¸Â¿Ã«Ã€ÃŒ Ã‡Ã˜ÃÂ¦ÂµÃˆÂ´Ã™.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						// Ã‡Ã˜Â´Ã§ Ã‚Ã¸Â¿Ã« ÂºÃÃ€Â§Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›ÃˆÂ¿Â°ÃºÂ¸Â¦ ÃÂ¦Â°Ã….
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
						return FALSE;
					}
					break;
				case 13: // Int
					if (m_pClientList[iClientH]->m_iInt < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â»Ã³Â¿Â¡Â¼Â­Â´Ã‚ Ã‚Ã¸Â¿Ã«ÂµÃˆ Â»Ã³Ã…Ã‚Ã€ÃŒÂ¹Ã‡Â·Ã Â¹Ã¾Â°ÃœÂ¾ÃŸ Ã‡Ã‘Â´Ã™. Ã‚Ã¸Â¿Ã«Ã€ÃŒ Ã‡Ã˜ÃÂ¦ÂµÃˆÂ´Ã™.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						// Ã‡Ã˜Â´Ã§ Ã‚Ã¸Â¿Ã« ÂºÃÃ€Â§Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›ÃˆÂ¿Â°ÃºÂ¸Â¦ ÃÂ¦Â°Ã….
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
						return FALSE;
					}
					break;
				case 14: // Mag
					if (m_pClientList[iClientH]->m_iMag < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â»Ã³Â¿Â¡Â¼Â­Â´Ã‚ Ã‚Ã¸Â¿Ã«ÂµÃˆ Â»Ã³Ã…Ã‚Ã€ÃŒÂ¹Ã‡Â·Ã Â¹Ã¾Â°ÃœÂ¾ÃŸ Ã‡Ã‘Â´Ã™. Ã‚Ã¸Â¿Ã«Ã€ÃŒ Ã‡Ã˜ÃÂ¦ÂµÃˆÂ´Ã™.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						// Ã‡Ã˜Â´Ã§ Ã‚Ã¸Â¿Ã« ÂºÃÃ€Â§Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›ÃˆÂ¿Â°ÃºÂ¸Â¦ ÃÂ¦Â°Ã….
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
						return FALSE;
					}
					break;
				case 15: // Chr
					if (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
						// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â»Ã³Â¿Â¡Â¼Â­Â´Ã‚ Ã‚Ã¸Â¿Ã«ÂµÃˆ Â»Ã³Ã…Ã‚Ã€ÃŒÂ¹Ã‡Â·Ã Â¹Ã¾Â°ÃœÂ¾ÃŸ Ã‡Ã‘Â´Ã™. Ã‚Ã¸Â¿Ã«Ã€ÃŒ Ã‡Ã˜ÃÂ¦ÂµÃˆÂ´Ã™.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
						// Ã‡Ã˜Â´Ã§ Ã‚Ã¸Â¿Ã« ÂºÃÃ€Â§Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›ÃˆÂ¿Â°ÃºÂ¸Â¦ ÃÂ¦Â°Ã….
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
						return FALSE;
					}
					break;
			}
		}

		if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
			// Stormbringer
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 845) {
				if(m_pClientList[iClientH]->m_iInt <= 65){
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, sItemIndex, NULL, NULL);
					ReleaseItemHandler(iClientH, sItemIndex , TRUE);
					return FALSE;
				}
			}
		}

		if (cEquipPos == DEF_EQUIPPOS_RHAND) {
			// Resurrection wand(MS.10) or Resurrection wand(MS.20)
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
				if(m_pClientList[iClientH]->m_iInt > 99 && m_pClientList[iClientH]->m_iMag > 99 &&  m_pClientList[iClientH]->m_iSpecialAbilityTime < 1){
					m_pClientList[iClientH]->m_cMagicMastery[94] = TRUE;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
				}
			}
		}

		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) || 
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) {

				if ((m_pClientList[iClientH]->m_iSpecialAbilityType != 0)) {
					// Ã€ÃŒÂ¹ÃŒ Ã†Â¯Â¼Ã¶Â´Ã‰Â·Ã‚Ã€ÃŒ Â¼Â³ÃÂ¤ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™. Ã€ÃŒÃ€Ã¼Â¿Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã› Ã‚Ã¸Â¿Ã« Ã‡Ã˜ÃÂ¦:
					// Â´Ãœ, Ã‚Ã¸Â¿Ã« ÂºÃÃ€Â§Â°Â¡ Â°Â°Â´Ã™Â¸Ã© Ã‡Ã˜ÃÂ¦ Â¸ÃÂ½ÃƒÃÃ¶ ÂºÂ¸Â³Â»ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
					if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos != m_pClientList[iClientH]->m_iSpecialAbilityEquipPos) {
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], NULL, NULL);
						// Ã‡Ã˜Â´Ã§ Ã‚Ã¸Â¿Ã« ÂºÃÃ€Â§Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›ÃˆÂ¿Â°ÃºÂ¸Â¦ ÃÂ¦Â°Ã….
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], TRUE);
					}
				}
			}


		if (cEquipPos == DEF_EQUIPPOS_NONE) return FALSE;

		if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
			// Â¾Ã§Â¼Ã•Ã€Â» Â»Ã§Â¿Ã«Ã‡ÃÂ´Ã‚ Â¹Â«Â±Ã¢Â°Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™Â¸Ã©  
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
			else {
				// Â¿Ã€Â¸Â¥Â¼Ã•, Â¿ÃÂ¼Ã•Â¿Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© Â¸Ã°ÂµÃ Ã€Ã¥Ã‚Ã¸ Ã‡Ã˜ÃÂ¦ 
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ], FALSE);
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ], FALSE);
			}
		}
		else {
			// Â¾Ã§Â¼Ã• Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™Â¸Ã© Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
			if ((cEquipPos == DEF_EQUIPPOS_LHAND) || (cEquipPos == DEF_EQUIPPOS_RHAND)) {
				// Â¹Â«Â±Ã¢Â³Âª Â¹Ã¦Ã†ÃÂ·Ã¹Â¶Ã³Â¸Ã© Â¾Ã§Â¼Ã•Â¹Â«Â±Ã¢Â¸Â¦ Ã‡Ã˜ÃÂ¦ 
				if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ], FALSE);
			}

			// Ã€Ã¥Ã‚Ã¸Ã€Â§Ã„Â¡Â¿Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Ã€ÃŒÂ¹ÃŒ Ã€Ã–Ã€Â¸Â¸Ã© Â»Ã¨ÃÂ¦.
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		}


		if (cEquipPos == DEF_EQUIPPOS_RELEASEALL) {
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) {
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_HEAD ], FALSE);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BODY ], FALSE);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_ARMS ], FALSE);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LEGGINGS ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LEGGINGS ], FALSE);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_PANTS ], FALSE);
			}
			if(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ] != -1){
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_BACK ], FALSE);
			}
		}
		else{
			if (cEquipPos == DEF_EQUIPPOS_HEAD || cEquipPos == DEF_EQUIPPOS_BODY || cEquipPos == DEF_EQUIPPOS_ARMS ||
				cEquipPos == DEF_EQUIPPOS_LEGGINGS || cEquipPos == DEF_EQUIPPOS_PANTS || cEquipPos == DEF_EQUIPPOS_BACK) {
					if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RELEASEALL ] != -1) {
						ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RELEASEALL ], FALSE);
					}
			}
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
					ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		}


		m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = sItemIndex;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = TRUE;

		switch (cEquipPos) {

			case DEF_EQUIPPOS_HEAD:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xFF0F;	// Ã…ÃµÂ±Â¸ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr Â°ÂªÃ€Â» Â¼Â¼Ã†Ãƒ. 
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
				iTemp = iTemp & 0xFFFFFFF0; // ÂºÃÃƒÃ· Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.				
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor));
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_PANTS:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xF0FF;	// Â¹Ã™ÃÃ¶ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr Â°ÂªÃ€Â» Â¼Â¼Ã†Ãƒ. 
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
				iTemp = iTemp & 0xFFFFF0FF; // Â¹Ã™ÃÃ¶ Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 8);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_LEGGINGS:
				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp & 0x0FFF;	// ÂºÃÃƒÃ· Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr Â°ÂªÃ€Â» Â¼Â¼Ã†Ãƒ. 
				m_pClientList[iClientH]->m_sAppr4 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
				iTemp = iTemp & 0xFFFFFF0F; // ÂºÃÃƒÃ· Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 4);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_BODY:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0x0FFF;	// Â°Ã‘Â¿ÃŠ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.

				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue < 100) {
					// Â¿ÃœÃ‡Ã¼Â°ÂªÃ€ÃŒ 100 Ã€ÃŒÃ‡Ã. ÃÂ¤Â»Ã³Ã€Ã»Ã€Ã Â°Âª 
					sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr Â°ÂªÃ€Â» Â¼Â¼Ã†Ãƒ. 
					m_pClientList[iClientH]->m_sAppr3 = sTemp;
				}
				else {
					// Â¿ÃœÃ‡Ã¼Â°ÂªÃ€ÃŒ 100 Ã€ÃŒÂ»Ã³Ã€ÃŒÂ¸Ã© ÃˆÂ®Ã€Ã¥ Ã‡ÃƒÂ·Â¡Â±Ã—Â¸Â¦ Â»Ã§Â¿Ã«Ã‡Ã‘Â´Ã™. 
					sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue - 100) << 12); // Appr Â°ÂªÃ€Â» Â¼Â¼Ã†Ãƒ. 
					m_pClientList[iClientH]->m_sAppr3 = sTemp;
					// Â°Ã‘Â¿ÃŠ ÃˆÂ®Ã€Ã¥ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Â¼Â¼Ã†Â®.
					sTemp = m_pClientList[iClientH]->m_sAppr4;
					sTemp = sTemp | 0x080;	
					m_pClientList[iClientH]->m_sAppr4 = sTemp;
				}

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
				iTemp = iTemp & 0xFF0FFFFF; // Â°Ã‘Â¿ÃŠ(Â°Â©Â¿ÃŠ) Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 20);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;
			
			case DEF_EQUIPPOS_ARMS:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0xFFF0;	// Â¼Ã“Â¿ÃŠ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr Â°ÂªÃ€Â» Â¼Â¼Ã†Ãƒ. 
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
				iTemp = iTemp & 0xFFFFFFFF; // Â¼Ã“Â¿ÃŠ Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®. // New 09/05/2004
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 12);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_LHAND:
				// Â¿ÃÂ¼Ã•Â¿Â¡ Ã€Ã¥Ã‚Ã¸Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›. Â¹Ã¦Ã†ÃÂ·Ã¹Ã€ÃŒÂ´Ã™. 
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xFFF0;	// Â¹Â«Â±Ã¢ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr Â°ÂªÃ€Â» Â¼Â¼Ã†Ãƒ. 
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
				iTemp = iTemp & 0xF0FFFFFF; // Â¹Ã¦Ã†Ã Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 24);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_RHAND:
				// Â¿Ã€Â¸Â¥Â¼Ã•Â¿Â¡ Ã€Ã¥Ã‚Ã¸Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›. Â¹Â«Â±Ã¢Â·Ã¹Ã€ÃŒÂ´Ã™. 
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xF00F;	// Â¹Â«Â±Ã¢ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr Â°ÂªÃ€Â» Â¼Â¼Ã†Ãƒ. 
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
				iTemp = iTemp & 0xFFFFFFF; // Â¹Â«Â±Ã¢ Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// Â¹Â«Â±Ã¢ Â¼Ã“ÂµÂµÂ¸Â¦ Â³ÂªÃ…Â¸Â³Â»Â´Ã‚ StatusÃ€Ã‡ ÂºÃ±Ã†Â®Â¸Â¦ Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™.
				iTemp = m_pClientList[iClientH]->m_iStatus;
				iTemp = iTemp & 0xFFFFFFF0;
				sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
				// StrÂ¿Â¡ ÂµÃ»Â¶Ã³ Â¹Â«Â±Ã¢ Â¼Ã“ÂµÂµÂ¸Â¦ ÃÃ™Ã€ÃÂ´Ã™. 
				sSpeed -= (m_pClientList[iClientH]->m_iStr / 13);
				if (sSpeed < 0) sSpeed = 0;
				iTemp = iTemp | (int)sSpeed;
				m_pClientList[iClientH]->m_iStatus = iTemp;
				m_pClientList[iClientH]->m_iComboAttackCount = 0;
				break;

			case DEF_EQUIPPOS_TWOHAND:
				// Â¾Ã§Â¼Ã•Ã…Â¸Ã€Ã”Ã€ÃŒÃÃ¶Â¸Â¸ Â»Ã§Â½Ã‡ Â¿Ã€Â¸Â¥Â¼Ã•Â¿Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃˆÂ´Ã™. 
				sTemp = m_pClientList[iClientH]->m_sAppr2;
				sTemp = sTemp & 0xF00F;	// Â¹Â«Â±Ã¢ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr Â°ÂªÃ€Â» Â¼Â¼Ã†Ãƒ. 
				m_pClientList[iClientH]->m_sAppr2 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
				iTemp = iTemp & 0xFFFFFFF; // Â¹Â«Â±Ã¢ Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
				m_pClientList[iClientH]->m_iApprColor = iTemp;

				// Â¹Â«Â±Ã¢ Â¼Ã“ÂµÂµÂ¸Â¦ Â³ÂªÃ…Â¸Â³Â»Â´Ã‚ StatusÃ€Ã‡ ÂºÃ±Ã†Â®Â¸Â¦ Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™.
				iTemp = m_pClientList[iClientH]->m_iStatus;
				iTemp = iTemp & 0xFFFFFFF0;
				sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
				// StrÂ¿Â¡ ÂµÃ»Â¶Ã³ Â¹Â«Â±Ã¢ Â¼Ã“ÂµÂµÂ¸Â¦ ÃÃ™Ã€ÃÂ´Ã™. 
				sSpeed -= (m_pClientList[iClientH]->m_iStr / 13);
				if (sSpeed < 0) sSpeed = 0;
				iTemp = iTemp | (int)sSpeed;
				m_pClientList[iClientH]->m_iStatus = iTemp;
				m_pClientList[iClientH]->m_iComboAttackCount = 0;
				break;

			case DEF_EQUIPPOS_BACK:
				sTemp = m_pClientList[iClientH]->m_sAppr4;
				sTemp = sTemp & 0xF0FF;	// Â¸ÃÃ…Ã¤ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr Â°ÂªÃ€Â» Â¼Â¼Ã†Ãƒ. 
				m_pClientList[iClientH]->m_sAppr4 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
				iTemp = iTemp & 0xFFF0FFFF; // Â¸ÃÃ…Ã¤ Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 16);
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;

			case DEF_EQUIPPOS_RELEASEALL:
				sTemp = m_pClientList[iClientH]->m_sAppr3;
				sTemp = sTemp & 0x0FFF;	// Â¸ÃÃ…Ã¤ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr Â°ÂªÃ€Â» Â¼Â¼Ã†Ãƒ. 
				m_pClientList[iClientH]->m_sAppr3 = sTemp;

				iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
				iTemp = iTemp & 0xFFF0FFFF; // Â¸ÃÃ…Ã¤ Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
				m_pClientList[iClientH]->m_iApprColor = iTemp;
				break;
		}

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
			// Â°Ã¸Â°Ã Ã†Â¯Â¼Ã¶ Â´Ã‰Â·Ã‚ ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã®
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
				case 0: break;
				case 1: // Â°Ã¸Â°ÃÂ½Ãƒ 50% HP Â°Â¨Â¼Ã’
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0004;	
					break;

				case 2: // Â³ÃƒÂµÂ¿ ÃˆÂ¿Â°Ãº 
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x000C;	
					break;

				case 3: // Â¸Â¶ÂºÃ± ÃˆÂ¿Â°Ãº 
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0008;	
					break;
			}
		}

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
			switch(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect){
				case 0:
					break;
				case 50:
				case 51:
				case 52:
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0002;
					break;
				default:
					if(m_pClientList[iClientH]->m_iAdminUserLevel > 0)
					m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0001;
					// m_sAppr4
					// 0x0001 GM	
					// 0x0002 Green	
					// 0x0003 ice element
					// 0x0004 sparkle
					// 0x0005 sparkle green gm
					// 0x0006 sparkle green
					break;
			}
		}
		
	cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = cHeroArmorType;
		
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	CalcTotalItemEffect(iClientH, sItemIndex, bNotify);
	return TRUE;

}

void CGame::SendEventToNearClient_TypeB(DWORD dwMsgID, WORD wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, short sV4)
{
 int i, iRet, iShortCutIndex;
 char  * cp, cData[100];
 DWORD * dwp, dwTime;
 WORD * wp;
 short * sp;
 BOOL bFlag;

	ZeroMemory(cData, sizeof(cData));
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	sp  = (short *)cp;
	*sp = sX;
	cp += 2;

	sp  = (short *)cp;
	*sp = sY;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV1;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV2;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;

	dwTime = timeGetTime();

	//for (i = 1; i < DEF_MAXCLIENTS; i++)
	bFlag = TRUE;
	iShortCutIndex = 0;
	while (bFlag == TRUE) {
		// DEF_MAXCLIENTS Â±Ã®ÃÃ¶ Â·Ã§Ã‡ÃÂ¸Â¦ ÂµÂ¹ÃÃ¶ Â¾ÃŠÂ±Ã¢ Ã€Â§Ã‡Ã‘ Â¹Ã¦Â¹Ã½. Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â¼Ã´Ã„Ã† Â¸Â®Â½ÂºÃ†Â®Â¿Â¡Â¼Â­ 0Ã€ÃŒ Â³ÂªÂ¿Ã€Â¸Ã© Â³Â¡Ã€ÃŒÂ´Ã™.
		i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = FALSE;

		if ((bFlag == TRUE) && (m_pClientList[i] != NULL)) {
			if ( (m_pClientList[i]->m_cMapIndex == cMapIndex) &&
				 (m_pClientList[i]->m_sX >= sX - 10) &&
				 (m_pClientList[i]->m_sX <= sX + 10) &&
				 (m_pClientList[i]->m_sY >= sY - 8 ) &&
				 (m_pClientList[i]->m_sY <= sY + 8 ) ) {

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 18);
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: checks if player is stopped
//  last updated		:: October 29, 2004; 6:46 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
{
 char cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 short   sOwnerH;
 char    cOwnerType;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);		
		if (sOwnerH != NULL) {
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}

	ClearSkillUsingStatus(iClientH);

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	m_pClientList[iClientH]->m_cDir = cDir;
	
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

void CGame::ResponseCreateNewGuildHandler(char * pData, DWORD dwMsgSize)
{
 register int i;
 WORD  * wp, wResult;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;
	
	// Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â·ÃÂºÃÃ…Ã Â±Ã¦ÂµÃ¥ Â»Ã½Â¼Âº Â¿Ã¤ÃƒÂ»Â¿Â¡ Â´Ã«Ã‡Ã‘ Ã€Ã€Â´Ã¤ÂµÂ¥Ã€ÃŒÃ…ÃÂ°Â¡ ÂµÂµÃ‚Ã¸Ã‡ÃŸÂ´Ã™. 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	
	// Ã€ÃŒÂ¸Â§Ã€ÃŒ Ã€ÃÃ„Â¡Ã‡ÃÂ´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¸Â¦ ÃƒÂ£Â´Ã‚Â´Ã™.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) &&
		(m_pClientList[i]->m_iLevel >= 20) && (m_pClientList[i]->m_iCharisma >= 20)) {
		
		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (*wp) {
		case DEF_LOGRESMSGTYPE_CONFIRM:
			// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Ã€Ã‡ Â±Ã¦ÂµÃ¥ Â»Ã½Â¼Âº Â¿Ã¤Â±Â¸Â°Â¡ Â¼ÂºÂ°Ã¸Ã‡ÃÂ¿Â´Â´Ã™. 
			wResult = DEF_MSGTYPE_CONFIRM;
			// Â±Ã¦ÂµÃ¥ Ã€ÃŒÂ¸Â§Ã€Âº Ã€ÃŒÂ¹ÃŒ Ã€ÃºÃ€Ã¥ÂµÃ‡Â¾Ã® Ã€Ã–Ã€Â¸Â¹Ã‡Â·Ã Â·Â©Ã…Â©Â¸Â¦ 0Ã€Â¸Â·Ã Â¹Ã™Â²Ã£ Ã€Â¯ÃˆÂ¿ÃˆÂ­ Ã‡Ã‘Â´Ã™.
			m_pClientList[i]->m_iGuildRank = 0;	// Â±Ã¦ÂµÃ¥ Â·Â©Ã…Â©Â´Ã‚ 0. Â±Ã¦ÂµÃ¥Â¸Â¶Â½ÂºÃ…ÃÃ€Ã“ 
			wsprintf(cTxt, "(!) New guild(%s) creation success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;

		case DEF_LOGRESMSGTYPE_REJECT:
			// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Ã€Ã‡ Â±Ã¦ÂµÃ¥ Â»Ã½Â¼Âº Â¿Ã¤Â±Â¸Â°Â¡ Â½Ã‡Ã†ÃÃ‡ÃÂ¿Â´Â´Ã™.
			// Ã‡Ã˜Â´Ã§ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Ã€Ã‡ Â±Ã¦ÂµÃ¥Ã€ÃŒÂ¸Â§Ã€Â» ÃƒÃŠÂ±Ã¢ÃˆÂ­Ã‡Ã‘Â´Ã™ "NONE".
			wResult = DEF_MSGTYPE_REJECT;
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;  
			m_pClientList[i]->m_iGuildGUID = -1;
			wsprintf(cTxt, "(!) New guild(%s) creation Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}				
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_CREATENEWGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;

		// Â±Ã¦ÂµÃ¥ Â»Ã½Â¼Âº Â¿Ã¤Â±Â¸ Ã€Ã€Â´Ã¤ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Ã€Ã¼Â¼Ã›
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
			DeleteClient(i, TRUE, TRUE);
			return;
		}

		return;
	}

	// Ã€ÃŒÂ¸Â§Ã€ÃŒ Ã€ÃÃ„Â¡Ã‡ÃÂ´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¸Â¦ ÃƒÂ£Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::RequestCreateNewGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cGuildName[21], cTxt[120], cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_bIsCrusadeMode == TRUE) return;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	
	cp += 10;
	cp += 10;
	cp += 10;
	
	ZeroMemory(cGuildName, sizeof(cGuildName));
	memcpy(cGuildName, cp, 20);
	cp += 20;

	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// Ã€ÃŒ Ã„Â³Â¸Â¯Ã…ÃÂ´Ã‚ Ã€ÃŒÂ¹ÃŒ Â±Ã¦ÂµÃ¥Â¿Â¡ Â°Â¡Ã€Ã”Ã‡ÃÂ¿Â© Ã€Ã–Ã€Â¸Â¹Ã‡Â·Ã Â±Ã¦ÂµÃ¥Â¸Â¦ Â¸Â¸ÂµÃ© Â¼Ã¶ Â¾Ã¸Â´Ã™.
		wsprintf(cTxt, "(!)Cannot create guild! Already guild member.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		if ( (m_pClientList[iClientH]->m_iLevel < 20) || (m_pClientList[iClientH]->m_iCharisma < 20) ||
			 (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) ||
			 (memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) != 0) ) { // v1.4
			// Ã€ÃšÂ°ÃÂ¿Ã¤Â°Ã‡Ã€ÃŒ Â¸Ã‚ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. Ã†Â¯Â¼ÂºÃ„Â¡Â°Â¡ Â³Â·Â°Ã…Â³Âª Â¸Â¶Ã€Â»Ã€Ã‡ Ã€Â§Ã„Â¡Â°Â¡ Â´Ã™Â¸Â£Â°Ã…Â³Âª Â½ÃƒÂ¹ÃÃ€ÃŒ Â¾Ã†Â´Ã‘ Â°Ã¦Â¿Ã¬  
			ZeroMemory(cData, sizeof(cData));

			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_CREATENEWGUILD;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_MSGTYPE_REJECT;

			// Â±Ã¦ÂµÃ¥ Â»Ã½Â¼Âº Â¿Ã¤Â±Â¸ Ã€Ã€Â´Ã¤ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Ã€Ã¼Â¼Ã›
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {
	   		// Â±Ã¦ÂµÃ¥ Ã€ÃŒÂ¸Â§Ã€Â» Ã€Ã“Â½ÃƒÂ·Ã Ã€ÃºÃ€Ã¥Ã‡Ã‘Â´Ã™. -> Â¾Ã®Ã‚Ã·Ã‡Ã‡ Â±Ã¦ÂµÃ¥ Ã€ÃŒÂ¸Â§Ã€Âº RankÂ°Â¡ -1Ã€ÃÂ¶Â§ Â¹Â«Ã€Ã‡Â¹ÃŒÃ‡ÃÂ¹Ã‡Â·Ã .
			ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, cGuildName);
			// Â±Ã¦ÂµÃ¥Ã€Ã‡ Â¼Ã’Â¼Ã“ Â¸Â¶Ã€Â» Ã€ÃŒÂ¸Â§Ã€Â» Ã€ÃºÃ€Ã¥Ã‡Ã‘Â´Ã™.
			ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
			strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
			// Â±Ã¦ÂµÃ¥Ã€Ã‡ GUIDÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡ÃÂ¿Â© Ã€Ã”Â·Ã‚Ã‡Ã‘Â´Ã™. 
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iGuildGUID = (int)(SysTime.wYear + SysTime.wMonth + SysTime.wDay + SysTime.wHour + SysTime.wMinute + timeGetTime());
			
			// Â±Ã¦ÂµÃ¥ Â»Ã½Â¼ÂºÂ¿Ã¤ÃƒÂ» Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Â·ÃÂ±Ã—Â¼Â­Â¹Ã¶Â·Ã Ã€Ã¼Â¼Ã›Ã‡Ã‘Â´Ã™.
			bSendMsgToLS(MSGID_REQUEST_CREATENEWGUILD, iClientH);
		}
	}
}


void CGame::RequestDisbandGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cGuildName[21], cTxt[120];

	if (m_bIsCrusadeMode == TRUE) return;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cGuildName, sizeof(cGuildName));
	
	cp += 10;
	cp += 10;
	cp += 10;
	
	memcpy(cGuildName, cp, 20);
	cp += 20;

	if ((m_pClientList[iClientH]->m_iGuildRank != 0) || (memcmp(m_pClientList[iClientH]->m_cGuildName, cGuildName, 20) != 0)) {
		// Â±Ã¦ÂµÃ¥Â¸Â¶Â½ÂºÃ…ÃÂ°Â¡ Â¾Ã†Â´ÃÂ°Ã…Â³Âª Â±Ã¦ÂµÃ¥Ã€Ã‡ Ã€ÃŒÂ¸Â§Ã€ÃŒ Â´Ã™Â¸Â£Â¹Ã‡Â·Ã Â±Ã¦ÂµÃ¥Ã‡Ã˜Â»ÃªÃ€Ã‡ Â±Ã‡Ã‡Ã‘Ã€ÃŒ Â¾Ã¸Â´Ã™.
		wsprintf(cTxt, "(!)Cannot Disband guild! Not guildmaster.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		// Â±Ã¦ÂµÃ¥ Ã‡Ã˜Â»Ãª Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Â·ÃÂ±Ã—Â¼Â­Â¹Ã¶Â·Ã Ã€Ã¼Â¼Ã›Ã‡Ã‘Â´Ã™.
		bSendMsgToLS(MSGID_REQUEST_DISBANDGUILD, iClientH);
	}
}

void CGame::ResponseDisbandGuildHandler(char * pData, DWORD dwMsgSize)
{
 register int i;
 WORD  * wp, wResult;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;
	
	// ·Î±× ¼­¹ö·ÎºÎÅÍ ±æµå ÇØ»ê ¿äÃ»¿¡ ´ëÇÑ ÀÀ´äµ¥ÀÌÅÍ°¡ µµÂøÇß´Ù. 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	
	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ğÆ®¸¦ Ã£´Â´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
		
		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (*wp) {
		case DEF_LOGRESMSGTYPE_CONFIRM:
			// Å¬¶óÀÌ¾ğÆ®ÀÇ ±æµå ÇØ»ê ¿ä±¸°¡ ¼º°øÇÏ¿´´Ù. 
			wResult = DEF_MSGTYPE_CONFIRM;
			wsprintf(cTxt, "(!) Disband guild(%s) success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			
			// Á¢¼ÓÁßÀÎ ±æµå¿øµé¿¡°Ô ±æµå°¡ ÇØ»êµÇ¾úÀ½À» ¾Ë¸®´Â ¸Ş½ÃÁö¸¦ Àü¼ÛÇÑ´Ù. 
			SendGuildMsg(i,	DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL);
			
			// ±æµåÀÌ¸§ Å¬¸®¾î
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;		// ±æµå ·©Å©´Â -1. ±æµå¿øÀÌ ¾Æ´Ï´Ù. 
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case DEF_LOGRESMSGTYPE_REJECT:
			// Å¬¶óÀÌ¾ğÆ®ÀÇ ±æµå ÇØ»ê ¿ä±¸°¡ ½ÇÆĞÇÏ¿´´Ù.
			wResult = DEF_MSGTYPE_REJECT;
			wsprintf(cTxt, "(!) Disband guild(%s) Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}				
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_DISBANDGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;

		// ±æµå ÇØ»ê ¿ä±¸ ÀÀ´ä ¸Ş½ÃÁö¸¦ Å¬¶óÀÌ¾ğÆ®¿¡°Ô Àü¼Û
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Ş½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ıÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(i, TRUE, TRUE);
			return;
		}
		return;
	}

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ğÆ®¸¦ Ã£À» ¼ö ¾ø´Ù.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

// 05/29/2004 - Hypnotoad - Purchase Dicount updated to take charisma into consideration
void CGame::RequestPurchaseItemHandler(int iClientH, char * pItemName, int iNum)
{
 class CItem * pItem;
 char  * cp, cItemName[21], cData[100];
 short * sp;
 DWORD * dwp, dwGoldCount, dwItemCount;
 WORD  * wp, wTempPrice;
 int   i, iRet, iEraseReq, iGoldWeight;
	 int   iCost, iDiscountRatio, iDiscountCost;
 double dTmp1, dTmp2, dTmp3;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	// Â¸Â¸Â¾Ã  Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â±Â¸Ã€Ã”Ã‡ÃÂ°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Â°Ã·Ã€ÃŒ Ã€ÃšÂ½Ã…Ã€Ã‡ Â¸Â¶Ã€Â»Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© Â±Â¸Ã€Ã”Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
	//if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
	//	 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, m_pClientList[iClientH]->m_cLocation, 10) != 0) ) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) {
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arefarm", 7) == 0)) {

			}
			else return;
		}

		if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvfarm", 7) == 0)) {

			}
			else return;
		}
	}
	
	
	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â±Â¸Ã€Ã”Ã‡Ã‘Â´Ã™. 
	ZeroMemory(cData, sizeof(cData));	
	ZeroMemory(cItemName, sizeof(cItemName));
	
	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) return;

	// Ã€Ã“Â½ÃƒÃ„ÃšÂµÃ¥Â´Ã™. 
	if (memcmp(pItemName, "10Arrows", 8) == 0) {
		strcpy(cItemName, "Arrow");
		dwItemCount = 10;
	}
	else if (memcmp(pItemName, "100Arrows", 9) == 0) {
		strcpy(cItemName, "Arrow");
		dwItemCount = 100;
	}
	else {
		memcpy(cItemName, pItemName, 20);
		dwItemCount = 1;
	}
	
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			// Â±Â¸Ã€Ã”Ã‡ÃÂ°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã› Â¸Â®Â½ÂºÃ†Â®Â»Ã³Â¿Â¡ Â¾Ã¸Â´Ã™. Â±Â¸Ã€Ã”Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™.
			delete pItem;
		}
		else {
			
			if (pItem->m_bIsForSale == FALSE) {
				// Ã†Ã‡Â¸Ã…ÂµÃ‡Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¾Ã†Â´ÃÂ´Ã™. Â»Ã¬ Â¼Ã¶ Â¾Ã¸Â´Ã™.
				delete pItem;
				return;
			}

			pItem->m_dwCount = dwItemCount;
			
			// Â°Â¡Â°ÃÃ€Â» Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™.
			iCost = pItem->m_wPrice * pItem->m_dwCount;
			
			/* v1.3 <- Ã€ÃŒÂ°Ã‡ _bAddClientItemListÂ¿Â¡Â¼Â­ ÃƒÂ¼Ã…Â©Ã‡ÃÂ´Ã‚ Â±Ã¢Â´Ã‰Ã€ÃŒÂ¹Ã‡Â·Ã ÂµÃÂ¹Ã¸Ã‡Ã’ Ã‡ÃŠÂ¿Ã¤Â°Â¡ Â¾Ã¸Â´Ã™.
			if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW))  
				iItemWeight = (pItem->m_wWeight * pItem->m_dwCount);
			else iItemWeight = pItem->m_wWeight;
			
			if ( (iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
				// ÃÃŸÂ·Â® ÃƒÃŠÂ°Ãº. Â±Â¸Ã€Ã”Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
				
				// Â´ÃµÃ€ÃŒÂ»Ã³ Â°Â¡ÃÃºÂ¼Ã¶ Â¾Ã¸Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
				
				delete pItem;
				return;
			}
			*/

			// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¼Ã’ÃÃ¶Ã‡Ã‘ GoldÂ°Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â»Ã§Â±Ã¢Â¿Â¡ ÃƒÃ¦ÂºÃÃ‡Ã‘ÃÃ¶ Â°Ã‹Â»Ã§Ã‡Ã‘Â´Ã™.
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			
			// CharismaÂ¿Â¡ ÂµÃ»Â¸Â¥ Ã‡Ã’Ã€ÃÂ·Ã¼Ã€Â» Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™. 
			// v2.14 Ã„Â«Â¸Â®Â½ÂºÂ¸Â¶Â°Â¡ 10Ã€ÃÂ°Ã¦Â¿Ã¬ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã‡Ã’Ã€Ã Ã‡ÃÃÃ¶ Â¾ÃŠÃ€Â½ 
			iDiscountRatio = ((m_pClientList[iClientH]->m_iCharisma -10)/ 4) ;
			
			// 2.03 Discount Method
			// CharismaÂ¿Â¡ ÂµÃ»Â¸Â¥ Ã‡Ã’Ã€ÃÂ·Ã¼Ã€Â» Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™. 
			// iDiscountRatio = (m_pClientList[iClientH]->m_iCharisma / 4) -1;
			// if (iDiscountRatio == 0) iDiscountRatio = 1;
			
			dTmp1 = (double)(iDiscountRatio);
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double)iCost;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int)dTmp3;
				
			if (iDiscountCost >= (iCost/2)) iDiscountCost = (iCost/2)-1;

			if ( dwGoldCount < (DWORD)(iCost - iDiscountCost) ) {
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â°Â®Â°Ã­Ã€Ã–Â´Ã‚ GoldÂ°Â¡ Â¾Ã†Ã€ÃŒÃ…Ã› Â°Â¡Â°ÃÂ¿Â¡ ÂºÃ±Ã‡Ã˜ Ã€Ã»Â´Ã™. Â»Ã¬Â¼Ã¶ Â¾Ã¸Ã€Â½.
				delete pItem;
				
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
				cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp  = -1; // -1Ã€ÃŒÂ¸Ã© Ã€Ã‡Â¹ÃŒÂ¾Ã¸Â´Ã™.
				cp++;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}
			
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// Â¿Â¡Â·Â¯ Â¹Ã¦ÃÃ¶Â¿Ã« Ã„ÃšÂµÃ¥
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// Â¾Ã†Ã€ÃŒÃ…Ã› Â»Ã²Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Ã€Ã¼Â¼Ã›Ã‡Ã‘Â´Ã™.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMPURCHASED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				// 1Â°Â³ ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™.
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // Â¾Ã²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;
				
				wp  = (WORD *)cp;
				*wp = (iCost - iDiscountCost);
				wTempPrice = (iCost - iDiscountCost);
				cp += 2;
				
				if (iEraseReq == 1) delete pItem;
				
				// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
				
				// GoldÃ€Ã‡ Â¼Ã¶Â·Â®Ã€Â» Â°Â¨Â¼Ã’Â½ÃƒÃ…Â²Â´Ã™. Â¹ÃÂµÃ¥Â½Ãƒ Â¿Â©Â±Ã¢Â¼Â­ Â¼Â¼Ã†ÃƒÃ‡Ã˜Â¾ÃŸ Â¼Ã¸Â¼Â­Â°Â¡ Â¹Ã™Â²Ã®ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
				iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - wTempPrice);
				// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
				iCalcTotalWeight(iClientH);

				//v1.4 Â¸Â¶Ã€Â»Ã€Ã‡ Ã€ÃšÂ±ÃÂ¿Â¡ Â´ÃµÃ‡Ã‘Â´Ã™. 
				m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += wTempPrice;
					
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
			else 
			{
				// Â°Ã¸Â°Â£Ã€ÃŒ ÂºÃÃÂ·Ã‡Ã˜ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¾Ã²Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.
				delete pItem;

				// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
 	}
}

void CGame::GiveItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char * pItemName)
{
 register int iRet, iEraseReq;
 short * sp, sOwnerH;
 char  * cp, cOwnerType, cData[100], cCharName[21];
 DWORD * dwp;
 WORD  * wp;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (iAmount <= 0) return;

	// Â¾Ã†Ã€ÃŒÃ…Ã› Ã€ÃŒÂ¸Â§Ã€ÃŒ Ã€ÃÃ„Â¡Ã‡ÃÃÃ¶ Â¾ÃŠÂ¾Ã†ÂµÂµ Â¹Â«Â½ÃƒÂµÃˆÂ´Ã™.
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) {
		PutLogList("GiveItemHandler - Not matching Item name");
		return;
	}

	ZeroMemory(cCharName, sizeof(cCharName));

	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount > (DWORD)iAmount) ) {
		// Â¼Ã’ÂºÃ±Â¼Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¾ÃºÂ°Ã­ Â¼Ã¶Â·Â®Â¸Â¸Ã…Â­ Â°Â¨Â¼Ã’Â½ÃƒÃ…Â°Â°Ã­ Â³Â²Ã€Âº Â°Ã” Ã€Ã–Â´Ã™Â¸Ã© 
		
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
			// ÂºÃÃ‡Ã’Ã‡ÃÂ°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¸Â®Â½ÂºÃ†Â®Â¿Â¡ Â¾Ã¸Â´Ã‚ Â°Ã…Â´Ã™. Ã€ÃŒÂ·Â± Ã€ÃÃ€Âº Ã€ÃÂ¾Ã®Â³Â¯ Â¼Ã¶Â°Â¡ Â¾Ã¸ÃÃ¶Â¸Â¸ 
			delete pItem;
			return;
		}
		else {
			pItem->m_dwCount = iAmount;
		}

		// Â¼Ã¶Â·Â® Â°Â¨Â¼Ã’: 0ÂºÂ¸Â´Ã™ Ã…Â©Â´Ã™.
		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

		// ÂºÂ¯Â°Ã¦ÂµÃˆ Â¼Ã¶Â·Â®Ã€Â» Â¼Â³ÃÂ¤Ã‡ÃÂ°Ã­ Â¾Ã‹Â¸Â°Â´Ã™.
		// v1.41 !!! Â¾Ã†Ã€ÃŒÃ…Ã› Ã€ÃŒÂ¸Â§Â¿Â¡Â¼Â­ Ã€ÃÂµÂ¦Â½ÂºÂ·Ã ÂºÂ¯Â°Ã¦ÂµÃ‡Â¾ÃºÂ´Ã™. 
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);
		
		//Ã€ÃŒÃÂ¦ dX, dYÂ¿Â¡ Ã€Ã–Â´Ã‚ Â¿Ã€ÂºÃªÃÂ§Ã†Â®Â¿Â¡Â°Ã” Â¼Ã’ÂºÃ±Â¼Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â°Ã‡Â³Ã—ÃÃ˜Â´Ã™. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		
		// v1.4 ÃÃ–Â°Ã­Ã€Ãš Ã‡Ã‘ Â°Â´ÃƒÂ¼Â¿Ã Â¸Ã‚Â´Ã‚ÃÃ¶ Ã†Ã‡Â´ÃœÃ‡Ã‘Â´Ã™.
		if (wObjectID != NULL) { 
			if (wObjectID < 10000) {
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® 
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != NULL) {
						if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != NULL) {
						if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
					}
				}
			}
		}

		if (sOwnerH == NULL) {
			// ÃÃ–Â°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¾Ã†Â¹Â«ÂµÂµ Â¾Ã¸Â´Ã™.
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â¸Â°Â´Ã™. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			
			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
	
			// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color
		}
		else {
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃ˜Â´Ã™.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” ÃÃ–Â¾ÃºÂ´Ã™.
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);

				if (sOwnerH == iClientH) {
					// Â¸Â¸Â¾Ã  Ã€ÃšÂ±Ã¢ Ã€ÃšÂ½Ã…Â¿Â¡Â°Ã” ÃÃ–Â´Ã‚ Â°Ã…Â¶Ã³Â¸Ã© Â¹Â«Â½ÃƒÃ‡Ã‘Â´Ã™. Ã‡Ã˜Ã…Â·Ã€Ã‡ Â¼Ã’ÃÃ¶Â°Â¡ Ã€Ã–Â´Ã™.
					delete pItem;
					return;
				}
				
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {
					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

					// 1Â°Â³ ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™. AmountÂ°Â¡ Â¾Ã†Â´ÃÂ´Ã™!
					*cp = 1;
					cp++;

					memcpy(cp, pItem->m_cName, 20);
					cp += 20;

					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;	// Â¼Ã¶Â·Â®Ã€Â» Ã€Ã”Â·Ã‚ 
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0; // Â¾Ã²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
					cp++;

					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
	
					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
		
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;
					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃ 
					cp++;
					*/

					if (iEraseReq == 1) delete pItem;

					// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}

					// v1.4 Â¼Ã¶Â·Â®Â´ÃœÃ€Â§Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€Ã¼Â´ÃÃ‡Ã‘ Â°ÃÃ€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™. 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, cCharName);
				}
				else {
					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€Ã¼Â´ÃÂ¹ÃÃ€Âº Ã„Â³Â¸Â¯Ã…ÃÂ°Â¡ Â´ÃµÃ€ÃŒÂ»Ã³ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÂºÂ¸Â°Ã¼Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â»Ã³Ã…Ã‚Ã€ÃŒÂ´Ã™.
					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â¸Â°Â´Ã™. 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
	
					// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

					// Â´ÃµÃ€ÃŒÂ»Ã³ Â°Â¡ÃÃºÂ¼Ã¶ Â¾Ã¸Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}

					// v1.4 Â¼Ã¶Â·Â®Â´ÃœÃ€Â§Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€Ã¼Â´ÃÂ¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTGIVEITEM, sItemIndex, iAmount, NULL, cCharName);
				}

			}
			else {
				// NPCÂ¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃ–Â¾ÃºÂ´Ã™.
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					// NPCÂ°Â¡ ÃƒÂ¢Â°Ã­ ÃÃ–Ã€ÃÃ€ÃŒÂ¾ÃºÂ´Ã™Â¸Ã© Â¹Â°Â°Ã‡Ã€Â» ÂºÂ¸Â°Ã¼Ã‡ÃÂ°ÃšÂ´Ã™Â´Ã‚ Ã€Ã‡Â¹ÃŒÃ€ÃŒÂ´Ã™. 
					if (bSetItemToBankItem(iClientH, pItem) == FALSE) {
						// Â¹Â°Â°Ã‡Ã€Â» Â¸ÃƒÂ±Ã¢Â´Ã‚ÂµÂ¥ Â½Ã‡Ã†ÃÃ‡ÃÂ¿Â´Â´Ã™.	
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);

						// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â¹Ã™Â´ÃšÂ¿Â¡ Â¶Â³Â±ÂºÂ´Ã™.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

						// v1.411  
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
	
						// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
								                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
									                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
					}
		   		}
				else {
					// Ã€ÃÂ¹Ã NPCÂ¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃ–Â¸Ã© Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â·ÃÂ¾ÃŸ Ã‡Ã‘Â´Ã™. 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
	
					// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
				}
			}
		}
	}
	else {
		// Â¾Ã†Ã€ÃŒÃ…Ã› Ã€Ã¼ÂºÃÂ¸Â¦ ÃÃ–Â¾ÃºÂ´Ã™.
		
		// Ã€Ã¥Ã‚Ã¸ÃÃŸÃ€Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃ–Â¾ÃºÂ´Ã™Â¸Ã© Â¾Ã†Ã€ÃŒÃ…Ã› Ã€Ã¥Ã‚Ã¸ÃˆÂ¿Â°ÃºÂ¸Â¦ Ã‡Ã˜ÃÂ¦Ã‡Ã˜Â¾ÃŸ Ã‡ÃÂ¹Ã‡Â·Ã.
		ReleaseItemHandler(iClientH, sItemIndex, TRUE);

		// ÃƒÂ³Â¸Â®ÂµÂµÃÃŸ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡Ã’Â¶Â§Â¸Â¦ Â´Ã«ÂºÃ±Ã‡Ã˜Â¼Â­ -1Â·Ã Ã‡Ã’Â´Ã§Ã‡Ã˜ Â³ÃµÂ´Ã‚Â´Ã™.
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) 
			m_pClientList[iClientH]->m_cArrowIndex = -1;
		
		//Ã€ÃŒÃÂ¦ dX, dYÂ¿Â¡ Ã€Ã–Â´Ã‚ Â¿Ã€ÂºÃªÃÂ§Ã†Â®Â¿Â¡Â°Ã” Â¼Ã’ÂºÃ±Â¼Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â°Ã‡Â³Ã—ÃÃ˜Â´Ã™. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); // Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» dX, dYÂ¿Â¡ Ã€Ã–Â´Ã‚ Ã„Â³Â¸Â¯Ã…ÃÂ¿Â¡Â°Ã” ÃÃ˜Â´Ã™. Â¸Â¸Â¾Ã  Â¹ÃÃ€Â» Ã„Â³Â¸Â¯Ã…ÃÂ°Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¹ÃÃÃ¶ Â¸Ã¸Ã‡Ã’ Â»Ã³ÃˆÂ²Ã€ÃŒÂ¶Ã³Â¸Ã© Â¶Â¥Â¿Â¡ Â¶Â³Â¾Ã®ÃÃ¸Â´Ã™.  
		
		// v1.4 ÃÃ–Â°Ã­Ã€Ãš Ã‡Ã‘ Â°Â´ÃƒÂ¼Â¿Ã Â¸Ã‚Â´Ã‚ÃÃ¶ Ã†Ã‡Â´ÃœÃ‡Ã‘Â´Ã™.
		if (wObjectID != NULL) { 
			if (wObjectID < 10000) {
				// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® 
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != NULL) {
						if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != NULL) {
						if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
					}
				}
			}
		}
	
		if (sOwnerH == NULL) {
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃ–Â°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Ã€Ã¥Â¼Ã’Â¿Â¡ Ã„Â³Â¸Â¯Ã…ÃÂ°Â¡ Â¾Ã¸Â´Ã™. 
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â¸Â°Â´Ã™. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                             m_pClientList[iClientH]->m_sY, 
																	     m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
	
			// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
								        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
		
			// Ã€ÃŒÃÂ¦ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÂ³Ã€Â¸Â¹Ã‡Â·Ã Â¸Â®Â½ÂºÃ†Â®Â¿Â¡Â¼Â­ Â»Ã¨ÃÂ¦Ã‡Ã’Â°ÃÃ€Â» Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);
		}
		else {
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â´Ã™Â¸Â¥ Ã„Â³Â¸Â¯Ã…ÃÂ¿Â¡Â°Ã” ÃÃ˜Â´Ã™. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
					
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				// Ä³¸¯ÅÍ¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾ú´Ù.	
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);
				pItem = m_pClientList[iClientH]->m_pItemList[sItemIndex];
				
				// v2.03 Å©·ç¼¼ÀÌµå ¸ğµåÀÎ°æ¿ìµµ ±æµå °¡ÀÔÀº °¡´ÉÇÏ´Ù.

				// v2.17 2002-7-31 ¾ÆÀÌÅÛÀ» ¾ÆÀÌÅÛ °íÀ¯¹øÈ£·Î »ı¼ºÇÒ ¼ö ÀÖ°Ô ÇÑ´Ù.
				if (pItem->m_sIDnum == 88) {

					// ÇÃ·¹ÀÌ¾î iClientH °¡ sOwnerH¿¡°Ô ±æµå°¡ÀÔ ½ÅÃ»¼­¸¦ ÁÖ¾ú´Ù. ¸¸¾à 
					// sOwnerH°¡ ±æµå¸¶½ºÅÍ¶ó¸é ¾ÆÀÌÅÛÀ» ¹Ş´Â °ÍÀÌ ¾Æ´Ï¶ó È®ÀÎÀ» ÇØ ÁÖ¾î¾ß ÇÑ´Ù.
								// v2.17 2002-7-31 ¾ÆÀÌÅÛÀ» ¾ÆÀÌÅÛ °íÀ¯¹øÈ£·Î »ı¼ºÇÒ ¼ö ÀÖ°Ô ÇÑ´Ù.
					if ((m_pClientList[iClientH]->m_iGuildRank == -1) && 
						(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
						(memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[sOwnerH]->m_cLocation, 10) == 0) &&
						(m_pClientList[sOwnerH]->m_iGuildRank == 0) ) {
						// ±æµå ¸¶½ºÅÍÀÌ´Ù.	±æµå ¸¶½ºÅÍ¿¡°Ô´Â °¡ÀÔÈ®ÀÎ ¿äÃ» ¸Ş½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						// ÀÌÁ¦ ¾ÆÀÌÅÛÀ» ÁØ º»ÀÎ¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾úÀ¸¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);
					
						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				// v2.17 2002-7-31 ¾ÆÀÌÅÛÀ» ¾ÆÀÌÅÛ °íÀ¯¹øÈ£·Î »ı¼ºÇÒ ¼ö ÀÖ°Ô ÇÑ´Ù.
				if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {

					// ÇÃ·¹ÀÌ¾î iClientH °¡ sOwnerH¿¡°Ô ±æµåÅ»Åğ ½ÅÃ»¼­¸¦ ÁÖ¾ú´Ù. ¸¸¾à 
					// sOwnerH°¡ ±æµå¸¶½ºÅÍÀÌ°í iClientH¿Í ±æµå ÀÌ¸§ÀÌ °°°í iClientH°¡ ±æµå¿øÀÌ¶ó¸é 
					// ¾ÆÀÌÅÛÀ» ¹Ş´Â °ÍÀÌ ¾Æ´Ï¶ó È®ÀÎÀ» ÇØ ÁÖ¾î¾ß ÇÑ´Ù.
					if ( (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) && 
						 (m_pClientList[iClientH]->m_iGuildRank != -1) && 
						 (m_pClientList[sOwnerH]->m_iGuildRank == 0) ) {
						// ±æµå ¸¶½ºÅÍÀÌ´Ù.	±æµå ¸¶½ºÅÍ¿¡°Ô´Â Å»ÅğÈ®ÀÎ ¿äÃ» ¸Ş½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						// ÀÌÁ¦ ¾ÆÀÌÅÛÀ» ÁØ º»ÀÎ¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾úÀ¸¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);

						_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH,(int) -1, pItem);
					
						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				// Ã€ÃÂ¹ÃÃ€Ã»Ã€Ã Â°Ã¦Â¿Ã¬ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â±Ã—Ã€Ãº Â¹ÃÃ€Â» Â»Ã“...
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {
					
					// v1.41 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€Ã¼Â´ÃÃ‡Ã‘ Â°ÃÃ€ÃŒÂ¶Ã³Â¸Ã© Â·ÃÂ±Ã—Â¸Â¦ Â³Â²Â±Ã¤Â´Ã™. 
					_bItemLog(DEF_ITEMLOG_GIVE, iClientH, sOwnerH, pItem);

					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

					// 1Â°Â³ ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™.
					*cp = 1;
					cp++;

					memcpy(cp, pItem->m_cName, 20);
					cp += 20;

					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0; // Â¾Ã²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
					cp++;

					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
	
					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
		
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;
					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃ 
					cp++;
					*/

					if (iEraseReq == 1) delete pItem;

					// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}
				}
				else {
					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€Ã¼Â´ÃÂ¹ÃÃ€Âº Ã„Â³Â¸Â¯Ã…ÃÂ°Â¡ Â´ÃµÃ€ÃŒÂ»Ã³ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÂºÂ¸Â°Ã¼Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â»Ã³Ã…Ã‚Ã€ÃŒÂ´Ã™.
					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â¸Â°Â´Ã™. 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					// v1.41 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¶Â³Â¾Ã®Â¶ÃŸÂ¸Â° Â°ÃÃ€ÃŒÂ¶Ã³Â¸Ã© Â·ÃÂ±Ã—Â¸Â¦ Â³Â²Â±Ã¤Â´Ã™. 
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
					// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

					// Â´ÃµÃ€ÃŒÂ»Ã³ Â°Â¡ÃÃºÂ¼Ã¶ Â¾Ã¸Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}

					// v1.4 Â¾Ã†Ã€ÃŒÃ…Ã› Ã€Ã¼Â´ÃÃ€ÃŒ Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â½Ã€Â» Â¾Ã‹Â¸Â®Â´Ã‚ Â¹Ã¦Â¹Ã½ 
					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}
			else {
				// NPCÂ¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃ–Â¾ÃºÂ´Ã™.
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					// NPCÂ°Â¡ ÃƒÂ¢Â°Ã­ ÃÃ–Ã€ÃÃ€ÃŒÂ¾ÃºÂ´Ã™Â¸Ã© Â¹Â°Â°Ã‡Ã€Â» ÂºÂ¸Â°Ã¼Ã‡ÃÂ°ÃšÂ´Ã™Â´Ã‚ Ã€Ã‡Â¹ÃŒÃ€ÃŒÂ´Ã™. 
					if (bSetItemToBankItem(iClientH, sItemIndex) == FALSE) {
						// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÂºÂ¸Â°Ã¼Ã‡ÃÂ´Ã‚ÂµÂ¥ Â½Ã‡Ã†ÃÃ‡ÃÂ¿Â© Â¹Ã™Â´ÃšÂ¿Â¡ Â¶Â³Â¾Ã®ÃÂ³Â´Ã™.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);
						
						// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â¹Ã™Â´ÃšÂ¿Â¡ Â¶Â³Â±ÂºÂ´Ã™.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
						                                                         	 m_pClientList[iClientH]->m_sY, 
							                                                         m_pClientList[iClientH]->m_pItemList[sItemIndex]);
						
						// v1.41 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¶Â³Â¾Ã®Â¶ÃŸÂ¸Â° Â°ÃÃ€ÃŒÂ¶Ã³Â¸Ã© Â·ÃÂ±Ã—Â¸Â¦ Â³Â²Â±Ã¤Â´Ã™. 
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
						
						// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
							                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
							                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
													m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
					}
				}
				else if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Kennedy", 7) == 0) {
					// Â±Ã¦ÂµÃ¥ Â»Ã§Â¹Â«Ã€Ã¥Â¿Â¡Â°Ã” Â±Ã¦ÂµÃ¥ Ã…Â»Ã…Ã° Â½Ã…ÃƒÂ»Â¼Â­Â¸Â¦ ÃÃ–Â¾ÃºÂ´Ã™Â¸Ã© Â±Ã¦ÂµÃ¥Â¸Â¦ Ã…Â»Ã…Ã°Ã‡Ã‘Â´Ã™. 
					if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 89)) {
						
						if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
							// Ã…Â»Ã…Ã° Â½Ã…ÃƒÂ»Ã€ÃšÂ¿Â¡Â°Ã” Ã…Â»Ã…Ã° Â¼ÂºÂ°Ã¸Ã‡ÃŸÃ€Â½Ã€Â» Â¾Ã‹Â¸Â®Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»ÃÃ˜Â´Ã™.
							SendNotifyMsg(iClientH, iClientH, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);
						
							// Â±Ã¦ÂµÃ¥ Ã…Â»Ã…Ã°. 
							ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
							memcpy(m_pClientList[iClientH]->m_cGuildName, "NONE", 4);
							m_pClientList[iClientH]->m_iGuildRank = -1;
							m_pClientList[iClientH]->m_iGuildGUID = -1;

							// Ã†Â¯Â¼ÂºÃ€ÃŒ Â¹Ã™Â²Ã®Â¹Ã‡Â·Ã Â¿ÃœÂ¾Ã§Ã€Â» Â»ÃµÂ·Ã ÂºÂ¸Â³Â½Â´Ã™. 
							SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

							// Â¾Ã Â°Â£Ã€Ã‡ Â°Ã¦Ã‡Ã¨Ã„Â¡Â°Â¡ Ã‡ÃÂ¶Ã´Ã‡Ã‘Â´Ã™.
							m_pClientList[iClientH]->m_iExp -= 300;
							if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
						}

						// Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Âº Â»Ã¨ÃÂ¦Â½ÃƒÃ„Ã‘Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
						delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
					} 
					else {
						// Â±Ã¦ÂµÃ¥ Ã…Â»Ã…Ã° Â½Ã…ÃƒÂ»Â¼Â­Â°Â¡ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© Â¹Ã™Â´ÃšÂ¿Â¡ Â¶Â³Â±ÂºÂ´Ã™. Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â¸Ã°ÂµÃ¥Ã€ÃÂ¶Â§ÂµÂµ Â±Ã¦ÂµÃ¥ Â°Ã¼Â·Ãƒ Â¿Â¬Â»Ãª ÂºÃ’Â°Â¡ 
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						// v1.41 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¶Â³Â¾Ã®Â¶ÃŸÂ¸Â° Â°ÃÃ€ÃŒÂ¶Ã³Â¸Ã© Â·ÃÂ±Ã—Â¸Â¦ Â³Â²Â±Ã¤Â´Ã™. 
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
						// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

						// v1.4 Â¾Ã†Ã€ÃŒÃ…Ã› Ã€Ã¼Â´ÃÃ€ÃŒ Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â½Ã€Â» Â¾Ã‹Â¸Â®Â´Ã‚ Â¹Ã¦Â¹Ã½ 
						ZeroMemory(cCharName, sizeof(cCharName));

					}
				}
				else {
					// Ã€ÃÂ¹Ã NPCÂ¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃ–Â¸Ã© Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â·ÃÂ¾ÃŸ Ã‡Ã‘Â´Ã™. 

					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					// v1.41 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¶Â³Â¾Ã®Â¶ÃŸÂ¸Â° Â°ÃÃ€ÃŒÂ¶Ã³Â¸Ã© Â·ÃÂ±Ã—Â¸Â¦ Â³Â²Â±Ã¤Â´Ã™. 
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
					// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

					// v1.4 Â¾Ã†Ã€ÃŒÃ…Ã› Ã€Ã¼Â´ÃÃ€ÃŒ Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â½Ã€Â» Â¾Ã‹Â¸Â®Â´Ã‚ Â¹Ã¦Â¹Ã½ 
					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}

			// Ã€ÃŒÃÂ¦ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃ˜ ÂºÂ»Ã€ÃÂ¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃ–Â¾ÃºÃ€Â¸Â¹Ã‡Â·Ã Â¸Â®Â½ÂºÃ†Â®Â¿Â¡Â¼Â­ Â»Ã¨ÃÂ¦Ã‡Ã’Â°ÃÃ€Â» Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, cCharName);
		}

REMOVE_ITEM_PROCEDURE:;

		// Â³Ã—Ã†Â®Â¿Ã¶Ã…Â© Â¿Ã€Â·Ã¹Â·Ã ÃƒÂ³Â¸Â®ÂµÂµÃÃŸ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â°Â¡ ÃÂ¦Â°Ã…ÂµÃ‡Â¾ÃºÂ´Ã™Â¸Ã© Â´ÃµÃ€ÃŒÂ»Ã³ ÃÃ¸Ã‡Ã Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
		if (m_pClientList[iClientH] == NULL) return;

		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃ–Â°Ã…Â³Âª Â¹Ã¶Â·ÃˆÃ€Â¸Â¹Ã‡Â·Ã ÃÃ¶Â¿Ã®Â´Ã™. deleteÃ‡Ã˜Â¼Â­Â´Ã‚ Â¾ÃˆÂµÃˆÂ´Ã™! 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
		
		// ÃˆÂ­Â»Ã¬ Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ Ã€Ã§ Ã‡Ã’Â´Ã§
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
	iCalcTotalWeight(iClientH);
}

void CGame::SendNotifyMsg(int iFromH, int iToH, WORD wMsgType, DWORD sV1, DWORD sV2, DWORD sV3, char * pString, DWORD sV4, DWORD sV5, DWORD sV6, DWORD sV7, DWORD sV8, DWORD sV9, char * pString2)
{
 char cData[1000];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 int   * ip, iRet, i;
	
	if (m_pClientList[iToH] == NULL) return;

	ZeroMemory(cData, sizeof(cData));

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);			   
	*wp  = wMsgType;

	cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);

	// !!! sV1, sV2, sV3Â´Ã‚ DWORDÃ‡Ã¼Ã€Ã“Ã€Â» Â¸Ã­Â½Ã‰Ã‡ÃÂ¶Ã³.
	switch (wMsgType) {
	case DEF_NOTIFY_HELDENIANCOUNT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		cp += 14;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);

		break;
	
	case DEF_NOTIFY_NOMOREAGRICULTURE:
	case DEF_NOTIFY_AGRICULTURESKILLLIMIT:
	case DEF_NOTIFY_AGRICULTURENOAREA:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	// New 18/05/2004
	case DEF_NOTIFY_SPAWNEVENT:
		*cp = (char)sV3;
		cp++;

		sp = (short *)cp;
		*cp = sV1;
		cp += 2;

		sp = (short *)cp;
		*cp = sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 11);
		break;

	case DEF_NOTIFY_QUESTCOUNTER:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;
	
	case DEF_NOTIFY_APOCGATECLOSE:
	case DEF_NOTIFY_APOCGATEOPEN:
		ip  = (int *)cp;
		*ip = sV1;
		cp += 4;

		ip  = (int *)cp;
		*ip = sV2;
		cp += 4;

		memcpy(cp,pString,10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;

	case DEF_NOTIFY_ABADDONKILLED:
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;

	case DEF_NOTIFY_APOCFORCERECALLPLAYERS:
	case DEF_NOTIFY_APOCGATESTARTMSG:
	case DEF_NOTIFY_APOCGATEENDMSG:
	case DEF_NOTIFY_NORECALL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_FORCERECALLTIME:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	// New 16/05/2004
	//0xB4E2, 0xBEB
	case DEF_NOTIFY_MONSTERCOUNT:
	case DEF_NOTIFY_SLATE_STATUS:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	//0x0BE5, 0x0BE7, 0x0BE8, 0x0BEA
	case DEF_NOTIFY_0BE8:
	case DEF_NOTIFY_HELDENIANTELEPORT:
	case DEF_NOTIFY_HELDENIANEND:
	case DEF_NOTIFY_RESURRECTPLAYER:
	case DEF_NOTIFY_SLATE_EXP:
	case DEF_NOTIFY_SLATE_MANA:
	case DEF_NOTIFY_SLATE_INVINCIBLE:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_SLATE_CREATEFAIL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_SLATE_CREATESUCCESS:
		dwp  = (DWORD *)cp;
		*dwp = sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	// New 07/05/2004
	// Party Notify Msg's
	case DEF_NOTIFY_PARTY:
		switch(sV1) {
		case 4:
		case 6:
			wp = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;

			memcpy(cp,pString,10);
			cp += 10;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
			break;
		case 5:
			wp = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;

			memcpy(cp, pString, sV3 * 11);
			cp += sV3 * 11;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12 + (sV3 * 11));
			break;
		default:
			wp = (WORD *)cp;
			*wp = (WORD)sV1;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV2;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV3;
			cp += 2;

			wp = (WORD *)cp;
			*wp = (WORD)sV4;
			cp += 2;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
				break;
		}
		break;

	case DEF_NOTIFY_REQGUILDNAMEANSWER:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);
		break;

	// New 06/05/2004
	// Upgrade Notify Msg's
	case DEF_NOTIFY_ITEMUPGRADEFAIL:
		sp  = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,8);
		break;

	case DEF_NOTIFY_ITEMATTRIBUTECHANGE:
	case DEF_NOTIFY_GIZONITEMUPGRADELEFT:
		sp  = (short *)cp;
		*sp = sV1;
		cp += 2;

		dwp = (DWORD *)cp;
		*dwp = sV2;
		cp += 4;

		dwp = (DWORD *)cp;
		*dwp = sV3;
		cp += 4;

		dwp = (DWORD *)cp;
		*dwp = sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,20);
		break;

	case DEF_NOTIFY_GIZONITEMCANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		*cp = (char)sV2;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		*cp = (char)sV6;
		cp++;

		*cp = (char)sV7;
		cp++;

		dwp = (DWORD *)cp;
		*dwp = sV8;
		cp += 4;

		memcpy(cp,pString,20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,41);
		break;

// 2.06 - by KLKS
	case DEF_NOTIFY_CHANGEPLAYMODE:
		memcpy(cp,pString,10);
		cp += 10;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData,16);
		break;
//

	case DEF_NOTIFY_TCLOC:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV5;
		cp += 2;
		
		memcpy(cp, pString2, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;
	
	//New 11/05/2004
	case DEF_NOTIFY_GRANDMAGICRESULT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		if (sV9 > 0) {
			memcpy(cp,pString2,(sV9*2)+2);
			cp += (sV9*2)+2;
		}
		else{
			sp = (short *)cp;
			*sp = 0;
			cp += 2;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, (sV9*2)+26);
		break;
	
	case DEF_NOTIFY_MAPSTATUSNEXT:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;

	case DEF_NOTIFY_MAPSTATUSLAST:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;
	
	case DEF_NOTIFY_LOCKEDMAP:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 18);
		break;
	
	case DEF_NOTIFY_BUILDITEMSUCCESS:
	case DEF_NOTIFY_BUILDITEMFAIL:
		
		if (sV1 >= 0) {
			sp = (short *)cp;
			*sp = (short)sV1;
			cp += 2;
		}
		else {
			sp = (short *)cp;
			*sp = (short)sV1 + 10000;
			cp += 2;
		}

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
		
	case DEF_NOTIFY_HELP:
	case DEF_NOTIFY_QUESTREWARD:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;
				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
		
	case DEF_NOTIFY_CANNOTCONSTRUCT:
	case DEF_NOTIFY_METEORSTRIKECOMING:
	case DEF_NOTIFY_METEORSTRIKEHIT:
	case DEF_NOTIFY_HELPFAILED:
	case DEF_NOTIFY_SPECIALABILITYENABLED:
	case DEF_NOTIFY_FORCEDISCONN:
	case DEF_NOTIFY_OBSERVERMODE:
	case DEF_NOTIFY_QUESTCOMPLETED:
	case DEF_NOTIFY_QUESTABORTED:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_QUESTCONTENTS:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;
	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 44);
		break;
		
	case DEF_NOTIFY_ENERGYSPHERECREATED:
	case DEF_NOTIFY_ITEMCOLORCHANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_NOMORECRUSADESTRUCTURE:
	case DEF_NOTIFY_EXCHANGEITEMCOMPLETE:
	case DEF_NOTIFY_CANCELEXCHANGEITEM:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SETEXCHANGEITEM:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;
		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;
	
	case DEF_NOTIFY_OPENEXCHANGEWINDOW:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;
	
	case DEF_NOTIFY_NOTFLAGSPOT:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_ITEMPOSLIST:
		for (i = 0; i < DEF_MAXITEMS; i++) {
			sp = (short *)cp;
			*sp = (short)m_pClientList[iToH]->m_ItemPosList[i].x;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_pClientList[iToH]->m_ItemPosList[i].y;
			cp += 2;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXITEMS*4);
		break;
	
	case DEF_NOTIFY_ENEMYKILLS:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_CRUSADE:
		ip = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_CONSTRUCTIONPOINT:
	case DEF_NOTIFY_SPECIALABILITYSTATUS:
	case DEF_NOTIFY_DAMAGEMOVE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case DEF_NOTIFY_DOWNSKILLINDEXSET:
	case DEF_NOTIFY_RESPONSE_CREATENEWPARTY:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_ADMINIFO:
		switch (sV1) {
		case 1:
			// NPCÃ€Ã‡ ÃÂ¤ÂºÂ¸Â¸Â¦ Â¾Ã²Â¾Ã®Â¿Ã‚Â´Ã™.
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHP;
			cp += 4;
			
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iDefenseRatio;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_bIsSummoned;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_cActionLimit;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHitDice;
			cp += 4;

			dwp  = (DWORD *)cp; // v1.4
			*dwp = m_pNpcList[sV2]->m_dwDeadTime;
			cp += 4;

			dwp  = (DWORD *)cp; 
			*dwp = m_pNpcList[sV2]->m_dwRegenTime;
			cp += 4;

			ip  = (int *)cp; 
			*ip	= (int)m_pNpcList[sV2]->m_bIsKilled;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26 + 12);
			break;
		}
		break;

	case DEF_NOTIFY_HELDENIANSTART:
	case DEF_NOTIFY_NPCTALK:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString != NULL) memcpy(cp, pString, 20);
		cp += 20;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 64);
		break;

	case DEF_NOTIFY_PORTIONSUCCESS:
	case DEF_NOTIFY_LOWPORTIONSKILL:
	case DEF_NOTIFY_PORTIONFAIL:
	case DEF_NOTIFY_NOMATCHINGPORTION:
		// Ã€ÃÃ„Â¡Ã‡ÃÂ´Ã‚ Ã†Ã·Â¼Ã‡ ÃÂ¶Ã‡Ã•Ã€ÃŒ Â¾Ã¸Â´Ã™.
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SUPERATTACKLEFT:
		sp = (short *)cp;
		*sp = m_pClientList[iToH]->m_iSuperAttackLeft;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_SAFEATTACKMODE:
		*cp = m_pClientList[iToH]->m_bIsSafeAttackMode;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
	
	case DEF_NOTIFY_QUERY_JOINPARTY:
	case DEF_NOTIFY_IPACCOUNTINFO:
		strcpy(cp, pString);
		cp += strlen(pString);

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
		break;
	
	case DEF_NOTIFY_REWARDGOLD:
		dwp = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iRewardGold;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SERVERSHUTDOWN:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_GLOBALATTACKMODE:
	case DEF_NOTIFY_WHETHERCHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
		
	case DEF_NOTIFY_FISHCANCELED:
	case DEF_NOTIFY_FISHSUCCESS:
	case DEF_NOTIFY_FISHFAIL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_DEBUGMSG:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_FISHCHANCE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_ENERGYSPHEREGOALIN:
	case DEF_NOTIFY_EVENTFISHMODE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_NOTICEMSG:
		memcpy(cp, pString, strlen(pString));
		cp += strlen(pString);

		*cp = NULL;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, strlen(pString) + 7);
		break;

	case DEF_NOTIFY_CANNOTRATING:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_RATINGPLAYER:
		*cp = (char)sV1;
		cp++;

		memcpy(cp, pString, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_ADMINUSERLEVELLOW:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_PLAYERSHUTUP:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 19);
		break;
	
	case DEF_NOTIFY_TIMECHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_TOBERECALLED:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_HUNGER:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_PLAYERPROFILE:
		if (strlen(pString) > 100) {
			memcpy(cp, pString, 100);
			cp += 100;
		}
		else {
			memcpy(cp, pString, strlen(pString));
			cp += strlen(pString);
		}
		*cp = NULL;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7 + strlen(pString));
		break;

	// New 10/05/2004 Changed
	case DEF_NOTIFY_WHISPERMODEON:
	case DEF_NOTIFY_WHISPERMODEOFF:
	case DEF_NOTIFY_PLAYERNOTONGAME:
		memcpy(cp, pString, 10);
		cp += 10;

		memcpy(cp, "          ", 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 27);
		break;

	// New 15/05/2004 Changed
	case DEF_NOTIFY_PLAYERONGAME:
		memcpy(cp, pString, 10);
		cp += 10;

		if (pString[0] != 0) {
			memcpy(cp, pString2, 14);
			cp += 14;
		}

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 31);
		break;
	
	// New 06/05/2004
	case DEF_NOTIFY_ITEMSOLD:
	case DEF_NOTIFY_ITEMREPAIRED:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	// New 06/05/2004
	case DEF_NOTIFY_REPAIRITEMPRICE:
	case DEF_NOTIFY_SELLITEMPRICE:
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV1;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV2;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV3;
		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = (DWORD)sV4;
		cp += 4;

		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 42);
		break;

	case DEF_NOTIFY_CANNOTREPAIRITEM:
	case DEF_NOTIFY_CANNOTSELLITEM:
		wp = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);

		break;
	
	case DEF_NOTIFY_SHOWMAP:
		wp  = (WORD *)cp;  // ÂºÂ¸Â¿Â©ÃÃ–Â´Ã‚ ÃÂ¾Â·Ã¹ 
		*wp = (WORD)sV1;
		cp += 2;
		
		wp  = (WORD *)cp;  // Â¸ÃŠ Â¹Ã¸ÃˆÂ£ (0 aresden, 1 elvine, 3 middleland...)
		*wp = (WORD)sV2;
		cp += 2;
	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SKILLUSINGEND:
		wp  = (WORD *)cp;  // Â±Ã¢Â¼Ãº Â»Ã§Â¿Ã« Â°Ã¡Â°Ãº 
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_TOTALUSERS:
		wp  = (WORD *)cp;    
		*wp = (WORD)m_iTotalGameServerClients; //_iGetTotalClients();
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_MAGICEFFECTOFF:
	case DEF_NOTIFY_MAGICEFFECTON:
		wp  = (WORD *)cp;  // Â¸Â¶Â¹Ã½ ÃˆÂ¿Â°Ãº ÃÂ¾Â·Ã¹ 
		*wp = (WORD)sV1;
		cp += 2;
		
		dwp  = (DWORD *)cp;  // Â¸Â¶Â¹Ã½ ÃˆÂ¿Â°Ãº ÃˆÂ¿Â·Ã‚  
		*dwp = (DWORD)sV2;
		cp += 4;

		dwp  = (DWORD *)cp;  // Â¸Â¶Â¹Ã½ ÃˆÂ¿Â°Ãº ÃˆÂ¿Â·Ã‚  
		*dwp = (DWORD)sV3;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;
	
	case DEF_NOTIFY_CANNOTITEMTOBANK:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SERVERCHANGE:
		memcpy(cp, m_pClientList[iToH]->m_cMapName, 10);
		cp += 10;
	
		// World ServerÃ€Ã‡ ÃÃ–Â¼Ã’Â¸Â¦ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
		memcpy(cp, m_cLogServerAddr, 15);
		cp += 15;

		ip = (int *)cp;
		*ip = m_iLogServerPort;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16 +19);
		break;

	case DEF_NOTIFY_SKILL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SETITEMCOUNT:
		wp  = (WORD *)cp;  // Â¾Ã†Ã€ÃŒÃ…Ã› Ã€ÃÂµÂ¦Â½Âº Â¹Ã¸ÃˆÂ£ 
		*wp = (WORD)sV1;
		cp += 2;
		
		dwp  = (DWORD *)cp;  // Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Ã‡Ã¶Ã€Ã§ Â¼Ã¶Â·Â® 
		*dwp = (DWORD)sV2;
		cp += 4;
				
		*cp = (char)sV3;
		cp++;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 13);
		break;

	case DEF_NOTIFY_ITEMDEPLETED_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case DEF_NOTIFY_DROPITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;
		
	case DEF_NOTIFY_CANNOTGIVEITEM:
	case DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_GIVEITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_ENEMYKILLREWARD:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iEnemyKillCount;
		cp += 4;
		memcpy(cp, m_pClientList[sV1]->m_cCharName, 10);
		cp += 10;
		memcpy(cp, m_pClientList[sV1]->m_cGuildName, 20);
		cp += 20;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[sV1]->m_iGuildRank;
		cp += 2;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[iToH]->m_iWarContribution;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_PKCAPTURED:
		// PKÂ¸Â¦ Ã€Ã¢Â¾Ã’Â´Ã™.
		// PKÃ€Ã‡ PKcount
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		memcpy(cp, pString, 10);
		cp += 10;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iRewardGold;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iExp;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_NOTIFY_PKPENALTY:
		// PK Ã†Ã¤Â³ÃÃ†Â¼Â¸Â¦ Â¸Ã”Â¾ÃºÂ´Ã™.
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iStr;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iVit;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iDex;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iInt;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMag;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iPKCount;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
	
	case DEF_NOTIFY_TRAVELERLIMITEDLEVEL:
	case DEF_NOTIFY_LIMITEDLEVEL:
		// ÃƒÂ¼Ã‡Ã¨Ã†Ã‡ Â»Ã§Â¿Ã«Ã€ÃšÂ´Ã‚ Â´ÃµÃ€ÃŒÂ»Ã³ Â·Â¹ÂºÂ§Ã€Â» Â¿ÃƒÂ¸Â± Â¼Ã¶ Â¾Ã¸Ã€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_ITEMRELEASED:
	case DEF_NOTIFY_ITEMLIFESPANEND:
		// Ã€Ã¼Ã…ÃµÃÃŸ Â¹Â«Â±Ã¢, ÃˆÂ¤Ã€Âº Â¹Ã¦Â¾Ã®Â±Â¸ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Ã­Ã€ÃŒ Â´Ã™Ã‡Ã˜ Â¸ÃÂ°Â¡ÃÂ³Ã€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
		sp  = (short *)cp;
		*sp = (short)sV1;	// Ã€Ã¥Ã‚Ã¸ Ã€Â§Ã„Â¡ 
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;	// Â¾Ã†Ã€ÃŒÃ…Ã› Â¹Ã¸ÃˆÂ£  
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_KILLED:
		// Â»Ã§Â¸Ã Ã…Ã«ÂºÂ¸ : ÃÃ—Ã€Ã Ã„Â³Â¸Â¯Ã…Ã Ã€ÃŒÂ¸Â§ÂµÂµ Ã‡Ã”Â²Â² ÂºÂ¸Â³Â»ÃÃ˜Â´Ã™. 
		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26);
		break;
	
	case DEF_NOTIFY_EXP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_NOTIFY_HP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iHP;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP; // v2.04 0926 HPÃ€Ã‡ ÂµÃšÂ¿Â¡ MPÂ¸Â¦ Â°Â°Ã€ÃŒ Â¾Ã‹Â·ÃÃÃ˜Â´Ã™. Â¸Â¶Â³ÂªÂºÂ¯ÃˆÂ¯Ã€Ã‡ Ã†Â¯Â¼ÂºÃ„Â¡ Â¶Â§Â¹Â® 
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_NOTIFY_MP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iSP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_CHARISMA:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

		//MOG Fixes
	case DEF_NOTIFY_STATECHANGE_FAILED:		// 2003-04-14 ÃÃ¶ÃÂ¸ Ã†Ã·Ã€ÃÃ†Â®Â¸Â¦ Â·Â¹ÂºÂ§ Â¼Ã¶ÃÂ¤Â¿Â¡ Â½Ã‡Ã†Ã..korean buttplugs
	case DEF_NOTIFY_SETTING_FAILED:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_STATECHANGE_SUCCESS:	// 2003-04-14 ÃÃ¶ÃÂ¸ Ã†Ã·Ã€ÃÃ†Â®Â¸Â¦ Â·Â¹ÂºÂ§ Â¼Ã¶ÃÂ¤Â¿Â¡ Â¼ÂºÂ°Ã¸.. wtf korean junk
		{
			int i;

			for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
				*cp = m_pClientList[iToH]->m_cMagicMastery[i];
				cp++;
			}

			for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
				*cp = m_pClientList[iToH]->m_cSkillMastery[i];
				cp++;
			}

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
		}
		break;

	case DEF_NOTIFY_SETTING_SUCCESS:
	case DEF_NOTIFY_LEVELUP:
		ip  = (int *)cp;
		*ip = m_pClientList[iToH]->m_iLevel;
		cp += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iStr;		
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iVit;								
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iDex;			
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iInt;					
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iMag;						
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iCharisma;
		cp  += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;

		/*
	case DEF_NOTIFY_LEVELUP:
		ip  = (int *)cp;
		*ip = m_pClientList[iToH]->m_iLevel;
		cp += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iStr;		
		cp  += 4;
		

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iDex;			
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iInt;					
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iMag;						
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iCharisma;
		cp  += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;
*/
	case DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
	case DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION:
	case DEF_NOTIFY_CANNOTJOINMOREGUILDSMAN:
		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		if (m_pClientList[iFromH] != NULL)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:			
    case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:		
    case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		if (m_pClientList[iFromH] != NULL)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;

	case DEF_NOTIFY_GUILDDISBANDED:
		
		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;
	  
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 36);
		break;

	// v1.4311-3 ÃƒÃŸÂ°Â¡ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â»Ã§Ã…ÃµÃ€Ã¥ Â¿Â¹Â¾Ã Ã€ÃŒ ÃƒÃ«Â¼Ã’ÂµÃ‡Â¾ÃºÂ´Ã™Â°Ã­ Â¾Ã‹Â¸Â² ..
	case DEF_NOTIFY_FIGHTZONERESERVE:
		ip = (int *)cp;
		*ip = (int )sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break; 

	// v1.4311-3 ÃƒÃŸÂ°Â¡ Â±Ã¦ÂµÃ¥ Â¸Â¶Â½ÂºÃ…ÃÂ°Â¡ Â¾Ã†Â´Ã‘Â°Ã¦Â¿Ã¬ .
	case DEF_NOTIFY_NOGUILDMASTERLEVEL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	// v1.4311-3 ÃƒÃŸÂ°Â¡ Ã€ÃšÂ½Ã…Ã€Ã‡ Â±Ã¦ÂµÃ¥Â¿Ã¸Ã€ÃŒ  Â¾Ã†Â´Ã‘Â°Ã¦Â¿Ã¬ 
	case DEF_NOTIFY_CANNOTBANGUILDMAN:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
		// ÃƒÂ³Â¸Â® ÂµÂµÃÃŸ Â¿Ã€Â·Ã¹Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃÂ´Ã‚ Â°ÃÃ€Â» Â¸Â·Â±Ã¢ Ã€Â§Ã‡Ã˜ ÃÃ¶Â¿Ã¬ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. Time OutÃ€Â¸Â·Ã Â»Ã¨ÃÂ¦ÂµÃ‰ Â°ÃÃ€Ã“. 
		//DeleteClient(iToH, TRUE, TRUE);
		return;
	}
}

void CGame::JoinGuildApproveHandler(int iClientH, char * pName)
{
 register int i;
 BOOL bIsExist = FALSE;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pNameÃ€Â» Â°Â®Â´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Ã€Ã‡ iClientH Â±Ã¦ÂµÃ¥Â¿Â¡ Â´Ã«Ã‡Ã‘ Â°Â¡Ã€Ã”Â¿Ã¤Â±Â¸Â°Â¡ Â¼ÂºÂ°Ã¸Ã‡ÃÂ¿Â´Â´Ã™.
	
	// pNameÃ€Ã‡ Ã€ÃŒÂ¸Â§Ã€Â» Â°Â®Â´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â±Â¸ÃÂ¶ÃƒÂ¼Â¸Â¦ Â°Ã‹Â»Ã¶Ã‡Ã‘Â´Ã™.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		// v1.4 Â¼Ã’Â¼Ã“ Â¸Â¶Ã€Â»Ã€ÃŒ Â´ÃÂ¶Ã³ÂµÂµ Â¹Â«Â½ÃƒÂµÃˆÂ´Ã™.
		if (memcmp(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) != 0) return;
		
		// Â±Ã¦ÂµÃ¥Ã€Ã‡ Ã€ÃŒÂ¸Â§Ã€Â» ÂºÂ¹Â»Ã§Ã‡ÃÂ°Ã­ Â¼Ã¶Ã„Â¡Â¸Â¦ ÃƒÃŠÂ±Ã¢ÃˆÂ­Ã‡Ã˜ ÃÃ˜Â´Ã™.
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName);
		
		// Â±Ã¦ÂµÃ¥ GUIDÂºÂ¹Â»Ã§Ã‡Ã‘Â´Ã™.
		m_pClientList[i]->m_iGuildGUID = m_pClientList[iClientH]->m_iGuildGUID;

		// Â±Ã¦ÂµÃ¥Ã€Ã‡ Â»Ã½Â¼ÂºÃ€Â§Ã„Â¡Â¸Â¦ ÃƒÃŠÂ±Ã¢ÃˆÂ­Ã‡Ã‘Â´Ã™.
		ZeroMemory(m_pClientList[i]->m_cLocation, sizeof(m_pClientList[i]->m_cLocation));
		strcpy(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation);

		m_pClientList[i]->m_iGuildRank = DEF_GUILDSTARTRANK; //@@@  GuildRankÃ€Ã‡ Â½ÃƒÃ€Ã›Ã€Âº DEF_GUILDSTARTRANK
		
		// Â°Â¡Ã€Ã” Â½Ã…ÃƒÂ»Ã€ÃšÂ¿Â¡Â°Ã” Â°Â¡Ã€Ã”Ã€ÃŒ Â¼ÂºÂ°Ã¸Ã‡ÃŸÃ€Â½Ã€Â» Â¾Ã‹Â¸Â®Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»ÃÃ˜Â´Ã™.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDAPPROVE, NULL, NULL, NULL, NULL);

		// Ã†Â¯Â¼ÂºÃ€ÃŒ Â¹Ã™Â²Ã®Â¹Ã‡Â·Ã Â¿ÃœÂ¾Ã§Ã€Â» Â»ÃµÂ·Ã ÂºÂ¸Â³Â½Â´Ã™. 
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		
		// Â´Ã™Â¸Â¥ Â±Ã¦ÂµÃ¥Â¿Ã¸ÂµÃ©Â¿Â¡Â°Ã” Â»Ãµ Â±Ã¦ÂµÃ¥Â¿Ã¸Ã€ÃŒ Ã€Ã–Ã€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
		SendGuildMsg(i, DEF_NOTIFY_NEWGUILDSMAN, NULL, NULL, NULL);

		// Â±Ã¦ÂµÃ¥ÃÂ¤ÂºÂ¸ÃˆÂ­Ã€ÃÂ¿Â¡ Â»Ãµ Â±Ã¦ÂµÃ¥Â¿Ã¸Ã€Ã‡ Ã€ÃŒÂ¸Â§Ã€Â» Â±Ã¢Â·ÃÃ‡Ã‘Â´Ã™.
		bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN, i);
		return;
	}

	// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡Ã‘ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¸Â¦ ÃƒÂ£Ã€Â»Â¼Ã¶ Â¾Ã¸Â´Ã™.(ÃÂ¢Â¼Ã“Ã€ÃŒ Â±Ã—Â»Ã§Ã€ÃŒ Â²Ã·Â°Ã¥Â´Ã™Â´Ã¸ÃÃ¶) Â¹Â«ÃˆÂ¿Ã€Ã“ 
}

void CGame::JoinGuildRejectHandler(int iClientH, char * pName)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pNameÃ€Â» Â°Â®Â´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Ã€Ã‡ iClientH Â±Ã¦ÂµÃ¥Â¿Â¡ Â´Ã«Ã‡Ã‘ Â°Â¡Ã€Ã” Â¿Ã¤Â±Â¸Â°Â¡ Â½Ã‡Ã†Ã Ã‡ÃÂ¿Â´Â´Ã™.

	// pNameÃ€Ã‡ Ã€ÃŒÂ¸Â§Ã€Â» Â°Â®Â´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â±Â¸ÃÂ¶ÃƒÂ¼Â¸Â¦ Â°Ã‹Â»Ã¶Ã‡Ã‘Â´Ã™.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		// Â°Â¡Ã€Ã” Â½Ã…ÃƒÂ»Ã€ÃšÂ¿Â¡Â°Ã” Â°Â¡Ã€Ã”Ã€ÃŒ Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â½Ã€Â» Â¾Ã‹Â¸Â®Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»ÃÃ˜Â´Ã™.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDREJECT, NULL, NULL, NULL, NULL);
		return;
	}

	// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡Ã‘ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¸Â¦ ÃƒÂ£Ã€Â»Â¼Ã¶ Â¾Ã¸Â´Ã™.(ÃÂ¢Â¼Ã“Ã€ÃŒ Â±Ã—Â»Ã§Ã€ÃŒ Â²Ã·Â°Ã¥Â´Ã™Â´Ã¸ÃÃ¶) Â¹Â«ÃˆÂ¿Ã€Ã“ 
}

void CGame::DismissGuildApproveHandler(int iClientH, char * pName)
{
 register int i;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);
		//_bItemLog(DEF_ITEMLOG_BANGUILD,i,(char *)NULL,NULL) ;
		SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);
	
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, "NONE");
		m_pClientList[i]->m_iGuildRank = -1; 
		m_pClientList[i]->m_iGuildGUID = -1;

		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);
		
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		return;
	}

}

void CGame::DismissGuildRejectHandler(int iClientH, char * pName)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pNameÃ€Â» Â°Â®Â´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Ã€Ã‡ iClientH Â±Ã¦ÂµÃ¥Â¿Â¡ Â´Ã«Ã‡Ã‘ Ã…Â»Ã…Ã° Â¿Ã¤Â±Â¸Â°Â¡ Â½Ã‡Ã†Ã Ã‡ÃÂ¿Â´Â´Ã™.

	// pNameÃ€Ã‡ Ã€ÃŒÂ¸Â§Ã€Â» Â°Â®Â´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â±Â¸ÃÂ¶ÃƒÂ¼Â¸Â¦ Â°Ã‹Â»Ã¶Ã‡Ã‘Â´Ã™.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		// Â°Â¡Ã€Ã” Â½Ã…ÃƒÂ»Ã€ÃšÂ¿Â¡Â°Ã” Ã…Â»Ã…Ã°Â°Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â½Ã€Â» Â¾Ã‹Â¸Â®Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»ÃÃ˜Â´Ã™.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDREJECT, NULL, NULL, NULL, NULL);
		return;
	}

	// Ã…Â»Ã…Ã°Â¸Â¦ Â½Ã…ÃƒÂ»Ã‡Ã‘ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¸Â¦ ÃƒÂ£Ã€Â»Â¼Ã¶ Â¾Ã¸Â´Ã™.(ÃÂ¢Â¼Ã“Ã€ÃŒ Â±Ã—Â»Ã§Ã€ÃŒ Â²Ã·Â°Ã¥Â´Ã™Â´Ã¸ÃÃ¶) Â¹Â«ÃˆÂ¿Ã€Ã“ 
}


DWORD CGame::dwGetItemCount(int iClientH, char * pName)
{
 register int i;
 char cTmpName[21];

	if (m_pClientList[iClientH] == NULL) return NULL;
	
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		
		return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
	}

	return 0;
}

int CGame::SetItemCount(int iClientH, char * pItemName, DWORD dwCount)
{
 register int i;
 char cTmpName[21];
 WORD wWeight;
	
	if (m_pClientList[iClientH] == NULL) return -1;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		
		wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], 1);// m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;

		// Ã„Â«Â¿Ã®Ã†Â®Â°Â¡ 0Ã€ÃŒÂ¸Ã© Â¸Ã°ÂµÃ Â¼Ã’Â¸Ã°ÂµÃˆ Â°ÃÃ€ÃŒÂ¹Ã‡Â·Ã Â¸Â®Â½ÂºÃ†Â®Â¿Â¡Â¼Â­ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
		if (dwCount == 0) {
			ItemDepleteHandler(iClientH, i, FALSE);
		}
		else {
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â·Â®Ã€ÃŒ ÂºÂ¯Â°Ã¦ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
			m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, i, dwCount, (char)TRUE, NULL);
		}
		
		return wWeight;
	}

	return -1;
}


int CGame::SetItemCount(int iClientH, int iItemIndex, DWORD dwCount)
{
 WORD wWeight;
	
	if (m_pClientList[iClientH] == NULL) return -1;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return -1;
	
	wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], 1);//m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wWeight;

	// Ã„Â«Â¿Ã®Ã†Â®Â°Â¡ 0Ã€ÃŒÂ¸Ã© Â¸Ã°ÂµÃ Â¼Ã’Â¸Ã°ÂµÃˆ Â°ÃÃ€ÃŒÂ¹Ã‡Â·Ã Â¸Â®Â½ÂºÃ†Â®Â¿Â¡Â¼Â­ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
	if (dwCount == 0) {
		ItemDepleteHandler(iClientH, iItemIndex, FALSE);
	}
	else {
		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â·Â®Ã€ÃŒ ÂºÂ¯Â°Ã¦ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = dwCount;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, iItemIndex, dwCount, (char)TRUE, NULL);
	}
		
	return wWeight;	
}

void CGame::ClientKilledHandler(int iClientH, int iAttackerH, char cAttackerType, short sDamage)
{
 char  * cp, cAttackerName[21], cData[120];
 short sAttackerWeapon;
 int   * ip, i, iExH;
 BOOL  bIsSAattacked = FALSE;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
 	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	// »çÅõÀåÀÎ °æ¿ì ½Ã°£À» ÀÔ·ÂÇÑ´Ù.
	// 2002-7-4 »çÅõÀåÀÇ °¹¼ö¸¦ ´Ã¸± ¼ö ÀÖµµ·Ï 
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fight", 5) == 0) {
		m_pClientList[iClientH]->m_dwFightzoneDeadTime = timeGetTime();
		wsprintf(G_cTxt, "Fightzone Dead Time: %d", m_pClientList[iClientH]->m_dwFightzoneDeadTime);
		PutLogList(G_cTxt);
	}

	m_pClientList[iClientH]->m_bIsKilled = TRUE;
	// HP´Â 0ÀÌ´Ù.
	m_pClientList[iClientH]->m_iHP = 0;

	// ¸¸¾à ±³È¯ ¸ğµå¶ó¸é ±³È¯À» Ãë¼ÒÇÑ´Ù.
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	// ÇöÀç ÀÌ NPC¸¦ °ø°İ´ë»óÀ¸·Î »ï°íÀÖ´Â °´Ã¼µéÀ» ÇØÁ¦ÇÑ´Ù.
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
	
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER_INDIRECT:
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iAttackerH] != NULL)
			memcpy(cAttackerName, m_pClientList[iAttackerH]->m_cCharName, 10);
		break;
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iAttackerH] != NULL)
#ifdef DEF_LOCALNPCNAME     // v2.14 NPC ÀÌ¸§ Áß¹®È­¸¦ À§ÇÑ ¼±¾ğ 
			wsprintf(cAttackerName,"NPCNPCNPC@%d",m_pNpcList[iAttackerH]->m_sType);
#else 
			memcpy(cAttackerName, m_pNpcList[iAttackerH]->m_cNpcName, 20);
#endif
		break ;
	default:
		break;
	}

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_KILLED, NULL, NULL, NULL, cAttackerName);
	// ´Ù¸¥ Å¬¶óÀÌ¾ğÆ®¿¡°Ô Á×´Â µ¿ÀÛ Àü¼Û.
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[iAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	}
	else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) {
		if (m_pClientList[iClientH]->m_cSide == 1) {
			m_iHeldenianAresdenDead++;
		}
		else if (m_pClientList[iClientH]->m_cSide == 2) {
			m_iHeldenianElvineDead++;
		}
		UpdateHeldenianStatus();
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		// v1.432
		// Æ¯¼ö ´É·ÂÀÌ ÀÖ´Â ¹«±â·Î °ø°İÀ» ´çÇß´Ù.
		switch (m_pClientList[iAttackerH]->m_iSpecialAbilityType) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			bIsSAattacked = TRUE;
			break;
		}
		
		if (iAttackerH == iClientH) return; // ÀÚÆøÀÌ´Ù.
		// ÇÃ·¹ÀÌ¾î°¡ ÇÃ·¹ÀÌ¾î¸¦ Á×¿´´Ù¸é PKÀÎÁö ÀüÅõÁß ½Â¸®ÀÎÁö¸¦ ÆÇº°ÇÏ¿© °æÇèÄ¡¸¦ ¿Ã¸°´Ù. 
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
			// Èñ»ıÀÚ°¡ ¿©ÇàÀÚÀÌ´Ù. 
			if (m_pClientList[iClientH]->m_iPKCount == 0) {


				// ¹«°íÇÑ ¿©ÇàÀÚ¿´´Ù. °ø°İÀÚ´Â PK ºÒÀÌÀÍÀ» ¹Ş´Â´Ù.
				ApplyPKpenalty(iAttackerH, iClientH);
			}
			else {

						// ¹üÁË¸¦ ÀúÁö¸¥ ¿©ÇàÀÚ¿´´Ù. °ø°İÀÚ´Â PK¸¦ ÀâÀº°Í¿¡ ´ëÇÑ Æ÷»óÀ» ¹Ş´Â´Ù. 
				PK_KillRewardHandler(iAttackerH, iClientH);
			}
		} 
		else {
			// Èñ»ıÀÚ°¡ ¿©ÇàÀÚ°¡ ¾Æ´Ï¶ó ÇÑ ¸¶À» ¼Ò¼ÓÀÌ´Ù. 
			if (m_pClientList[iClientH]->m_iGuildRank == -1) {
				// Èñ»ıÀÚ´Â ½Ã¹ÎÀÌ´Ù.
				// °ø°İÀÚ°¡ ¿©ÇàÀÚ, °°Àº ¸¶À» ½Ã¹Î, °°Àº ¸¶À» ±æµå¿ø -> PK°¡ µÊ. ´Ù¸¥ ¸¶À» ½Ã¹Î, ±æµå¿ø -> Á¤´çÇÑ °ø°İ
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					// °ø°İÀÚ°¡ ¿©ÇàÀÚÀÌ´Ù. 				
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						// ¹«°íÇÑ ½Ã¹ÎÀ» ¿©ÇàÀÚ°¡ Á×¿´´Ù. ¿©ÇàÀÚ´Â PK°¡ µÈ´Ù.
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {
						// ¿©ÇàÀÚ´Â PK¸¦ Àâ¾Æµµ º¸»óÀ» ¹ŞÁö ¸øÇÑ´Ù.

					}
				}
				else {
					// °ø°İÀÚ°¡ ½Ã¹Î, È¤Àº ±æµå¿ø -> ¸¶À»ÀÌ °°À¸¸é PK, ´Ù¸¥ ¸¶À»ÀÌ¶ó¸é Á¤´çÇÑ °ø°İ 
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						// °°Àº ¸¶À» ½Ã¹ÎÀ» °°Àº¸¶À» ½Ã¹Î È¤Àº ±æµå¿øÀÌ °ø°İÇÑ °ÍÀÌ´Ù.  
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							// Èñ»ıÀÚ°¡ ¹«°íÇÑ »óÅÂ. PKÀÌ´Ù.
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {
							// ¹üÁËÀÚ¸¦ Àâ¾Ò´Ù. 
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						// °ø°İÀÚ°¡ ´Ù¸¥ ¸¶À» ¼Ò¼Ó. Á¤´çÇÑ °ø°İÇàÀ§
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
			else {
				// Èñ»ıÀÚ´Â ±æµå¿øÀÌ´Ù. 
				// °ø°İÇÑ ÀÚ°¡ ¿©ÇàÀÚ, ½Ã¹Î, ÀüÀï»óÅÂ°¡ ¾Æ´Ñ ±æµå¿ø-> PK / Àü»ı»óÅÂÁßÀÎ ±æµå¿ø -> Á¤´çÇÑ ÀüÅõÇàÀ§
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					// °ø°İÀÚ°¡ ¿©ÇàÀÚÀÌ´Ù.
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						// ¹«°íÇÑ ±æµå¿øÀ» ¿©ÇàÀÚ°¡ Á×¿´´Ù. ¿©ÇàÀÚ´Â PK°¡ µÈ´Ù.
						ApplyPKpenalty(iAttackerH, iClientH);
					}
					else {
						// ¿©ÇàÀÚ´Â PK¸¦ Àâ¾Æµµ º¸»óÀ» ¹ŞÁö ¸øÇÑ´Ù.

					}
				}
				else {
					// °ø°İÀÚ´Â ½Ã¹Î È¤Àº ±æµå¿ø -> ¸¶À»ÀÌ °°À¸¸é PK, ´Ù¸¥ ¸¶À»ÀÌ¶ó¸é Á¤´çÇÑ °ø°İ 
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						// °°Àº ¸¶À» ±æµå¿øÀ» °°Àº¸¶À» ½Ã¹Î È¤Àº ±æµå¿øÀÌ °ø°İÇÑ °ÍÀÌ´Ù.  
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							// Èñ»ıÀÚ°¡ ¹«°íÇÑ »óÅÂ. PKÀÌ´Ù.
							ApplyPKpenalty(iAttackerH, iClientH);
						}
						else {
							// ¹üÁËÀÚ¸¦ Àâ¾Ò´Ù. 
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						// °ø°İÀÚ°¡ ´Ù¸¥ ¸¶À» ¼Ò¼Ó. Á¤´çÇÑ °ø°İÇàÀ§
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
		}

		// Èñ»ı´çÇÑ ÇÃ·¹ÀÌ¾îÀÇ µî±Ş¿¡ ¸Â´Â Æä³ÎÆ¼¸¦ ÃëÇÑ´Ù. 
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
				//¿©ÇàÀÚ¿¡°Ô °ø°İ¹Ş¾Æ Á×¾ú´Ù. 
				//PK´çÇßÀ¸¹Ç·Î °æÇèÄ¡°¡ ÁÙÁö ¾Ê´Â´Ù.
				//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
				//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
				//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
			}
			else {
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) == 0) {
					//°°Àº ¸¶À» ½Ã¹Î È¤Àº ±æµå¿ø¿¡°Ô Á×¾ú´Ù. 
					//PK´çÇßÀ¸¹Ç·Î °æÇèÁö°¡ ÁÙÁö ¾Ê´Â´Ù. 
					//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
					//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
					//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
				}
				else {
					// ´Ù¸¥ ¸¶À» ½Ã¹Î È¤Àº ±æµå¿ø¿¡°Ô Á×¾ú´Ù. ÀüÀïÁß Á×¾úÀ¸¹Ç·Î °æÇèÄ¡¿Í ¾ÆÀÌÅÛÀÌ ¶³¾îÁø´Ù. 
					ApplyCombatKilledPenalty(iClientH, 2, bIsSAattacked);
				}
			}
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
	}
	else if (cAttackerType == DEF_OWNERTYPE_NPC) {

		_bPKLog(DEF_PKLOG_BYNPC,iClientH,NULL,cAttackerName) ;

		// ÇÃ·¹ÀÌ¾î°¡ ¸÷¿¡°Ô Á×¾ú´Ù. Èñ»ı´çÇÑ ÇÃ·¹ÀÌ¾îÀÇ µî±Ş¿¡ ¸Â´Â Æä³ÎÆ¼¸¦ ÃëÇÑ´Ù.
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			ApplyCombatKilledPenalty(iClientH, 1, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
		// ¸¸¾à °ø°İÇÑ NPC°¡ ÀüÀï¿ë À¯´ÏÆ®¶ó¸é ÁöÈÖ°ü¿¡°Ô °Ç¼³ Æ÷ÀÎÆ® ºÎ°¡
		if (m_pNpcList[iAttackerH]->m_iGuildGUID != NULL) {
						
			if (m_pNpcList[iAttackerH]->m_cSide != m_pClientList[iClientH]->m_cSide) {
				// ÀüÀï¿ë ±¸Á¶¹° È¤Àº À¯´ÏÆ®°¡ Àû ÇÃ·¹ÀÌ¾î¸¦ Á×¿´´Ù. ¹Ù·Î Åëº¸ÇÑ´Ù.
				// ÇöÀç ¼­¹ö¿¡ ÁöÈÖ°üÀÌ ÀÖ´Ù¸é °ğ¹Ù·Î Åëº¸. ¾øÀ¸¸é ´Ù¸¥ ¼­¹ö·Î ¾Ë·ÁÁÜ.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[iAttackerH]->m_iGuildGUID) &&
					(m_pClientList[i]->m_iCrusadeDuty == 3)) {
					m_pClientList[i]->m_iConstructionPoint += (m_pClientList[iClientH]->m_iLevel / 2);

					if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
						m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

					//testcode
					wsprintf(G_cTxt, "Enemy Player Killed by Npc! Construction +%d", (m_pClientList[iClientH]->m_iLevel / 2));
					PutLogList(G_cTxt);
					// ÁöÈÖ°ü¿¡°Ô ¹Ù·Î Åëº¸.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
					return;
				}
				
				// ÇöÀç ¼­¹ö¿¡ ¾ø´Ù. ´Ù¸¥ ¼­¹öÀÇ ÁöÈÖ°ü¿¡°Ô ¾Ë·Á¾ß ÇÑ´Ù.
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				*cp = GSM_CONSTRUCTIONPOINT;
				cp++;
				ip = (int*)cp;
				*ip = m_pNpcList[iAttackerH]->m_iGuildGUID;
				cp += 4;
				ip = (int*)cp;
				*ip = (m_pClientList[iClientH]->m_iLevel / 2);
				cp += 4;
				bStockMsgToGateServer(cData, 9);
			}
		}
	}
	else if (cAttackerType == DEF_OWNERTYPE_PLAYER_INDIRECT) {
		_bPKLog(DEF_PKLOG_BYOTHER,iClientH,NULL,NULL) ;
		// ÇÃ·¹ÀÌ¾î°¡ Á×¾úÁö¸¸ °ø°İÀÚ°¡ °£Á¢ÀûÀÌ´Ù. ¾Æ¹«·± ¿µÇâÀÌ ¾ø´Ù.
		// m_pClientList[iClientH]->m_iExp -= iDice(1, 50);
		// if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		// SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}
}

void CGame::ReleaseItemHandler(int iClientH, short sItemIndex, BOOL bNotice)
{
 char cEquipPos, cHeroArmorType;
 short  sTemp;
 int   iTemp;

	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return;
	
	if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == FALSE) return;
	
	cHeroArmorType = _cCheckHeroItemEquipped(iClientH);
	if (cHeroArmorType != 0x0FFFFFFFF) m_pClientList[iClientH]->m_cHeroArmourBonus = 0;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
	if (cEquipPos == DEF_EQUIPPOS_RHAND) {
		if(m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL){
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 866)) {
				m_pClientList[iClientH]->m_cMagicMastery[94] = FALSE;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
			}
		}
	}

	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Ã‡Ã˜ÃÂ¦Ã€Â§Ã„Â¡Â¿Â¡ Â¸Ã‚Â°Ã” ApprÂºÂ¯Â¼Ã¶Â¸Â¦ ÃÂ¶ÃÂ¤Ã‡Ã‘Â´Ã™.
	switch (cEquipPos) {
	case DEF_EQUIPPOS_RHAND:
		// Â¿Ã€Â¸Â¥Â¼Ã•Â¿Â¡ Ã€Ã¥Ã‚Ã¸Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›. Â¹Â«Â±Ã¢Â·Ã¹Ã€ÃŒÂ´Ã™. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// Â¹Â«Â±Ã¢ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
		iTemp = iTemp & 0x0FFFFFFF; // Â¹Â«Â±Ã¢ Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		// V1.3 Â¹Â«Â±Ã¢Â¼Ã“ÂµÂµ Ã€Ã§Â°Ã¨Â»Ãª <- Â¸Ã‡Â¼Ã•Ã€ÃŒÂ´ÃÂ±Ã± 0
		iTemp = m_pClientList[iClientH]->m_iStatus;
		iTemp = iTemp & 0xFFFFFFF0;
		m_pClientList[iClientH]->m_iStatus = iTemp;
		break;

	case DEF_EQUIPPOS_LHAND:
		// Â¿ÃÂ¼Ã•Â¿Â¡ Ã€Ã¥Ã‚Ã¸Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›. Â¹Ã¦Ã†ÃÂ·Ã¹Ã€ÃŒÂ´Ã™. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;	// Â¹Â«Â±Ã¢ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
		iTemp = iTemp & 0xF0FFFFFF; // Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_TWOHAND:
		// Â¾Ã§Â¼Ã•Â¿Â¡ Ã€Ã¥Ã‚Ã¸Ã‡Ã‘Â´Ã™ÃÃ¶Â¸Â¸ Â»Ã§Â½Ã‡ Â¿Ã€Â¸Â¥Â¼Ã•Â¿Â¡Â¸Â¸ ÂµÃ©Â°Ã­ Ã€Ã–Â´Ã™. Â¿ÃÂ¼Ã•Ã€Âº ÂºÃ±Â¾Ã®Ã€Ã–Â´Ã‚ Â»Ã³Ã…Ã‚.
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// Â¹Â«Â±Ã¢ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
		iTemp = iTemp & 0x0FFFFFFF; // Â¹Â«Â±Ã¢ Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// Â°Ã‘Â¿ÃŠ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		// Â°Ã‘Â¿ÃŠ ÃˆÂ®Ã€Ã¥ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xFF7F;	
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
		iTemp = iTemp & 0xFF0FFFFF; // Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;	// Â¸ÃÃ…Ã¤ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
		iTemp = iTemp & 0xFFF0FFFF; // Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;	// Â°Ã‘Â¿ÃŠ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
		iTemp = iTemp & 0xFFFF0FFF; // Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;	// Â°Ã‘Â¿ÃŠ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
		iTemp = iTemp & 0xFFFFF0FF; // Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_LEGGINGS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;	// Â°Ã‘Â¿ÃŠ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
		iTemp = iTemp & 0xFFFFFF0F; // Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;	// Ã…ÃµÂ±Â¸ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
		iTemp = iTemp & 0xFFFFFFF0; // Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_RELEASEALL:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// Â¸ÃÃ…Ã¤ Ã†Â¯Â¼ÂºÃ„Â¡ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 Ã„ÃƒÂ·Â¯Â°Âª Â¼Â¼Ã†Ãƒ 
		iTemp = iTemp & 0xFFF0FFFF; // Â¸ÃÃ…Ã¤ Â»Ã¶ ÂºÃ±Ã†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
 	}

	//v1.432 Ã†Â¯Â¼Ã¶ Â´Ã‰Â·Ã‚Ã€ÃŒ ÂºÃÂ¿Â©ÂµÃˆ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¶Ã³Â¸Ã© Ã‡ÃƒÂ·Â¡Â±Ã— Â¼Â³ÃÂ¤ 
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		// Â°Ã¸Â°Ã Ã†Â¯Â¼Ã¶ Â´Ã‰Â·Ã‚ ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã®
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;	
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		// Â¹Ã¦Â¾Ã®Â±Â¸ Ã†Â¯Â¼Ã¶ Â´Ã‰Â·Ã‚ ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã®
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
	}
	
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = -1;
	
	// Â¿ÃœÃ‡Ã¼Ã€ÃŒ Â¹Ã™Â²Ã¯Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™.
	if (bNotice == TRUE)
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	// Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã‡Ã˜ÃÂ¦Ã‡ÃÂ´Ã‚ Â°ÃÂ¿Â¡ ÂµÃ»Â¸Â£Â´Ã‚ Ã†Â¯Â¼ÂºÃ„Â¡Ã€Ã‡ ÂºÂ¯ÃˆÂ­Â¸Â¦ Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™. 
	CalcTotalItemEffect(iClientH, sItemIndex, TRUE);
}


BOOL CGame::_bDecodeNpcConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iNpcConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// NPC
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Too long Npc name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					ZeroMemory(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, sizeof(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName));
					memcpy(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:
					// m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					// m_iHitDice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitDice = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_iDefenseRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iDefenseRatio = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_iHitRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitRatio = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_iMinBravery
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMinBravery = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_iExpDiceMin
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDiceMin = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_iExpDiceMax
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDiceMax = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_iGoldDiceMin
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iGoldDiceMin = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_iGoldDiceMax
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iGoldDiceMax = atoi(token);
					cReadModeB = 11;
					break;
				
				case 11:
					// m_cAttackDiceThrow
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceThrow = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// m_cAttackDiceRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceRange = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					// m_cSize
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSize = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 15;
					break;
				
				case 15:
					// ActionLimit 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cActionLimit = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// Action Time
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwActionTime = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// ResistMagic
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cResistMagic = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// cMagicLevel
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cMagicLevel = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// cGenDayWeekLimit  // Ã†Â¯ÃÂ¤ Â¿Ã¤Ã€ÃÂ¿Â¡Â¸Â¸ Â»Ã½Â¼ÂºÂµÃ‡Â´Ã‚ Â¸Ã³Â½ÂºÃ…ÃÂ¿Â©ÂºÃ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cDayOfWeekLimit = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// cChatMsgPresence
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence = atoi(token);
					
					if (m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence == 1) {
						// Â¿Â¬Â°Ã¡ÂµÃˆ ÃƒÂ¤Ã†Ãƒ Â¸ÃÂ½ÃƒÃÃ¶Â°Â¡ ÃÂ¸Ã€Ã§Ã‡Ã‘Â´Ã™. Â³Â»Â¿Ã«Ã€Â» Ã€ÃÂ¾Ã® Ã€ÃºÃ€Ã¥Ã‡Ã‘Â´Ã™. 


					}
					cReadModeB = 21;
					break;

				case 21:
					// m_cTargetSearchRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cTargetSearchRange = atoi(token);
										
					cReadModeB = 22;
					break;		

				case 22:
					// Npc Ã€Ã§ Â»Ã½Â¼ÂºÂ±Ã®ÃÃ¶Ã€Ã‡ Â½ÃƒÂ°Â£
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwRegenTime = atoi(token);
										
					cReadModeB = 23;
					break;

				case 23:
					// Attribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttribute = atoi(token);
										
					cReadModeB = 24;
					break;

				case 24:
					// Absorb Magic Damage
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAbsDamage = atoi(token);
					
					cReadModeB = 25;
					break;

				case 25:
					// Maximum Mana Point
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMaxMana = atoi(token);
					
					cReadModeB = 26;
					break;

				case 26:
					// MagicHitRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMagicHitRatio = atoi(token);
									
					cReadModeB = 27;
					break;

				case 27:
					// AttackRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAttackRange = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					iNpcConfigListIndex++;
					break;
				}
				break;

			case 2:
				m_iPlayerMaxLevel = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Npc", 3) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pNpcConfigList[iNpcConfigListIndex] = new class CNpc(" ");
			}

			if (memcmp(token, "world-server-max-level", 22) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! NPC configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) NPC(Total:%d) configuration - success!", iNpcConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

BOOL CGame::_bInitNpcAttr(class CNpc * pNpc, char * pNpcName, short sClass, char cSA)
{
 register int i, iTemp;
 char cTmpName[21];
 int sTemp;
 double dV1, dV2, dV3;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pNpcName);

	for (i = 0; i < DEF_MAXNPCTYPES; i++) 
	if (m_pNpcConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pNpcConfigList[i]->m_cNpcName, 20) == 0) {
			// Â°Â°Ã€Âº Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ NPC Â¼Â³ÃÂ¤Ã€Â» ÃƒÂ£Â¾Ã’Â´Ã™. Â¼Â³ÃÂ¤Â°ÂªÃ€Â¸Â·Ã ÃƒÃŠÂ±Ã¢ÃˆÂ­Ã‡Ã‘Â´Ã™.
			ZeroMemory(pNpc->m_cNpcName, sizeof(pNpc->m_cNpcName));
			memcpy(pNpc->m_cNpcName, m_pNpcConfigList[i]->m_cNpcName, 20);
			
			pNpc->m_sType  = m_pNpcConfigList[i]->m_sType;
			
			// HitDiceÂ¿Â¡ ÂµÃ»Â¶Ã³ Â°Ã¸Â½Ã„Ã€ÃŒ Â´Ã™Â¸Â£Â´Ã™. Â¸Ã·Â°Â£Ã€Ã‡ Ã‚Ã·ÂºÂ°Ã€Â» ÂµÃÂ±Ã¢ Ã€Â§Ã‡Ã”.
			if (m_pNpcConfigList[i]->m_iHitDice <= 5)
				 pNpc->m_iHP  = abs(iDice(m_pNpcConfigList[i]->m_iHitDice, 4) + m_pNpcConfigList[i]->m_iHitDice);
			else pNpc->m_iHP  = abs((m_pNpcConfigList[i]->m_iHitDice * 4) + m_pNpcConfigList[i]->m_iHitDice + iDice(1, m_pNpcConfigList[i]->m_iHitDice));
			// v1.4 ÃˆÂ®Ã€ÃÃ„ÃšÂµÃ¥
			if (pNpc->m_iHP == 0) pNpc->m_iHP = 1; 

			pNpc->m_iExpDiceMin		 = m_pNpcConfigList[i]->m_iExpDiceMin;
			pNpc->m_iExpDiceMax		 = m_pNpcConfigList[i]->m_iExpDiceMax;
			pNpc->m_iGoldDiceMin	 = m_pNpcConfigList[i]->m_iGoldDiceMin;
			pNpc->m_iGoldDiceMax	 = m_pNpcConfigList[i]->m_iGoldDiceMax;
			pNpc->m_iExp			 = (iDice(1, (m_pNpcConfigList[i]->m_iExpDiceMax - m_pNpcConfigList[i]->m_iExpDiceMin)) + m_pNpcConfigList[i]->m_iExpDiceMin);

			pNpc->m_iHitDice         = m_pNpcConfigList[i]->m_iHitDice;   
			pNpc->m_iDefenseRatio    = m_pNpcConfigList[i]->m_iDefenseRatio;
			pNpc->m_iHitRatio        = m_pNpcConfigList[i]->m_iHitRatio;
			pNpc->m_iMinBravery      = m_pNpcConfigList[i]->m_iMinBravery;
			pNpc->m_cAttackDiceThrow = m_pNpcConfigList[i]->m_cAttackDiceThrow;
			pNpc->m_cAttackDiceRange = m_pNpcConfigList[i]->m_cAttackDiceRange;
			pNpc->m_cSize            = m_pNpcConfigList[i]->m_cSize;
			pNpc->m_cSide            = m_pNpcConfigList[i]->m_cSide;
			pNpc->m_cActionLimit     = m_pNpcConfigList[i]->m_cActionLimit;
			pNpc->m_dwActionTime     = m_pNpcConfigList[i]->m_dwActionTime;
			pNpc->m_dwRegenTime      = m_pNpcConfigList[i]->m_dwRegenTime;
			pNpc->m_cResistMagic     = m_pNpcConfigList[i]->m_cResistMagic;
			pNpc->m_cMagicLevel      = m_pNpcConfigList[i]->m_cMagicLevel;
			pNpc->m_iMaxMana         = m_pNpcConfigList[i]->m_iMaxMana; // v1.4
			pNpc->m_iMana            = m_pNpcConfigList[i]->m_iMaxMana;
			pNpc->m_cChatMsgPresence = m_pNpcConfigList[i]->m_cChatMsgPresence;
			pNpc->m_cDayOfWeekLimit  = m_pNpcConfigList[i]->m_cDayOfWeekLimit;
			pNpc->m_cTargetSearchRange = m_pNpcConfigList[i]->m_cTargetSearchRange;
			
			switch (sClass) {
			case 43:
			case 44:
			case 45:
			case 46:
			case 47: // Ã€Ã¼Ã€Ã¯Â¿Ã« Ã€Â¯Â´Ã–Ã€Ã‡ Â°Ã¦Â¿Ã¬ Â¹Â«ÃÂ¶Â°Ã‡ Â°Ã¸Â°ÃÂ¸Â¸ Ã‡ÃÂ´Ã‚ Ã€Ã¼Â·Â«Ã€Â» Â±Â¸Â»Ã§.
				pNpc->m_iAttackStrategy = DEF_ATTACKAI_NORMAL;
				break;

			default: 
				pNpc->m_iAttackStrategy = iDice(1,10); 
				break;
			}
	
			pNpc->m_iAILevel		   = iDice(1,3);
			pNpc->m_iAbsDamage         = m_pNpcConfigList[i]->m_iAbsDamage;
			pNpc->m_iMagicHitRatio     = m_pNpcConfigList[i]->m_iMagicHitRatio;
			pNpc->m_iAttackRange       = m_pNpcConfigList[i]->m_iAttackRange;
			pNpc->m_cSpecialAbility    = cSA;
			pNpc->m_iBuildCount		   = m_pNpcConfigList[i]->m_iMinBravery;

			// v1.411 NPCÃ€Ã‡ Ã†Â¯Â¼Ã¶ ÃˆÂ¿Â°Ãº Â°Ã¨Â»Ãª. Â°Ã¦Ã‡Ã¨Ã„Â¡ Â°Â¡ÃÃŸ 
			switch (pNpc->m_cSpecialAbility) {
			case 1:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 2:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 30.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			
			case 3: // Absorbing Physical Damage
				if (pNpc->m_iAbsDamage > 0) {
					// Â±Ã¢ÂºÂ»Ã€Ã»Ã€Â¸Â·Ã Â¸Â¶Â¹Ã½ Â´Ã«Â¹ÃŒÃÃ¶ Ã€Ã½Â°Â¨ Â´Ã‰Â·Ã‚Ã€ÃŒ Ã€Ã–Â´Ã‚ Â°Ã¦Â¿Ã¬ Â¹Â°Â¸Â® Â´Ã«Â¹ÃŒÃÃ¶ Ã€Ã½Â°Â¨Ã€Âº Ã€Ã»Â¿Ã«ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 
					pNpc->m_cSpecialAbility = NULL;
					cSA = NULL;
				}
				else {
					iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage -= iTemp;
					if (pNpc->m_iAbsDamage < -90) pNpc->m_iAbsDamage = -90;
				}

				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)abs(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 4: // Absorbing Magical Damage
				if (pNpc->m_iAbsDamage < 0) {
					// Â±Ã¢ÂºÂ»Ã€Ã»Ã€Â¸Â·Ã Â¹Â°Â¸Â® Â´Ã«Â¹ÃŒÃÃ¶ Ã€Ã½Â°Â¨ Â´Ã‰Â·Ã‚Ã€ÃŒ Ã€Ã–Â´Ã‚ Â°Ã¦Â¿Ã¬ Â¸Â¶Â¹Ã½ Â´Ã«Â¹ÃŒÃÃ¶ Ã€Ã½Â°Â¨Ã€Âº Ã€Ã»Â¿Ã«ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 
					pNpc->m_cSpecialAbility = NULL;
					cSA = NULL;
				}
				else {
					iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage += iTemp;
					if (pNpc->m_iAbsDamage > 90) pNpc->m_iAbsDamage = 90;
				}

				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 5:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 15.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 6:
			case 7:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 20.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 8:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			}

			// v1.411 Ã€Â§Ã„Â¡ Â¿Ã…Â±Ã¨ 
			pNpc->m_iNoDieRemainExp  = (pNpc->m_iExp) - (pNpc->m_iExp/3);

			// v1.411 NPCÃ€Ã‡ Ã†Â¯Â¼Ã¶ Â´Ã‰Â·Ã‚ Â»Ã°Ã€Ã” 
			pNpc->m_iStatus	= pNpc->m_iStatus & 0xFFFFF0FF;
			sTemp           = cSA;
			sTemp           = sTemp << 8;
			pNpc->m_iStatus = pNpc->m_iStatus | sTemp;
	
			// v1.41 NPCÃ€Ã‡ ClassÂ»Ã°Ã€Ã”.
			pNpc->m_iStatus			   = pNpc->m_iStatus & 0xFFFFFFF0;
			pNpc->m_iStatus            = pNpc->m_iStatus | (sClass);
	
			return TRUE;
		}
	}

	// NPCÂ¸Â®Â½ÂºÃ†Â®Â¸Â¦ Â¸Ã°ÂµÃ Â°Ã‹Â»Ã¶Ã‡ÃŸÃ€Â½Â¿Â¡ÂµÂµ Â¹ÃŸÂ°ÃŸÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™. 
	return FALSE;
}

/*********************************************************************************************************************
**  int CGame::iDice(int iThrow, int iRange)																		**
**  description			:: produces a random number between the throw and range										**
**  last updated		:: November 20, 2004; 10:24 PM; Hypnotoad													**
**	return value		:: int																						**
**********************************************************************************************************************/
int CGame::iDice(int iThrow, int iRange)
{
 register int i, iRet;

	if (iRange <= 0) return 0;
	iRet = 0;
	for (i = 1; i <= iThrow; i++) {
		iRet += (rand() % iRange) + 1;
	}
	return iRet;
}

/*
void CGame::OnStartGameSignal()
{
 int i;
 char * cp;
 HANDLE hFile;
 FILE * pFile;
 DWORD  dwFileSize;
	
	// Â¸ÃŠ Ã€ÃŒÂºÂ¥Ã†Â® ÃˆÂ­Ã€ÃÃ€Â» Ã€ÃÂ¾Ã® Â°Â¢Â°Â¢Ã€Ã‡ Â¸ÃŠÂ¿Â¡ Ã‡Ã’Â´Ã§ÂµÃˆ NPCÂµÃ©Ã€Â» Â¼Â¼Ã†ÃƒÃ‡Ã‘Â´Ã™.
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) 
		_bReadMapInfoFiles(i);
	
	// Crusade
	
	// ÃÂ¡Â·Ã‰ Â±ÃªÂ¹ÃŸ ÃÂ¤ÂºÂ¸ Ã€ÃÂ´Ã‚Â´Ã™.
	hFile = CreateFile("GameData\\OccupyFlag.txt", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen("GameData\\OccupyFlag.txt", "rt");
	if (pFile == NULL) {
		// ÃÂ¡Â·Ã‰ Â±ÃªÂ¹ÃŸ ÃÂ¤ÂºÂ¸Â¸Â¦ Ã€ÃÃ€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.
		PutLogList("(!) Cannot open file: GameData\\OccupyFlag.txt");
	}
	else {
		PutLogList("(!) Occupy Flag save file contents decoding...");
	
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		_bDecodeOccupyFlagSaveFileContents(cp, dwFileSize);
		delete cp;
	}

	// ÃƒÃŠÂ±Ã¢ Â¼Â³Ã„Â¡ Â°Ã‡Â¹Â° ÃÂ¤ÂºÂ¸ Ã€ÃÂ´Ã‚Â´Ã™.
	bReadCrusadeStructureConfigFile("Crusade.cfg");
	// Ã†Ã¸Â°Ã Ã†Ã·Ã€ÃÃ†Â® ÃÂ¤ÂºÂ¸Â¸Â¦ Â¹Ã™Ã…ÃÃ€Â¸Â·Ã Â¸ÃŠ Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ Â¸ÂµÃ…Â©Â½ÃƒÃ…Â²Â´Ã™.
	_LinkStrikePointMapIndex();

	bReadCrusadeGUIDFile("GameData\\CrusadeGUID.txt");
	
	PutLogList("");
	PutLogList("(!) Game Server Activated.");
}*/

void CGame::CalculateGuildEffect(int iVictimH, char cVictimType, short sAttackerH)
{
 register int ix, iy, iExp;
 short sOwnerH;
 char cOwnerType;

	// ### ERROR POINT! Ã€Ã“Â½ÃƒÂ·Ã Â¸Â·Â¾Ã† Â³Ã­Â´Ã™.
	return;

	if (m_pClientList[sAttackerH] == NULL) return;

	switch (cVictimType) {

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iVictimH] == NULL) return;

		for (ix = m_pNpcList[iVictimH]->m_sX-2; ix <= m_pNpcList[iVictimH]->m_sX+2; ix++)
		for (iy = m_pNpcList[iVictimH]->m_sY-2; iy <= m_pNpcList[iVictimH]->m_sY+2; iy++) {
			
			m_pMapList[m_pNpcList[iVictimH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH != NULL) && (sOwnerH != sAttackerH) &&
			 	 (memcmp(m_pClientList[sAttackerH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) &&
				 (m_pClientList[sAttackerH]->m_iLevel >= m_pClientList[sOwnerH]->m_iLevel) ) {
				 // Â±Ã¦ÂµÃ¥Â¿Ã¸Â°ÃºÃ€Ã‡ Ã‡Ã¹ÂµÂ¿Ã€Ã¼Ã…ÃµÂ¿Â¡Â¼Â­ Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â¾Ã²Â±Ã¢ Ã€Â§Ã‡Ã˜Â¼Â­Â´Ã‚ Â¸Ã³Â½ÂºÃ…ÃÂ¸Â¦ ÃÃ—Ã€Ã Â±Ã¦ÂµÃ¥Â¿Ã¸Ã€Ã‡ Â·Â¹ÂºÂ§ÂºÂ¸Â´Ã™ Â³Â·Ã€Âº Â±Ã¦ÂµÃ¥Â¿Ã¸Ã€ÃŒÂ¾Ã®Â¾ÃŸ Ã‡Ã‘Â´Ã™.
				 // 1D3Ã€Ã‡ Â°ÂªÃ€ÃŒ 2Ã€ÃÂ¶Â§ Â¸Ã³Â½ÂºÃ…Ã Â°Ã¦Ã‡Ã¨Ã„Â¡Ã€Ã‡ 3ÂºÃÃ€Ã‡ 1Ã€Â» Â¾Ã²Â´Ã‚Â´Ã™. 
				if (iDice(1,3) == 2) {
					iExp = (m_pNpcList[iVictimH]->m_iExp / 3);
					if (m_pClientList[sAttackerH]->m_iLevel >= m_iPlayerMaxLevel) iExp = 0;

					if (iExp > 0) {
						
						m_pClientList[sOwnerH]->m_iExp += iExp;
						if (bCheckLimitedUser(sOwnerH) == FALSE) {
							// ÃƒÂ¼Ã‡Ã¨Ã†Ã‡ Â»Ã§Â¿Ã«Ã€Ãš ÃÂ¦Ã‡Ã‘Â¿Â¡ Â°Ã‰Â¸Â®ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™. Â°Ã¦Ã‡Ã¨Ã„Â¡Â°Â¡ Â¿ÃƒÂ¶ÃºÂ´Ã™Â´Ã‚ Ã…Ã«ÂºÂ¸Â¸Â¦ Ã‡Ã‘Â´Ã™.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
						}
						// Â·Â¹ÂºÂ§Ã€ÃŒ Â¿ÃƒÂ¶ÃºÂ´Ã‚ÃÃ¶Â¸Â¦ Â°Ã‹Â»Ã§Ã‡Ã‘Â´Ã™.
						bCheckLevelUp(sOwnerH);
					}
				}
			}
		}												     
		break;
	}
}

void CGame::TimeManaPointsUp(int iClientH)
{
 register int iMaxMP, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;

	iMaxMP = (2*m_pClientList[iClientH]->m_iMag) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->m_iInt/2); // v1.4
	if (m_pClientList[iClientH]->m_iMP < iMaxMP) {
		iTotal = iDice(1, (m_pClientList[iClientH]->m_iMag));
		if (m_pClientList[iClientH]->m_iAddMP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddMP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iMP += iTotal;
		
		if (m_pClientList[iClientH]->m_iMP > iMaxMP) 
			m_pClientList[iClientH]->m_iMP = iMaxMP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
	}
}

// 05/29/2004 - Hypnotoad - fixed infinite sp bug
void CGame::TimeStaminarPointsUp(int iClientH)
{
	register int iMaxSP, iTotal=0;
	double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚ÂºÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â±ÃƒÂ¢ Ã‚Â±ÃƒÂ¢Ã‚Â¼ÃƒÂº Ã‚Â»ÃƒÂ§Ã‚Â¿ÃƒÂ«ÃƒÂÃƒÅ¸Ã‚Â¿Ã‚Â¡Ã‚Â´Ãƒâ€š Ã‚Â½Ã‚ÂºÃƒâ€¦Ãƒâ€”Ã‚Â¹ÃƒÅ’Ã‚Â³ÃƒÅ  Ã‚Â¿Ãƒâ‚¬Ã‚Â¸Ã‚Â£ÃƒÂÃƒÂ¶ Ã‚Â¾ÃƒÅ Ãƒâ‚¬Ã‚Â½.

	iMaxSP = (2*m_pClientList[iClientH]->m_iStr) + (2*m_pClientList[iClientH]->m_iLevel);
	if (m_pClientList[iClientH]->m_iSP < iMaxSP) {

		iTotal = iDice(1, (m_pClientList[iClientH]->m_iVit/3)); // Staminar PointÂ´Ã‚ 10ÃƒÃŠÂ¸Â¶Â´Ã™ 1D(Vit/3)Â¾Â¿ Â¿ÃƒÂ¶Ã³Â°Â£Â´Ã™.
		if (m_pClientList[iClientH]->m_iAddSP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddSP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}
	
		// v2.03 Â·Â¹ÂºÂ§ 60 Ã€ÃŒÃ‡ÃÂ´Ã‚ ÃÂ¤Â±Ã¢Ã€Ã»Ã€Â¸Â·Ã Â½ÂºÃ…Ã—Â¹ÃŒÂ³ÂªÂ°Â¡ Â¸Â¹Ã€ÃŒ Ã‚Ã¹Â´Ã™.
		if (m_pClientList[iClientH]->m_iLevel <= 20) {
			iTotal += 15;
		} else if ( m_pClientList[iClientH]->m_iLevel <= 40) {
			iTotal += 10;
		}  else if ( m_pClientList[iClientH]->m_iLevel <= 60) { 
			iTotal += 5;
		}

		m_pClientList[iClientH]->m_iSP += iTotal;
		if (m_pClientList[iClientH]->m_iSP > iMaxSP) 
			m_pClientList[iClientH]->m_iSP = iMaxSP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
	}
}

void CGame::DelayEventProcess()
{

}

void CGame::SendGuildMsg(int iClientH, WORD wNotifyMsgType, short sV1, short sV2, char * pString)
{
 char cData[500];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 register int i, iRet;
	
	// Â°Â°Ã€Âº Â±Ã¦ÂµÃ¥Â¿Ã¸ÂµÃ©Â¿Â¡Â°Ã”Â¸Â¸ ÂºÂ¸Â³Â»Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ÂµÃ©
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ( (m_pClientList[i] != NULL) && 
		 (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) ) {

		// ### BUG POINT Ã€Â§Ã„Â¡Â°Â¡ Ã€ÃŸÂ¸Ã¸ÂµÃ‡Â¾Ã® Ã†Ã·Ã€ÃÃ…Ã Â¿Â¬Â»ÃªÃ€ÃŒ Ã€ÃŸÂ¸Ã¸ÂµÃ‡Â¾ÃºÂ´Ã™. 
		ZeroMemory(cData, sizeof(cData));

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wNotifyMsgType;
	
		cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);

		// Â°Â°Ã€Âº Â±Ã¦ÂµÃ¥ Ã€ÃŒÂ¸Â§Ã€Â» Â°Â®Â°Ã­ Ã€Ã–Â´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™.
		switch (wNotifyMsgType) {
		case DEF_NOTIFY_GUILDDISBANDED:
			if (i == iClientH) break; // <-- Â±Ã¦ÂµÃ¥ Â¸Â¶Â½ÂºÃ…Ã Ã€ÃšÂ½Ã…Â¿Â¡Â°Ã”Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
			// Â±Ã¦ÂµÃ¥ Ã‡Ã˜Â»Ãª Ã…Ã«ÂºÂ¸Â¿Â¡ Ã‡Ã˜Â´Ã§ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Ã€Ã‡ Â±Ã¦ÂµÃ¥ Â·Â©Ã…Â©Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®Ã‡Ã‘Â´Ã™. 
			memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
			cp += 20;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 26);
			// Ã‡Ã˜Â´Ã§ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Ã€Ã‡ Â±Ã¦ÂµÃ¥Â³Â»Â¿Ã«Ã€Â» Ã…Â¬Â¸Â®Â¾Ã®Ã‡Ã‘Â´Ã™. @@@@@@@
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1;
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case DEF_NOTIFY_EVENTMSGSTRING:
			// Â±Ã¦ÂµÃ¥Â¿Ã¸ÂµÃ©Â¿Â¡Â°Ã” Ã€Ã¼Â´ÃÂµÃ‡Â´Ã‚ Ã€ÃŒÂºÂ¥Ã†Â® Â¸ÃÂ½ÃƒÃÃ¶ Â½ÂºÃ†Â®Â¸Âµ 
			strcpy(cp, pString);
			cp += strlen(pString);

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
			break;

		case DEF_NOTIFY_NEWGUILDSMAN:
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
			break;

		case DEF_NOTIFY_DISMISSGUILDSMAN:
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
			break;
		}
	
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
			DeleteClient(i, TRUE, TRUE);
			return;
		}
	}

}

void CGame::GuildNotifyHandler(char * pData, DWORD dwMsgSize)
{
 // Â´Ã™Â¸Â¥ Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶Â·ÃÂºÃÃ…Ã Â±Ã¦ÂµÃ¥ Ã€ÃŒÂºÂ¥Ã†Â®Â°Â¡ ÂµÂµÃ‚Ã¸Ã‡ÃŸÂ´Ã™. 
 char * cp, cCharName[11], cGuildName[21];

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	// Â¾Ã†ÃÃ· Â±Â¸Ã‡Ã¶ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™. 
}

void CGame::ToggleCombatModeHandler(int iClientH)
{
	short sAppr2;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	// ÃÃ—Ã€ÂºÃƒÂ´Ã‡ÃÂ±Ã¢Â³Âª ÃÃ—Ã€Âº Â»Ã³Ã…Ã‚Â¿Â¡Â¼Â­Â´Ã‚ ÂºÂ¯ÃˆÂ¯Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;

	sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);

	m_pClientList[iClientH]->m_bIsAttackModeChange = TRUE; // v2.172


	if (sAppr2 == 0) {
		// ÂºÃ±Ã€Ã¼Ã…Ãµ Â¸Ã°ÂµÃ¥Â¿Â´Â´Ã™. Ã€Ã¼Ã…ÃµÂ¸Ã°ÂµÃ¥Â·Ã Â¹Ã™Â²Ã›Â´Ã™.
		m_pClientList[iClientH]->m_sAppr2 = (0xF000 | m_pClientList[iClientH]->m_sAppr2);
	}
	else {
		// Ã€Ã¼Ã…Ãµ Â¸Ã°ÂµÃ¥Â¿Â´Â´Ã™. ÂºÃ±Ã€Ã¼Ã…ÃµÂ¸Ã°ÂµÃ¥Â·Ã Â¹Ã™Â²Ã›Â´Ã™.
		m_pClientList[iClientH]->m_sAppr2 = (0x0FFF & m_pClientList[iClientH]->m_sAppr2);
	}

	// Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ Â¿ÃœÃ‡Ã¼Ã€ÃŒ Â¹Ã™Â²Ã®Â¾ÃºÃ€Â¸Â¹Ã‡Â·Ã Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ Ã€Ã¼Â´ÃÃ‡Ã‘Â´Ã™.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

}

void CGame::OnGateSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 int   iRet;
	
	if (m_pGateSock == NULL) return;

	iRet = m_pGateSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:
		PutLogList("(!!!) Gate-socket connected!");
		SendMsgToGateServer(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// Â°Ã”Ã€ÃŒÃ†Â®Â¼Â­Â¹Ã¶Â·ÃÃ€Ã‡ Â¿Â¬Â°Ã¡Ã€ÃŒ Ã€ÃŒÂ·Ã§Â¾Ã® ÃÂ³Ã€Â¸Â¹Ã‡Â·Ã Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶ ÂµÃ®Â·Ã Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Ã€Ã¼Â¼Ã›Ã‡Ã‘Â´Ã™.
		// v1.41 gate-socketÃ€Â» Ã€Ã§Â¿Â¬Â°Ã¡Ã‡Ã’ Â¶Â§ Ã„Â«Â¿Ã®Ã†Ãƒ Ã‡ÃÂ´Ã‚ ÂºÂ¯Â¼Ã¶. Â¼Â­Â¹Ã¶ Ã€Ã›ÂµÂ¿ ÂµÂµÃÃŸ gate-socketÃ€ÃŒ Â¼Ã’Ã„ÃÂ¿Â¡Â·Â¯Â·Ã Â²Ã·Â±Ã¢Â¸Ã© Â°Ã°Â¹Ã™Â·Ã Ã€Ã§ÃÂ¢Â¼Ã“Ã€Â» 
		// Â½ÃƒÂµÂµÃ‡ÃÂ¸Ã§ Ã€ÃŒ Â°ÂªÃ€ÃŒ Ã€ÃÃÂ¤Ã„Â¡ Ã€ÃŒÂ»Ã³Ã€ÃŒ ÂµÃ‡Â¸Ã© Â¿Â¬Â°Ã¡ Â½Ã‡Ã†ÃÂ·Ã Â°Â£ÃÃ–ÂµÃ‡Â¾Ã® Ã€ÃšÂµÂ¿ Â¼Â­Â¹Ã¶ Â¼Ã‹Â´Ã™Â¿Ã® Â¸Ã°ÂµÃ¥(4)Â·Ã ÂµÃ©Â¾Ã®Â°Â£Â´Ã™. 
		m_iGateSockConnRetryTimes = 0;
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		// Â¸ÃÂ½ÃƒÃÃ¶Â°Â¡ Â¼Ã¶Â½Ã…ÂµÃ‡Â¾ÃºÂ´Ã™.
		OnGateRead();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		// ÃˆÂ®Ã€ÃÃ„ÃšÂµÃ¥Â°Â¡ Ã€ÃÃ„Â¡Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		// Â¼Ã¶Â½Ã…Ã‡Ã˜Â¾ÃŸ Ã‡Ã’ Â¸ÃÂ½ÃƒÃÃ¶ Ã…Â©Â±Ã¢Â°Â¡ Â¹Ã¶Ã†Ã›ÂºÂ¸Â´Ã™ Ã…Â©Â´Ã™.	ÃÂ¾Â·Ã¡Ã‡Ã˜Â¾ÃŸÂ¸Â¸ Ã‡Ã‘Â´Ã™.
	case DEF_XSOCKEVENT_SOCKETERROR:
		// Â¼Ã’Ã„ÃÂ¿Â¡ Â¿Â¡Â·Â¯Â°Â¡ Â³ÂµÂ´Ã™.
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Â¼Ã’Ã„ÃÃ€ÃŒ Â´ÃÃ‡Ã»Â´Ã™.
		delete m_pGateSock;
		m_pGateSock = NULL;
		PutLogList("(!!!) Gate-socket connection lost!");
		m_bIsGateSockAvailable = FALSE;

		// v1.41 Gate ServerÂ·ÃÃ€Ã‡ Ã€Ã§Â¿Â¬Â°Ã¡ Â½ÃƒÂµÂµ 
		m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
		m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
		// v1.41 Â¿Â¬Â°Ã¡ Â½ÃƒÂ°Â£ ÃƒÂ¼Ã…Â©Â¿Ã« 
		m_iGateSockConnRetryTimes = 1;

		wsprintf(G_cTxt, "(!!!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
		PutLogList(G_cTxt);

		/*
		// Â°Ã”Ã€ÃŒÃ†Â® Â¼Â­Â¹Ã¶Â¿ÃÃ€Ã‡ Â¿Â¬Â°Ã¡Ã€ÃŒ Â²Ã·Â°Ã¥Ã€Â¸Â¹Ã‡Â·Ã ÂºÂ¹Â±Â¸Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. Ã€ÃšÂµÂ¿Ã€Â¸Â·Ã Â¼Â­Â¹Ã¶Â¸Â¦ Â¼Ã‹Â´Ã™Â¿Ã®Ã‡Ã‘Â´Ã™.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 4;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// Â°Ã”Ã€Ã“ Â¼Â­Â¹Ã¶ Â¼Ã‹Â´Ã™Â¿Ã®Ã€ÃŒ Â½ÃƒÃ€Ã›ÂµÃ‡Â¸Ã© Â´ÃµÃ€ÃŒÂ»Ã³Ã€Ã‡ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® ÃÂ¢Â¼Ã“Ã€ÃŒ Â°Ã…ÂºÃÂµÃˆÂ´Ã™. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by gate-server connection Lost)!!!");
		}
		*/
		break;
	}
}

void CGame::OnGateRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pGateSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_GATESERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		// Â¸ÃÂ½ÃƒÃÃ¶ Ã…Â¥Â¿Â¡ Ã€ÃŒÂ»Ã³Ã€ÃŒ Â»Ã½Â°Ã¥Â´Ã™. Ã„Â¡Â¸Ã­Ã€Ã»Ã€Ã Â¿Â¡Â·Â¯.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

void CGame::SendMsgToGateServer(DWORD dwMsg, int iClientH, char * pData)
{
 DWORD * dwp;
 WORD  * wp;
 int     iRet, i;
 char    cData[1000], cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;

	if (m_pGateSock == NULL) {
		PutLogList("(!) SendMsgToGateServer fail - Socket to Gate-Server not available.");
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,  sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	switch (dwMsg) {
	// New 07/05/2004
	case MSGID_PARTYOPERATION:
		iRet = m_pGateSock->iSendMsg(pData, 50);
		break;

	case MSGID_SERVERSTOCKMSG:
		iRet = m_pGateSock->iSendMsg(pData, m_iIndexGSS+1);
		break;
	
	case MSGID_ITEMLOG:
		// Â¾Ã†Ã€ÃŒÃ…Ã› Ã€Ã¼Â´Ã Â·ÃÂ±Ã—Â´Ã™. Â»Ã§Â¿Ã«Ã‡ÃÃÃ¶ Â¾ÃŠÃ€Â½.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_ITEMLOG;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cp, pData, 47);
		cp += 47;

		iRet = m_pGateSock->iSendMsg(cData, 53);
		break;
	
	case MSGID_REQUEST_REGISTERGAMESERVER:
		// Â°Ã”Ã€ÃŒÃ†Â® Â¼Â­Â¹Ã¶Â¿Â¡Â°Ã” Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶ ÂµÃ®Â·ÃÃ€Â» Â¿Ã¤ÃƒÂ»Ã‡Ã‘Â´Ã™.
		wsprintf(cTxt, "(!) Try to register game server(%s) - GateServer", m_cServerName);
		PutLogList(cTxt);
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cAccountName, m_cServerName, 10);
		if (m_iGameServerMode == 1)
		{
			memcpy(cAddress, m_cGameServerAddrInternal, strlen(m_cGameServerAddrInternal));
		}
		if (m_iGameServerMode == 2)
		{
			memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));
		}

		memcpy(cp, cAccountName, 10);
		cp += 10;

		memcpy(cp, cAddress, 16);
		cp += 16;

		wp  = (WORD *)cp;
		*wp = m_iGameServerPort;
		cp += 2;

		*cp = m_iTotalMaps;
		cp++;

		for (i = 0; i < m_iTotalMaps; i++) {
			memcpy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}
		
		dwp = (DWORD *)cp;
		*dwp = (DWORD)GetCurrentProcessId();	 // Ã‡ÃÂ·ÃÂ¼Â¼Â½Âº Ã‡ÃšÂµÃ©Ã€Â» Â±Ã¢Â·ÃÃ‡Ã‘Â´Ã™.

		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = DEF_BUILDDATE;

		iRet = m_pGateSock->iSendMsg(cData, 43 + m_iTotalMaps*11);
		break;

	case MSGID_GAMESERVERALIVE:
		// ÃÂ¤Â±Ã¢Ã€Ã»Ã€Â¸Â·Ã Â°Ã”Ã€Ã“ Â¼Â­Â¹Ã¶Ã€Ã‡ ÃÂ¤ÂºÂ¸Â¸Â¦ Ã€Ã¼Â¼Ã› 
		// Â¸Â¸Â¾Ã  Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â¿ÃÃ€Ã‡ Â¼Ã’Ã„Ã Â¿Â¬Â°Ã¡Ã€ÃŒ Â²Ã·Â¾Ã®ÃÂ³Â´Ã™Â¸Ã© Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»ÃÃ¶ Â¾ÃŠÂ¾Ã† Â¼Â­Â¹Ã¶Â¿Â¡ Ã€ÃŒÂ»Ã³Ã€ÃŒ Â»Ã½Â°Ã¥Ã€Â½Ã€Â» Â¾Ã‹Â¸Â®Â°Ã” Ã€Â¯ÂµÂµÃ‡Ã‘Â´Ã™.
		if (m_bIsLogSockAvailable == FALSE) return;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERALIVE;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp  = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		wp  = (WORD *)cp;
		*wp = m_iTotalClients;
		cp += 2;
		
		iRet = m_pGateSock->iSendMsg(cData, 8);
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Â°Ã”Ã€ÃŒÃ†Â® Â¼Â­Â¹Ã¶Â·Ã Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™.
		PutLogList("(***) Socket to Gate-Server crashed! Critical error!");
		delete m_pGateSock;
		m_pGateSock = NULL;
		m_bIsGateSockAvailable = FALSE;

		// v1.41 Gate ServerÂ·ÃÃ€Ã‡ Ã€Ã§Â¿Â¬Â°Ã¡ Â½ÃƒÂµÂµ: Â¼Â­Â¹Ã¶Â¸Â¦ Â¼Ã‹Â´Ã™Â¿Ã® Ã‡ÃÂ´Ã‚ Â°ÃÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™. 
		m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
		m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
		// v1.41 Â¿Â¬Â°Ã¡ Â½ÃƒÂ°Â£ ÃƒÂ¼Ã…Â©Â¿Ã« 
		m_iGateSockConnRetryTimes = 1;	

		wsprintf(G_cTxt, "(!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
		PutLogList(G_cTxt);

		/*
		// Â°Ã”Ã€ÃŒÃ†Â® Â¼Â­Â¹Ã¶Â¿ÃÃ€Ã‡ Â¿Â¬Â°Ã¡Ã€ÃŒ Â²Ã·Â°Ã¥Ã€Â¸Â¹Ã‡Â·Ã ÂºÂ¹Â±Â¸Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. Ã€ÃšÂµÂ¿Ã€Â¸Â·Ã Â¼Â­Â¹Ã¶Â¸Â¦ Â¼Ã‹Â´Ã™Â¿Ã®Ã‡Ã‘Â´Ã™.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 4;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// Â°Ã”Ã€Ã“ Â¼Â­Â¹Ã¶ Â¼Ã‹Â´Ã™Â¿Ã®Ã€ÃŒ Â½ÃƒÃ€Ã›ÂµÃ‡Â¸Ã© Â´ÃµÃ€ÃŒÂ»Ã³Ã€Ã‡ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® ÃÂ¢Â¼Ã“Ã€ÃŒ Â°Ã…ÂºÃÂµÃˆÂ´Ã™. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by zserver connection Lost)!!!");
		}
		*/
		return;
	}
}

/////////////////////////////////////////////////////////////////////////////////////
//  int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
//  description			:: checks if player is casting magic
//  last updated		:: October 29, 2004; 6:51 PM; Hypnotoad
//	return value		:: int
/////////////////////////////////////////////////////////////////////////////////////
int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
{
 char  cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 		
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	
	ClearSkillUsingStatus(iClientH);

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	if ( (m_pClientList[iClientH]->m_iStatus & 0x10) != 0 )	{
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);		
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
	}

	m_pClientList[iClientH]->m_cDir = cDir;
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

/*********************************************************************************************************************
**  void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, BOOL bItemEffect, int iV1)			**
**  description			:: handles all magic related items/spells													**
**  last updated		:: November 22, 2004; 5:45 PM; Hypnotoad													**
**	return value		:: void																						**
**  commentary			::	-	added 3.51 casting detection														**
**							-	updated it so civilians can only cast certain spells on players and vice versa		**
**							-	fixed bug causing spell to be cast when mana is below required amount				**
**********************************************************************************************************************/
int  _tmp_iMCProb[]        = {0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40};
int  _tmp_iMLevelPenalty[] = {0,   5,   5,   8,   8,  10, 14, 28, 32, 36, 40};
void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, BOOL bItemEffect, int iV1)
{
	short  * sp, sX, sY, sOwnerH, sMagicCircle, rx, ry, sRemainItemSprite, sRemainItemSpriteFrame, sLevelMagic, sTemp;
	char   * cp, cData[120], cDir, cOwnerType, cName[11], cItemName[21], cNpcWaypoint[11], cName_Master[11], cNpcName[21], cRemainItemColor, cScanMessage[256];
	double dV1, dV2, dV3, dV4;
	int    i, iErr, iRet, ix, iy, iResult, iDiceRes, iNamingValue, iFollowersNum, iEraseReq, iWhetherBonus;
	int    tX, tY, iManaCost, iMagicAttr;
	class  CItem * pItem;
	DWORD * dwp, dwTime;
	WORD  * wp, wWeaponType;
	short sEqStatus;

	dwTime = timeGetTime();
	m_pClientList[iClientH]->m_bMagicConfirm = TRUE;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
		(dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return;

	if (((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) < 1000) && (bItemEffect == 0)) {
		wsprintf(G_cTxt, "3.51 Detection: (%s) Player: (%s) - Magic casting speed is too fast! Hack?", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
	m_pClientList[iClientH]->m_dwLastActionTime = dwTime;

	if (m_pClientList[iClientH]->m_cMapIndex < 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == NULL) return;

	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;

	if ((bItemEffect == FALSE) && (m_pClientList[iClientH]->m_cMagicMastery[sType] != 1)) return;

	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;
	//if ((var_874 == TRUE) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) && (m_pMagicConfigList[sType]->m_sType != 8)) return;

	if (((m_pClientList[iClientH]->m_iStatus & 0x100000) != 0) && (bItemEffect != TRUE)) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, NULL, -1, NULL);
			return;
	}

	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);		
		if ((wWeaponType >= 34) && (wWeaponType <= 39)) {
		}
		else return;
	}

	if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND]   != -1) ||
		(m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)) return;

	if ((m_pClientList[iClientH]->m_iSpellCount > 1) && (bItemEffect == FALSE)) {
		wsprintf(G_cTxt, "TSearch Spell Hack: (%s) Player: (%s) - casting magic without precasting.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	if (m_pClientList[iClientH]->m_bInhibition == TRUE) {
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
		return;
	}

	/*if (((m_pClientList[iClientH]->m_iUninteruptibleCheck - (iGetMaxHP(iClientH)/10)) > (m_pClientList[iClientH]->m_iHP)) && (m_pClientList[iClientH]->m_bMagicItem == FALSE)) {
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, NULL,
			NULL, NULL, NULL, NULL, NULL, NULL);
		return;
	}*/
	
	if (m_pMagicConfigList[sType]->m_sType == 32) { // Invisiblity
		sEqStatus = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if ((sEqStatus != -1) && (m_pClientList[iClientH]->m_pItemList[sEqStatus] != NULL)) {
			if((m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 865) || (m_pClientList[iClientH]->m_pItemList[sEqStatus]->m_sIDnum == 866)) {
				bItemEffect = TRUE;
			}
		}
	}

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	sMagicCircle = (sType / 10) + 1;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] == 0)
		dV1 = 1.0f;
	else dV1 = (double)m_pClientList[iClientH]->m_cSkillMastery[4];

	if (bItemEffect == TRUE) dV1 = (double)100.0f;
	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];
	dV1 = dV2 * dV3;
	iResult = (int)dV1;

	if (m_pClientList[iClientH]->m_iInt > 50)
		iResult += (m_pClientList[iClientH]->m_iInt - 50)/2;

	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;
			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			iResult += 5*abs(sMagicCircle - sLevelMagic);
		}
	}

	switch (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus) {
	case 0: break;
	case 1: iResult = iResult - (iResult / 24); break;
	case 2:	iResult = iResult - (iResult / 12); break;
	case 3: iResult = iResult - (iResult / 5);  break;
	}

	if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 10) {
		dV1 = (double)iResult;
		dV2 = (double)(m_pClientList[iClientH]->m_iSpecialWeaponEffectValue * 3);
		dV3 = dV1 + dV2;
		iResult = (int)dV3;
	}

	if (iResult <= 0) iResult = 1;

	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);

	iManaCost = m_pMagicConfigList[sType]->m_sValue1;
	if ((m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) && 
		(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)) {
			iManaCost += (iManaCost / 2) - (iManaCost / 10);
		}
		
		if (m_pClientList[iClientH]->m_iManaSaveRatio > 0) {
			dV1 = (double)m_pClientList[iClientH]->m_iManaSaveRatio;
			dV2 = (double)(dV1 / 100.0f);
			dV3 = (double)iManaCost;
			dV1 = dV2 * dV3;	
			dV2 = dV3 - dV1; 
			iManaCost = (int)dV2;

			if (iManaCost <= 0) iManaCost = 1;
		}

		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 34) {
			iManaCost += 20;
		}

		if (iResult < 100) {
			iDiceRes = iDice(1,100);
			if (iResult < iDiceRes) {
				SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
				return;
			}
		}

		if (((m_pClientList[iClientH]->m_iHungerStatus <= 10) || (m_pClientList[iClientH]->m_iSP <= 0)) && (iDice(1,1000) <= 100)) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
			return;	
		}

		if (m_pClientList[iClientH]->m_iMP < iManaCost) {
			return;
		}

		iResult = m_pClientList[iClientH]->m_cSkillMastery[4];
		if (m_pClientList[iClientH]->m_iMag > 50) iResult += (m_pClientList[iClientH]->m_iMag - 50); 	

		sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
		if (sMagicCircle != sLevelMagic) {
			if (sMagicCircle > sLevelMagic) {
				dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
				dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
				dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
				dV4 = (dV1 / dV3)*dV2;

				iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
			}
			else {
				iResult += 5*abs(sMagicCircle - sLevelMagic);
			}
		}

		iResult += m_pClientList[iClientH]->m_iAddAR;
		if (iResult <= 0) iResult = 1;

		if (sType >= 80) iResult += 10000;

		if (m_pMagicConfigList[sType]->m_sType == 28) {
			iResult += 10000;
		}
		
		if (m_pMagicConfigList[sType]->m_cCategory == 1) {
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000005) != 0) return;
		}

		iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;
		if ((m_pClientList[iClientH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
		}

		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if ((m_bIsCrusadeMode == FALSE) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
			if ((m_pClientList[iClientH]->m_bIsPlayerCivil != TRUE) && (m_pClientList[sOwnerH]->m_bIsPlayerCivil == TRUE)) {
				if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) return;
			}
			else if ((m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE) && (m_pClientList[sOwnerH]->m_bIsPlayerCivil == FALSE)) {
				switch (m_pMagicConfigList[sType]->m_sType) {
					case 1:  // DEF_MAGICTYPE_DAMAGE_SPOT
					case 4:  // DEF_MAGICTYPE_SPDOWN_SPOT 4
					case 8:  // DEF_MAGICTYPE_TELEPORT 8
					case 10: // DEF_MAGICTYPE_CREATE 10
					case 11: // DEF_MAGICTYPE_PROTECT 11
					case 12: // DEF_MAGICTYPE_HOLDOBJECT 12
					case 16: // DEF_MAGICTYPE_CONFUSE
					case 17: // DEF_MAGICTYPE_POISON
					case 24: // DEF_MAGICTYPE_RESURRECTION
						return;
				}
			}
		}

		if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
			switch (m_pMagicConfigList[sType]->m_sType) {
				
				case DEF_MAGICTYPE_DAMAGE_SPOT:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					}
					break;
				
				case DEF_MAGICTYPE_HPUP_SPOT:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
					break;

				case DEF_MAGICTYPE_DAMAGE_AREA:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					}

					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0)) {
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}
					}
					break;				
				
				case DEF_MAGICTYPE_SPDOWN_SPOT:
					break;

				case DEF_MAGICTYPE_SPDOWN_AREA:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
					}
					break;
				
				case DEF_MAGICTYPE_POLYMORPH:
					// Ã‚ÂºÃ‚Â¯Ã‚Â½Ãƒâ€¦ Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (1) { // bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								// Ã‚Â¿ÃƒÂ¸Ã‚Â·Ã‚Â¡ Ãƒâ€¦Ã‚Â¸Ãƒâ‚¬Ãƒâ€Ãƒâ‚¬Ã‚Â» Ãƒâ‚¬ÃƒÂºÃƒâ‚¬ÃƒÂ¥Ãƒâ€¡ÃƒËœ Ã‚Â³ÃƒÂµÃ‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
								m_pClientList[sOwnerH]->m_sOriginalType = m_pClientList[sOwnerH]->m_sType;
								// Ã‚Â¹Ãƒâ„¢Ã‚Â²ÃƒÂ¯ Ã‚Â¿ÃƒÅ“Ãƒâ€¡ÃƒÂ¼Ãƒâ‚¬Ã‚Â» Ãƒâ€¦ÃƒÂ«Ã‚ÂºÃ‚Â¸Ãƒâ€¡ÃƒËœ ÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
								m_pClientList[sOwnerH]->m_sType = 18;
								SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								// Ã‚Â¿ÃƒÂ¸Ã‚Â·Ã‚Â¡ Ãƒâ€¦Ã‚Â¸Ãƒâ‚¬Ãƒâ€Ãƒâ‚¬Ã‚Â» Ãƒâ‚¬ÃƒÂºÃƒâ‚¬ÃƒÂ¥Ãƒâ€¡ÃƒËœ Ã‚Â³ÃƒÂµÃ‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
								m_pNpcList[sOwnerH]->m_sOriginalType = m_pNpcList[sOwnerH]->m_sType;
								// Ã‚Â¹Ãƒâ„¢Ã‚Â²ÃƒÂ¯ Ã‚Â¿ÃƒÅ“Ãƒâ€¡ÃƒÂ¼Ãƒâ‚¬Ã‚Â» Ãƒâ€¦ÃƒÂ«Ã‚ÂºÃ‚Â¸Ãƒâ€¡ÃƒËœ ÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
								m_pNpcList[sOwnerH]->m_sType = 18;
								SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
								break;
						}

						// Ã‚ÂºÃ‚Â¯Ã‚Â½Ãƒâ€¦ ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_POLYMORPH, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ã‚Â»ÃƒÂ½Ã‚Â°ÃƒÂ¥Ãƒâ‚¬Ã‚Â½Ãƒâ‚¬Ã‚Â» Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
						if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POLYMORPH, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					}
					break;

				// 05/20/2004 - Hypnotoad - Cancellation
				case DEF_MAGICTYPE_CANCELLATION:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) && (m_pClientList[sOwnerH]->m_iHP > 0) && (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)) {

						// Removes Invisibility Flag 0x0010
						SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);

						// Removes Illusion Flag 0x01000000
						SetIllusionFlag(sOwnerH, cOwnerType, FALSE);

						// Removes Defense Shield Flag 0x02000000
						// Removes Great Defense Shield Flag 0x02000000
						SetDefenseShieldFlag(sOwnerH, cOwnerType, FALSE);

						// Removes Absolute Magic Protection Flag 0x04000000	
						// Removes Protection From Magic Flag 0x04000000
						SetMagicProtectionFlag(sOwnerH, cOwnerType, FALSE);

						// Removes Protection From Arrow Flag 0x08000000
						SetProtectionFromArrowFlag(sOwnerH, cOwnerType, FALSE);

						// Removes Illusion Movement Flag 0x00200000
						SetIllusionMovementFlag(sOwnerH, cOwnerType, FALSE);

						// Removes Berserk Flag 0x0020
						SetBerserkFlag(sOwnerH, cOwnerType, FALSE);

						if (m_pClientList[iClientH]->m_bInhibition == TRUE)
						bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INHIBITION);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
						sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						if (m_pClientList[iClientH]->m_iStatus & 0x0010)
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						if (m_pClientList[iClientH]->m_iStatus & 0x0020)
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_BERSERK);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						if ( (m_pClientList[iClientH]->m_iStatus & 0x08000000) || (m_pClientList[iClientH]->m_iStatus & 0x04000000) || (m_pClientList[iClientH]->m_iStatus & 0x02000000))
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						if ((m_pClientList[iClientH]->m_iStatus & 0x01000000) || (m_pClientList[iClientH]->m_iStatus & 0x00200000))
							bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_CONFUSE);
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						// Update Client
						SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT_SPDOWN:
					// Á÷°İÀº Ã³¸®ÇÏÁö ¾Ê´Â´Ù.
					// ÁÖº¯ °ø°İ È¿°ú 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// ÀÚ½Åµµ ÇÇÆøµÉ ¼ö ÀÖÀ¸´Ï ÁÖÀÇ.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
							Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 				 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
							// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
								Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
							}
						}
					}
					break;

				case DEF_MAGICTYPE_DAMAGE_LINEAR:
					// Ãƒâ‚¬ÃƒÂÃƒÂÃƒÂ·Ã‚Â¼Ã‚Â± Ã‚Â»ÃƒÂ³Ã‚Â¿Ã‚Â¡ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ã‚Â¸ÃƒÂ±Ãƒâ€¡Ã‚Â¥Ã‚Â¸Ã‚Â¦ Ã‚Â¸ÃƒÂ°Ã‚ÂµÃƒÅ½ Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
					sX = m_pClientList[iClientH]->m_sX;
					sY = m_pClientList[iClientH]->m_sY;

					for (i = 2; i < 10; i++) {
						iErr = 0;
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

						// tx, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}

							// tx-1, ty
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								}

								// tx+1, ty
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
									(m_pClientList[sOwnerH]->m_iHP > 0) ) {
										// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									}

									// tx, ty-1
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
										(m_pClientList[sOwnerH]->m_iHP > 0) ) {
											// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										}

										// tx, ty+1
										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
											Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
											(m_pClientList[sOwnerH]->m_iHP > 0) ) {
												// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
											}

											if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}

					// ÃƒÂÃƒâ€“Ã‚ÂºÃ‚Â¯ Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂ ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// Ãƒâ‚¬ÃƒÅ¡Ã‚Â½Ãƒâ€¦Ã‚ÂµÃ‚Âµ Ãƒâ€¡Ãƒâ€¡Ãƒâ€ ÃƒÂ¸Ã‚ÂµÃƒâ€° Ã‚Â¼ÃƒÂ¶ Ãƒâ‚¬Ãƒâ€“Ãƒâ‚¬Ã‚Â¸Ã‚Â´ÃƒÂ ÃƒÂÃƒâ€“Ãƒâ‚¬Ãƒâ€¡.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								}
						}

						// dX, dY
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
							}
							break;

				// v2.16 2002-5-23 Ã‚Â°ÃƒÂ­Ã‚Â±Ã‚Â¤Ãƒâ€¡ÃƒÂ¶ 
				case DEF_MAGICTYPE_ICE_LINEAR:
					// Ãƒâ‚¬ÃƒÂÃƒÂÃƒÂ·Ã‚Â¼Ã‚Â± Ã‚Â»ÃƒÂ³Ã‚Â¿Ã‚Â¡ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ã‚Â¸ÃƒÂ±Ãƒâ€¡Ã‚Â¥Ã‚Â¸Ã‚Â¦ Ã‚Â¸ÃƒÂ°Ã‚ÂµÃƒÅ½ Ã‚Â¾ÃƒÂ³Ã‚Â¸Ã‚Â®Ã‚Â¸ÃƒÂ§ Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
					sX = m_pClientList[iClientH]->m_sX;
					sY = m_pClientList[iClientH]->m_sY;

					for (i = 2; i < 10; i++) {
						iErr = 0;
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

						// tx, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (m_pClientList[sOwnerH]->m_iHP < 0) goto MAGIC_NOEFFECT;
									// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
													SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												}
											}
											break;
									}
									//
								}
							}

							// tx-1, ty
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
												SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
											}
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											}
										}
										break;
								}
								//
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
												if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
														// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
														SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
													}
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													}
												}
												break;
										}
										//
									}
								}

								// tx+1, ty
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
													SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												}
											}
											break;
									}
									//
								}

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
									(m_pClientList[sOwnerH]->m_iHP > 0) ) {
										// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
											// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
											switch (cOwnerType) {
												case DEF_OWNERTYPE_PLAYER:
													if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
													if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
														if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
															m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
															SetIceFlag(sOwnerH, cOwnerType, TRUE);
															// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
															bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
															// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
															SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
														}
													}
													break;

												case DEF_OWNERTYPE_NPC:
													if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
														if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
															m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
															SetIceFlag(sOwnerH, cOwnerType, TRUE);
															// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
															bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
														}
													}
													break;
											}
											//
										}
									}

									// tx, ty-1
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
												if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
														// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
														SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
													}
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													}
												}
												break;
										}
										//
									}

									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
										(m_pClientList[sOwnerH]->m_iHP > 0) ) {
											// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
												// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
												switch (cOwnerType) {
													case DEF_OWNERTYPE_PLAYER:
														if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
														// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
														if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
															if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
																m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
																SetIceFlag(sOwnerH, cOwnerType, TRUE);
																// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
																bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																	sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
																// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
																SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
															}
														}
														break;

													case DEF_OWNERTYPE_NPC:
														if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
														if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
															if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
																m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
																SetIceFlag(sOwnerH, cOwnerType, TRUE);
																// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
																bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																	sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
															}
														}
														break;
												}
												//
											}
										}

										// tx, ty+1
										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
											// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
											switch (cOwnerType) {
												case DEF_OWNERTYPE_PLAYER:
													if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
													if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
														if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
															m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
															SetIceFlag(sOwnerH, cOwnerType, TRUE);
															// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
															bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
															// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
															SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
														}
													}
													break;

												case DEF_OWNERTYPE_NPC:
													if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
														if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
															m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
															SetIceFlag(sOwnerH, cOwnerType, TRUE);
															// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
															bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
														}
													}
													break;
											}
											//
										}

										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
											(m_pClientList[sOwnerH]->m_iHP > 0) ) {
												// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
													// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
													switch (cOwnerType) {
														case DEF_OWNERTYPE_PLAYER:
															if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
															// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
															if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
																if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
																	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
																	SetIceFlag(sOwnerH, cOwnerType, TRUE);
																	// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
																	bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																		sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
																	// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
																	SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
																}
															}
															break;

														case DEF_OWNERTYPE_NPC:
															if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
															if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
																if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
																	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
																	SetIceFlag(sOwnerH, cOwnerType, TRUE);
																	// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
																	bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
																		sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
																}
															}
															break;
													}
													//
												}
											}

											if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}

					// ÃƒÂÃƒâ€“Ã‚ÂºÃ‚Â¯ Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂ ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// Ãƒâ‚¬ÃƒÅ¡Ã‚Â½Ãƒâ€¦Ã‚ÂµÃ‚Âµ Ãƒâ€¡Ãƒâ€¡Ãƒâ€ ÃƒÂ¸Ã‚ÂµÃƒâ€° Ã‚Â¼ÃƒÂ¶ Ãƒâ‚¬Ãƒâ€“Ãƒâ‚¬Ã‚Â¸Ã‚Â´ÃƒÂ ÃƒÂÃƒâ€“Ãƒâ‚¬Ãƒâ€¡.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
												SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
											}
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											}
										}
										break;
								}
								//
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
												if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
														// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
														SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
													}
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
													if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
														m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
														SetIceFlag(sOwnerH, cOwnerType, TRUE);
														// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
														bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
															sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													}
												}
												break;
										}
										//
									}
								}
						}

						// dX, dY
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
							// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
									if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
										}
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
										if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
											m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
											SetIceFlag(sOwnerH, cOwnerType, TRUE);
											// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
										}
									}
									break;
							}
							//
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
									// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
											if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
													// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
													SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
												}
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
													SetIceFlag(sOwnerH, cOwnerType, TRUE);
													// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
													bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
														sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												}
											}
											break;
									}
									//
								}
							}
							break;


				case DEF_MAGICTYPE_INHIBITION:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INHIBITION ] != 0) goto MAGIC_NOEFFECT;
						if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;
						//if (m_pClientList[sOwnerH]->m_iAdminUserLevel != 0) goto MAGIC_NOEFFECT;
						m_pClientList[sOwnerH]->m_bInhibition = TRUE;
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INHIBITION, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
						break;
					}
					break;
	
				
				case DEF_MAGICTYPE_TREMOR: // v1.4 ÃƒÂÃƒâ€“Ã‚ÂºÃ‚Â¯ Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂ ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â¿Ã‚Â¡ Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ® Ãƒâ‚¬ÃƒÅ“Ã‚Â·ÃƒÂ¹ ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ„¢.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {
							// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						}

						// ÃƒÂÃƒâ€“Ã‚ÂºÃ‚Â¯ Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂ ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº 
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
							for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
								// Ãƒâ‚¬ÃƒÅ¡Ã‚Â½Ãƒâ€¦Ã‚ÂµÃ‚Âµ Ãƒâ€¡Ãƒâ€¡Ãƒâ€ ÃƒÂ¸Ã‚ÂµÃƒâ€° Ã‚Â¼ÃƒÂ¶ Ãƒâ‚¬Ãƒâ€“Ãƒâ‚¬Ã‚Â¸Ã‚Â´ÃƒÂ ÃƒÂÃƒâ€“Ãƒâ‚¬Ãƒâ€¡.
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
								if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
									(m_pClientList[sOwnerH]->m_iHP > 0) ) {
										// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									}
							}
							break;

				case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
					// ÃƒÂÃƒÂ·Ã‚Â°ÃƒÂÃƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â³Ã‚Â¸Ã‚Â®Ãƒâ€¡ÃƒÂÃƒÂÃƒÂ¶ Ã‚Â¾ÃƒÅ Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
					// ÃƒÂÃƒâ€“Ã‚ÂºÃ‚Â¯ Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂ ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// Ãƒâ‚¬ÃƒÅ¡Ã‚Â½Ãƒâ€¦Ã‚ÂµÃ‚Âµ Ãƒâ€¡Ãƒâ€¡Ãƒâ€ ÃƒÂ¸Ã‚ÂµÃƒâ€° Ã‚Â¼ÃƒÂ¶ Ãƒâ‚¬Ãƒâ€“Ãƒâ‚¬Ã‚Â¸Ã‚Â´ÃƒÂ ÃƒÂÃƒâ€“Ãƒâ‚¬Ãƒâ€¡.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								}
						}
						break;

				case DEF_MAGICTYPE_SPUP_AREA:
					// SpÃ‚Â°Ã‚Â¡ Ã‚Â»ÃƒÂ³Ã‚Â½Ãƒâ€šÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					// Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÅ Ã‚Â¿ÃƒÂ¤Ã‚Â¾ÃƒÂ¸Ã‚Â´Ãƒâ„¢. 
					Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
					// ÃƒÂÃƒâ€“Ã‚ÂºÃ‚Â¯ Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂ ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// Ãƒâ‚¬ÃƒÅ¡Ã‚Â½Ãƒâ€¦Ã‚ÂµÃ‚Âµ Ãƒâ€¡Ãƒâ€¡Ãƒâ€ ÃƒÂ¸Ã‚ÂµÃƒâ€° Ã‚Â¼ÃƒÂ¶ Ãƒâ‚¬Ãƒâ€“Ãƒâ‚¬Ã‚Â¸Ã‚Â´ÃƒÂ ÃƒÂÃƒâ€“Ãƒâ‚¬Ãƒâ€¡.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							// Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÅ Ã‚Â¿ÃƒÂ¤ Ã‚Â¾ÃƒÂ¸Ã‚Â´Ãƒâ„¢.
							Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
						}
						break;

						// v2.16 2002-5-23 Â°Ã­Â±Â¤Ã‡Ã¶ 
				case DEF_MAGICTYPE_DAMAGE_LINEAR_SPDOWN:
					// Ã€ÃÃÃ·Â¼Â± Â»Ã³Â¿Â¡ Ã€Ã–Â´Ã‚ Â¸Ã±Ã‡Â¥Â¸Â¦ Â¸Ã°ÂµÃ Â¾Ã³Â¸Â®Â¸Ã§ Â°Ã¸Â°ÃÃ‡Ã‘Â´Ã™.
					sX = m_pClientList[iClientH]->m_sX;
					sY = m_pClientList[iClientH]->m_sY;

					for (i = 2; i < 10; i++) {
						iErr = 0;
						m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);

						// tx, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											}
											break;
									}
									//
								}
							}

							// tx-1, ty
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

										}
										break;
								}
								//
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												}
												break;
										}
										//
									}
								}

								// tx+1, ty
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											}
											break;
									}
									//
								}

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
								if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
									(m_pClientList[sOwnerH]->m_iHP > 0) ) {
										// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
											// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
											switch (cOwnerType) {
												case DEF_OWNERTYPE_PLAYER:
													if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
													if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
														Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
														Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													}
													break;

												case DEF_OWNERTYPE_NPC:
													if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
														Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
														Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													}
													break;
											}
											//
										}
									}

									// tx, ty-1
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												}
												break;
										}
										//
									}

									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
									if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
										(m_pClientList[sOwnerH]->m_iHP > 0) ) {
											// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
												// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
												switch (cOwnerType) {
													case DEF_OWNERTYPE_PLAYER:
														if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
														// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
														if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
															Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
															Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
														}
														break;

													case DEF_OWNERTYPE_NPC:
														if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
														if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
															Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
															Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
														}
														break;
												}
												//
											}
										}

										// tx, ty+1
										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, sX, sY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
											// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
											switch (cOwnerType) {
												case DEF_OWNERTYPE_PLAYER:
													if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
													if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
														Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
														Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													}
													break;

												case DEF_OWNERTYPE_NPC:
													if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
													if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
														Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
														Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
													}
													break;
											}
											//
										}

										m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
										if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
											(m_pClientList[sOwnerH]->m_iHP > 0) ) {
												// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
													// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
													switch (cOwnerType) {
														case DEF_OWNERTYPE_PLAYER:
															if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
															// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
															if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
																Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
																Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
															}
															break;

														case DEF_OWNERTYPE_NPC:
															if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
															if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
																Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
																Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
															}
															break;
													}
													//
												}
											}

											if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
					}

					// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
											Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
										}
										break;
								}
								//
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
													Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
													Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

												}
												break;
										}
										//
									}
								}
						}

						// dX, dY
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
							// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
									}
									break;
							}
							//
						}

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
									// Â¾Ã³Â¾Ã®Â¼Â­ ÂµÂ¿Ã€Ã›Ã€ÃŒ Â´ÃŠÂ¾Ã®ÃÃ¶Â´Ã‚ ÃˆÂ¿Â°Ãº
									switch (cOwnerType) {
										case DEF_OWNERTYPE_PLAYER:
											if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											// Ã…Â¸Â°Ã™Ã€ÃŒ Â»Ã¬Â¾Ã†Ã€Ã–Â°Ã­ Â¾Ã³Ã€Â½ Ã€ÃºÃ‡Ã—Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™Â¸Ã© Â¾Ã³Â¾Ã®ÂºÃ™Â´Ã‚Â´Ã™.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
											}
											break;

										case DEF_OWNERTYPE_NPC:
											if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
												Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);

											}
											break;
									}
									//
								}
							}
							break;

				case DEF_MAGICTYPE_TELEPORT:
					// Ãƒâ€¦ÃƒÅ¡Ã‚Â·Ã‚Â¹Ãƒâ€ ÃƒÂ·Ãƒâ€ Ã‚Â® Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½. sValue 4Ã‚Â¿Ã‚Â¡ Ã‚ÂµÃƒÂ»Ã‚Â¶ÃƒÂ³Ã‚Â¼Ã‚Â­ Ãƒâ€¦ÃƒÅ¡Ã‚Â·Ã‚Â¹Ãƒâ€ ÃƒÂ·Ãƒâ€ Ã‚Â® Ã‚Â¸ÃƒÂ±Ãƒâ‚¬ÃƒÂ»ÃƒÂÃƒÂ¶Ã‚Â°Ã‚Â¡ Ã‚Â°ÃƒÂ¡ÃƒÂÃ‚Â¤Ã‚ÂµÃƒË†Ã‚Â´Ãƒâ„¢.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					// Ãƒâ‚¬ÃƒÅ¡Ã‚Â½Ãƒâ€¦Ãƒâ‚¬ÃƒÅ’ Ã‚Â¼Ãƒâ€™Ã‚Â¼Ãƒâ€œÃ‚ÂµÃƒË† Ã‚Â¸Ã‚Â¶Ãƒâ‚¬Ã‚Â»Ã‚Â·ÃƒÅ½ Ãƒâ€¦ÃƒÅ¡Ã‚Â·Ã‚Â¹Ãƒâ€ ÃƒÂ·Ãƒâ€ Ã‚Â®. RecallÃƒâ‚¬ÃƒÅ’Ã‚Â´Ãƒâ„¢.
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH) ) {
						// Ãƒâ‚¬ÃƒÅ¡Ã‚Â½Ãƒâ€¦Ã‚Â¿ÃƒÅ“Ã‚Â¿Ã‚Â¡Ã‚Â´Ãƒâ€š RecallÃƒâ€¡Ãƒâ€™ Ã‚Â¼ÃƒÂ¶ Ã‚Â¾ÃƒÂ¸Ã‚Â´Ãƒâ„¢.
						RequestTeleportHandler(iClientH, "1   ");
					}
					break;
					}
					break;

				case DEF_MAGICTYPE_SUMMON:
					// Ã‚Â¼Ãƒâ€™ÃƒË†Ã‚Â¯Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ 

					// Ã‚Â»ÃƒÂ§Ãƒâ€¦ÃƒÂµÃƒâ‚¬ÃƒÂ¥ Ã‚Â³Ã‚Â»Ã‚Â¿Ã‚Â¡Ã‚Â¼Ã‚Â­Ã‚Â´Ãƒâ€š Ã‚Â¼Ãƒâ€™ÃƒË†Ã‚Â¯Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½Ãƒâ‚¬ÃƒÅ’ Ã‚ÂºÃƒâ€™Ã‚Â°Ã‚Â¡Ã‚Â´Ãƒâ€°.
					if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) return;

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					// ÃƒÂÃƒÂ¶ÃƒÂÃ‚Â¤Ã‚ÂµÃƒË† OwnerÃ‚Â°Ã‚Â¡ MasterÃ‚Â°Ã‚Â¡ Ã‚ÂµÃƒË†Ã‚Â´Ãƒâ„¢. 
					if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
						// MasterÃ‚Â·ÃƒÅ½ ÃƒÂÃƒÂ¶ÃƒÂÃ‚Â¤Ã‚ÂµÃƒË† Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬Ã‚Â» Ã‚ÂµÃƒÂ»Ã‚Â¶ÃƒÂ³Ã‚Â´Ãƒâ„¢Ã‚Â´ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ã‚Â°Ã‚Â´ÃƒÆ’Ã‚Â¼ Ã‚Â¼ÃƒÂ¶Ã‚Â¸Ã‚Â¦ Ã‚Â°ÃƒÂ¨Ã‚Â»ÃƒÂªÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢. 
						iFollowersNum = iGetFollowerNumber(sOwnerH, cOwnerType);

						// Ã‚Â¼Ãƒâ€™ÃƒË†Ã‚Â¯Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½Ãƒâ‚¬Ã‚Â» CastingÃƒâ€¡Ãƒâ€˜ Ãƒâ‚¬ÃƒÅ¡Ãƒâ‚¬Ãƒâ€¡ Magery/20 Ã‚Â¸Ã‚Â¸Ãƒâ€¦Ã‚Â­Ãƒâ‚¬Ãƒâ€¡ Ã‚Â¸ÃƒÂ³Ã‚Â½Ã‚ÂºÃƒâ€¦ÃƒÂÃ‚Â¸Ã‚Â¦ Ã‚Â¼Ãƒâ€™ÃƒË†Ã‚Â¯Ãƒâ€¡Ãƒâ€™ Ã‚Â¼ÃƒÂ¶ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ„¢.
						if (iFollowersNum >= (m_pClientList[iClientH]->m_cSkillMastery[4]/20)) break;

						iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
						if (iNamingValue == -1) {
							// Ã‚Â´ÃƒÂµÃƒâ‚¬ÃƒÅ’Ã‚Â»ÃƒÂ³ Ãƒâ‚¬ÃƒÅ’ Ã‚Â¸ÃƒÅ Ã‚Â¿Ã‚Â¡ NPCÃ‚Â¸Ã‚Â¦ Ã‚Â¸Ã‚Â¸Ã‚ÂµÃƒÂ©Ã‚Â¼ÃƒÂ¶ Ã‚Â¾ÃƒÂ¸Ã‚Â´Ãƒâ„¢. Ãƒâ‚¬ÃƒÅ’Ã‚Â¸Ã‚Â§Ãƒâ‚¬Ã‚Â» Ãƒâ€¡Ãƒâ€™Ã‚Â´ÃƒÂ§Ãƒâ€¡Ãƒâ€™ Ã‚Â¼ÃƒÂ¶ Ã‚Â¾ÃƒÂ¸Ã‚Â±ÃƒÂ¢ Ã‚Â¶Ã‚Â§Ã‚Â¹Ã‚Â®.
						}
						else {
							// NPCÃ‚Â¸Ã‚Â¦ Ã‚Â»ÃƒÂ½Ã‚Â¼Ã‚ÂºÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = '_';
							cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;

							// MageryÃ‚Â¿Ã‚Â¡ Ã‚ÂµÃƒÂ»Ã‚Â¶ÃƒÂ³ Ã‚Â¼Ãƒâ€™ÃƒË†Ã‚Â¯Ã‚ÂµÃƒâ€¡Ã‚Â´Ãƒâ€š Ã‚Â¸ÃƒÂ³Ã‚Â½Ã‚ÂºÃƒâ€¦ÃƒÂÃƒâ‚¬Ãƒâ€¡ Ã‚ÂµÃƒÂ®Ã‚Â±ÃƒÅ¾Ãƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ¾Ã‚Â¶ÃƒÂ³ÃƒÂÃƒÂ¸Ã‚Â´Ãƒâ„¢.
							ZeroMemory(cNpcName, sizeof(cNpcName));

							switch (iV1) {
								case NULL: // Ãƒâ‚¬ÃƒÂÃ‚Â¹ÃƒÂÃƒâ‚¬ÃƒÂ»Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ 
									iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);

									// v1.42 ÃƒÆ’Ãƒâ€“Ãƒâ‚¬ÃƒÂº Ã‚Â¸ÃƒÂ· Ã‚Â·Ã‚Â¹Ã‚ÂºÃ‚Â§Ãƒâ‚¬Ã‚Â» Ãƒâ‚¬Ãƒâ€Ã‚Â·Ãƒâ€š 
									if (iResult < m_pClientList[iClientH]->m_cSkillMastery[4] / 20) 
										iResult = m_pClientList[iClientH]->m_cSkillMastery[4] / 20;

									switch (iResult) {
										case 1: strcpy(cNpcName, "Slime"); break;
										case 2: strcpy(cNpcName, "Giant-Ant"); break;
										case 3: strcpy(cNpcName, "Amphis"); break;
										case 4: strcpy(cNpcName, "Orc"); break;
										case 5: strcpy(cNpcName, "Skeleton"); break;
										case 6:	strcpy(cNpcName, "Clay-Golem"); break;
										case 7:	strcpy(cNpcName, "Stone-Golem"); break;
										case 8: strcpy(cNpcName, "Orc-Mage"); break;
										case 9:	strcpy(cNpcName, "Hellbound"); break;
										case 10:strcpy(cNpcName, "Cyclops"); break;
									}
									break;

								case 1:	strcpy(cNpcName, "Orc"); break;
								case 2: strcpy(cNpcName, "Skeleton"); break;
								case 3: strcpy(cNpcName, "Clay-Golem"); break;
								case 4: strcpy(cNpcName, "Stone-Golem"); break;
								case 5: strcpy(cNpcName, "Hellbound"); break;
								case 6: strcpy(cNpcName, "Cyclops"); break;
								case 7: strcpy(cNpcName, "Troll"); break;
								case 8: strcpy(cNpcName, "Orge"); break;
							}

							if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypoint, NULL, NULL, m_pClientList[iClientH]->m_cSide, FALSE, TRUE) == FALSE) {
								// Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ãƒâ‚¬Ã‚Â¸Ã‚Â¹Ãƒâ€¡Ã‚Â·ÃƒÅ½ Ã‚Â¿Ã‚Â¹Ã‚Â¾ÃƒÂ Ã‚ÂµÃƒË† NameValueÃ‚Â¸Ã‚Â¦ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚Â½ÃƒÆ’Ãƒâ€¦Ã‚Â²Ã‚Â´Ãƒâ„¢.
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								ZeroMemory(cName_Master, sizeof(cName_Master));
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										memcpy(cName_Master, m_pClientList[sOwnerH]->m_cCharName, 10);
										break;
									case DEF_OWNERTYPE_NPC:
										memcpy(cName_Master, m_pNpcList[sOwnerH]->m_cName, 5);
										break;
								}
								bSetNpcFollowMode(cName, cName_Master, cOwnerType);
							}
						}
					}
					break;

				case DEF_MAGICTYPE_CREATE:
					// Ã‚Â¹Ã‚Â«Ã‚Â¾ÃƒÂ°Ã‚Â°Ã‚Â¡Ã‚Â¸Ã‚Â¦ Ã‚Â»ÃƒÂ½Ã‚Â¼Ã‚ÂºÃ‚Â½ÃƒÆ’Ãƒâ€¦Ã‚Â°Ã‚Â´Ãƒâ€š Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ 

					// Ãƒâ‚¬Ã‚Â§Ãƒâ€Ã‚Â¡Ãƒâ€¡Ãƒâ€™ Ã‚Â¼ÃƒÂ¶ Ã‚Â¾ÃƒÂ¸Ã‚Â´Ãƒâ€š Ã‚Â°ÃƒÂ·Ã‚Â¿Ã‚Â¡Ã‚Â´Ãƒâ€š Ã‚Â»ÃƒÂ½Ã‚Â±ÃƒÂ¢ÃƒÂÃƒÂ¶ Ã‚Â¾ÃƒÅ Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢. 
					if ( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsMoveAllowedTile(dX, dY) == FALSE )
						goto MAGIC_NOEFFECT;

					pItem = new class CItem;

					switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					// Food
					if (iDice(1,2) == 1)
						wsprintf(cItemName, "Meat");
					else wsprintf(cItemName, "Baguette");
					break;
					}

					_bInitItemAttr(pItem, cItemName);

					// v2.15 Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½Ãƒâ‚¬Ã‚Â¸Ã‚Â·ÃƒÅ½ Ã‚Â»ÃƒÂ½Ã‚Â±ÃƒÂ¤ Ã‚Â¾Ãƒâ€ Ãƒâ‚¬ÃƒÅ’Ãƒâ€¦Ãƒâ€ºÃ‚Â¿Ã‚Â¡ Ã‚Â°ÃƒÂ­Ãƒâ‚¬Ã‚Â¯Ã‚Â¹ÃƒÂ¸ÃƒË†Ã‚Â£ Ãƒâ‚¬ÃƒÂºÃƒâ‚¬ÃƒÂ¥ 
					pItem->m_sTouchEffectType   = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1,100000);
					pItem->m_sTouchEffectValue2 = iDice(1,100000);
					pItem->m_sTouchEffectValue3 = (short)timeGetTime();

					// Ã‚Â¾Ãƒâ€ Ãƒâ‚¬ÃƒÅ’Ãƒâ€¦Ãƒâ€ºÃƒâ‚¬Ã‚Â» Ã‚Â¼Ã‚Â­Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ‚¬Ã‚Â§Ãƒâ€Ã‚Â¡Ã‚Â¿Ã‚Â¡ Ã‚Â¹ÃƒÂ¶Ã‚Â¸Ã‚Â°Ã‚Â´Ãƒâ„¢. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

					// v1.41 ÃƒË†ÃƒÂ±Ã‚Â±ÃƒÂ Ã‚Â¾Ãƒâ€ Ãƒâ‚¬ÃƒÅ’Ãƒâ€¦Ãƒâ€ºÃƒâ‚¬Ã‚Â» Ã‚Â¶Ã‚Â³Ã‚Â¾ÃƒÂ®Ã‚Â¶ÃƒÅ¸Ã‚Â¸Ã‚Â° Ã‚Â°ÃƒÂÃƒâ‚¬ÃƒÅ’Ã‚Â¶ÃƒÂ³Ã‚Â¸ÃƒÂ© Ã‚Â·ÃƒÅ½Ã‚Â±Ãƒâ€”Ã‚Â¸Ã‚Â¦ Ã‚Â³Ã‚Â²Ã‚Â±ÃƒÂ¤Ã‚Â´Ãƒâ„¢. 
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, (int) -1, pItem);

					// Ã‚Â´Ãƒâ„¢Ã‚Â¸Ã‚Â¥ Ãƒâ€¦Ã‚Â¬Ã‚Â¶ÃƒÂ³Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ°Ãƒâ€ Ã‚Â®Ã‚Â¿Ã‚Â¡Ã‚Â°Ãƒâ€ Ã‚Â¾Ãƒâ€ Ãƒâ‚¬ÃƒÅ’Ãƒâ€¦Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â¶Ã‚Â³Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¸ Ã‚Â°ÃƒÂÃƒâ‚¬Ã‚Â» Ã‚Â¾Ãƒâ€¹Ã‚Â¸Ã‚Â°Ã‚Â´Ãƒâ„¢. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
						dX, dY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
					break;

				case DEF_MAGICTYPE_PROTECT:
					// Ã‚ÂºÃ‚Â¸ÃƒË†Ã‚Â£ Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					// Ã‚ÂºÃ‚Â¸ÃƒË†Ã‚Â£ Ã‚Â»ÃƒÂ³Ãƒâ€¦Ãƒâ€šÃ‚Â¶ÃƒÂ³Ã‚Â´Ãƒâ€š Ã‚Â°ÃƒÂÃƒâ‚¬Ã‚Â» Ã‚Â¼Ã‚Â³ÃƒÂÃ‚Â¤Ãƒâ€¡ÃƒÂÃ‚Â±ÃƒÂ¢ Ãƒâ‚¬ÃƒÂ¼Ã‚Â¿Ã‚Â¡ Ãƒâ‚¬ÃƒÅ’Ã‚Â¹ÃƒÅ’ Ãƒâ€¡ÃƒËœÃ‚Â´ÃƒÂ§ Ã‚ÂºÃ‚Â¸ÃƒË†Ã‚Â£Ã‚Â°Ã‚Â¡ Ã‚Â°Ãƒâ€°Ã‚Â·ÃƒÂÃƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€šÃƒÂÃƒÂ¶ ÃƒË†Ã‚Â®Ãƒâ‚¬ÃƒÅ½Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ã‚Â°Ãƒâ€°Ã‚Â·ÃƒÂÃƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½Ãƒâ‚¬Ã‚Âº Ã‚Â¹Ã‚Â«Ã‚Â½ÃƒÆ’Ã‚ÂµÃƒË†Ã‚Â´Ãƒâ„¢. 
					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
							// v1.4334 ÃƒÂÃƒÅ¸Ã‚Â¸Ã‚Â³Ãƒâ‚¬Ã‚Âº Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â¿Ã‚Â¡Ã‚Â°Ãƒâ€ Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ¦Ãƒâ‚¬Ã‚Â» Ã‚Â¸ÃƒÂ¸Ãƒâ€¡ÃƒÂÃ‚Â°Ãƒâ€ Ã‚Â¼ÃƒÂ¶ÃƒÂÃ‚Â¤
							if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
							switch (m_pMagicConfigList[sType]->m_sValue4){
							case 1:
								SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
								break;
							case 2:
							case 5:
								SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
								break;
							case 3:
							case 4:
								SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
								break;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
							// ÃƒÂÃ‚Â¤Ãƒâ‚¬ÃƒÂ» NPCÃ‚ÂµÃƒÂ©Ãƒâ‚¬Ã‚Âº Ã‚ÂºÃ‚Â¸ÃƒË†Ã‚Â£ Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ Ãƒâ‚¬ÃƒÂ»Ã‚Â¿ÃƒÂ« Ã‚Â¾ÃƒË†Ã‚ÂµÃƒÅ .				
							if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
							m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;

							switch (m_pMagicConfigList[sType]->m_sValue4){
							case 1:
								SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
								break;
							case 2:
							case 5:
								SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
								break;
							case 3:
							case 4:
								SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
								break;
							}
							break;
					}

					// Ã‚ÂºÃ‚Â¸ÃƒË†Ã‚Â£ ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
						sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

					// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ã‚Â»ÃƒÂ½Ã‚Â°ÃƒÂ¥Ãƒâ‚¬Ã‚Â½Ãƒâ‚¬Ã‚Â» Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
					if (cOwnerType == DEF_OWNERTYPE_PLAYER)
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_PROTECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					break;
					
/*					// Magictype:	Protection from Magic, Protection from Arrow, Defense Shield
		//				Absolue Magic Protection, Great Defense Shield
		case DEF_MAGICTYPE_PROTECT:
			// iClientH (the caster) gets the spell targets (sOwnerH) type (npc/pc) and coords (x,y)
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// switch cases for the owner type (DEF_OWNERTYPE_PLAYER, DEF_OWNERTYPE_NPC)
			switch (cOwnerType) {
			// if the owners is a player
			case DEF_OWNERTYPE_PLAYER:
				// DISABLED: if the caster side isnt the same as the targets side, no effect occurs
				// DISABLED: if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) goto MAGIC_NOEFFECT;
				// if the player target doesnt exist no magic effect
				if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
				// if the player target already has a protect magic on, no magic effect occurs
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != FALSE) goto MAGIC_NOEFFECT;
				// if the caster is neutral go to no magic effect
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;
				// switch cases for the effect4 of the spell
				switch (m_pMagicConfigList[sType]->m_sValue4){
					// Protection From Arrow
					case 1:
						// triggers the spell target's protection from arrow flag on
						SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
						break; // end case 1
					// Protection From Magic
					// Absolue Magic Protection
					case 2:
					case 5:
						// triggers the spell target's protection from magic flag on
						SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
						break; // end case 2, case 5
					// Defense Shield
					// Great Defense Shield
					case 3:
					case 4:
						// triggers the spells target's defense shield flag on
						SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
						break; // end case 3, case 4
				} // end switch (m_pMagicConfigList[sType]->m_sValue4){
				// the target's magic effect is set to the effect4 value of the spell cast on him
				m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
				break; // break; DEF_OWNERTYPE_PLAYER

			case DEF_OWNERTYPE_NPC:
				// if the npc target doesnt exist no magic effect
				if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
				// if the npc target already has a protect magic on, no magic effect occurs
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
				// if the npc's action limit is not 0, no magic effect occurs				
				if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
				// switch cases for the effect4 of the spell
				switch (m_pMagicConfigList[sType]->m_sValue4){
					// Protection From Arrow
					case 1:
						// triggers the spell target's protection from arrow flag on
						SetProtectionFromArrowFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
						break; // end case 1
					// Protection From Magic
					// Absolue Magic Protection
					case 2:
					case 5:
						// triggers the spell target's protection from magic flag on
						SetMagicProtectionFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
						break; // end case 2, case 5
					// Defense Shield
					// Great Defense Shield
					case 3:
					case 4:
						// triggers the spells target's defense shield flag on
						SetDefenseShieldFlag(sOwnerH, DEF_OWNERTYPE_NPC, TRUE);
						break; // end case 3, case 4
				} // end switch (m_pMagicConfigList[sType]->m_sValue4){
				// the npc's magic effect is set to the effect4 value of the spell cast on it
			   	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
				break;
			} // end switch (cOwnerType) {
			// the DEF_MAGICTYPE_PROTECT effect leaves after the magic effects "Last" time (in seconds)
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
				                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			// if the owner is a player send a message
			if (cOwnerType == DEF_OWNERTYPE_PLAYER)
				SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_PROTECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			break; // end case DEF_MAGICTYPE_PROTECT:*/

				case DEF_MAGICTYPE_SCAN:
					ZeroMemory(cScanMessage, sizeof(cScanMessage));
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								wsprintf(cScanMessage, " Player: %s HP:%d MP:%d.", m_pClientList[sOwnerH]->m_cCharName, m_pClientList[sOwnerH]->m_iHP, m_pClientList[sOwnerH]->m_iMP);
								ShowClientMsg(iClientH, cScanMessage);
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								wsprintf(cScanMessage, " NPC: %s HP:%d MP:%d", m_pNpcList[sOwnerH]->m_cNpcName, m_pNpcList[sOwnerH]->m_iHP, m_pNpcList[sOwnerH]->m_iMana);
								ShowClientMsg(iClientH, cScanMessage);
								break;
						}
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
							m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, 10, 10);
					}
					break;

				case DEF_MAGICTYPE_HOLDOBJECT:
					// Ã‚Â¿Ãƒâ‚¬Ã‚ÂºÃƒÂªÃƒÂÃ‚Â§Ãƒâ€ Ã‚Â®Ãƒâ‚¬Ãƒâ€¡ Ã‚Â¿ÃƒÂ²ÃƒÂÃƒÂ·Ãƒâ‚¬Ãƒâ€œÃƒâ‚¬Ã‚Â» Ã‚ÂºÃƒâ‚¬Ã‚Â¼ÃƒÂ¢Ãƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
								if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto MAGIC_NOEFFECT;
								// v1.4334 ÃƒÂÃƒÅ¸Ã‚Â¸Ã‚Â³Ãƒâ‚¬Ã‚Âº Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â¿Ã‚Â¡Ã‚Â°Ãƒâ€ Ãƒâ€ ÃƒÂÃ‚Â·Ã‚Â²Ãƒâ‚¬Ã‚Â» Ã‚Â¸ÃƒÂ¸Ãƒâ€¡ÃƒÂÃ‚Â°Ãƒâ€ Ã‚Â¼ÃƒÂ¶ÃƒÂÃ‚Â¤
								if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;
								// 2002-09-10 #2 Ã‚Â¾ÃƒË†Ãƒâ‚¬ÃƒÂ¼ÃƒÂÃƒÂ¶Ã‚Â´ÃƒÂ«(No-Attack-Area) Ãƒâ€ ÃƒÂÃ‚Â·Ã‚Â² Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ Ã‚Â¾ÃƒË†Ã‚ÂµÃƒâ€¡Ã‚Â°Ãƒâ€ Ãƒâ€¡Ãƒâ€
								if (  cOwnerType == DEF_OWNERTYPE_PLAYER )  {

									if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
									if (m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) goto MAGIC_NOEFFECT;
								}

								// 2002-09-10 #3 Ãƒâ‚¬ÃƒÂ¼Ã‚Â¸ÃƒÂ©Ãƒâ‚¬ÃƒÂ¼Ã‚Â½ÃƒÆ’Ã‚Â¿ÃƒÂ Ã‚Â¹ÃƒÅ’Ã‚ÂµÃƒÂ©Ã‚Â·Ã‚Â£Ã‚ÂµÃƒÂ¥Ã‚Â¿Ã‚Â¡Ã‚Â¼Ã‚Â­Ã‚Â¸Ã‚Â¦ ÃƒÂÃ‚Â¦Ã‚Â¿ÃƒÅ“Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ã‚Â°Ã‚Â°Ãƒâ‚¬Ã‚Âº Ãƒâ€ ÃƒÂ­Ã‚Â¿Ã‚Â¡Ã‚Â°Ãƒâ€Ã‚Â´Ãƒâ€š Ãƒâ€ ÃƒÂÃ‚Â·Ã‚Â² Ã‚Â¾ÃƒË†Ã‚ÂµÃƒÅ 
								if( strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "middleland") != 0 &&
									m_bIsCrusadeMode == FALSE &&
									m_pClientList[iClientH]->m_cSide == m_pClientList[sOwnerH]->m_cSide )
									goto MAGIC_NOEFFECT;

								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto MAGIC_NOEFFECT; // v1.4 Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ Ã‚Â·Ã‚Â¹Ã‚ÂºÃ‚Â§ 6Ãƒâ‚¬ÃƒÅ’Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ½ Ã‚Â¸Ã‚Â®Ãƒâ€Ã‚Â¡Ã‚Â±ÃƒÅ¾ Ãƒâ‚¬ÃƒÅ’Ã‚Â»ÃƒÂ³Ãƒâ‚¬Ãƒâ€¡ Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ Ã‚Â¸ÃƒÂ³Ã‚Â½Ã‚ÂºÃƒâ€¦ÃƒÂÃ‚Â¿Ã‚Â¡Ã‚Â°Ãƒâ€Ã‚Â´Ãƒâ€š Ã‚Â¸Ã‚Â¶Ã‚ÂºÃƒÂ± Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ Ãƒâ€¦ÃƒÂ«Ãƒâ€¡ÃƒÂÃƒÂÃƒÂ¶ Ã‚Â¾ÃƒÅ Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
								if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								break;
						}

						// Ã‚ÂºÃ‚Â¸ÃƒË†Ã‚Â£ ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
						bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
							sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

						// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ã‚Â»ÃƒÂ½Ã‚Â°ÃƒÂ¥Ãƒâ‚¬Ã‚Â½Ãƒâ‚¬Ã‚Â» Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
						if (cOwnerType == DEF_OWNERTYPE_PLAYER)
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
					}
					break;

				case DEF_MAGICTYPE_INVISIBILITY:
					switch (m_pMagicConfigList[sType]->m_sValue4) {
				case 1:
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;
							if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;

							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
							SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
							RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;

							if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) {
								// Ãƒâ‚¬ÃƒÅ’Ã‚ÂµÃ‚Â¿Ãƒâ€¡ÃƒÂÃƒÂÃƒÂ¶ Ã‚Â¾ÃƒÅ Ã‚Â´Ãƒâ€š NPCÃ‚Â´Ãƒâ€š Ãƒâ€¦ÃƒÂµÃ‚Â¸ÃƒÂ­ Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½Ãƒâ‚¬Ã‚Â» Ã‚Â°Ãƒâ€° Ã‚Â¼ÃƒÂ¶ Ã‚Â¾ÃƒÂ¸Ã‚Â´Ãƒâ„¢.
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
								SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
								// Ãƒâ‚¬ÃƒÅ’ NPCÃ‚Â¸Ã‚Â¦ ÃƒÆ’ÃƒÅ¸Ãƒâ‚¬ÃƒÂ»Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´ÃƒÂ¸ Ã‚Â¸ÃƒÂ³Ã‚Â½Ã‚ÂºÃƒâ€¦ÃƒÂÃ‚Â¸Ã‚Â¦ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚Â½ÃƒÆ’Ãƒâ€¦Ã‚Â²Ã‚Â´Ãƒâ„¢.
								RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);	
							}
							break;
							}

							// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							if (cOwnerType == DEF_OWNERTYPE_PLAYER)
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
							break;

						case 2:
							// v1.4334 ÃƒÂÃƒÅ¸Ã‚Â¸Ã‚Â³Ãƒâ‚¬Ã‚Âº Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â¿Ã‚Â¡Ã‚Â°Ãƒâ€ ÃƒÂÃƒÅ¸Ã‚ÂµÃ‚Â¶Ãƒâ‚¬Ã‚Â» Ã‚Â¸ÃƒÂ¸Ãƒâ€¡ÃƒÂÃ‚Â°Ãƒâ€ Ã‚Â¼ÃƒÂ¶ÃƒÂÃ‚Â¤
							if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

							// dX, dY Ã‚Â¹ÃƒÂÃ‚Â°ÃƒÂ¦ 8 ÃƒÂÃƒâ€“Ã‚ÂºÃ‚Â¯Ãƒâ‚¬Ãƒâ€¡ Invisibility Ã‚Â»ÃƒÂ³Ãƒâ€¦Ãƒâ€šÃƒâ‚¬ÃƒÅ½ ObjectÃ‚Â°Ã‚Â¡ Ãƒâ‚¬Ãƒâ€“Ãƒâ‚¬Ã‚Â¸Ã‚Â¸ÃƒÂ© Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦ Ã‚Â½ÃƒÆ’Ãƒâ€¦Ã‚Â²Ã‚Â´Ãƒâ„¢.
							for (ix = dX - 8; ix <= dX + 8; ix++)
								for (iy = dY - 8; iy <= dY + 8; iy++) {
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (sOwnerH != NULL) {
										switch (cOwnerType) {
											case DEF_OWNERTYPE_PLAYER:
												if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
													m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
													SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
													bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
												}
												break;

											case DEF_OWNERTYPE_NPC:
												if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
												if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
													m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
													SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
													bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
												}
												break;
										}
									}
								}
								break;
					}
					break;

				case DEF_MAGICTYPE_CREATE_DYNAMIC:
					// Dynamic ObjectÃ‚Â¸Ã‚Â¦ Ã‚Â»ÃƒÂ½Ã‚Â¼Ã‚ÂºÃƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ ÃƒË†Ã‚Â¿Ã‚Â·Ãƒâ€šÃƒâ‚¬ÃƒÅ’ ÃƒÂÃƒÂ¶Ã‚Â¼Ãƒâ€œÃ‚ÂµÃƒâ€¡Ã‚Â´Ãƒâ€š Ãƒâ€¦Ã‚Â¸Ãƒâ‚¬Ãƒâ€.

					// v2.1 Ã‚Â¸Ã‚Â¶Ãƒâ‚¬Ã‚Â» Ã‚Â³Ã‚Â»Ã‚Â¿Ã‚Â¡Ã‚Â¼Ã‚Â­Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÅ Ã‚ÂµÃƒÂ¥ Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ Ã‚Â±ÃƒÂÃƒÂÃƒÂ¶(Ãƒâ‚¬ÃƒÂ¼Ã‚Â¸ÃƒÂ©Ãƒâ‚¬ÃƒÂ¼Ã‚Â½ÃƒÆ’ ÃƒÂÃ‚Â¦Ã‚Â¿ÃƒÅ“)
					if (m_bIsCrusadeMode == FALSE) {
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "aresden") == 0) return;
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvine") == 0) return;
						// v2.14
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) return;
						if (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0) return;
					}

					switch (m_pMagicConfigList[sType]->m_sValue10) {
				case DEF_DYNAMICOBJECT_PCLOUD_BEGIN: // Ã‚ÂµÃ‚Â¶Ã‚Â±Ã‚Â¸Ã‚Â¸Ã‚Â§

				case DEF_DYNAMICOBJECT_FIRE:   // Fire Ãƒâ‚¬ÃƒÅ’Ã‚Â´Ãƒâ„¢.
				case DEF_DYNAMICOBJECT_SPIKE:  // Spike

		#ifdef DEF_TAIWANLOG 
					short sTemp_X, sTemp_Y ;
					// v2.15 Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½Ãƒâ‚¬Ã‚Â» Ã‚Â»ÃƒÂ§Ã‚Â¿ÃƒÂ«Ãƒâ€¡Ãƒâ€˜ Ãƒâ‚¬Ã‚Â§Ãƒâ€Ã‚Â¡Ã‚Â¸Ã‚Â¦ Ãƒâ€¡Ã‚Â¥Ã‚Â½ÃƒÆ’Ãƒâ€¡ÃƒÂÃ‚Â±ÃƒÂ¢ Ãƒâ‚¬Ã‚Â§Ãƒâ€¡Ãƒâ€˜ Ã‚ÂºÃ‚Â¯Ã‚Â¼ÃƒÂ¶
					sTemp_X = m_pClientList[iClientH]->m_sX ;
					sTemp_Y = m_pClientList[iClientH]->m_sY ;

					m_pClientList[iClientH]->m_sX = dX;
					m_pClientList[iClientH]->m_sY = dY;

					_bItemLog(DEF_ITEMLOG_SPELLFIELD,iClientH,m_pMagicConfigList[sType]->m_cName,NULL) ;

					m_pClientList[iClientH]->m_sX = sTemp_X;
					m_pClientList[iClientH]->m_sY = sTemp_Y;
		#endif

					switch (m_pMagicConfigList[sType]->m_sValue11) {
				case 1: 
					// wall - type
					cDir = m_Misc.cGetNextMoveDir(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY);
					switch (cDir) {
				case 1:	rx = 1; ry = 0;   break;
				case 2: rx = 1; ry = 1;   break;
				case 3: rx = 0; ry = 1;   break;
				case 4: rx = -1; ry = 1;  break;
				case 5: rx = 1; ry = 0;   break;
				case 6: rx = -1; ry = -1; break;
				case 7: rx = 0; ry = -1;  break;
				case 8: rx = 1; ry = -1;  break;
					}

					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
						dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000);	

					bAnalyzeCriminalAction(iClientH, dX, dY);

					for (i = 1; i <= m_pMagicConfigList[sType]->m_sValue12; i++) {
						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
							dX + i*rx, dY + i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
						bAnalyzeCriminalAction(iClientH, dX + i*rx, dY + i*ry);

						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
							dX - i*rx, dY - i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
						bAnalyzeCriminalAction(iClientH, dX - i*rx, dY - i*ry);
					}
					break;

				case 2:
					// Field - Type
					BOOL bFlag = FALSE;
					int cx, cy;
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue12; ix <= dX + m_pMagicConfigList[sType]->m_sValue12; ix++)
						for (iy = dY - m_pMagicConfigList[sType]->m_sValue12; iy <= dY + m_pMagicConfigList[sType]->m_sValue12; iy++) {
							iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
								ix, iy, m_pMagicConfigList[sType]->m_dwLastTime*1000, m_pMagicConfigList[sType]->m_sValue5);	

							// Ã‚Â¸Ã‚Â¸Ã‚Â¾ÃƒÂ  Ã‚Â¸Ã‚Â¶Ãƒâ‚¬Ã‚Â»Ã‚Â¿Ã‚Â¡Ã‚Â¼Ã‚Â­ Ãƒâ€¡ÃƒÅ Ã‚ÂµÃƒÂ¥Ã‚Â¸Ã‚Â¦ Ã‚Â±ÃƒÂ± Ã‚Â°ÃƒÂ·Ã‚Â¿Ã‚Â¡ Ã‚Â¹Ã‚Â«Ã‚Â°ÃƒÂ­Ãƒâ€¡Ãƒâ€˜ Ãƒâ‚¬ÃƒÅ¡Ã‚Â°Ã‚Â¡ Ãƒâ‚¬Ãƒâ€“Ã‚Â¾ÃƒÂºÃ‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂÃƒâ‚¬ÃƒÅ¡Ã‚Â´Ãƒâ€š Ã‚Â°Ã‚Â¡Ã‚ÂµÃƒÂ¥Ãƒâ‚¬Ãƒâ€¡ Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂÃƒâ‚¬Ã‚Â» Ã‚Â¹ÃƒÅ¾Ã‚Â°Ãƒâ€ Ã‚ÂµÃƒË†Ã‚Â´Ãƒâ„¢. 
							if (bAnalyzeCriminalAction(iClientH, ix, iy, TRUE) == TRUE) {
								bFlag = TRUE;
								cx = ix;
								cy = iy;
							}
						}
						// Ãƒâ€¡ÃƒÅ Ã‚ÂµÃƒÂ¥Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â°ÃƒÂ¦Ã‚ÂºÃƒÂ±Ã‚Â¸Ã‚Â¦ 1Ã‚Â¸ÃƒÂ­Ã‚Â¸Ã‚Â¸ Ã‚Â¼Ãƒâ€™ÃƒË†Ã‚Â¯Ãƒâ€¡ÃƒÂÃ‚Â±ÃƒÂ¢ Ãƒâ‚¬Ã‚Â§Ãƒâ€¡Ãƒâ€.
						if (bFlag == TRUE) bAnalyzeCriminalAction(iClientH, cx, cy);
						break;
					}
					//
					break;

				case DEF_DYNAMICOBJECT_ICESTORM:
					// Ice-Storm Dynamic Object 
					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
						dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000,
						m_pClientList[iClientH]->m_cSkillMastery[4]);	
					break;

				default:
					break;
					}
					break;

				case DEF_MAGICTYPE_POSSESSION:
					// Ã‚Â¿ÃƒÂ¸Ã‚Â°Ãƒâ€¦Ã‚Â¸Ã‚Â®Ã‚Â¿Ã‚Â¡ Ã‚Â¶Ã‚Â³Ã‚Â¾ÃƒÂ®ÃƒÂÃ‚Â® Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ã‚Â¹Ã‚Â°Ã‚Â°Ãƒâ€¡Ãƒâ‚¬Ã‚Â» ÃƒÂÃƒÂ½Ã‚Â¾ÃƒÂ®Ã‚Â¿Ãƒâ‚¬Ã‚Â´Ãƒâ€š Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½Ãƒâ‚¬ÃƒÅ’Ã‚Â´Ãƒâ„¢. 
					// v2.12 ÃƒÂÃƒÅ¸Ã‚Â¸Ã‚Â³Ãƒâ‚¬Ã‚Âº Ãƒâ€ ÃƒÂ·ÃƒÂÃ‚Â¦Ã‚Â¼Ãƒâ€¡ Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ Ã‚Â»ÃƒÂ§Ã‚Â¿ÃƒÂ« Ã‚ÂºÃƒâ€™Ã‚Â°Ã‚Â¡ 
					if (m_pClientList[iClientH]->m_cSide == NULL) goto MAGIC_NOEFFECT;

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
					if (sOwnerH != NULL) break; // v1.41 Ãƒâ€ ÃƒÂ·ÃƒÂÃ‚Â¦Ã‚Â¼Ãƒâ€¡ Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½Ãƒâ‚¬Ã‚Âº Ã‚Â»ÃƒÂ§Ã‚Â¶ÃƒÂ·Ãƒâ‚¬ÃƒÅ’ Ã‚Â¼Ã‚Â­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ‚¬Ã‚Â§Ã‚Â¿Ã‚Â¡Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â·Ãƒâ€šÃƒâ‚¬ÃƒÅ’ Ã‚Â¾ÃƒÂ¸Ã‚Â´Ãƒâ„¢. 

					pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(dX, dY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
					if (pItem != NULL) {
						// Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â°Ã‚Â¡ Ã‚Â¾Ãƒâ€ Ãƒâ‚¬ÃƒÅ’Ãƒâ€¦Ãƒâ€ºÃƒâ‚¬Ã‚Â» ÃƒË†Ã‚Â¹Ã‚ÂµÃƒÂ¦Ãƒâ€¡ÃƒÂÃ‚Â¿Ã‚Â´Ã‚Â´Ãƒâ„¢. 
						if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
							// Ã‚Â¾Ãƒâ€ Ãƒâ‚¬ÃƒÅ’Ãƒâ€¦Ãƒâ€ºÃƒâ‚¬Ã‚Â» ÃƒË†Ã‚Â¹Ã‚ÂµÃƒÂ¦Ãƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢.

							// v1.411 Ã‚Â·ÃƒÅ½Ã‚Â±Ãƒâ€” Ã‚Â³Ã‚Â²Ã‚Â±ÃƒÂ¤Ã‚Â´Ãƒâ„¢.
							_bItemLog(DEF_ITEMLOG_GET, iClientH, (int) -1, pItem);

							dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
							*dwp = MSGID_NOTIFY;
							wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
							*wp  = DEF_NOTIFY_ITEMOBTAINED;

							cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

							// 1Ã‚Â°Ã‚Â³ ÃƒË†Ã‚Â¹Ã‚ÂµÃƒÂ¦Ãƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢. <- Ã‚Â¿Ã‚Â©Ã‚Â±ÃƒÂ¢Ã‚Â¼Ã‚Â­ 1Ã‚Â°Ã‚Â³Ã‚Â¶ÃƒÂµ Ãƒâ€Ã‚Â«Ã‚Â¿ÃƒÂ®Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚Â¸Ã‚Â»Ãƒâ€¡ÃƒÂÃ‚Â´Ãƒâ€š Ã‚Â°ÃƒÂÃƒâ‚¬ÃƒÅ’ Ã‚Â¾Ãƒâ€ Ã‚Â´ÃƒÂÃ‚Â´Ãƒâ„¢
							*cp = 1;
							cp++;

							memcpy(cp, pItem->m_cName, 20);
							cp += 20;

							dwp  = (DWORD *)cp;
							*dwp = pItem->m_dwCount;
							cp += 4;

							*cp = pItem->m_cItemType;
							cp++;

							*cp = pItem->m_cEquipPos;
							cp++;

							*cp = (char)0; // Ã‚Â¾ÃƒÂ²Ãƒâ‚¬Ã‚Âº Ã‚Â¾Ãƒâ€ Ãƒâ‚¬ÃƒÅ’Ãƒâ€¦Ãƒâ€ºÃƒâ‚¬ÃƒÅ’Ã‚Â¹Ãƒâ€¡Ã‚Â·ÃƒÅ½ Ãƒâ‚¬ÃƒÂ¥Ãƒâ€šÃƒÂ¸Ã‚ÂµÃƒâ€¡ÃƒÂÃƒÂ¶ Ã‚Â¾ÃƒÅ Ã‚Â¾Ãƒâ€™Ã‚Â´Ãƒâ„¢.
							cp++;

							sp  = (short *)cp;
							*sp = pItem->m_sLevelLimit;
							cp += 2;

							*cp = pItem->m_cGenderLimit;
							cp++;

							wp = (WORD *)cp;
							*wp = pItem->m_wCurLifeSpan;
							cp += 2;

							wp = (WORD *)cp;
							*wp = pItem->m_wWeight;
							cp += 2;

							sp  = (short *)cp;
							*sp = pItem->m_sSprite;
							cp += 2;

							sp  = (short *)cp;
							*sp = pItem->m_sSpriteFrame;
							cp += 2;

							*cp = pItem->m_cItemColor;
							cp++;

							*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
							cp++;

							dwp = (DWORD *)cp;
							*dwp = pItem->m_dwAttribute;
							cp += 4;
							/*
							*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃƒâ‚¬ÃƒÅ½ÃƒÂÃƒÂ¶Ãƒâ‚¬Ãƒâ€¡ Ã‚Â¿Ã‚Â©Ã‚ÂºÃƒÅ½ 
							cp++;
							*/

							if (iEraseReq == 1) delete pItem;

							// Ã‚Â¾Ãƒâ€ Ãƒâ‚¬ÃƒÅ’Ãƒâ€¦Ãƒâ€ºÃƒâ‚¬Ã‚Â» ÃƒÂÃƒÂÃ‚Â°ÃƒÂ­Ã‚Â³Ã‚Â­ ÃƒË†Ãƒâ€ Ã‚Â³Ã‚Â²Ãƒâ‚¬Ã‚Âº Ã‚Â¾Ãƒâ€ Ãƒâ‚¬ÃƒÅ’Ãƒâ€¦Ãƒâ€ºÃƒâ‚¬Ã‚Â» Ã‚Â´Ãƒâ„¢Ã‚Â¸Ã‚Â¥ Ãƒâ€¦Ã‚Â¬Ã‚Â¶ÃƒÂ³Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ°Ãƒâ€ Ã‚Â®Ã‚Â¿Ã‚Â¡Ã‚Â°Ãƒâ€ Ã‚Â¾Ãƒâ€¹Ã‚Â¸Ã‚Â°Ã‚Â´Ãƒâ„¢. 
							SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
								dX, dY,	sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor); // v1.4

							// Ã‚Â¾Ãƒâ€ Ãƒâ‚¬ÃƒÅ’Ãƒâ€¦Ãƒâ€º ÃƒÂÃ‚Â¤Ã‚ÂºÃ‚Â¸ Ãƒâ‚¬ÃƒÂ¼Ã‚Â¼Ãƒâ€º 
							iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);

							switch (iRet) {
								case DEF_XSOCKEVENT_QUENEFULL:
								case DEF_XSOCKEVENT_SOCKETERROR:
								case DEF_XSOCKEVENT_CRITICALERROR:
								case DEF_XSOCKEVENT_SOCKETCLOSED:
									// Ã‚Â¸ÃƒÅ¾Ã‚Â½ÃƒÆ’ÃƒÂÃƒÂ¶Ã‚Â¸Ã‚Â¦ Ã‚ÂºÃ‚Â¸Ã‚Â³Ã‚Â¾Ã‚Â¶Ã‚Â§ Ã‚Â¿Ã‚Â¡Ã‚Â·Ã‚Â¯Ã‚Â°Ã‚Â¡ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© ÃƒÂÃ‚Â¦Ã‚Â°Ãƒâ€¦Ãƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
									DeleteClient(iClientH, TRUE, TRUE);
									return;
							}
						}
						else 
						{
							// Ã‚Â°ÃƒÂ¸Ã‚Â°Ã‚Â£Ãƒâ‚¬ÃƒÅ’ Ã‚ÂºÃƒÅ½ÃƒÂÃ‚Â·Ãƒâ€¡ÃƒÂÃ‚Â°Ãƒâ€¦Ã‚Â³Ã‚Âª Ãƒâ€¡Ãƒâ€˜Ã‚Â°ÃƒÂ¨ÃƒÂÃƒÅ¸Ã‚Â·Ã‚Â®Ãƒâ‚¬Ã‚Â» ÃƒÆ’ÃƒÅ Ã‚Â°ÃƒÂºÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢. Ã‚Â¾Ãƒâ€ Ãƒâ‚¬ÃƒÅ’Ãƒâ€¦Ãƒâ€ºÃƒâ‚¬Ã‚Â» Ã‚Â¾ÃƒÂ²Ãƒâ‚¬Ã‚Â» Ã‚Â¼ÃƒÂ¶ Ã‚Â¾ÃƒÂ¸Ã‚Â´Ãƒâ„¢.

							// Ã‚Â°Ã‚Â¡ÃƒÂÃ‚Â®Ã‚Â¿Ãƒâ€Ã‚Â´ÃƒÂ¸ Ã‚Â¾Ãƒâ€ Ãƒâ‚¬ÃƒÅ’Ãƒâ€¦Ãƒâ€ºÃƒâ‚¬Ã‚Â» Ã‚Â¿ÃƒÂ¸Ã‚Â»ÃƒÂ³ÃƒË†Ã‚Â¸Ã‚ÂºÃ‚Â¹Ã‚Â½ÃƒÆ’Ãƒâ€¦Ã‚Â²Ã‚Â´Ãƒâ„¢. 
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

							dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
							*dwp = MSGID_NOTIFY;
							wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
							*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;

							iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
							switch (iRet) {
								case DEF_XSOCKEVENT_QUENEFULL:
								case DEF_XSOCKEVENT_SOCKETERROR:
								case DEF_XSOCKEVENT_CRITICALERROR:
								case DEF_XSOCKEVENT_SOCKETCLOSED:
									// Ã‚Â¸ÃƒÅ¾Ã‚Â½ÃƒÆ’ÃƒÂÃƒÂ¶Ã‚Â¸Ã‚Â¦ Ã‚ÂºÃ‚Â¸Ã‚Â³Ã‚Â¾Ã‚Â¶Ã‚Â§ Ã‚Â¿Ã‚Â¡Ã‚Â·Ã‚Â¯Ã‚Â°Ã‚Â¡ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© ÃƒÂÃ‚Â¦Ã‚Â°Ãƒâ€¦Ãƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
									DeleteClient(iClientH, TRUE, TRUE);
									return;
							}
						}
					}
					//
					break;

				case DEF_MAGICTYPE_CONFUSE:
					// if the caster side is the same as the targets side, no effect occurs
						switch (m_pMagicConfigList[sType]->m_sValue4) {
						case 1: // confuse LanguageÃƒÂ¬Ã‚ÂÃ‚Â´ÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤. 
						case 2: // Confusion, Mass Confusion 	
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
								for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
									// ÃƒÂ¬Ã…Â¾Ã‚ÂÃƒÂ¬Ã¢â‚¬Â¹Ã‚Â ÃƒÂ«Ã‚ÂÃ¢â‚¬Å¾ ÃƒÂ­Ã¢â‚¬ÂÃ‚Â¼ÃƒÂ­Ã‚ÂÃ‚Â­ÃƒÂ«Ã‚ÂÃ‚Â  ÃƒÂ¬Ã‹â€ Ã‹Å“ ÃƒÂ¬Ã…Â¾Ã‹â€ ÃƒÂ¬Ã…â€œÃ‚Â¼ÃƒÂ«Ã¢â‚¬Â¹Ã‹â€  ÃƒÂ¬Ã‚Â£Ã‚Â¼ÃƒÂ¬Ã‚ÂÃ‹Å“.
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										// ÃƒÂ­Ã¢â‚¬Â¢Ã‚Â´ÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¹ ÃƒÂ¬Ã…â€œÃ¢â‚¬Å¾ÃƒÂ¬Ã‚Â¹Ã‹Å“ÃƒÂ¬Ã¢â‚¬â€Ã‚Â ÃƒÂ¬Ã‚ÂºÃ‚ÂÃƒÂ«Ã‚Â¦Ã‚Â­ÃƒÂ­Ã¢â‚¬Å¾Ã‚Â°ÃƒÂªÃ‚Â°Ã¢â€šÂ¬ ÃƒÂ¬Ã…Â¾Ã‹â€ ÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤.
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											// ÃƒÂ¬Ã†â€™Ã‚ÂÃƒÂ«Ã…â€™Ã¢â€šÂ¬ÃƒÂ«Ã‚Â°Ã‚Â©ÃƒÂ¬Ã‚ÂÃ‚Â´ ÃƒÂ«Ã‚Â§Ã‹â€ ÃƒÂ«Ã‚Â²Ã¢â‚¬Â¢ ÃƒÂ¬Ã‚Â Ã¢â€šÂ¬ÃƒÂ­Ã¢â‚¬Â¢Ã‚Â­ÃƒÂ¬Ã¢â‚¬â€Ã‚Â ÃƒÂ¬Ã¢â‚¬Â¹Ã‚Â¤ÃƒÂ­Ã…â€™Ã‚Â¨ÃƒÂ­Ã¢â‚¬â€œÃ‹â€ ÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤.
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //ÃƒÂ¬Ã‚ÂÃ‚Â´ÃƒÂ«Ã‚Â¯Ã‚Â¸ ÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤ÃƒÂ«Ã‚Â¥Ã‚Â¸ ConfuseÃƒÂ­Ã…Â¡Ã‚Â¨ÃƒÂªÃ‚Â³Ã‚Â¼ÃƒÂªÃ‚Â°Ã¢â€šÂ¬ ÃƒÂ¬Ã…Â¾Ã‹â€ ÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤ÃƒÂ«Ã‚Â©Ã‚Â´ ÃƒÂ«Ã‚Â¬Ã‚Â´ÃƒÂ¬Ã¢â‚¬Â¹Ã…â€œÃƒÂ«Ã‚ÂÃ…â€œÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤.
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;

											// ÃƒÂ­Ã…Â¡Ã‚Â¨ÃƒÂªÃ‚Â³Ã‚Â¼ÃƒÂªÃ‚Â°Ã¢â€šÂ¬ ÃƒÂ­Ã¢â‚¬Â¢Ã‚Â´ÃƒÂ¬Ã‚Â Ã…â€œÃƒÂ«Ã‚ÂÃ‚Â  ÃƒÂ«Ã¢â‚¬Â¢Ã…â€™ ÃƒÂ«Ã‚Â°Ã…â€œÃƒÂ¬Ã†â€™Ã‚ÂÃƒÂ­Ã¢â‚¬Â¢Ã‚Â  ÃƒÂ«Ã¢â‚¬ÂÃ…â€œÃƒÂ«Ã‚Â Ã‹â€ ÃƒÂ¬Ã‚ÂÃ‚Â´ ÃƒÂ¬Ã‚ÂÃ‚Â´ÃƒÂ«Ã‚Â²Ã‚Â¤ÃƒÂ­Ã…Â Ã‚Â¸ÃƒÂ«Ã‚Â¥Ã‚Â¼ ÃƒÂ«Ã¢â‚¬Å“Ã‚Â±ÃƒÂ«Ã‚Â¡Ã‚ÂÃƒÂ­Ã¢â‚¬Â¢Ã…â€œÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

											// ÃƒÂ«Ã‚Â§Ã‹â€ ÃƒÂ«Ã‚Â²Ã¢â‚¬Â¢ÃƒÂ¬Ã¢â‚¬â€Ã‚Â ÃƒÂªÃ‚Â±Ã‚Â¸ÃƒÂ«Ã‚Â Ã‚Â¸ÃƒÂ¬Ã‚ÂÃ…â€™ÃƒÂ¬Ã‚ÂÃ¢â‚¬Å¾ ÃƒÂ¬Ã¢â‚¬Â¢Ã…â€™ÃƒÂ«Ã‚Â¦Ã‚Â°ÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤.
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
										}
									}
								}	
								break;

						case 3: // Ilusion, Mass-Ilusion
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
								for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
									// ÃƒÂ¬Ã…Â¾Ã‚ÂÃƒÂ¬Ã¢â‚¬Â¹Ã‚Â ÃƒÂ«Ã‚ÂÃ¢â‚¬Å¾ ÃƒÂ­Ã¢â‚¬ÂÃ‚Â¼ÃƒÂ­Ã‚ÂÃ‚Â­ÃƒÂ«Ã‚ÂÃ‚Â  ÃƒÂ¬Ã‹â€ Ã‹Å“ ÃƒÂ¬Ã…Â¾Ã‹â€ ÃƒÂ¬Ã…â€œÃ‚Â¼ÃƒÂ«Ã¢â‚¬Â¹Ã‹â€  ÃƒÂ¬Ã‚Â£Ã‚Â¼ÃƒÂ¬Ã‚ÂÃ‹Å“.
									m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
									if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										// ÃƒÂ­Ã¢â‚¬Â¢Ã‚Â´ÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¹ ÃƒÂ¬Ã…â€œÃ¢â‚¬Å¾ÃƒÂ¬Ã‚Â¹Ã‹Å“ÃƒÂ¬Ã¢â‚¬â€Ã‚Â ÃƒÂ¬Ã‚ÂºÃ‚ÂÃƒÂ«Ã‚Â¦Ã‚Â­ÃƒÂ­Ã¢â‚¬Å¾Ã‚Â°ÃƒÂªÃ‚Â°Ã¢â€šÂ¬ ÃƒÂ¬Ã…Â¾Ã‹â€ ÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤.
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											// ÃƒÂ¬Ã†â€™Ã‚ÂÃƒÂ«Ã…â€™Ã¢â€šÂ¬ÃƒÂ«Ã‚Â°Ã‚Â©ÃƒÂ¬Ã‚ÂÃ‚Â´ ÃƒÂ«Ã‚Â§Ã‹â€ ÃƒÂ«Ã‚Â²Ã¢â‚¬Â¢ ÃƒÂ¬Ã‚Â Ã¢â€šÂ¬ÃƒÂ­Ã¢â‚¬Â¢Ã‚Â­ÃƒÂ¬Ã¢â‚¬â€Ã‚Â ÃƒÂ¬Ã¢â‚¬Â¹Ã‚Â¤ÃƒÂ­Ã…â€™Ã‚Â¨ÃƒÂ­Ã¢â‚¬â€œÃ‹â€ ÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤.
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //ÃƒÂ¬Ã‚ÂÃ‚Â´ÃƒÂ«Ã‚Â¯Ã‚Â¸ ÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤ÃƒÂ«Ã‚Â¥Ã‚Â¸ ConfuseÃƒÂ­Ã…Â¡Ã‚Â¨ÃƒÂªÃ‚Â³Ã‚Â¼ÃƒÂªÃ‚Â°Ã¢â€šÂ¬ ÃƒÂ¬Ã…Â¾Ã‹â€ ÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤ÃƒÂ«Ã‚Â©Ã‚Â´ ÃƒÂ«Ã‚Â¬Ã‚Â´ÃƒÂ¬Ã¢â‚¬Â¹Ã…â€œÃƒÂ«Ã‚ÂÃ…â€œÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤.
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;

											switch (m_pMagicConfigList[sType]->m_sValue4) {
												case 3:
													SetIllusionFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
													break;
											}

											// ÃƒÂ­Ã…Â¡Ã‚Â¨ÃƒÂªÃ‚Â³Ã‚Â¼ÃƒÂªÃ‚Â°Ã¢â€šÂ¬ ÃƒÂ­Ã¢â‚¬Â¢Ã‚Â´ÃƒÂ¬Ã‚Â Ã…â€œÃƒÂ«Ã‚ÂÃ‚Â  ÃƒÂ«Ã¢â‚¬Â¢Ã…â€™ ÃƒÂ«Ã‚Â°Ã…â€œÃƒÂ¬Ã†â€™Ã‚ÂÃƒÂ­Ã¢â‚¬Â¢Ã‚Â  ÃƒÂ«Ã¢â‚¬ÂÃ…â€œÃƒÂ«Ã‚Â Ã‹â€ ÃƒÂ¬Ã‚ÂÃ‚Â´ ÃƒÂ¬Ã‚ÂÃ‚Â´ÃƒÂ«Ã‚Â²Ã‚Â¤ÃƒÂ­Ã…Â Ã‚Â¸ÃƒÂ«Ã‚Â¥Ã‚Â¼ ÃƒÂ«Ã¢â‚¬Å“Ã‚Â±ÃƒÂ«Ã‚Â¡Ã‚ÂÃƒÂ­Ã¢â‚¬Â¢Ã…â€œÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤.
											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

											// ÃƒÂ«Ã‚Â§Ã‹â€ ÃƒÂ«Ã‚Â²Ã¢â‚¬Â¢ÃƒÂ¬Ã¢â‚¬â€Ã‚Â ÃƒÂªÃ‚Â±Ã‚Â¸ÃƒÂ«Ã‚Â Ã‚Â¸ÃƒÂ¬Ã‚ÂÃ…â€™ÃƒÂ¬Ã‚ÂÃ¢â‚¬Å¾ ÃƒÂ¬Ã¢â‚¬Â¢Ã…â€™ÃƒÂ«Ã‚Â¦Ã‚Â°ÃƒÂ«Ã¢â‚¬Â¹Ã‚Â¤.
											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
										}
									}
								}	
								break;

						case 4: // Ilusion Movement
							if (m_pClientList[iClientH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] != 0) break;
							for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
							for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
								if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break;
											m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;
											switch (m_pMagicConfigList[sType]->m_sValue4) {
												case 4:
													SetIllusionMovementFlag(sOwnerH, DEF_OWNERTYPE_PLAYER, TRUE);
													break;
											}

											bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
												sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

											SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
										}
									}
								}	
					}
					break;


				case DEF_MAGICTYPE_POISON:
					// ÃƒÂÃƒÅ¸Ã‚ÂµÃ‚Â¶ Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½. Ã‚Â¸Ãƒâ€¢Ãƒâ‚¬ÃƒÂº Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ãƒâ‚¬Ã‚Â» Ã‚Â±Ã‚Â¼Ã‚Â¸Ã‚Â®Ã‚Â°ÃƒÂ­ Ã‚Â´Ãƒâ„¢Ãƒâ‚¬Ã‚Â½Ãƒâ‚¬Ã‚Â¸Ã‚Â·ÃƒÅ½ Ã‚ÂµÃ‚Â¶Ã‚Â¼Ã‚ÂºÃƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ãƒâ‚¬Ã‚Â» Ãƒâ€¡Ãƒâ€˜Ã‚Â¹ÃƒÂ¸ Ã‚Â´ÃƒÂµ Ã‚Â±Ã‚Â¼Ã‚Â¸Ã‚Â°Ã‚Â´Ãƒâ„¢. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

					if (m_pMagicConfigList[sType]->m_sValue4 == 1) {
						// ÃƒÂÃƒÅ¸Ã‚ÂµÃ‚Â¶Ãƒâ‚¬Ã‚Â» Ã‚Â°Ãƒâ€¦Ã‚Â´Ãƒâ€š Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ 
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								// v1.4334 ÃƒÂÃƒÅ¸Ã‚Â¸Ã‚Â³Ãƒâ‚¬Ã‚Âº Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â¿Ã‚Â¡Ã‚Â°Ãƒâ€ ÃƒÂÃƒÅ¸Ã‚ÂµÃ‚Â¶Ãƒâ‚¬Ã‚Â» Ã‚Â¸ÃƒÂ¸Ãƒâ€¡ÃƒÂÃ‚Â°Ãƒâ€ Ã‚Â¼ÃƒÂ¶ÃƒÂÃ‚Â¤
								if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;

								// Ã‚Â¹ÃƒÂ¼ÃƒÂÃƒâ€¹Ãƒâ€¡ÃƒÂ Ãƒâ‚¬Ã‚Â§Ã‚Â¶ÃƒÂ³Ã‚Â¸ÃƒÂ© 
								bAnalyzeCriminalAction(iClientH, dX, dY);

								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									// Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢. Ã‚ÂµÃ‚Â¶Ã‚Â¼Ã‚ÂºÃƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ãƒâ‚¬Ã‚Â» Ã‚Â°ÃƒÂ¨Ã‚Â»ÃƒÂªÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
									if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
										// ÃƒÂÃƒÅ¸Ã‚ÂµÃ‚Â¶Ã‚ÂµÃƒâ€¡Ã‚Â¾ÃƒÂºÃ‚Â´Ãƒâ„¢.
										m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
										m_pClientList[sOwnerH]->m_iPoisonLevel = m_pMagicConfigList[sType]->m_sValue5;
										m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
										// 05/06/2004 - Hypnotoad - poison aura appears when cast Poison
										SetPoisonFlag(sOwnerH, cOwnerType, TRUE);
										// ÃƒÂÃƒÅ¸Ã‚ÂµÃ‚Â¶Ã‚ÂµÃƒâ€¡Ã‚Â¾ÃƒÂºÃƒâ‚¬Ã‚Â½Ãƒâ‚¬Ã‚Â» Ã‚Â¾Ãƒâ€¹Ã‚Â¸Ã‚Â°Ã‚Â´Ãƒâ„¢. 
										SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pMagicConfigList[sType]->m_sValue5, NULL, NULL);
					#ifdef DEF_TAIWANLOG
										_bItemLog(DEF_ITEMLOG_POISONED,sOwnerH,(char *) NULL,NULL) ;
					#endif
									}
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								if (m_pNpcList[sOwnerH]->m_iHP > 0) goto MAGIC_NOEFFECT;
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
									// Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢. Ã‚ÂµÃ‚Â¶Ã‚Â¼Ã‚ÂºÃƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ãƒâ‚¬Ã‚Â» Ã‚Â°ÃƒÂ¨Ã‚Â»ÃƒÂªÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
									if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
										// ÃƒÂÃƒÅ¸Ã‚ÂµÃ‚Â¶Ã‚ÂµÃƒâ€¡Ã‚Â¾ÃƒÂºÃ‚Â´Ãƒâ„¢.

									}
								}
								break;
						}
					}
					else if (m_pMagicConfigList[sType]->m_sValue4 == 0) {
						// ÃƒÂÃƒÅ¸Ã‚ÂµÃ‚Â¶Ãƒâ‚¬Ã‚Â» Ãƒâ€¡Ã‚ÂªÃ‚Â´Ãƒâ€š Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ 
						switch (cOwnerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;

								if (m_pClientList[sOwnerH]->m_bIsPoisoned == TRUE) {
									// ÃƒÂÃƒÅ¸Ã‚ÂµÃ‚Â¶Ã‚ÂµÃƒË† Ã‚Â»ÃƒÂ³Ãƒâ€¦Ãƒâ€šÃ‚Â¿Ã‚Â´Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© ÃƒÂÃƒÅ¸Ã‚ÂµÃ‚Â¶Ãƒâ‚¬Ã‚Â» Ãƒâ€¡Ã‚Â¬Ã‚Â´Ãƒâ„¢.
									m_pClientList[sOwnerH]->m_bIsPoisoned = FALSE;
									// 05/06/2004 - Hypnotoad - poison aura removed when cure cast
									SetPoisonFlag(sOwnerH, cOwnerType, FALSE);
									// ÃƒÂÃƒÅ¸Ã‚ÂµÃ‚Â¶Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡Ã‚Â®Ã‚Â·ÃƒË†Ãƒâ‚¬Ã‚Â½Ãƒâ‚¬Ã‚Â» Ã‚Â¾Ãƒâ€¹Ã‚Â¸Ã‚Â°Ã‚Â´Ãƒâ„¢. 
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
								break;
						}
					}
					break;

				case DEF_MAGICTYPE_BERSERK:
					switch (m_pMagicConfigList[sType]->m_sValue4) {
						case 1:
							// Ã‚Â¹ÃƒÂ¶Ã‚Â¼Ã‚Â­Ãƒâ€Ã‚Â¿ Ã‚Â¸ÃƒÂ°Ã‚ÂµÃƒÂ¥Ã‚Â·ÃƒÅ½ Ãƒâ‚¬ÃƒÂ¼ÃƒË†Ã‚Â¯Ã‚ÂµÃƒË†Ã‚Â´Ãƒâ„¢.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

							switch (cOwnerType) {
								case DEF_OWNERTYPE_PLAYER:
									if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue4;
									SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
									break;

								case DEF_OWNERTYPE_NPC:
									if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
									if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
									// ÃƒÂÃ‚Â¤Ãƒâ‚¬ÃƒÂ» NPCÃ‚ÂµÃƒÂ©Ãƒâ‚¬Ã‚Âº Ã‚Â±Ã‚Â¤Ã‚ÂºÃƒÂ Ã‚Â¾ÃƒË†Ã‚ÂµÃƒÅ 				
									if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
									// 2002-09-11 #3 Ãƒâ‚¬ÃƒÂ» Ã‚Â¸ÃƒÂ³Ã‚Â½Ã‚ÂºÃƒâ€¦ÃƒÂÃ‚Â´Ãƒâ€š Ã‚Â±Ã‚Â¤Ã‚ÂºÃƒÂÃ‚ÂµÃƒâ€¡ÃƒÂÃƒÂ¶ Ã‚Â¾ÃƒÅ Ãƒâ‚¬Ã‚Â½
									if ( m_pClientList[iClientH]->m_cSide != m_pNpcList[sOwnerH]->m_cSide ) goto MAGIC_NOEFFECT;

									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue4;
									SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
									break;
							}

							// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
								sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							if (cOwnerType == DEF_OWNERTYPE_PLAYER)
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
							break;
					}
					break;

					// v2.16 2002-5-23 Ã‚Â°ÃƒÂ­Ã‚Â±Ã‚Â¤Ãƒâ€¡ÃƒÂ¶ Ã‚Â¼ÃƒÂ¶ÃƒÂÃ‚Â¤
				case DEF_MAGICTYPE_DAMAGE_AREA_ARMOR_BREAK:
					// ÃƒÂÃƒâ€“Ã‚ÂºÃ‚Â¯ Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂ ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº 
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// Ãƒâ‚¬ÃƒÅ¡Ã‚Â½Ãƒâ€¦Ã‚ÂµÃ‚Âµ Ãƒâ€¡Ãƒâ€¡Ãƒâ€ ÃƒÂ¸Ã‚ÂµÃƒâ€° Ã‚Â¼ÃƒÂ¶ Ãƒâ‚¬Ãƒâ€“Ãƒâ‚¬Ã‚Â¸Ã‚Â´ÃƒÂ ÃƒÂÃƒâ€“Ãƒâ‚¬Ãƒâ€¡.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								// Ã‚Â¹ÃƒÂ¦Ã‚Â¾ÃƒÂ®Ã‚Â±Ã‚Â¸Ãƒâ‚¬Ãƒâ€¡ Ã‚Â¼ÃƒÂ¶Ã‚Â¸ÃƒÂ­Ãƒâ‚¬Ã‚Â» ÃƒÂÃƒâ„¢Ãƒâ‚¬ÃƒÅ½Ã‚Â´Ãƒâ„¢.
								ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
										Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										// Ã‚Â¹ÃƒÂ¦Ã‚Â¾ÃƒÂ®Ã‚Â±Ã‚Â¸Ãƒâ‚¬Ãƒâ€¡ Ã‚Â¼ÃƒÂ¶Ã‚Â¸ÃƒÂ­Ãƒâ‚¬Ã‚Â» ÃƒÂÃƒâ„¢Ãƒâ‚¬ÃƒÅ½Ã‚Â´Ãƒâ„¢.
										ArmorLifeDecrement(iClientH,sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue10);
									}
								}
						}
						break;

/*						// Resurrection Magic. 
				case DEF_MAGICTYPE_RESURRECTION: 
					// 10 Mins once
					if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) goto MAGIC_NOEFFECT;
					m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC/2;
					// Get the ID of the dead Player/NPC on coords dX, dY. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY); 
					switch (cOwnerType) { 
								// For Player. 
						case DEF_OWNERTYPE_PLAYER: 
							// The Player has to exist. 
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT; 
							// Resurrection is not for alive Players. 
							if (m_pClientList[sOwnerH]->m_bIsKilled == FALSE) goto MAGIC_NOEFFECT; 
							// Set Deadflag to Alive. 
							m_pClientList[sOwnerH]->m_bIsKilled = FALSE; 
							// Player's HP becomes half of the Max HP. 
							m_pClientList[sOwnerH]->m_iHP = ((m_pClientList[sOwnerH]->m_iLevel * 2) + (m_pClientList[sOwnerH]->m_iVit * 3) + (m_pClientList[sOwnerH]->m_iStr / 2)) / 2; 
							// Send new HP to Player. 
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL); 
							// Make Player stand up. (Currently, by a fake damage). 
							m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->ClearDeadOwner(dX, dY); 
							m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->SetOwner(sOwnerH, DEF_OWNERTYPE_PLAYER, dX, dY); 
							SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, NULL, NULL, NULL); 
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL); 
							break; 
							// Resurrection is not for NPC's. 
						case DEF_OWNERTYPE_NPC: 
							goto MAGIC_NOEFFECT; 
							break; 
					} 
					break;*/

				case DEF_MAGICTYPE_ICE:
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
								// Ã‚Â´ÃƒÂ«Ã‚Â¹ÃƒÅ’ÃƒÂÃƒÂ¶Ã‚Â¿ÃƒÂ Ãƒâ€¡Ãƒâ€Ã‚Â²Ã‚Â²
								//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
								Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
								// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº
								switch (cOwnerType) {
									case DEF_OWNERTYPE_PLAYER:
										if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										// Ãƒâ€¦Ã‚Â¸Ã‚Â°Ãƒâ„¢Ãƒâ‚¬ÃƒÅ’ Ã‚Â»ÃƒÂ¬Ã‚Â¾Ãƒâ€ Ãƒâ‚¬Ãƒâ€“Ã‚Â°ÃƒÂ­ Ã‚Â¾ÃƒÂ³Ãƒâ‚¬Ã‚Â½ Ãƒâ‚¬ÃƒÂºÃƒâ€¡Ãƒâ€”Ã‚Â¿Ã‚Â¡ Ã‚Â½Ãƒâ€¡Ãƒâ€ ÃƒÂÃƒâ€¡ÃƒÅ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚ÂºÃƒâ„¢Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢.
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
												// Ã‚Â´ÃƒÂ«Ã‚Â»ÃƒÂ³Ãƒâ‚¬ÃƒÅ’ Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ãƒâ‚¬ÃƒÅ½ Ã‚Â°ÃƒÂ¦Ã‚Â¿ÃƒÂ¬ Ã‚Â¾Ãƒâ€¹Ã‚Â·ÃƒÂÃƒÂÃƒËœÃ‚Â´Ãƒâ„¢.
												SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
											}
										}
										break;

									case DEF_OWNERTYPE_NPC:
										if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
										if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
											}
										}
										break;
								}

							}

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃƒÂÃƒâ€”Ãƒâ‚¬Ã‚Âº ÃƒÆ’Ã‚Â´Ãƒâ€¡ÃƒÂÃ‚Â°ÃƒÂ­ Ãƒâ‚¬Ãƒâ€“Ã‚Â´Ãƒâ€š Ãƒâ€¡ÃƒÆ’Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ®Ã‚Â´Ãƒâ„¢.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

										//Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
										// Ã‚Â¾ÃƒÂ³Ã‚Â¾ÃƒÂ®Ã‚Â¼Ã‚Â­ Ã‚ÂµÃ‚Â¿Ãƒâ‚¬Ãƒâ€ºÃƒâ‚¬ÃƒÅ’ Ã‚Â´ÃƒÅ Ã‚Â¾ÃƒÂ®ÃƒÂÃƒÂ¶Ã‚Â´Ãƒâ€š ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂº. ÃƒÂÃƒâ€”ÃƒÂÃƒÂ¶ Ã‚Â¾ÃƒÅ Ã‚Â¾Ãƒâ€™Ãƒâ‚¬Ã‚Â¸Ã‚Â¸ÃƒÂ© Ãƒâ‚¬ÃƒÂ»Ã‚Â¿ÃƒÂ« 
										if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
											if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
												m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
												SetIceFlag(sOwnerH, cOwnerType, TRUE);
												// ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â°Ã‚Â¡ Ãƒâ€¡ÃƒËœÃƒÂÃ‚Â¦Ã‚ÂµÃƒâ€° Ã‚Â¶Ã‚Â§ Ã‚Â¹ÃƒÅ¸Ã‚Â»ÃƒÂ½Ãƒâ€¡Ãƒâ€™ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’ Ãƒâ‚¬ÃƒÅ’Ã‚ÂºÃ‚Â¥Ãƒâ€ Ã‚Â®Ã‚Â¸Ã‚Â¦ Ã‚ÂµÃƒÂ®Ã‚Â·ÃƒÂÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
												bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
													sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

												SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
											}
										}
									}
								}
						}
						break;

				default:
					break;
			}
		}
		else {
			// Casting ÃƒË†Ãƒâ€ Ã‚ÂµÃƒÂ´Ã‚Â·Ã‚Â¹Ãƒâ‚¬ÃƒÅ’Ã‚Â°Ã‚Â¡ Ã‚Â°Ãƒâ€°Ã‚Â¸Ã‚Â®Ã‚Â´Ãƒâ€š Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½
			// Resurrection wand(MS.10) or Resurrection wand(MS.20)

				if (m_pMagicConfigList[sType]->m_sType == DEF_MAGICTYPE_RESURRECTION) {
					//Check if player has resurrection wand
					if (m_pClientList[iClientH] != NULL && m_pClientList[iClientH]->m_iSpecialAbilityTime == 0 &&
						m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == FALSE) {
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
							if(m_pClientList[sOwnerH] != NULL){
							// GM's can ressurect ne1, and players must be on same side to ressurect
							/*if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]]->m_sIDnum != 865) || 
								(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]]->m_sIDnum != 866)) {
								wsprintf(G_cTxt, "(!!!) Hack: Player(%s) cast resurrect without wand!", m_pClientList[iClientH]->m_cCharName);
								PutLogList(G_cTxt);
								DeleteClient(iClientH, TRUE, TRUE, TRUE, TRUE);
								return;
							}*/


							if ((m_pClientList[iClientH]->m_iAdminUserLevel < 1) &&
								(m_pClientList[sOwnerH]->m_cSide != m_pClientList[iClientH]->m_cSide)) {
								return;
							}
							if (cOwnerType == DEF_OWNERTYPE_PLAYER && m_pClientList[sOwnerH] != NULL &&
								m_pClientList[sOwnerH]->m_iHP <= 0){
								m_pClientList[sOwnerH]->m_bIsBeingResurrected = TRUE;
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_RESURRECTPLAYER, NULL, NULL, NULL, NULL);
									if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
										m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = TRUE;
										m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;
										m_pClientList[iClientH]->m_iSpecialAbilityLastSec = 0;
										m_pClientList[iClientH]->m_iSpecialAbilityTime = m_pMagicConfigList[sType]->m_dwDelayTime;

										sTemp = m_pClientList[iClientH]->m_sAppr4;
										sTemp = 0xFF0F & sTemp;
										sTemp = sTemp | 0x40;
										m_pClientList[iClientH]->m_sAppr4 = sTemp;
									}
								SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, NULL);
								SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
							}
						}
					}
				}
			}

MAGIC_NOEFFECT:;

		if (m_pClientList[iClientH] == NULL) return;
		
		//Mana Slate
		if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0) {
			iManaCost = 0;
		}

		// ManaÃ‚Â¸Ã‚Â¦ Ã‚Â°Ã‚Â¨Ã‚Â¼Ãƒâ€™Ã‚Â½ÃƒÆ’Ãƒâ€¦Ã‚Â°Ã‚Â°ÃƒÂ­ Ãƒâ€¦ÃƒÂ«Ã‚ÂºÃ‚Â¸Ãƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢.
		m_pClientList[iClientH]->m_iMP -= iManaCost; // sValue1Ãƒâ‚¬ÃƒÅ’ Mana Cost
		if (m_pClientList[iClientH]->m_iMP < 0) 
			m_pClientList[iClientH]->m_iMP = 0;

		CalculateSSN_SkillIndex(iClientH, 4, 1 );

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);

		// Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½ ÃƒË†Ã‚Â¿Ã‚Â°ÃƒÂºÃ‚Â¸Ã‚Â¦ Ã‚Â´Ãƒâ„¢Ã‚Â¸Ã‚Â¥ Ãƒâ€¦Ã‚Â¬Ã‚Â¶ÃƒÂ³Ãƒâ‚¬ÃƒÅ’Ã‚Â¾ÃƒÂ°Ãƒâ€ Ã‚Â®Ã‚Â¿Ã‚Â¡Ã‚Â°Ãƒâ€ Ãƒâ‚¬ÃƒÂ¼Ã‚Â¼Ãƒâ€ºÃƒâ€¡Ãƒâ€˜Ã‚Â´Ãƒâ„¢. Ã‚Â¸Ã‚Â¶Ã‚Â¹ÃƒÂ½Ã‚Â¹ÃƒÂ¸ÃƒË†Ã‚Â£ + 100Ãƒâ‚¬ÃƒÅ’ Ã‚Â¿Ã‚Â¡Ãƒâ€ ÃƒÂ¥Ãƒâ€ Ã‚Â® Ã‚Â¹ÃƒÂ¸ÃƒË†Ã‚Â£ 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, (sType+100), m_pClientList[iClientH]->m_sType);

}


void CGame::NpcMagicHandler(int iNpcH, short dX, short dY, short sType)
{
 short  sOwnerH;
 char   cOwnerType;
 register int i, iErr, ix, iy, sX, sY, tX, tY, iResult, iWhetherBonus, iMagicAttr;
 DWORD  dwTime = timeGetTime();

	if (m_pNpcList[iNpcH] == NULL) return;
	if ((dX < 0) || (dX >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX) ||
        (dY < 0) || (dY >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY)) return;
									   
	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;
	
	// °ø°İÀ§Ä¡°¡ °ø°İ ºÒ°¡´É ¸ÊÀÌ¶ó¸é °ø°İ ºÒ°¡´É 
	if (m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
	
	// ¸ó½ºÅÍ º° ¸¶¹ı ¸íÁß·ü ÀÔ·Â 
	iResult = m_pNpcList[iNpcH]->m_iMagicHitRatio;
	
	// ³¯¾¾¿¡ ÀÇÇÑ ¸¶¹ı °ø°İ·Â Á¶Á¤  
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cWhetherStatus);

	// v1.41 ¸¶¹ı ¼Ó¼º 
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
		// Áï½Ã È¿°ú¸¦ º¸´Â ¸¶¹ı 
		switch (m_pMagicConfigList[sType]->m_sType) {
		case DEF_MAGICTYPE_INVISIBILITY:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// º¸ÀÌÁö ¾Ê´Â »óÅÂ·Î ¸¸µç´Ù. 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					// ÀÌ Ä³¸¯ÅÍ¸¦ ÃßÀûÇÏ°í ÀÖ´ø ¸ó½ºÅÍ¸¦ ÇØÁ¦½ÃÅ²´Ù.
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					// ÀÌ NPC¸¦ ÃßÀûÇÏ°í ÀÖ´ø ¸ó½ºÅÍ¸¦ ÇØÁ¦½ÃÅ²´Ù.
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC);
					break;
				}
			
				// È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ıÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;

			case 2:
				// dX, dY ¹İ°æ 8 ÁÖº¯ÀÇ Invisibility »óÅÂÀÎ Object°¡ ÀÖÀ¸¸é ÇØÁ¦ ½ÃÅ²´Ù.
				for (ix = dX - 8; ix <= dX + 8; ix++)
				for (iy = dY - 8; iy <= dY + 8; iy++) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								if (m_pClientList[sOwnerH]->m_sType != 66) {
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
									SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
								}
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								if (m_pClientList[sOwnerH]->m_sType != 66) {
									m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
									SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
									bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
								}
							}
							break;
						}
					}
				}
				break;
			}
			break;

		case DEF_MAGICTYPE_HOLDOBJECT:
			// ¿ÀºêÁ§Æ®ÀÇ ¿òÁ÷ÀÓÀ» ºÀ¼âÇÑ´Ù. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto NMH_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
					
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto NMH_NOEFFECT; // v1.4 ¸¶¹ı ·¹º§ 6ÀÌ»óÀÎ ¸®Ä¡±Ş ÀÌ»óÀÇ ¸¶¹ı ¸ó½ºÅÍ¿¡°Ô´Â ¸¶ºñ ¸¶¹ı ÅëÇÏÁö ¾Ê´Â´Ù.
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
				}
				
				// ºÀ¼â È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ıÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				
				// È¿°ú°¡ »ı°åÀ½À» ¾Ë·ÁÁØ´Ù.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			}
			break;
		
		
		case DEF_MAGICTYPE_DAMAGE_LINEAR:
			// ÀÏÁ÷¼± »ó¿¡ ÀÖ´Â ¸ñÇ¥¸¦ ¸ğµÎ °ø°İÇÑ´Ù.
			sX = m_pNpcList[iNpcH]->m_sX;
			sY = m_pNpcList[iNpcH]->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
			
				// tx, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx-1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx+1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty-1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty+1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// ÁÖº¯ °ø°İ È¿°ú 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// ÀÚ½Åµµ ÇÇÆøµÉ ¼ö ÀÖÀ¸´Ï ÁÖÀÇ.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}

			// dX, dY
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			}
			break;
		
		case DEF_MAGICTYPE_DAMAGE_SPOT:
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_HPUP_SPOT:
			// ÀÌ ¸¶¹ıÀº ¸íÁß·ü°ú´Â »ó°üÀÌ ¾ø´Ù.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA:
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}
			
			// ÁÖº¯ °ø°İ È¿°ú 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// ÀÚ½Åµµ ÇÇÆøµÉ ¼ö ÀÖÀ¸´Ï ÁÖÀÇ.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			   	}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
			// Á÷°İÀº °è»êÇÏÁö ¾Ê´Â´Ù.			
			// ÁÖº¯ °ø°İ È¿°ú 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// ÀÚ½Åµµ ÇÇÆøµÉ ¼ö ÀÖÀ¸´Ï ÁÖÀÇ.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			   	}
			}
			break;

		case DEF_MAGICTYPE_SPDOWN_AREA:
			// Sp°¡ ÁÙ¾îµç´Ù.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// ÁÖº¯ °ø°İ È¿°ú 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// ÀÚ½Åµµ ÇÇÆøµÉ ¼ö ÀÖÀ¸´Ï ÁÖÀÇ.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_SPUP_AREA:
			// Sp°¡ »ó½ÂÇÑ´Ù.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// ¸¶¹ı ÀúÇ×ÀÌ ÇÊ¿ä¾ø´Ù. 
			Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// ÁÖº¯ °ø°İ È¿°ú 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// ÀÚ½Åµµ ÇÇÆøµÉ ¼ö ÀÖÀ¸´Ï ÁÖÀÇ.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				// ¸¶¹ıÀúÇ×ÀÌ ÇÊ¿ä ¾ø´Ù.
				Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		}
	}
	else {
		// Casting ÈÄ µô·¹ÀÌ°¡ °É¸®´Â ¸¶¹ı

	}

NMH_NOEFFECT:;

	// Mana¸¦ °¨¼Ò½ÃÅ²´Ù.
	m_pNpcList[iNpcH]->m_iMana -= m_pMagicConfigList[sType]->m_sValue1; // sValue1ÀÌ Mana Cost
	if (m_pNpcList[iNpcH]->m_iMana < 0) 
		m_pNpcList[iNpcH]->m_iMana = 0;

	// ¸¶¹ı È¿°ú¸¦ ´Ù¸¥ Å¬¶óÀÌ¾ğÆ®¿¡°Ô Àü¼ÛÇÑ´Ù. ¸¶¹ı¹øÈ£ + 100ÀÌ ¿¡ÆåÆ® ¹øÈ£ 
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pNpcList[iNpcH]->m_cMapIndex,
					            m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, dX, dY, (sType+100), m_pNpcList[iNpcH]->m_sType);

}

void CGame::RequestTeleportHandler(int iClientH, char * pData, char * cMapName, int dX, int dY)
{
	char  * pBuffer, cTempMapName[21];
	DWORD * dwp;
	WORD  * wp;
	char  * cp, cDestMapName[11], cDir, cMapIndex, cQuestRemain;
	short * sp, sX, sY, sSummonPoints;
	int   * ip, i, iRet, iSize, iDestX, iDestY, iExH, iMapSide;
	BOOL    bRet, bIsLockedMapNotify;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsRecallImpossible == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0) &&
		(m_pClientList[iClientH]->m_bIsKilled == FALSE) && (m_bIsApocalypseMode == TRUE)  && (m_pClientList[iClientH]->m_iHP > 0)) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NORECALL, NULL, NULL, NULL, NULL);
		return;
	}
	// v2.16 2002-6-2 »ó´ë¹æ ¸¶À»¿¡¼­´Â ¸®ÄİÀÌ µÇÁö ¾Ê´Â´Ù.
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0)
		&& (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0)
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0)
		&& ((pData[0] == '1')  || (pData[0] == '3'))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
		&& (m_bIsCrusadeMode == FALSE)) return;

	// v2.16 2002-6-2 »ó´ë¹æ ¸¶À»¿¡¼­´Â ¸®ÄİÀÌ µÇÁö ¾Ê´Â´Ù.
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) 
		&& (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 0)
		&& (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0)
		&& ((pData[0] == '1')  || (pData[0] == '3'))
		&& (m_pClientList[iClientH]->m_iAdminUserLevel == 0)
		&& (m_bIsCrusadeMode == FALSE)) return;

	bIsLockedMapNotify = FALSE;

	// Ã«Â§Å’Ã¬â€¢Â½ ÃªÂµÂÃ­â„¢Ëœ Ã«ÂªÂ¨Ã«â€œÅ“Ã«ÂÂ¼Ã«Â©Â´ ÃªÂµÂÃ­â„¢ËœÃ¬Ââ€ Ã¬Â·Â¨Ã¬â€ Å’Ã­â€¢Å“Ã«â€¹Â¤.
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	// Ã¬Â¤â€˜Ã«Â¦Â½Ã¬ÂÂ´ Ã«Â¦Â¬Ã¬Â½Å“ Ã«Â§Ë†Ã«Â²â€¢Ã¬Ââ€ Ã¬â€šÂ¬Ã¬Å¡Â©Ã­â€¢ËœÃ«Â©Â´ Ã­Ë†Â¬Ã«Âªâ€¦Ã­â€¢ËœÃªÂ²Å’ Ã«ÂËœÃ«Å â€ Ã«Â²â€ÃªÂ·Â¸ Ã¬Ë†ËœÃ¬Â â€¢ 
	// Ã¬Â¤â€˜Ã«Â¦Â½Ã¬ÂÂ´Ã«Â©Â´ Ã«Â¦Â¬Ã¬Â½Å“ Ã«Â§Ë†Ã«Â²â€¢Ã¬Ââ€ Ã¬â€šÂ¬Ã¬Å¡Â©Ã­â€¢ËœÃ¬Â§â‚¬ Ã«ÂªÂ»Ã­â€¢ËœÃªÂ²Å’ Ã«ÂÅ“Ã«â€¹Â¤. 
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && (pData[0] == '1'))
		return;

	// Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬ÂÂ´ Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´Ã«Â¥Â¼ Ã«ÂªÂ©Ã­â€˜Å“Ã«Â¡Å“ Ã¬â€šÂ¼ÃªÂ³Â  Ã¬Å¾Ë†Ã«Å â€ Ã«ÂªÂ¹Ã«â€œÂ¤Ã¬ÂËœ ÃªÂ³ÂµÃªÂ²Â©Ã­â€“â€°Ã«Ââ„¢Ã¬Ââ€ Ã«Â©Ë†Ã¬Â¶â€ÃªÂ²Å’ Ã­â€¢Å“Ã«â€¹Â¤. 
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);

	// Ã­Ëœâ€Ã¬Å¾Â¬ Ã«Â§Âµ Ã¬Å“â€Ã¬Â¹ËœÃ¬â€”ÂÃ¬â€Å“ Ã¬Â§â‚¬Ã¬Å¡Â´Ã«â€¹Â¤.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER, 
		m_pClientList[iClientH]->m_sX, 
		m_pClientList[iClientH]->m_sY);

	// Ã«â€¹Â¤Ã«Â¥Â¸ Ã­ÂÂ´Ã«ÂÂ¼Ã¬ÂÂ´Ã¬â€“Â¸Ã­Å Â¸Ã«â€œÂ¤Ã¬â€”ÂÃªÂ²Å’ Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´ÃªÂ°â‚¬ Ã­Ëœâ€ Ã¬Å“â€Ã¬Â¹ËœÃ¬â€”ÂÃ¬â€Å“ Ã¬â€šÂ¬Ã«ÂÂ¼Ã¬Â§ÂÃ¬Ââ€ Ã¬â€¢Å’Ã«Â¦Â°Ã«â€¹Â¤. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

	// Ã­Ëœâ€Ã¬Å¾Â¬ Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ÃªÂ°â‚¬ Ã«Â§Ë†Ã«Â²â€¢Ã¬â€”Â Ã¬ÂËœÃ­â€¢Å“ ÃªÂ²Æ’Ã¬ÂÂ¸Ã¬Â§â‚¬, Ã¬â€¢â€Ã«â€¹Ë†Ã«Â©Â´ Ã¬ÂÂ¼Ã«Â°ËœÃ¬Â ÂÃ¬ÂÂ¸ Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã­Æ’â‚¬Ã¬ÂÂ¼Ã¬â€”Â Ã¬ÂËœÃ­â€¢Å“ ÃªÂ²Æ’Ã¬ÂÂ¸Ã¬Â§â‚¬Ã«Â¥Â¼ Ã¬Â²Â´Ã­ÂÂ¬Ã­â€¢Å“Ã«â€¹Â¤. 
	// Ã«Â§Å’Ã¬â€¢Â½ Ã¬ÂÂ¼Ã«Â°ËœÃ¬Â ÂÃ¬ÂÂ¸ Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã­Æ’â‚¬Ã¬ÂÂ¼Ã¬â€”Â Ã¬ÂËœÃ­â€¢Å“ ÃªÂ²Æ’Ã¬ÂÂ´Ã«ÂÂ¼Ã«Â©Â´ Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸Ã­â€¢Â  Ã¬Å“â€Ã¬Â¹ËœÃ¬ÂËœ Ã«Â§ÂµÃ¬ÂÂ´Ã«Â¦â€, Ã¬Â¢Å’Ã­â€˜Å“Ã«Â¥Â¼ ÃªÂµÂ¬Ã­â€¢Â´Ã¬â„¢â‚¬Ã¬â€Å“ 
	// ÃªÂ·Â¸ Ã«Â§ÂµÃ¬ÂÂ´ Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬â€Å“Ã«Â²â€Ã¬â€”Â Ã¬Â¡Â´Ã¬Å¾Â¬Ã­â€¢ËœÃ«Å â€Ã¬Â§â‚¬Ã«Â¥Â¼ ÃªÂ²â‚¬Ã¬Æ’â€°Ã­â€¢Å“Ã«â€¹Â¤. Ã«Â§Å’Ã¬â€¢Â½ Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬â€Å“Ã«Â²â€Ã¬â€”Â Ã¬Â¡Â´Ã¬Å¾Â¬Ã­â€¢ËœÃ¬Â§â‚¬ Ã¬â€¢Å Ã«Å â€Ã«â€¹Â¤Ã«Â©Â´ Ã­ÂÂ´Ã«ÂÂ¼Ã¬ÂÂ´Ã¬â€“Â¸Ã­Å Â¸Ã¬â€”ÂÃªÂ²Å’ 
	// Ã«â€¹Â¤Ã«Â¥Â¸ Ã¬â€Å“Ã«Â²â€Ã«Â¡Å“Ã¬ÂËœ Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã¬â€¹Å“Ã«Ââ€Ã­â€¢ËœÃ«ÂÂ¼Ã«Å â€ Ã«Â©â€Ã¬â€¹Å“Ã¬Â§â‚¬Ã«Â¥Â¼ Ã«Â³Â´Ã«â€šÂ¸Ã«â€¹Â¤. 

	// Ã«Â¨Â¼Ã¬Â â‚¬ Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´ÃªÂ°â‚¬ Ã¬â€Å“Ã¬Å¾Ë†Ã«Å â€ Ã¬Å“â€Ã¬Â¹ËœÃªÂ°â‚¬ Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã­Æ’â‚¬Ã¬ÂÂ¼Ã¬ÂÂ¸Ã¬Â§â‚¬ Ã¬â€¢Å’Ã¬â€¢â€Ã«â€šÂ¸Ã«â€¹Â¤. 
	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	ZeroMemory(cDestMapName, sizeof(cDestMapName));
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSearchTeleportDest(sX, sY, cDestMapName, &iDestX, &iDestY, &cDir);

	// Crusade
	if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
		// Ã­Å Â¹Ã¬Â â€¢ Ã«Â§ÂµÃ¬â€”Â ÃªÂ°â€“Ã­Å¾Å’ Ã¬Æ’ÂÃ­Æ’Å“Ã¬ÂÂ´Ã«â€¹Â¤. Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã­Æ’â‚¬Ã¬ÂÂ¼Ã¬ÂËœ Ã¬Å“â€Ã¬Â¹ËœÃ«Â¥Â¼ ÃªÂ°â€“Ã­Å¾Å’ Ã«Â§ÂµÃ¬Å“Â¼Ã«Â¡Å“ Ã«Â³â‚¬Ã­Ëœâ€¢Ã­â€¢Å“Ã«â€¹Â¤.
		// Ã«Â§Å’Ã¬â€¢Â½ ÃªÂ°Ë† Ã«Â§ÂµÃ¬ÂÂ´ ÃªÂ±Â´Ã«Â¬Â¼ Ã«â€šÂ´Ã«Â¶â‚¬Ã«ÂÂ¼Ã«Â©Â´  
		iMapSide = iGetMapLocationSide(cDestMapName);
		if (iMapSide > 3) iMapSide -= 2; // New 18/05/2004
		if ((iMapSide != 0) && (m_pClientList[iClientH]->m_cSide == iMapSide)) {
		// Ã«â€œÂ¤Ã¬â€“Â´ÃªÂ°â‚¬ÃªÂ³Â Ã¬Å¾Â Ã­â€¢ËœÃ«Å â€ Ã«Â§ÂµÃ¬ÂÂ´ ÃªÂ°â„¢Ã¬Ââ‚¬ Ã­Å½Â¸Ã¬ÂËœ ÃªÂ±Â´Ã«Â¬Â¼ Ã«â€šÂ´Ã«Â¶â‚¬Ã«ÂÂ¼Ã«Â©Â´ Ã«â€œÂ¤Ã¬â€“Â´ÃªÂ°Ë† Ã¬Ë†Ëœ Ã¬Å¾Ë†Ã«â€¹Â¤.
		}
		else {
			iDestX = -1;
			iDestY = -1;
			bIsLockedMapNotify = TRUE;
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, m_pClientList[iClientH]->m_cLockedMapName);
		}
	}

	if ((bRet == TRUE) && (cMapName == NULL)) {
		// Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´ÃªÂ°â‚¬ Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã­Æ’â‚¬Ã¬ÂÂ¼ Ã¬Å“â€Ã¬â€”Â Ã¬â€Å“ Ã¬Å¾Ë†Ã«â€¹Â¤. Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã­â€¢Â  Ã«Â§ÂµÃ¬ÂÂ´ Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬â€Å“Ã«Â²â€Ã¬â€”Â Ã¬Â¡Â´Ã¬Å¾Â¬Ã­â€¢ËœÃ«Å â€Ã¬Â§â‚¬ ÃªÂ²â‚¬Ã¬Æ’â€°Ã­â€¢Å“Ã«â€¹Â¤. Ã«Â¬Â¼Ã«Â¡Â  Ã«ÂªÂ©Ã¬Â ÂÃ¬Â§â‚¬ÃªÂ°â‚¬ Ã¬Â§â‚¬Ã¬Â â€¢Ã«ÂËœÃ¬Â§â‚¬ Ã¬â€¢Å Ã¬Ââ‚¬ Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸Ã¬â€”Â¬Ã¬â€¢Â¼Ã­â€¢Å“Ã«â€¹Â¤.
		for (i = 0; i < DEF_MAXMAPS; i++)
			if (m_pMapList[i] != NULL) {
				if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) {
					// Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬â€Å“Ã«Â²â€Ã¬â€”Â Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸Ã­â€¢Â  Ã«Â§ÂµÃ¬ÂÂ´ Ã¬Â¡Â´Ã¬Å¾Â¬Ã­â€¢Å“Ã«â€¹Â¤.
					m_pClientList[iClientH]->m_sX   = iDestX;	  // Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã¬Â¢Å’Ã­â€˜Å“Ã«Â¥Â¼ Ã¬Å¾â€¦Ã«Â Â¥Ã­â€¢Å“Ã«â€¹Â¤.
					m_pClientList[iClientH]->m_sY   = iDestY;
					m_pClientList[iClientH]->m_cDir = cDir;
					m_pClientList[iClientH]->m_cMapIndex = i; // Ã«Â§Âµ Ã¬ÂÂ¸Ã«ÂÂ±Ã¬Å Â¤Ã«Â¥Â¼ Ã«Â°â€ÃªÂ¾Â¼Ã«â€¹Â¤.
					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // Ã«Â§Âµ Ã¬ÂÂ´Ã«Â¦â€Ã¬Ââ€ Ã«Â°â€ÃªÂ¾Â¼Ã«â€¹Â¤.
					goto RTH_NEXTSTEP;
				}
			}

			// Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬â€Å“Ã«Â²â€Ã¬â€”Â Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã­â€¢Â  Ã«Â§ÂµÃ¬ÂÂ´ Ã¬â€”â€ Ã«â€¹Â¤. Ã­ÂÂ´Ã«ÂÂ¼Ã¬ÂÂ´Ã¬â€“Â¸Ã­Å Â¸Ã«Å â€ Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã¬Â¢â€¦Ã«Â£Å’Ã­â€¢ËœÃªÂ³Â  Ã«â€¹Â¤Ã«Â¥Â¸ Ã¬â€Å“Ã«Â²â€Ã«Â¡Å“ Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã¬â€¹Å“Ã«Ââ€Ã­â€¢Â´Ã¬â€¢Â¼ Ã­â€¢Å“Ã«â€¹Â¤.
			m_pClientList[iClientH]->m_sX   = iDestX;	  // Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã¬Â¢Å’Ã­â€˜Å“Ã«Â¥Â¼ Ã¬Å¾â€¦Ã«Â Â¥Ã­â€¢Å“Ã«â€¹Â¤.
			m_pClientList[iClientH]->m_sY   = iDestY;
			m_pClientList[iClientH]->m_cDir = cDir;
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10);  // Ã«Â§Âµ Ã¬ÂÂ´Ã«Â¦â€Ã¬Ââ€ Ã«Â°â€ÃªÂ¾Â¼Ã«â€¹Â¤.

			// New 18/05/2004
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
				m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
			SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);

			// Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´Ã¬ÂËœ Ã«ÂÂ°Ã¬ÂÂ´Ã­â€Â°Ã«Â¥Â¼ Ã¬Â â‚¬Ã¬Å¾Â¥Ã­â€¢ËœÃªÂ³Â  Ã¬Â â‚¬Ã¬Å¾Â¥Ã­â€“Ë†Ã«â€¹Â¤Ã«Å â€ Ã¬Ââ€˜Ã«â€¹ÂµÃ¬ÂÂ´ Ã¬ËœÂ¤Ã«Â©Â´ Ã­ÂÂ´Ã«ÂÂ¼Ã¬ÂÂ´Ã¬â€“Â¸Ã­Å Â¸Ã¬â€”ÂÃªÂ²Å’ Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã«â€¹Â¤Ã¬â€¹Å“ Ã­â€¢Â ÃªÂ²Æ’Ã¬Ââ€ Ã¬â€¢Å’Ã«Â Â¤Ã¬Â¤â‚¬Ã«â€¹Â¤.
			bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE);  // ! Ã¬Â¹Â´Ã¬Å¡Â´Ã­Å’â€¦ Ã­â€¢ËœÃ¬Â§â‚¬ Ã¬â€¢Å Ã«Å â€Ã«â€¹Â¤.
			// !!!!
			m_pClientList[iClientH]->m_bIsOnServerChange = TRUE;
			m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
			return;
	}
	else {
		// Ã«Â§Ë†Ã«Â²â€¢Ã¬â€”Â Ã¬ÂËœÃ­â€¢Å“ Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸Ã¬ÂÂ´Ã«â€¹Â¤. 
		switch (pData[0]) {
		case '0':
			// Forced Recall. 
			// Ã«Â Ë†Ã«Â²Â¨ Ã¬Â Å“Ã­â€¢Å“Ã¬ÂÂ´ Ã¬Å¾Ë†Ã«Å â€ Ã«Â§ÂµÃ¬â€”Â Ã«â€œÂ¤Ã¬â€“Â´ÃªÂ°â€Ã¬Ââ€Ã«â€¢Å’ Ã¬ÂÂ¼Ã¬â€“Â´Ã«â€šÅ“Ã«â€¹Â¤. 
			ZeroMemory(cTempMapName, sizeof(cTempMapName));
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
				strcpy(cTempMapName, "default");
			}
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0) {
				strcpy(cTempMapName, "arefarm");
			}
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0) {
				strcpy(cTempMapName, "elvfarm");
			}
			else strcpy(cTempMapName, m_pClientList[iClientH]->m_cLocation);

			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// Ã­Å Â¹Ã¬Â â€¢ Ã«Â§ÂµÃ¬â€”Â ÃªÂ°â€“Ã­Å¾Å’ Ã¬Æ’ÂÃ­Æ’Å“Ã¬ÂÂ´Ã«â€¹Â¤. Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã­Æ’â‚¬Ã¬ÂÂ¼Ã¬ÂËœ Ã¬Å“â€Ã¬Â¹ËœÃ«Â¥Â¼ ÃªÂ°â€“Ã­Å¾Å’ Ã«Â§ÂµÃ¬Å“Â¼Ã«Â¡Å“ Ã«Â³â‚¬Ã­Ëœâ€¢Ã­â€¢Å“Ã«â€¹Â¤.
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}

			for (i = 0; i < DEF_MAXMAPS; i++)
				if (m_pMapList[i] != NULL) {
					if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
						// Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬â€Å“Ã«Â²â€Ã¬â€”Â Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸Ã­â€¢Â  Ã«Â§ÂµÃ¬ÂÂ´ Ã¬Â¡Â´Ã¬Å¾Â¬Ã­â€¢Å“Ã«â€¹Â¤.
						GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);

						m_pClientList[iClientH]->m_cMapIndex = i; // Ã«Â§Âµ Ã¬ÂÂ¸Ã«ÂÂ±Ã¬Å Â¤Ã«Â¥Â¼ Ã«Â°â€ÃªÂ¾Â¼Ã«â€¹Â¤.
						ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
						memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // Ã«Â§Âµ Ã¬ÂÂ´Ã«Â¦â€Ã¬Ââ€ Ã«Â°â€ÃªÂ¾Â¼Ã«â€¹Â¤.
						goto RTH_NEXTSTEP;
					}
				}

				// Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬â€Å“Ã«Â²â€Ã¬â€”Â Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã­â€¢Â  Ã«Â§ÂµÃ¬ÂÂ´ Ã¬â€”â€ Ã«â€¹Â¤. Ã­ÂÂ´Ã«ÂÂ¼Ã¬ÂÂ´Ã¬â€“Â¸Ã­Å Â¸Ã«Å â€ Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã¬Â¢â€¦Ã«Â£Å’Ã­â€¢ËœÃªÂ³Â  Ã«â€¹Â¤Ã«Â¥Â¸ Ã¬â€Å“Ã«Â²â€Ã«Â¡Å“ Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã¬â€¹Å“Ã«Ââ€Ã­â€¢Â´Ã¬â€¢Â¼ Ã­â€¢Å“Ã«â€¹Â¤.
				m_pClientList[iClientH]->m_sX   = -1;	  // Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã¬Â¢Å’Ã­â€˜Å“Ã«Â¥Â¼ Ã¬Å¾â€¦Ã«Â Â¥Ã­â€¢Å“Ã«â€¹Â¤.
				m_pClientList[iClientH]->m_sY   = -1;	  // -1Ã¬Ââ‚¬ InitialPointÃ«Â¥Â¼ Ã«Â§ÂÃ­â€¢Å“Ã«â€¹Â¤.

				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // Ã«Â§Âµ Ã¬ÂÂ´Ã«Â¦â€Ã¬Ââ€ Ã«Â°â€ÃªÂ¾Â¼Ã«â€¹Â¤.

				// New 18/05/2004
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
					m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);

				// Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´Ã¬ÂËœ Ã«ÂÂ°Ã¬ÂÂ´Ã­â€Â°Ã«Â¥Â¼ Ã¬Â â‚¬Ã¬Å¾Â¥Ã­â€¢ËœÃªÂ³Â  Ã¬Ââ€˜Ã«â€¹ÂµÃ¬Ââ€ Ã«Â°â€ºÃ¬Ââ‚¬ Ã­â€ºâ€ Ã¬Å¾Â¬Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã¬â€¢Å’Ã«Â Â¤Ã¬â€¢Â¼ Ã­â€¢Å“Ã«â€¹Â¤.
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! Ã¬Â¹Â´Ã¬Å¡Â´Ã­Å’â€¦ Ã­â€¢ËœÃ¬Â§â‚¬ Ã¬â€¢Å Ã«Å â€Ã«â€¹Â¤.

				m_pClientList[iClientH]->m_bIsOnServerChange = TRUE;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
				return;

		case '1':
			// Recall.Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´ÃªÂ°â‚¬ Ã¬â€ Å’Ã¬â€ ÂÃ«ÂÅ“ Ã«Â§Ë†Ã¬Ââ€Ã¬ÂËœ Ã¬Â§â€Ã¬Å¾â€¦ Ã­ÂÂ¬Ã¬ÂÂ¸Ã­Å Â¸Ã«Â¡Å“ ÃªÂ°â€Ã«â€¹Â¤.
			// Ã«Â§Å’Ã¬â€¢Â½ Ã«Â¶â‚¬Ã­â„¢Å“Ã¬Â¡Â´Ã¬ÂÂ´Ã«ÂÂ¼Ã«Â©Â´ Ã«Â¦Â¬Ã¬Â½Å“Ã«ÂËœÃ¬Â§â‚¬ Ã¬â€¢Å Ã«Å â€Ã«â€¹Â¤.
			// if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, "resurr", 6) == 0) return;

			ZeroMemory(cTempMapName, sizeof(cTempMapName));
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
				strcpy(cTempMapName, "default");
			}
			else {				
				// v2.14 Â·Â¹ÂºÂ§ 80 Ã€ÃŒÃ‡ÃÂ´Ã‚ Â¸Â®Ã„ÃÂ½Ãƒ Â³Ã³Â°Ã¦ÃÃ¶Â·Ã Â°Â£Â´Ã™.
				if (m_pClientList[iClientH]->m_iLevel > 80)
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) 
						strcpy(cTempMapName, "aresden");
					else strcpy(cTempMapName, "elvine");
				else {
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) 
						strcpy(cTempMapName, "arefarm");
					else strcpy(cTempMapName, "elvfarm");
				}
			}
			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// Ã­Å Â¹Ã¬Â â€¢ Ã«Â§ÂµÃ¬â€”Â ÃªÂ°â€“Ã­Å¾Å’ Ã¬Æ’ÂÃ­Æ’Å“Ã¬ÂÂ´Ã«â€¹Â¤. Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã­Æ’â‚¬Ã¬ÂÂ¼Ã¬ÂËœ Ã¬Å“â€Ã¬Â¹ËœÃ«Â¥Â¼ ÃªÂ°â€“Ã­Å¾Å’ Ã«Â§ÂµÃ¬Å“Â¼Ã«Â¡Å“ Ã«Â³â‚¬Ã­Ëœâ€¢Ã­â€¢Å“Ã«â€¹Â¤.
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}

			for (i = 0; i < DEF_MAXMAPS; i++)
				if (m_pMapList[i] != NULL) {
					if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
						// Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬â€Å“Ã«Â²â€Ã¬â€”Â Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸Ã­â€¢Â  Ã«Â§ÂµÃ¬ÂÂ´ Ã¬Â¡Â´Ã¬Å¾Â¬Ã­â€¢Å“Ã«â€¹Â¤.

						GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);

						m_pClientList[iClientH]->m_cMapIndex = i; // Ã«Â§Âµ Ã¬ÂÂ¸Ã«ÂÂ±Ã¬Å Â¤Ã«Â¥Â¼ Ã«Â°â€ÃªÂ¾Â¼Ã«â€¹Â¤.
						ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
						memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // Ã«Â§Âµ Ã¬ÂÂ´Ã«Â¦â€Ã¬Ââ€ Ã«Â°â€ÃªÂ¾Â¼Ã«â€¹Â¤.
						goto RTH_NEXTSTEP;
					}
				}

				// Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬â€Å“Ã«Â²â€Ã¬â€”Â Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã­â€¢Â  Ã«Â§ÂµÃ¬ÂÂ´ Ã¬â€”â€ Ã«â€¹Â¤. Ã­ÂÂ´Ã«ÂÂ¼Ã¬ÂÂ´Ã¬â€“Â¸Ã­Å Â¸Ã«Å â€ Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã¬Â¢â€¦Ã«Â£Å’Ã­â€¢ËœÃªÂ³Â  Ã«â€¹Â¤Ã«Â¥Â¸ Ã¬â€Å“Ã«Â²â€Ã«Â¡Å“ Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã¬â€¹Å“Ã«Ââ€Ã­â€¢Â´Ã¬â€¢Â¼ Ã­â€¢Å“Ã«â€¹Â¤.
				m_pClientList[iClientH]->m_sX   = -1;	  // Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã¬Â¢Å’Ã­â€˜Å“Ã«Â¥Â¼ Ã¬Å¾â€¦Ã«Â Â¥Ã­â€¢Å“Ã«â€¹Â¤.
				m_pClientList[iClientH]->m_sY   = -1;	  // -1Ã¬Ââ‚¬ InitialPointÃ«Â¥Â¼ Ã«Â§ÂÃ­â€¢Å“Ã«â€¹Â¤.

				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // Ã«Â§Âµ Ã¬ÂÂ´Ã«Â¦â€Ã¬Ââ€ Ã«Â°â€ÃªÂ¾Â¼Ã«â€¹Â¤.

				// New 18/05/2004
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
					m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);

				// Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´Ã¬ÂËœ Ã«ÂÂ°Ã¬ÂÂ´Ã­â€Â°Ã«Â¥Â¼ Ã¬Â â‚¬Ã¬Å¾Â¥Ã­â€¢ËœÃªÂ³Â  Ã¬Ââ€˜Ã«â€¹ÂµÃ¬Ââ€ Ã«Â°â€ºÃ¬Ââ‚¬ Ã­â€ºâ€ Ã¬Å¾Â¬Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã¬â€¢Å’Ã«Â Â¤Ã¬â€¢Â¼ Ã­â€¢Å“Ã«â€¹Â¤.
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! Ã¬Â¹Â´Ã¬Å¡Â´Ã­Å’â€¦ Ã­â€¢ËœÃ¬Â§â‚¬ Ã¬â€¢Å Ã«Å â€Ã«â€¹Â¤.
				// !!!
				m_pClientList[iClientH]->m_bIsOnServerChange   = TRUE;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
				return;

		case '2':
			// Ã«ÂªÂ©Ã¬Â ÂÃ¬Â§â‚¬ÃªÂ°â‚¬ Ã¬Â§â‚¬Ã¬Â â€¢Ã«ÂÅ“ Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸.

			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// Ã­Å Â¹Ã¬Â â€¢ Ã«Â§ÂµÃ¬â€”Â ÃªÂ°â€“Ã­Å¾Å’ Ã¬Æ’ÂÃ­Æ’Å“Ã¬ÂÂ´Ã«â€¹Â¤. Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã­Æ’â‚¬Ã¬ÂÂ¼Ã¬ÂËœ Ã¬Å“â€Ã¬Â¹ËœÃ«Â¥Â¼ ÃªÂ°â€“Ã­Å¾Å’ Ã«Â§ÂµÃ¬Å“Â¼Ã«Â¡Å“ Ã«Â³â‚¬Ã­Ëœâ€¢Ã­â€¢Å“Ã«â€¹Â¤.
				dX = -1;
				dY = -1;
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
			else {
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}

			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) {
				// Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬â€Å“Ã«Â²â€Ã¬â€”Â Ã«ÂªÂ©Ã¬Â ÂÃ¬Â§â‚¬ÃªÂ°â‚¬ Ã¬â€”â€ Ã«â€¹Â¤. 
				// Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬â€Å“Ã«Â²â€Ã¬â€”Â Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã­â€¢Â  Ã«Â§ÂµÃ¬ÂÂ´ Ã¬â€”â€ Ã«â€¹Â¤. Ã­ÂÂ´Ã«ÂÂ¼Ã¬ÂÂ´Ã¬â€“Â¸Ã­Å Â¸Ã«Å â€ Ã­Ëœâ€Ã¬Å¾Â¬ Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã¬Â¢â€¦Ã«Â£Å’Ã­â€¢ËœÃªÂ³Â  Ã«â€¹Â¤Ã«Â¥Â¸ Ã¬â€Å“Ã«Â²â€Ã«Â¡Å“ Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã¬â€¹Å“Ã«Ââ€Ã­â€¢Â´Ã¬â€¢Â¼ Ã­â€¢Å“Ã«â€¹Â¤.
				m_pClientList[iClientH]->m_sX   = dX; //-1;	  // Ã­â€¦â€Ã«Â Ë†Ã­ÂÂ¬Ã­Å Â¸ Ã¬Â¢Å’Ã­â€˜Å“Ã«Â¥Â¼ Ã¬Å¾â€¦Ã«Â Â¥Ã­â€¢Å“Ã«â€¹Â¤.
				m_pClientList[iClientH]->m_sY   = dY; //-1;	  // -1Ã¬Ââ‚¬ InitialPointÃ«Â¥Â¼ Ã«Â§ÂÃ­â€¢Å“Ã«â€¹Â¤.

				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // Ã«Â§Âµ Ã¬ÂÂ´Ã«Â¦â€Ã¬Ââ€ Ã«Â°â€ÃªÂ¾Â¼Ã«â€¹Â¤.
				// Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´Ã¬ÂËœ Ã«ÂÂ°Ã¬ÂÂ´Ã­â€Â°Ã«Â¥Â¼ Ã¬Â â‚¬Ã¬Å¾Â¥Ã­â€¢ËœÃªÂ³Â  Ã¬Ââ€˜Ã«â€¹ÂµÃ¬Ââ€ Ã«Â°â€ºÃ¬Ââ‚¬ Ã­â€ºâ€ Ã¬Å¾Â¬Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã¬â€¢Å’Ã«Â Â¤Ã¬â€¢Â¼ Ã­â€¢Å“Ã«â€¹Â¤.

				// New 18/05/2004
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_CONFUSE,
					m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ], NULL, NULL);
				SetSlateFlag(iClientH, DEF_NOTIFY_SLATECLEAR, FALSE);

				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! Ã¬Â¹Â´Ã¬Å¡Â´Ã­Å’â€¦ Ã­â€¢ËœÃ¬Â§â‚¬ Ã¬â€¢Å Ã«Å â€Ã«â€¹Â¤.
				// !!!
				m_pClientList[iClientH]->m_bIsOnServerChange   = TRUE;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
				return;
			}

			m_pClientList[iClientH]->m_sX   = dX;
			m_pClientList[iClientH]->m_sY   = dY;
			m_pClientList[iClientH]->m_cMapIndex = cMapIndex;

			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);  
			break;
		}
	}

RTH_NEXTSTEP:;

	// New 17/05/2004
	SetPlayingStatus(iClientH);
	int iTemp, iTemp2;
	iTemp = m_pClientList[iClientH]->m_iStatus;
	iTemp = 0x0FFFFFFF & iTemp;
	iTemp2 = iGetPlayerABSStatus(iClientH);
	iTemp = iTemp | (iTemp2 << 28);
	m_pClientList[iClientH]->m_iStatus = iTemp;

	// Crusade
	if (bIsLockedMapNotify == TRUE) SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);

	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);

	// Ã«Â§ÂµÃ«ÂÂ°Ã¬ÂÂ´Ã­â€Â°Ã«Â¥Â¼ Ã¬Â â€Ã¬â€ Â¡Ã­â€¢Å“Ã«â€¹Â¤.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	// Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´Ã¬ÂËœ Ã¬Å“â€Ã¬Â¹ËœÃ«Â¥Â¼ Ã­â„¢â€¢Ã¬Â â€¢Ã­â€¢Å“Ã«â€¹Â¤.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// Ã¬Â â€Ã¬â€ Â¡Ã­â€¢Â  Ã«Â§Âµ Ã«ÂÂ°Ã¬ÂÂ´Ã­â€Â°Ã¬ÂËœ ÃªÂ¸Â°Ã¬Â¤â‚¬Ã¬Å“â€Ã¬Â¹Ëœ. Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´Ã«Å â€ ÃªÂ¸Â°Ã¬Â¤â‚¬Ã¬Å“â€Ã¬Â¹Ëœ (x, y)Ã«Â¡Å“Ã«Â¶â‚¬Ã­â€Â° (x+14, y+12)Ã¬â€”Â Ã¬Å“â€Ã¬Â¹ËœÃ­â€¢Å“Ã«â€¹Â¤.
	sp  = (short *)cp;
	*sp = iClientH;		// Player ObjectID
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;
	// v1.4 ApprColor
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;

	ip  = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iStatus;
	cp += 4;//Original 2

	// (!) Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´ÃªÂ°â‚¬ Ã¬Å“â€Ã¬Â¹ËœÃ­â€¢ËœÃ«Å â€ Ã«Â§ÂµÃ¬ÂÂ´Ã«Â¦â€Ã¬Ââ€ ÃªÂ¸Â°Ã«Â¡ÂÃ­â€¢Å“Ã«â€¹Â¤.
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	// Ã«Âªâ€¦Ã¬Â¹Â­Ã¬Æ’ÂÃ¬ÂËœ Ã«Â§Âµ Ã¬ÂÂ´Ã«Â¦â€Ã¬Ââ€ Ã¬Å¾â€¦Ã«Â Â¥Ã­â€¢Å“Ã«â€¹Â¤. 
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	// Ã¬Â£Â¼Ã¬â€¢Â¼ÃªÂ°â€ Ã«ÂªÂ¨Ã«â€œÅ“Ã«Â¥Â¼ Ã¬â€šÂ½Ã¬Å¾â€¦ 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		*cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	// ÃªÂ¸Â°Ã¬Æ’Â Ã¬Æ’ÂÃ­Æ’Å“ Ã«ÂªÂ¨Ã«â€œÅ“Ã«Â¥Â¼ Ã¬â€šÂ½Ã¬Å¾â€¦ 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		*cp = NULL;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	// v1.4 Contribution
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;

	// @@@ Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´Ã«Â¥Â¼ Ã«Â§ÂµÃ¬Æ’ÂÃ¬â€”Â Ã¬ÂµÅ“Ã¬Â´Ë†Ã«Â¡Å“ Ã¬Å“â€Ã¬Â¹ËœÃ¬â€¹Å“Ã­â€šÂ¨Ã«â€¹Â¤.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, 
			DEF_OWNERTYPE_PLAYER, 
			m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY);
	}

	// v1.41
	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;

	// v1.41 
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	// v1.44
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;
	//Unknown variable
	*cp = 0;
	cp++;

	// Ã«Â§ÂµÃ¬ÂËœ Ã¬Â â€¢Ã«Â³Â´Ã«Â¥Â¼ Ã¬Â¶â€ÃªÂ°â‚¬Ã­â€¢Å“Ã«â€¹Â¤. 
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp );
	// Ã«Â©â€Ã¬â€¹Å“Ã¬Â§â‚¬ Ã¬Â â€Ã¬â€ Â¡ 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4 + 3); //Zabuza fix
	//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4); // v1.41
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Ã«Â©â€Ã¬â€¹Å“Ã¬Â§â‚¬Ã«Â¥Â¼ Ã«Â³Â´Ã«â€šÂ¼Ã«â€¢Å’ Ã¬â€”ÂÃ«Å¸Â¬ÃªÂ°â‚¬ Ã«Â°Å“Ã¬Æ’ÂÃ­â€“Ë†Ã«â€¹Â¤Ã«Â©Â´ Ã¬Â Å“ÃªÂ±Â°Ã­â€¢Å“Ã«â€¹Â¤.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	if(pBuffer != NULL) delete pBuffer;

	// Ã«â€¹Â¤Ã«Â¥Â¸ Ã­ÂÂ´Ã«ÂÂ¼Ã¬ÂÂ´Ã¬â€“Â¸Ã­Å Â¸Ã«â€œÂ¤Ã¬â€”ÂÃªÂ²Å’ Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´ÃªÂ°â‚¬ Ã¬Æ’Ë†Ã«Â¡Å“Ã¬Å¡Â´ Ã¬Å“â€Ã¬Â¹ËœÃ¬â€”Â Ã«â€šËœÃ­Æ’â‚¬Ã«â€šÂ¬Ã¬ÂÅ’Ã¬Ââ€ Ã¬â€¢Å’Ã«Â¦Â°Ã«â€¹Â¤. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);

	if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) && 
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) && 
		(m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {

			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			// New 17/05/2004
			CheckForceRecallTime(iClientH);
		}
	else if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) && 
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) && 
			(m_pClientList[iClientH]->m_iAdminUserLevel == 0) ) {

				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

				// New 17/05/2004
				CheckForceRecallTime(iClientH);
			}
		else if ( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE ) {
			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			SetForceRecallTime(iClientH) ;

			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;  

		} else {
			m_pClientList[iClientH]->m_bIsWarLocation = FALSE;	
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
			SetForceRecallTime(iClientH) ;
		}

		// No entering enemy shops
		int iMapside, iMapside2;

		iMapside = iGetMapLocationSide(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName);
		if (iMapside > 3) iMapside2 = iMapside - 2;
		else iMapside2 = iMapside;
		m_pClientList[iClientH]->m_bIsInsideOwnTown = FALSE;
		if ((m_pClientList[iClientH]->m_cSide != iMapside2) && (iMapside != 0)) {
			if ((iMapside <= 2) && (m_pClientList[iClientH]->m_iAdminUserLevel < 1)) {
				if (m_pClientList[iClientH]->m_cSide != 0) {
					m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
					m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
					m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
					m_pClientList[iClientH]->m_bIsInsideOwnTown = TRUE;
				}
			}
		}
		else{
			if (m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsFightZone == TRUE &&
				m_iFightzoneNoForceRecall == FALSE && 
				m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
					m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
					GetLocalTime(&SysTime);
					m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;
				}
			else{
				if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "arejail", 7) == 0 ||
					memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cLocationName, "elvjail", 7) == 0) {
						if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
							m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
							m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
							if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0)
								m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
							else if(m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > 100)
								m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 100;
						}
					}
			}
		}

		// Ã¬Â¶â€ÃªÂ°â‚¬Ã«Â¡Å“ Ã«Â³Â´Ã«â€šÂ´Ã¬Â¤ËœÃ¬â€¢Â¼ Ã­â€¢Â  Ã¬Â â€¢Ã«Â³Â´Ã«Â¥Â¼ Ã«Â³Â´Ã«â€šÂ¸Ã«â€¹Â¤. v1.1
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
		// v1.3
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
		// V1.3
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);
		// v1.4 
		_SendQuestContents(iClientH);
		_CheckQuestEnvironment(iClientH);

		// v1.432
		if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0)
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);

			// Crusade Ã­Å¡â€°Ã¬Â²Â ?Ã¬Â±Å’ Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦ Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦?Ã­Å¡â€˜Ã¬Â§Â¸Ã¬Â±Â  Ã­Å¡â€°Ã­Å¡â€Ã¬Â¨Å’Ã¬Â¨â€?Ã­Å¡â€˜Ã¬Â©ÂÃ¬Â±Â¤?Ã­Å¡â€° CrusadeGUIDÃ¬Â§Â¸Ã¬Â§â€¢ 0 Ã­Å¡Å Ã¬Â§Å¡?Ã¬Â¨Ëœ Ã­Å¡â€°Ã¬Â²Â ?Ã¬Â±Å’Ã¬Â©â€Ã­Å¡â€™ Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨ÂÃ¬Â§â„¢Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨ÂÃ¬Â±â€¢ Ã­Å¡â€Ã¬Â¨â‚¬?Ã¬Â©Â Ã­Å¡â€°Ã­Å¡ËœÃ¬Â¨Ë†Ã¬Â±Å’Ã¬Â¨â€°Ã­Å¡â€°Ã¬Â¨Ë†Ã­Å¡â€š Ã¬Â§Â¸Ã­Å¡â€™?Ã­Å¡â€˜Ã¬Â¨Ë†Ã­Å¡Â¢. Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦ Ã¬Â©â€Ã¬Â§Â§Ã­Å¡â€°Ã­Å¡Ëœ Ã­Å¡â€Ã­Å¡Å½Ã¬Â§Â¹Ã¬Â°Â½Ã­Å¡Å Ã¬Â§Â¯.
			if (m_bIsCrusadeMode == TRUE) {
				if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
					// Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦?Ã­Å¡â€˜Ã¬Â§Â¸Ã¬Â±Â  Ã­Å¡â€°Ã­Å¡â€Ã¬Â¨Å’Ã¬Â¨â€?Ã­Å¡â€˜Ã¬Â©ÂÃ¬Â±Â¤?Ã­Å¡â€° GUIDÃ¬Â§Â¸Ã¬Â§â€¢ 0?Ã­Å¡â€˜Ã¬Â¨â€¹Ã¬Â²Å“ Ã¬Â§Â¸Ã­Å¡â€™?Ã¬Â¨Ëœ Ã­Å¡â€Ã¬Â¨â‚¬?Ã¬Â©Â Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦ Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦Ã¬Â©â€Ã¬Â§â€¢ Ã¬Â¨â€°Ã¬Â±â€¢Ã¬Â©ÂÃ¬Â±Â¤Ã¬Â©â€Ã­Å¡Å¡Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨Ë†Ã­Å¡â€š ?Ã­Å¡â€°Ã¬Â¨â€Ã­Å¡â€˜. Ã¬Â©â€Ã¬Â§Â§Ã­Å¡â€°Ã­Å¡Ëœ Ã­Å¡â€Ã­Å¡Å½Ã¬Â§Â¹Ã¬Â°Â½Ã­Å¡Å Ã¬Â§Â¯.
					m_pClientList[iClientH]->m_iCrusadeDuty = 0;
					m_pClientList[iClientH]->m_iConstructionPoint = 0;
					m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
				}
				else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
					// Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦?Ã­Å¡â€˜Ã¬Â§Â¸Ã¬Â±Â  Ã­Å¡â€°Ã­Å¡â€Ã¬Â¨Å’Ã¬Â¨â€?Ã­Å¡â€˜Ã¬Â©ÂÃ¬Â±Â¤?Ã­Å¡â€° GUIDÃ¬Â§Â¸Ã¬Â§â€¢ Ã­Å¡â€°Ã¬Â²Â ?Ã¬Â±Å’ Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦ Ã¬Â©ÂÃ­Å¡Ë†?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±Â¨Ã¬Â©â€Ã­Å¡â€™ Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨ÂÃ¬Â§â„¢Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨Ë†Ã­Å¡â€š Ã¬Â§Â¸Ã­Å¡â€™?Ã¬Â¨Ëœ ?Ã¬Â²Â¬Ã¬Â¨â€Ã¬Â²Â©Ã¬Â©â€Ã¬Â§â€¢ Ã¬Â¨â€Ã¬Â²Â¬Ã¬Â©ÂÃ¬Â±Â¤Ã­Å¡ÂÃ¬Â¨â‚¬Ã¬Â¨Ë†Ã¬Â²Â© Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦?Ã­Å¡â€° Ã¬Â§Â¸Ã¬Â°Â¼Ã¬Â§Â¸Ã¬Â²Â¬?Ã­Å¡â€˜Ã¬Â¨Ë†Ã­Å¡Â¢.
					// ?Ã­Å¡â€˜Ã¬Â¨Å’Ã¬Â§Â¹ Ã¬Â§Â¸Ã¬Â±Ë†Ã¬Â©â€Ã¬Â±â„¢ ?Ã¬Â²Â´Ã¬Â§Â¸Ã¬Â²Â©Ã¬Â©â€Ã¬Â§â€¢ Ã¬Â¨â€°Ã¬Â²Â­Ã¬Â¨ÂÃ¬Â§Å“ Ã­Å¡Ë†Ã¬Â²Â¨Ã¬Â¨Â©Ã¬Â²Ëœ?Ã¬Â¨Â© Ã­Å¡â€°Ã­Å¡Ëœ Ã¬Â©Å’Ã¬Â²Â  Ã¬Â©ÂÃ¬Â²Â©Ã¬Â¨Ë†Ã­Å¡Â¢. Ã­Å¡â€Ã­Å¡Å“Ã¬Â©Å’Ã­Å¡ËœÃ­Å¡â€°Ã­Å¡â€” Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦ Ã¬Â¨ÂÃ¬Â±Â¨Ã¬Â¨â€°Ã¬Â±â€¦Ã¬Â§Â¸Ã¬Â§â€¢ Ã­Å¡ÂÃ¬Â©ÂÃ¬Â¨Å’Ã¬Â°Â¼Ã¬Â¨â€°Ã­Å¡Å  Ã¬Â¨Ë†Ã­Å¡Â¢?Ã¬Â©Â Ã¬Â¨Ë†Ã­Å¡Â¢?Ã¬Â©Â ?Ã¬Â²Â´Ã¬Â¨ÂÃ¬Â±â€¢?Ã¬Â²Â´?Ã­Å¡â€˜ Ã¬Â©ÂÃ­Å¡â€?Ã­Å¡Â¤Ã¬Â¨â€°Ã­Å¡â€°Ã¬Â§Â¹Ã¬Â°Â½ ?Ã¬Â²Â´Ã¬Â©â€Ã¬Â§â€¢ Ã­Å¡ÂÃ¬Â§â€“Ã¬Â©Å’Ã­Å¡â„¢?Ã¬Â¨Â© Ã­Å¡â€°Ã­Å¡Â Ã¬Â©ÂÃ­Å¡Â© Ã­Å¡Ë†Ã¬Â²Â¨Ã¬Â¨Â©Ã¬Â²Ëœ?Ã¬Â¨Â© Ã¬Â©ÂÃ¬Â±Âµ?Ã¬Â¨Â© Ã¬Â©Å’Ã¬Â²Â  ?Ã­Å¡Å“Ã¬Â¨Ë†Ã­Å¡Â¢.
					// ?Ã­Å¡â€˜?Ã¬Â²Â´Ã¬Â©â€Ã¬Â§â€¢ Ã­Å¡â€°Ã­Å¡ËœÃ¬Â¨Ë†Ã¬Â±Å’Ã¬Â¨â€°Ã­Å¡â€°Ã¬Â©ÂÃ¬Â²Â¬Ã¬Â¨Ë†Ã¬Â²Â© Ã¬Â©â€Ã¬Â§Â§Ã­Å¡â€°Ã­Å¡Ëœ, Ã¬Â§Â¸Ã­Å¡â€°Ã¬Â©Å’Ã¬Â¨â‚¬ Ã­Å¡Ë†Ã¬Â²Â¨?Ã­Å¡â€œÃ­Å¡Ë†Ã¬Â§Â°, ?Ã¬Â²Â´?Ã¬Â±Â¦ Ã¬Â§Â¸Ã¬Â²Â©Ã­Å¡â€°Ã¬Â±â€¦Ã¬Â¨â€°Ã¬Â¨â€° Ã­Å¡â€Ã­Å¡Å½Ã¬Â§Â¹Ã¬Â°Â½Ã­Å¡Å Ã¬Â§Â¯.
					m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
					m_pClientList[iClientH]->m_iConstructionPoint = 0;
					m_pClientList[iClientH]->m_iWarContribution   = 0;
					m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
					// Ã­Å¡â€¡Ã¬Â§Â¤Ã¬Â¨Å’Ã¬Â±Å’Ã¬Â©Å’Ã¬Â©Å’?Ã­Å¡â€˜Ã¬Â¨â€°Ã¬Â±â€¦ GUIDÃ¬Â§Â¸Ã¬Â§â€¢ Ã¬Â¨Ë†Ã­Å¡Â¢Ã¬Â¨ÂÃ¬Â§â„¢Ã¬Â¨Ë†Ã­Å¡Â¢. Ã­Å¡Ë†Ã¬Â²Â¨Ã¬Â¨Â©Ã¬Â²Ëœ Ã¬Â¨ËœÃ­Å¡ËœÃ¬Â§Â¸Ã¬Â§â€¢.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
				}
				m_pClientList[iClientH]->m_cVar = 1;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
			}
			else if (m_bIsHeldenianMode == TRUE) {
				sSummonPoints = m_pClientList[iClientH]->m_iCharisma*300;
				if (sSummonPoints > DEF_MAXSUMMONPOINTS) sSummonPoints = DEF_MAXSUMMONPOINTS;
				if (m_pClientList[iClientH]->m_dwHeldenianGUID == NULL) {
					m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
					m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
				}
				else if (m_pClientList[iClientH]->m_dwHeldenianGUID != m_dwHeldenianGUID) {
					m_pClientList[iClientH]->m_iConstructionPoint = sSummonPoints;
					m_pClientList[iClientH]->m_iWarContribution = 0;
					m_pClientList[iClientH]->m_dwHeldenianGUID = m_dwHeldenianGUID;
				}
				m_pClientList[iClientH]->m_cVar = 2;
				if (m_bIsHeldenianMode == TRUE) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, NULL, NULL, NULL, NULL);
				}
				if (m_bHeldenianInitiated == TRUE) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL);
				}
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, NULL, NULL);
				UpdateHeldenianStatus();
			}
			else if ((m_pClientList[iClientH]->m_cVar == 1) && (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID)) {
				m_pClientList[iClientH]->m_iCrusadeDuty = 0;
				m_pClientList[iClientH]->m_iConstructionPoint = 0;
			}
			else {
				if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
					if (m_pClientList[iClientH]->m_cVar == 1) {
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, NULL, NULL, -1);
					}
				}
				else {
					m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
					m_pClientList[iClientH]->m_iWarContribution   = 0;
					m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
				}
			}		
		/*// Crusade Ã­Ëœâ€Ã¬Å¾Â¬ Ã­ÂÂ¬Ã«Â£Â¨Ã¬â€Â¸Ã¬ÂÂ´Ã«â€œÅ“ Ã«ÂªÂ¨Ã«â€œÅ“Ã¬ÂÂ´ÃªÂ³Â  Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´Ã¬ÂËœ CrusadeGUIDÃªÂ°â‚¬ 0 Ã­ËœÂ¹Ã¬Ââ‚¬ Ã­Ëœâ€Ã¬Å¾Â¬Ã¬â„¢â‚¬ Ã«â€¹Â¤Ã«Â¥Â´Ã«â€¹Â¤Ã«Â©Â´ Ã¬Â²ËœÃ¬ÂÅ’ Ã­â€¢Â Ã«â€¹Â¹Ã«ÂËœÃ«Å â€ ÃªÂ²Æ’Ã¬ÂÂ´Ã«â€¹Â¤. Ã­ÂÂ¬Ã«Â£Â¨Ã¬â€Â¸Ã¬ÂÂ´Ã«â€œÅ“ Ã¬â€”Â­Ã­â€¢Â  Ã¬Â´Ë†ÃªÂ¸Â°Ã­â„¢â€.
		if (m_bIsCrusadeMode == TRUE) {
			if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
				// Ã­ÂÂ¬Ã«Â£Â¨Ã¬â€Â¸Ã¬ÂÂ´Ã«â€œÅ“Ã«ÂªÂ¨Ã«â€œÅ“Ã¬ÂÂ´ÃªÂ³Â  Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´Ã¬ÂËœ GUIDÃªÂ°â‚¬ 0Ã¬ÂÂ´Ã«Å¾â‚¬ ÃªÂ²Æ’Ã¬Ââ‚¬ Ã¬Â²ËœÃ¬ÂÅ’ Ã­ÂÂ¬Ã«Â£Â¨Ã¬â€Â¸Ã¬ÂÂ´Ã«â€œÅ“ Ã«ÂªÂ¨Ã«â€œÅ“Ã¬â€”Â Ã«â€œÂ¤Ã¬â€“Â´Ã¬â„¢â€Ã«â€¹Â¤Ã«Å â€ Ã¬ÂËœÃ«Â¯Â¸. Ã¬â€”Â­Ã­â€¢Â  Ã¬Â´Ë†ÃªÂ¸Â°Ã­â„¢â€.
				m_pClientList[iClientH]->m_iCrusadeDuty = 0;
				m_pClientList[iClientH]->m_iConstructionPoint = 0;
				m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			}
			else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
				// Ã­ÂÂ¬Ã«Â£Â¨Ã¬â€Â¸Ã¬ÂÂ´Ã«â€œÅ“Ã«ÂªÂ¨Ã«â€œÅ“Ã¬ÂÂ´ÃªÂ³Â  Ã­â€Å’Ã«Â Ë†Ã¬ÂÂ´Ã¬â€“Â´Ã¬ÂËœ GUIDÃªÂ°â‚¬ Ã­Ëœâ€Ã¬Å¾Â¬ Ã­ÂÂ¬Ã«Â£Â¨Ã¬â€Â¸Ã¬ÂÂ´Ã«â€œÅ“ Ã¬â€¢â€Ã¬ÂÂ´Ã«â€â€Ã¬â„¢â‚¬ Ã«â€¹Â¤Ã«Â¥Â´Ã«â€¹Â¤Ã«Å â€ ÃªÂ²Æ’Ã¬Ââ‚¬ Ã¬Â â‚¬Ã«Â²Ë†Ã¬â€”Â Ã«Â²Å’Ã¬â€“Â´Ã¬Â¡Å’Ã«ÂËœ Ã­ÂÂ¬Ã«Â£Â¨Ã¬â€Â¸Ã¬ÂÂ´Ã«â€œÅ“Ã¬ÂËœ ÃªÂ²Â°ÃªÂ³Â¼Ã¬ÂÂ´Ã«â€¹Â¤.
				// Ã¬ÂÂ´Ã«Å¸Â° ÃªÂ²Â½Ã¬Å¡Â° Ã¬Â â€ÃªÂ³ÂµÃ¬â€”Â Ã«â€Â°Ã«Â¥Â¸ Ã­ÂÂ¬Ã¬Æ’ÂÃ¬Ââ€ Ã­â€¢Â  Ã¬Ë†Ëœ Ã¬â€”â€ Ã«â€¹Â¤. Ã¬ÂµÅ“Ã¬â€ Å’Ã­â€¢Å“ Ã­ÂÂ¬Ã«Â£Â¨Ã¬â€Â¸Ã¬ÂÂ´Ã«â€œÅ“ Ã«ÂªÂ¨Ã«â€œÅ“ÃªÂ°â‚¬ Ã¬Â¢â€¦Ã«Â£Å’Ã«ÂÅ“ Ã«â€¹Â¤Ã¬ÂÅ’ Ã«â€¹Â¤Ã¬ÂÅ’ Ã¬Â â€Ã«Â©Â´Ã¬Â â€Ã¬ÂÂ´ Ã¬â€¹Å“Ã¬Å¾â€˜Ã«ÂËœÃªÂ¸Â° Ã¬Â â€Ã¬â€”Â Ã¬Â â€˜Ã¬â€ ÂÃ¬Ââ€ Ã­â€¢Â´Ã¬â€¢Â¼ Ã­ÂÂ¬Ã¬Æ’ÂÃ¬Ââ€ Ã¬â€“Â»Ã¬Ââ€ Ã¬Ë†Ëœ Ã¬Å¾Ë†Ã«â€¹Â¤.
				// Ã¬ÂÂ´Ã¬Â â€Ã¬â€”Â Ã­â€¢Â Ã«â€¹Â¹Ã«ÂËœÃ¬â€”Ë†Ã«ÂËœ Ã¬â€”Â­Ã­â€¢Â , ÃªÂ±Â´Ã¬â€Â¤ Ã­ÂÂ¬Ã¬ÂÂ¸Ã­Å Â¸, Ã¬Â â€Ã¬Å¸Â ÃªÂ³ÂµÃ­â€”Å’Ã«Ââ€ Ã¬Â´Ë†ÃªÂ¸Â°Ã­â„¢â€.
				m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
				m_pClientList[iClientH]->m_iConstructionPoint = 0;
				m_pClientList[iClientH]->m_iWarContribution   = 0;
				m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
				// Ã­ÂÂ¬Ã«Â£Â¨Ã¬â€Â¸Ã¬ÂÂ´Ã«â€œÅ“ GUIDÃªÂ°â‚¬ Ã«â€¹Â¤Ã«Â¥Â´Ã«â€¹Â¤. Ã­ÂÂ¬Ã¬Æ’Â Ã«Â¶Ë†ÃªÂ°â‚¬.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
			}
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
		}
		else {
			// Ã­ÂÂ¬Ã«Â£Â¨Ã¬â€Â¸Ã¬ÂÂ´Ã«â€œÅ“ Ã«ÂªÂ¨Ã«â€œÅ“ÃªÂ°â‚¬ Ã¬â€¢â€Ã«â€¹Å’ ÃªÂ²Â½Ã¬Å¡Â° Ã¬â€”Â­Ã­â€¢Â ÃªÂ³Â¼ ÃªÂ³ÂµÃ­â€”Å’ Ã­ÂÂ¬Ã¬ÂÂ¸Ã­Å Â¸Ã«Â§Å’ Ã¬Â´Ë†ÃªÂ¸Â°Ã­â„¢â€. Ã¬Â â€Ã¬Å¸Â ÃªÂ³ÂµÃ­â€”Å’Ã«Ââ€Ã«Å â€ Ã¬Å¾Â Ã¬â€¹Å“Ã­â€ºâ€Ã¬â€”Â ÃªÂ³â€Ã¬â€šÂ°Ã«ÂËœÃ¬â€“Â´Ã¬â€Å“ Ã­ÂÂ¬Ã¬Æ’ÂÃ«ÂÅ“Ã«â€¹Â¤.
			if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
				m_pClientList[iClientH]->m_iCrusadeDuty = 0;
				m_pClientList[iClientH]->m_iConstructionPoint = 0;
			}
			else if ((m_pClientList[iClientH]->m_dwCrusadeGUID != NULL) && (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)) {
				// Ã­ÂÂ¬Ã«Â£Â¨Ã¬â€Â¸Ã¬ÂÂ´Ã«â€œÅ“ GUIDÃªÂ°â‚¬ Ã«â€¹Â¤Ã«Â¥Â´Ã«â€¹Â¤. Ã­ÂÂ¬Ã¬Æ’Â Ã«Â¶Ë†ÃªÂ°â‚¬.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
				m_pClientList[iClientH]->m_iWarContribution   = 0;
				m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
			}
		}*/

		// v1.42
		// 2002-7-4 Ã‚Â»ÃƒÂ§Ãƒâ€¦ÃƒÂµÃƒâ‚¬ÃƒÂ¥Ãƒâ‚¬Ãƒâ€¡ Ã‚Â°Ã‚Â¹Ã‚Â¼ÃƒÂ¶Ã‚Â¸Ã‚Â¦ Ã‚Â´ÃƒÆ’Ã‚Â¸Ã‚Â± Ã‚Â¼ÃƒÂ¶ Ãƒâ‚¬Ãƒâ€“Ã‚ÂµÃ‚ÂµÃ‚Â·ÃƒÂ 
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fight", 5) == 0) {
			wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
			PutLogEventFileList(G_cTxt);
		}

		// Crusade
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);

		// v2.15
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

		if (m_bIsHeldenianMode == TRUE) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANTELEPORT, NULL, NULL, NULL, NULL);
			if (m_bHeldenianInitiated == TRUE) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL);
			}
			else {
				UpdateHeldenianStatus();
			}
		}
		
		if (m_pClientList[iClientH]->m_iQuest != NULL) { 
				cQuestRemain = (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iMaxCount - m_pClientList[iClientH]->m_iCurQuestCount);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOUNTER, cQuestRemain, NULL, NULL, NULL);
				_bCheckIsQuestCompleted(iClientH);
		}

}

void CGame::ReleaseFollowMode(short sOwnerH, char cOwnerType)
{
 register int i;

	for (i = 0; i < DEF_MAXNPCS; i++)
	if ((i != sOwnerH) && (m_pNpcList[i] != NULL)) {
		if ((m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) &&
			(m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) &&
			(m_pNpcList[i]->m_cFollowOwnerType == cOwnerType)) {
			
			m_pNpcList[i]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
		}
	}
}

BOOL CGame::_bDecodeMagicConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iMagicConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Â¸Â¶Â¹Ã½ Â¹Ã¸ÃˆÂ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pMagicConfigList[atoi(token)] != NULL) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃˆ Â¹Ã¸ÃˆÂ£Â°Â¡ Ã€Ã–Â´Ã™. Â¿Â¡Â·Â¯Ã€ÃŒÂ´Ã™.
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[atoi(token)] = new class CMagic;
					iMagicConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// Â¸Â¶Â¹Ã½ Ã€ÃŒÂ¸Â§ 
					ZeroMemory(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, sizeof(m_pMagicConfigList[iMagicConfigListIndex]->m_cName));
					memcpy(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					// Â¸Â¶Â¹Ã½ ÃÂ¾Â·Ã¹ m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// Â¸Â¶Â¹Ã½ ÂµÃ´Â·Â¹Ã€ÃŒ Â½ÃƒÂ°Â£ m_dwDelayTime
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// Â¸Â¶Â¹Ã½ ÃÃ¶Â¼Ã“Â½ÃƒÂ°Â£ m_dwLastTime
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwLastTime = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 7;
					break;
				
				case 7:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// m_sValue7
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue7 = atoi(token);
					cReadModeB = 13;
					break;
				
				case 13:
					// m_sValue8
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue8 = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// m_sValue9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue9 = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// m_sValue10
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue10 = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// m_sValue11
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue11 = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// m_sValue12
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue12 = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// m_sIntLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sIntLimit = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// m_iGoldCost
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iGoldCost = atoi(token);
					
					cReadModeB = 20;
					break;

				case 20:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_iAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iAttribute = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) MAGIC(Total:%d) configuration - success!", iMagicConfigListIndex);
	PutLogList(cTxt);

	return TRUE;

}



BOOL CGame::_bDecodeSkillConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iSkillConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Â½ÂºÃ…Â³ Â¹Ã¸ÃˆÂ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pSkillConfigList[atoi(token)] != NULL) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃˆ Â¹Ã¸ÃˆÂ£Â°Â¡ Ã€Ã–Â´Ã™. Â¿Â¡Â·Â¯Ã€ÃŒÂ´Ã™.
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[atoi(token)] = new class CSkill;
					iSkillConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// Â½ÂºÃ…Â³ Ã€ÃŒÂ¸Â§ 
					ZeroMemory(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, sizeof(m_pSkillConfigList[iSkillConfigListIndex]->m_cName));
					memcpy(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					// Â½ÂºÃ…Â³ ÃÂ¾Â·Ã¹ m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) SKILL(Total:%d) configuration - success!", iSkillConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

// 12-22 ¼ºÈÄ´Ï ¼öÁ¤  ¸¶¹ı¹è¿ì±â¿¡ ½ÇÆĞÇÑ ÀÌÀ¯¸¦ Å¬¶óÀÌ¾ğÆ®¿¡ º¸³»ÁØ´Ù.
void CGame::RequestStudyMagicHandler(int iClientH, char * pName, BOOL bIsPurchase)
{
 char  * cp, cMagicName[31], cData[100];
 DWORD * dwp, dwGoldCount;
 WORD  * wp;
 int   * ip, iReqInt, iCost, iRet;
 BOOL bMagic = TRUE ;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// ¸¶¹ıÀ» ¹è¿î´Ù. 
	ZeroMemory(cData, sizeof(cData));	

	ZeroMemory(cMagicName, sizeof(cMagicName));
	memcpy(cMagicName, pName, 30);
	
	iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
	if (iRet == -1) {
		// ÀÌ·± ÀÌ¸§ÀÇ ¸¶¹ıÀº Á¸ÀçÇÏÁö ¾Ê´Â´Ù. ¹«½ÃÇÑ´Ù. 

	}
	else {
		if (bIsPurchase == TRUE) {
			if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) bMagic = FALSE ; // ÀÏ¹İÀûÀ¸·Î ¹è¿ï¼ö ¾ø´Â ¸¶¹ıÀÌ¶ó¸é(°¡°İÀÌ À½¼ö) ¹è¿ï ¼ö ¾ø´Ù.
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			if ((DWORD)iCost > dwGoldCount)  bMagic = FALSE ; // µ·ÀÌ ºÎÁ·ÇØµµ ¹è¿ï ¼ö ¾ø´Ù.
		}
	
		if (m_pClientList[iClientH]->m_bIsInsideWizardTower == FALSE) return;
		if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return;

		if ((iReqInt <= m_pClientList[iClientH]->m_iInt) && (bMagic == TRUE) ) {
			
			// µ·À» »ç¿ëÇßÀ½À» ¾Ë¸°´Ù.
			if (bIsPurchase == TRUE) SetItemCount(iClientH, "Gold", dwGoldCount - iCost);
			
			// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
			iCalcTotalWeight(iClientH);
		
			// ¸¶¹ı »ç¿ë ´É·Â Ç¥½Ã .
			m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;
	
			// ¸¶¹ıÀ» ¹è¿ü´Ù´Â ¸Ş½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYSUCCESS;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			
			// ¸¶¹ı ¹øÈ£ 
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			// Á¤º¸ Àü¼Û 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 37);

			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Ş½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ıÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {
			// Á¶°ÇÀÌ ¸¸Á·µÇÁö ¾Ê¾Æ ¸¶¹ıÀ» ¹è¿ï ¼ö ¾ø´Ù.
			// ¸¶¹ıÀ» ¹è¿ï¼ö ¾ø¾ú´Ù´Â ¸Ş½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYFAIL;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// ½ÇÆĞÀÌÀ¯.
			*cp = 1;
			cp++;

			// ¸¶¹ı ¹øÈ£ 
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			ip = (int *)cp;
			*ip = iCost;
			cp += 4;

			ip = (int *)cp;
			*ip = iReqInt;
			cp += 4;

			// Á¤º¸ Àü¼Û 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 46);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Ş½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ıÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
	}
}

/*void CGame::RequestStudyMagicHandler(int iClientH, char * pName, BOOL bIsPurchase)
{
 char  * cp, cMagicName[31], cData[100];
 DWORD * dwp, dwGoldCount;
 WORD  * wp;
 int   * ip, iReqInt, iCost, iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	// Â¸Â¶Â¹Ã½Ã€Â» Â¹Ã¨Â¿Ã®Â´Ã™. 
	ZeroMemory(cData, sizeof(cData));	

	ZeroMemory(cMagicName, sizeof(cMagicName));
	memcpy(cMagicName, pName, 30);
	
	iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
	if (iRet == -1) {
		// Ã€ÃŒÂ·Â± Ã€ÃŒÂ¸Â§Ã€Ã‡ Â¸Â¶Â¹Ã½Ã€Âº ÃÂ¸Ã€Ã§Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. Â¹Â«Â½ÃƒÃ‡Ã‘Â´Ã™. 

	}
	else {
		if (bIsPurchase == TRUE) {
			if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) return; // Ã€ÃÂ¹ÃÃ€Ã»Ã€Â¸Â·Ã Â¹Ã¨Â¿Ã¯Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â¸Â¶Â¹Ã½Ã€ÃŒÂ¶Ã³Â¸Ã©(Â°Â¡Â°ÃÃ€ÃŒ Ã€Â½Â¼Ã¶) Â¹Ã¨Â¿Ã¯ Â¼Ã¶ Â¾Ã¸Â´Ã™.
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			if ((DWORD)iCost > dwGoldCount) return; // ÂµÂ·Ã€ÃŒ ÂºÃÃÂ·Ã‡Ã˜ÂµÂµ Â¹Ã¨Â¿Ã¯ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		}
	
		// Ã€ÃŒÂ¹ÃŒ Â¹Ã¨Â¿Ã® Â¸Â¶Â¹Ã½Ã€Â» Â´Ã™Â½Ãƒ Â¹Ã¨Â¿Ã¬Â°ÃšÂ´Ã™Â°Ã­ Â¿Ã¤ÃƒÂ»Ã‡ÃÂ¸Ã© Â¹Â«Â½Ãƒ 
		if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return;
		if (iReqInt <= m_pClientList[iClientH]->m_iInt) {
			
			// ÂµÂ·Ã€Â» Â»Ã§Â¿Ã«Ã‡ÃŸÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
			if (bIsPurchase == TRUE) SetItemCount(iClientH, "Gold", dwGoldCount - iCost);
			
			// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
			iCalcTotalWeight(iClientH);
		
			// Â¸Â¶Â¹Ã½ Â»Ã§Â¿Ã« Â´Ã‰Â·Ã‚ Ã‡Â¥Â½Ãƒ .
			m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;
	
			// Â¸Â¶Â¹Ã½Ã€Â» Â¹Ã¨Â¿Ã¼Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Ã€Ã¼Â¼Ã›Ã‡Ã‘Â´Ã™.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYSUCCESS;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			
			// Â¸Â¶Â¹Ã½ Â¹Ã¸ÃˆÂ£ 
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			// ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 37);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {
			// ÃÂ¶Â°Ã‡Ã€ÃŒ Â¸Â¸ÃÂ·ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã† Â¸Â¶Â¹Ã½Ã€Â» Â¹Ã¨Â¿Ã¯ Â¼Ã¶ Â¾Ã¸Â´Ã™.
			// Â¸Â¶Â¹Ã½Ã€Â» Â¹Ã¨Â¿Ã¯Â¼Ã¶ Â¾Ã¸Â¾ÃºÂ´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Ã€Ã¼Â¼Ã›Ã‡Ã‘Â´Ã™.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYFAIL;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// Â½Ã‡Ã†ÃÃ€ÃŒÃ€Â¯.
			*cp = 1;
			cp++;

			// Â¸Â¶Â¹Ã½ Â¹Ã¸ÃˆÂ£ 
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			ip = (int *)cp;
			*ip = iCost;
			cp += 4;

			ip = (int *)cp;
			*ip = iReqInt;
			cp += 4;

			// ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 46);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
	}
}*/

int CGame::_iGetMagicNumber(char * pMagicName, int * pReqInt, int * pCost)
{
 register int i;
 char cTmpName[31];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMagicName);

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) 
	if (m_pMagicConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pMagicConfigList[i]->m_cName, 30) == 0) {
			// Â°Â°Ã€Âº Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ Â¸Â¶Â¹Ã½ Â¼Â³ÃÂ¤Ã€Â» ÃƒÂ£Â¾Ã’Â´Ã™. Â¸Â¶Â¹Ã½ Â¹Ã¸ÃˆÂ£Â¸Â¦ Â¹ÃÃˆÂ¯Ã‡Ã‘Â´Ã™.
			*pReqInt = (int)m_pMagicConfigList[i]->m_sIntLimit;
			*pCost   = (int)m_pMagicConfigList[i]->m_iGoldCost;
			
			return i;
		}
	}
	
	return -1;
}

void CGame::TrainSkillResponse(BOOL bSuccess, int iClientH, int iSkillNum, int iSkillLevel)
{
 char  * cp, cData[100];
 DWORD * dwp;
 WORD  * wp;
 int   iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((iSkillNum < 0)	|| (iSkillNum > 100)) return;
	if ((iSkillLevel < 0) || (iSkillLevel > 100)) return;

	if (bSuccess == TRUE) {
		// ÀÌ¹Ì ±â¼úÀ» ÀÍÈù »óÅÂ¶ó¸é ¼Ò¿ëÀÌ ¾ø´Ù.
		if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] != 0) return;
		
		m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] = iSkillLevel;
		// ±â¼ú ÃÑ ÇÕÀ» Àç °è»êÇÑ´Ù.
		bCheckTotalSkillMasteryPoints(iClientH, iSkillNum);

		// ±â¼úÀ» ¹è¿ü´Ù´Â ¸Ş½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_SKILLTRAINSUCCESS;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// ±â¼ú¹øÈ£
		*cp = iSkillNum;
		cp++;
		
		// ±â¼ú ·¹º§ .
		*cp = iSkillLevel;
		cp++;
	 
		//wsprintf(G_cTxt, "Skill Improve: (%s) increased (%s) at %s (%d,%d).", m_pClientList[iClientH]->m_cCharName, m_pSkillConfigList[iSkillNum]->m_cName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		//PutLogFileList(G_cTxt);

		if (m_pSkillConfigList[iSkillNum]->m_cName != NULL) 
			_bItemLog(DEF_ITEMLOG_SKILLLEARN,iClientH,m_pSkillConfigList[iSkillNum]->m_cName,NULL);

		// Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 8);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Ş½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ıÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
	else {


	}

	/*
	// ±â¼úÀ» ¹è¿î´Ù. 
	ZeroMemory(cData, sizeof(cData));	

	ZeroMemory(cSkillName, sizeof(cSkillName));
	memcpy(cSkillName, pName, 20);
	
	iRet = _iGetSkillNumber(cSkillName);
	if (iRet == 0) {
		// ÀÌ·± ÀÌ¸§ÀÇ ±â¼úÀº Á¸ÀçÇÏÁö ¾Ê´Â´Ù.

	}
	else {
		// Å¬¶óÀÌ¾ğÆ®°¡ iRet¹øÂ° ±â¼úÀÇ ¸î·¹º§À» ¹è¿ì´Â Áö, ¹è¿ì±â¿¡ ÃæºĞÇÑ ´É·ÂÄ¡¸¦ °®°í ÀÖ´ÂÁö °Ë»çÇÑ´Ù. 
		
		if (1) {
			// @@ Test¿ëÀ¸·Î ÀÏ´Ü ¹«Á¶°Ç »ç¿ëÀÌ °¡´ÉÇÏ°Ô ¸¸µç´Ù. 
			m_pClientList[iClientH]->m_cSkillMastery[iRet]++;
	
			// ±â¼úÀ» ¹è¿ü´Ù´Â ¸Ş½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_SKILLTRAINSUCCESS;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// ±â¼ú ·¹º§ .
			*cp = m_pClientList[iClientH]->m_cSkillMastery[iRet];
			cp++;

			// ±â¼ú¹øÈ£
			*cp = iRet;
			cp++;

			memcpy(cp, cSkillName, 20);
			cp += 20;

			// Á¤º¸ Àü¼Û 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 28);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Ş½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ıÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {
			// Á¶°ÇÀÌ ¸¸Á·µÇÁö ¾Ê¾Æ ¸¶¹ıÀ» ¹è¿ï ¼ö ¾ø´Ù.
			// ¸¶¹ıÀ» ¹è¿ï¼ö ¾ø¾ú´Ù´Â ¸Ş½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_SKILLTRAINFAIL;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// ½ÇÆĞÀÌÀ¯.
			*cp = 1;
			cp++;

			// ±â¼ú¹øÈ£
			*cp = iRet;
			cp++;

			memcpy(cp, cSkillName, 20);
			cp += 20;

			// Á¤º¸ Àü¼Û 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 28);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Ş½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ıÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
	}
	*/
}


int CGame::_iGetSkillNumber(char * pSkillName)
{
 register int i;
 char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pSkillName);

	for (i = 1; i < DEF_MAXSKILLTYPE; i++) 
	if (m_pSkillConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pSkillConfigList[i]->m_cName, 20) == 0) {
			// Â°Â°Ã€Âº Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ Â±Ã¢Â¼Ãº Â¼Â³ÃÂ¤Ã€Â» ÃƒÂ£Â¾Ã’Â´Ã™. Â±Ã¢Â¼Ãº Â¹Ã¸ÃˆÂ£Â¸Â¦ Â¹ÃÃˆÂ¯Ã‡Ã‘Â´Ã™.
			return i;
		}
	}
	
	return 0;
}

BOOL CGame::bPlayerItemToBank(int iClientH, short sItemIndex)
{
 register int i, iIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		iIndex = i;
		goto NEXT_STEP_PLTB;
	}
	// Â´ÃµÃ€ÃŒÂ»Ã³ Ã€ÃºÃ€Ã¥Ã‡Ã’ Â°Ã¸Â°Â£Ã€ÃŒ Â¾Ã¸Â´Ã™. 
	return FALSE;

NEXT_STEP_PLTB:;

	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€ÃºÃ€Ã¥Ã‡Ã’ Â°Ã¸Â°Â£Ã€ÃŒ Â³Â²Â¾Ã†Ã€Ã–Â´Ã™. 
	// Â¸Ã•Ã€Ãº Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™Â¸Ã© Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
	ReleaseItemHandler(iClientH, sItemIndex, TRUE);

	// Â¾Ã†Ã€ÃŒÃ…Ã› Ã…Â¬Â·Â¡Â½ÂºÃ€Ã‡ ÃÃ–Â¼Ã’Â¸Â¦ Â¹Ã™Â²Ã›Â´Ã™. 
	m_pClientList[iClientH]->m_pItemInBankList[iIndex] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
	// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã® Â¾Ã†Ã€ÃŒÃ…Ã› Â¸Â®Â½ÂºÃ†Â®Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®Ã‡ÃÂ°Ã­ 
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

	// Â¾Ã†Ã€ÃŒÃ…Ã› Â¸Â®Â½ÂºÃ†Â®Ã€Ã‡ ÂºÃ³ Â°Ã¸Â°Â£Ã€Â» Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
	for (i = 1; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i-1] == NULL) && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
		m_pClientList[iClientH]->m_pItemList[i-1]       = m_pClientList[iClientH]->m_pItemList[i];	
		m_pClientList[iClientH]->m_bIsItemEquipped[i-1] = m_pClientList[iClientH]->m_bIsItemEquipped[i];	
		m_pClientList[iClientH]->m_pItemList[i]   = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
	}

	return TRUE;
}



BOOL CGame::bBankItemToPlayer(int iClientH, short sItemIndex)
{
 register int i, iIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	
	if (m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] == NULL) return FALSE;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
		iIndex = i;
		goto NEXT_STEP_PLTB;
	}
	// Â´ÃµÃ€ÃŒÂ»Ã³ Â°Â®Â°Ã­Ã€Ã–Ã€Â» Â°Ã¸Â°Â£Ã€ÃŒ Â¾Ã¸Â´Ã™. 
	return FALSE;

NEXT_STEP_PLTB:;

	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Ã’ÃÃ¶Ã‡Ã’ Â°Ã¸Â°Â£Ã€ÃŒ Â³Â²Â¾Ã†Ã€Ã–Â´Ã™. 
	
	// Â¾Ã†Ã€ÃŒÃ…Ã› Ã…Â¬Â·Â¡Â½ÂºÃ€Ã‡ ÃÃ–Â¼Ã’Â¸Â¦ Â¹Ã™Â²Ã›Â´Ã™. 
	m_pClientList[iClientH]->m_pItemList[iIndex] = m_pClientList[iClientH]->m_pItemInBankList[sItemIndex]; 
	
	m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] = NULL;

	return TRUE;
}



BOOL CGame::__bReadMapInfo(int iMapIndex)
{
 char * pContents, * token, * pTile,  cTxt[250], cFn[255];	 
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iTeleportLocIndex  = 0;
 int  iWayPointCfgIndex  = 0;
 int  iTotalNpcSetting   = 0;
 int  iMGARCfgIndex      = 0;
 int  iSMGRCfgIndex      = 0;
 int  iNMRCfgIndex       = 0;
 int  iFishPointIndex 	 = 0;
 int  iMineralPointIndex = 0;
 int  iStrategicPointIndex = 0;
 int  iIndex = 0;

 int  iNamingValue;
 class CStrTok * pStrTok;
 HANDLE hFile;
 DWORD  dwFileSize, dwReadSize;
 FILE * pFile;

 char cName[6], cNpcName[21], cNpcMoveType, cNpcWaypointIndex[10], cNamePrefix, cMapIndex;
 short sIPindex, dX, dY;

	// Â»Ã§Ã…ÃµÃ€Ã¥Ã€ÃÃÃ¶Â¸Â¦ Ã†Ã‡Â´Ãœ.
	if (memcmp(m_pMapList[iMapIndex]->m_cName, "fightzone", 9) == 0) 
		m_pMapList[iMapIndex]->m_bIsFightZone = TRUE;

	if (memcmp(m_pMapList[iMapIndex]->m_cName, "icebound", 8) == 0) 
		m_pMapList[iMapIndex]->m_bIsSnowEnabled = TRUE;

	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn, "mapdata\\");
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");
	
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return FALSE;
	dwFileSize = GetFileSize(hFile, NULL);
	CloseHandle(hFile);


	pContents = new char[dwFileSize+1];
	ZeroMemory(pContents, dwFileSize+1);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// Â¸ÃŠ ÃÂ¤ÂºÂ¸Ã†Ã„Ã€ÃÃ€Â»  Ã€ÃÃ€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.
		wsprintf(cTxt, "(!) Cannot open file : %s", cFn);
		PutLogList(cTxt);
		return FALSE;
	}
	else {
		wsprintf(cTxt, "(!) Reading Map info file : %s", cFn);
		PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® Â¼Ã’Â½Âº ÃÃ‚Ã‡Â¥ X  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 1 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcX = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® Â¼Ã’Â½Âº ÃÃ‚Ã‡Â¥ Y 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 2 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcY = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® Â¸Ã±Ã€Ã»ÃÃ¶ Â¸ÃŠ Ã€ÃŒÂ¸Â§ 
					ZeroMemory(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, 
						       sizeof(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName));
					strcpy(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, token);
					cReadModeB = 4;
					break;

				case 4:
					// Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® Â¸Ã±Ã€Ã»ÃÃ¶ Ã€Â§Ã„Â¡ X 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 3 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestX = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					// Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® Â¸Ã±Ã€Ã»ÃÃ¶ Ã€Â§Ã„Â¡ Y 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 4 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestY = atoi(token);
					cReadModeB = 6;
					break;
				
				case 6:
					// Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® ÃˆÃ„ Â¹Ã¦Ã‡Ã¢  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 5 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDir = atoi(token);
					iTeleportLocIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 2:
				switch (cReadModeB) {
				case 1:
					// waypoint Â¹Ã¸ÃˆÂ£   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 6 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iWayPointCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x != -1) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃ‡Â¾Ã®Ã€Ã–Â´Ã‚ Waypoint Â¹Ã¸ÃˆÂ£Ã€ÃŒÂ´Ã™.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 7 - Duplicated waypoint");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;
				
				case 2:
					// waypoint ÃÃ½Ã‡Ã• ÃÂ¤Ã€Ã‡ X  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 8 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// waypoint ÃÃ½Ã‡Ã• ÃÂ¤Ã€Ã‡ Y  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 9 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 3:
				// NpcÂ¸Â¦ Ã†Â¯ÃÂ¤Ã€Â§Ã„Â¡Â¿Â¡ Ã€Â§Ã„Â¡Â½ÃƒÃ…Â²Â´Ã™.
				switch (cReadModeB) {
				case 1:
					// NPCÃ€Ã‡ Ã€ÃŒÂ¸Â§. 
					ZeroMemory(cNpcName, sizeof(cNpcName));
					strcpy(cNpcName, token);
					cReadModeB = 2;
					break;
				case 2:
					// NpcMoveType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 10 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cNpcMoveType = atoi(token);
					cReadModeB = 3;
					break;
				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 11 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cNpcWaypointIndex[cReadModeB-3] = atoi(token);
					cReadModeB++;
					break;
				case 13:
					// cNamePrefix
					cNamePrefix = token[0];
					// Ã€ÃŒÃÂ¦ Ã€ÃŒÂ°Ã·Â¿Â¡Â¼Â­ NPCÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™. 
					
					iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
					if (iNamingValue == -1) {
						// Â´ÃµÃ€ÃŒÂ»Ã³ Ã€ÃŒ Â¸ÃŠÂ¿Â¡ NPCÂ¸Â¦ Â¸Â¸ÂµÃ©Â¼Ã¶ Â¾Ã¸Â´Ã™. Ã€ÃŒÂ¸Â§Ã€Â» Ã‡Ã’Â´Ã§Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â±Ã¢ Â¶Â§Â¹Â®.
					}
					else {
						// NPCÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™.
						ZeroMemory(cName, sizeof(cName));
						wsprintf(cName, "XX%d", iNamingValue);
						cName[0] = cNamePrefix;
						cName[1] = iMapIndex+65;
											
						if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, 0, cNpcMoveType, NULL, NULL, cNpcWaypointIndex, NULL, NULL, -1, FALSE) == FALSE) {
							// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â¿Â¹Â¾Ã ÂµÃˆ NameValueÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
							m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
						} 
					}
					cReadModeA = 0;
					cReadModeB = 0;
					iTotalNpcSetting++;
					break;
				}
				break;

			case 4:
				switch (cReadModeB) {
				case 1:
					// Random-Mob-Generator Â»Ã§Â¿Ã« Â¿Â©ÂºÃ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bRandomMobGenerator = (BOOL)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// Mob- Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 5:
				// Maximum object
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 6:
				// Ã„Â³Â¸Â¯Ã…Ã Â·Â£Â´Ã½ Â»Ã½Â¼Âº Â±ÃÃÃ¶ Â±Â¸Â¿Âª : Â¸Â¶Ã€Â» ÃÃŸÂ½Ã‰ÂºÃ Â°Â°Ã€ÂºÂµÂ¥Â¼Â­ Â¸Ã·Ã€ÃŒ Â¹ÃŸÂ»Ã½ÂµÃ‡Â¸Ã© Â°Ã¯Â¶ÃµÃ‡ÃÂ¹Ã‡Â·Ã 
				switch (cReadModeB) {
				case 1:
					// Rect Â¹Ã¸ÃˆÂ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iMGARCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left != -1) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃ‡Â¾Ã®Ã€Ã–Â´Ã‚ Waypoint Â¹Ã¸ÃˆÂ£Ã€ÃŒÂ´Ã™.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeB = 2;
					break;

				case 2:
					// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 7:
				// Ã†Â¯ÃÂ¤ÃÃ¶Â¿Âª Â¸Ã· Â»Ã½Â¼Âº 
				switch (cReadModeB) {
				case 1:
					// Rect Â¹Ã¸ÃˆÂ£ m_stSpotMobGenerator[]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iSMGRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined == TRUE) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃ‡Â¾Ã®Ã€Ã–Â´Ã‚ Â¸Ã· ÃÂ¦Â³ÃŠÂ·Â¹Ã€ÃŒÃ…Ã Â¹Ã¸ÃˆÂ£Ã€ÃŒÂ´Ã™.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error - ");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = TRUE;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 1)
						cReadModeB = 3;
					else if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 2)
						cReadModeB = 9;  // RECTÂ°Â¡ Â¾Ã†Â´ÃÂ¶Ã³ WaypointÃÃ½Ã‡Ã•Ã€Â» Ã€ÃÂ¾Ã®Â¾ÃŸ Ã‡Ã‘Â´Ã™.
					break;

				case 3:
					// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 23 - Wrong Data format(SMGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// Max Mobs
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
					cReadModeB++;
			   		break;

				case 19:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
			  	}
				break;

			case 8:
				// Â¸ÃŠÃ€ÃŒ Â¼Ã“Ã‡Ã‘ Ã€Ã¥Â¼Ã’ Ã€ÃŒÂ¸Â§ 
				ZeroMemory(m_pMapList[iMapIndex]->m_cLocationName, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
				memcpy(m_pMapList[iMapIndex]->m_cLocationName, token, 10);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 9:
				switch (cReadModeB) {
				case 1:
					// Initial-Point Index
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32:1 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					sIPindex = atoi(token);
					if (m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Duplicate Initial Point Index!");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;
				
				case 2:
					// Initial-Point X
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Initial-Point Y
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 33 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
		
			case 10:
				// Â°Ã¸Â°Ã Â¹Â«ÃˆÂ¿ÃˆÂ­ Â¿ÂµÂ¿Âª RECT
				switch (cReadModeB) {
				case 1:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 34 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iNMRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top != -1) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃ‡Â¾Ã®Ã€Ã–Â´Ã‚ No-Magic-Rect Â¹Ã¸ÃˆÂ£Ã€ÃŒÂ´Ã™.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 35 - Duplicate No-Magic-Rect number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 36 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 37 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 38 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 39 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 11:
				m_pMapList[iMapIndex]->m_bIsFixedDayMode = (BOOL)atoi(token);
				if (m_pMapList[iMapIndex]->m_bIsFixedDayMode == TRUE)
					m_pMapList[iMapIndex]->m_bIsSnowEnabled = FALSE;
				cReadModeA = 0;
				break;

			case 12:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 40 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iFishPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x != -1) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃ‡Â¾Ã®Ã€Ã–Â´Ã‚ Fish Point Â¹Ã¸ÃˆÂ£Ã€ÃŒÂ´Ã™.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 41 - Duplicate FishPoint number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalFishPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 42 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 43 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 44 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxFish = atoi(token);

				cReadModeA = 0;
				break;

			case 14:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 45 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cType = atoi(token);

				cReadModeA = 0;
				break;

			case 15:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 46 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 16:
				// Â±Â¤Â¹Â° ÃÂ¦Â³Ã—Â·Â¹Ã€ÃŒÃ…ÃÃ€Ã‡ ÃÂ¸Ã€Ã§Ã€Â¯Â¹Â«Â¿Ã ÂµÃ®Â±Ã 
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 47 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bMineralGenerator = (BOOL)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 48 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 17:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 49 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iMineralPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x != -1) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃ‡Â¾Ã®Ã€Ã–Â´Ã‚ Mineral Point Â¹Ã¸ÃˆÂ£Ã€ÃŒÂ´Ã™.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 50 - Duplicate MineralPoint number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalMineralPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 51 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 52 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 18:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 53 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxMineral = atoi(token);

				cReadModeA = 0;
				break;

			case 19:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 54 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iUpperLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 20:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 55 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iStrategicPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] != NULL) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃ‡Â¾Ã®Ã€Ã–Â´Ã‚ Strategic Point Â¹Ã¸ÃˆÂ£Ã€ÃŒÂ´Ã™.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 56 - Duplicate Strategic Point number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] = new class CStrategicPoint;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 57 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iSide = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 58 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iValue = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 59 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iX = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 60 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 21:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 61 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType != NULL) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃ‡Â¾Ã®Ã€Ã–Â´Ã‚ Energy-Sphere-Creation Point Â¹Ã¸ÃˆÂ£Ã€ÃŒÂ´Ã™.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 62 - Duplicate EnergySphereCreation number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 63 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 64 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 65 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 22:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 66 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult != NULL) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃ‡Â¾Ã®Ã€Ã–Â´Ã‚ Energy-Sphere-Goal Point Â¹Ã¸ÃˆÂ£Ã€ÃŒÂ´Ã™.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 67 - Duplicate EnergySphereGoal number(%d:%d)", iIndex, m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 68 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 69 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 70 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenY = atoi(token);
					
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 71 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineX = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 72 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineY = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 23:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 73 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (strlen(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName) != NULL) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃ‡Â¾Ã®Ã€Ã–Â´Ã‚  Point Â¹Ã¸ÃˆÂ£Ã€ÃŒÂ´Ã™.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 74 - Duplicate Strike Point number(%d)", iIndex);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 75 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dX = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 76 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dY = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iHP = atoi(token);
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iInitHP = atoi(token);
					cReadModeB = 5;
					break;


				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[0] = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[0] = atoi(token);
					
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[1] = atoi(token);
					
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[1] = atoi(token);
					
					cReadModeB = 9;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[2] = atoi(token);
					
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[2] = atoi(token);
					
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[3] = atoi(token);
					
					cReadModeB = 12;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[3] = atoi(token);
					
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[4] = atoi(token);
					
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[4] = atoi(token);
					
					cReadModeB = 15;
					break;

				case 15:
					ZeroMemory(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName));
					strcpy(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, token);
					
					m_pMapList[iMapIndex]->m_iTotalStrikePoints++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break; // end 23

			case 24:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (strlen(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName) != NULL) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Item-Event ¹øÈ£ÀÌ´Ù.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 79 - Duplicate Item-Event number(%d:%s)", iIndex, m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalItemEvents++;
					cReadModeB = 2;
					break;
				
				case 2:
					strcpy(m_pMapList[iMapIndex]->m_stItemEventList[iIndex].cItemName, token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 81 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iAmount = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 82 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iTotalNum = atoi(token);
					
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iMonth = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 83 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stItemEventList[iIndex].iDay = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 25: //mobevent-amount
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 78 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->sMobEventAmount = atoi(token);
					cReadModeB = 0;
					break;
				}
				break;

			case 26: //ApocalypseMobGenType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMobGenType - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iApocalypseMobGenType = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 27: // ApocalypseBossMob
				switch (cReadModeB) {
				case 1: // 3CB6Ch m_pMapList[]->m_ApocalypseBossMobNpcID
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_iApocalypseBossMobNpcID = atoi(token);
					cReadModeB = 2;					
					break;
				case 2: // 3CB70h m_pMapList[]->ApocalypseBossMobRectX1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRectX1 = atoi(token);
					cReadModeB = 3;					
					break;
				case 3: // 3CB74h m_pMapList[]->ApocalypseBossMobRectY1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRectY1 = atoi(token);
					cReadModeB = 4;					
					break;
				case 4: // 3CB78h m_pMapList[]->ApocalypseBossMobRectX2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRectX2 = atoi(token);
					cReadModeB = 5;					
					break;
				case 5: // 3CB7Ch m_pMapList[]->ApocalypseBossMobRectY2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sApocalypseBossMobRectY2 = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;					
					break;
				}
				break;

			case 28: //DynamicGateType // 28
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error DynamicGateType - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cDynamicGateType = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
								
			case 29: //DynamicGateCoord // 29
				// DynamicGateCoord	= 59 196 60 197        abaddon	   -1  -1
				switch (cReadModeB) {
				case 1: // 3CA20h
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX1 = atoi(token);
					cReadModeB = 2;
					break;

				case 2: // 3CA24h
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY1 = atoi(token);
					cReadModeB = 3;
					break;

				case 3: // 3CA28h
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectX2 = atoi(token);
					cReadModeB = 4;
					break;

				case 4: // 3CA2Ch
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordRectY2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5: // 3CA30h
					memcpy(m_pMapList[iMapIndex]->m_cDynamicGateCoordDestMap, token, strlen(token));
					cReadModeB = 6;
					break;

				case 6: // 3CA3Ch
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtX = atoi(token);
					cReadModeB = 7;
					break;

				case 7: // (ty = 3CB60h) unknown (3CA3Eh)
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseBossMob - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_sDynamicGateCoordTgtY = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 30: // RecallImpossible // 30
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error RecallImpossible -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsRecallImpossible = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 31: // ApocalypseMap // 31
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error ApocalypseMap -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsApocalypseMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
			
			case 32: // CitizenLimit // 32
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsCitizenLimit = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;
					
			case 33: // HeldenianMap
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error CitizenLimit -  Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_bIsHeldenianMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 34: // HeldenianTower
				switch (cReadModeB) {
				case 1: // NpcID
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian tower type id - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].sTypeID = atoi(token);
					cReadModeB = 2;
					break;
				case 2: // side 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Side - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].cSide = atoi(token);
					cReadModeB = 3;
					break;
				case 3: // sX
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower X pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianTower[iIndex].dX = atoi(token);
					cReadModeB = 4;
					break;
				case 4: // sY
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Tower Y pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 35: // HeldenianModeMap
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cHeldenianModeMap = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 36: // HeldenianWinningZone
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					dX = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Hedenian Map Mode - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					dY = atoi(token);
					pTile = 0;
					pTile = (char *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
					if (pTile == 0) {
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map Info file error HeldenianWinningZone - pTile is Null dx(%d), dy(%d).", dX, dY);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					//pTile->m_iAttribute = 1;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 37: // HeldenianGateDoor // 37
				switch (cReadModeB) {
				case 1: 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Direction - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].cDir = atoi(token);
					cReadModeB = 2;
					break;
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door X pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dX = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error Heldenian Door Y pos - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stHeldenianGateDoor[iIndex].dY = atoi(token);
					iIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "teleport-loc", 12) == 0) {
				m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex] = new class CTeleportLoc;
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "waypoint", 8) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}

			if (memcmp(token, "npc", 3) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

			if (memcmp(token, "random-mob-generator", 20) == 0) {
				cReadModeA = 4;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "maximum-object", 14) == 0) 
				cReadModeA = 5;

			if (memcmp(token, "npc-avoidrect", 13) == 0) {
				cReadModeA = 6;
				cReadModeB = 1;
			}

			if (memcmp(token, "spot-mob-generator", 18) == 0) {
				cReadModeA = 7;
				cReadModeB = 1;
			}

			if (memcmp(token, "map-location", 12) == 0)
				cReadModeA = 8;

			if (memcmp(token, "initial-point", 13) == 0) {
				cReadModeA = 9;
				cReadModeB = 1;
			}

			if (memcmp(token, "no-attack-area", 14) == 0) {
				cReadModeA = 10;
				cReadModeB = 1;
			}

			if (memcmp(token, "fixed-dayornight-mode", 21) == 0) cReadModeA = 11;

			if (memcmp(token, "fish-point", 10) == 0) {
				cReadModeA = 12;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-fish", 8) == 0)		cReadModeA = 13;	
			if (memcmp(token, "type", 4) == 0)			cReadModeA = 14;	
			if (memcmp(token, "level-limit", 11) == 0)	cReadModeA = 15;	

			if (memcmp(token, "mineral-generator", 17) == 0) {
				cReadModeA = 16;
				cReadModeB = 1;
			}

			if (memcmp(token, "mineral-point", 13) == 0) {
				cReadModeA = 17;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-mineral", 11) == 0)			cReadModeA = 18;	
			if (memcmp(token, "upper-level-limit", 17) == 0)	cReadModeA = 19;	// v1.4
			if (memcmp(token, "strategic-point", 15) == 0) {	// v1.41
				cReadModeA = 20;	
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-creation-point", 28) == 0) {
				cReadModeA = 21;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-goal-point", 24) == 0) {
				cReadModeA = 22;
				cReadModeB = 1;
			}

			if (memcmp(token, "strike-point", 12) == 0) {
				cReadModeA = 23;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "item-event", 10) == 0) {
				cReadModeA = 24;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "energy-sphere-auto-creation", 27) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				m_pMapList[iMapIndex]->m_bIsEnergySphereAutoCreation = TRUE;
			}

			if (memcmp(token, "mobevent-amount", 15) == 0) {
				cReadModeA = 25;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseMobGenType", 20) == 0) {
				cReadModeA = 26;
				cReadModeB = 1;
			}

			if (memcmp(token, "ApocalypseBossMob", 17) == 0) {
				cReadModeA = 27;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateType", 15) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
			}

			if (memcmp(token, "DynamicGateCoord", 16) == 0) {
				cReadModeA = 29;
				cReadModeB = 1;
			}

			if (memcmp(token, "RecallImpossible", 16) == 0) {
				cReadModeA = 30;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "ApocalypseMap", 13) == 0) {
				cReadModeA = 31;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "CitizenLimit", 12) == 0) {
				cReadModeA = 32;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianMap", 12) == 0) {
				cReadModeA = 33;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianTower", 14) == 0) {
				cReadModeA = 34;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianModeMap", 16) == 0) {
				cReadModeA = 35;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianWinningZone", 20) == 0) {
				cReadModeA = 36;
				cReadModeB = 1;
			}

			if (memcmp(token, "HeldenianGateDoor", 17) == 0) {
				cReadModeA = 37;
				cReadModeB = 1;
			}

			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = pStrTok->pGet();
	}	

RMI_SKIPDECODING:;

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! map info file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) Map info file decoding(%s) - success! TL(%d) WP(%d) LNPC(%d) MXO(%d) RMG(%d / %d)", cFn, iTeleportLocIndex, iWayPointCfgIndex, iTotalNpcSetting, m_pMapList[iMapIndex]->m_iMaximumObject, m_pMapList[iMapIndex]->m_bRandomMobGenerator, m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel);
	PutLogList(cTxt);

	// Crusade Â°Ã¸Â°Ã ÂºÃ’Â°Â¡Â´Ã‰ Â¿ÂµÂ¿ÂªÃ€Â» Ã…Â¸Ã€ÃÂ¿Â¡ Ã‡Â¥Â½ÃƒÃ‡Ã‘Â´Ã™.
	m_pMapList[iMapIndex]->_SetupNoAttackArea();

	return TRUE;

}

void CGame::Quit()
{
 int i;	

	// Â¾Â²Â·Â¹ÂµÃ¥Â¸Â¦ ÃÃ—Ã€ÃÂ´Ã™.
	G_bIsThread = FALSE;
	Sleep(300);
		
	if (m_pMainLogSock != NULL) delete m_pMainLogSock;
	if (m_pGateSock != NULL) delete m_pGateSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
	if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
	if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
	if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
	if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
	if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
	if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
	if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
	if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];

//	for (i = 0; i < DEF_MAXTELEPORTTYPE; i++)
//	if (m_pTeleportConfigList[i] != NULL) delete m_pTeleportConfigList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != NULL) delete m_pDupItemIDList[i];

	if (m_pNoticementData != NULL) delete m_pNoticementData;

}

int CGame::iGetLevelExp(int iLevel)
{
 int iRet;
	
	if (iLevel == 0) return 0;
	
	iRet = iGetLevelExp(iLevel - 1) + iLevel * ( 50 + (iLevel * (iLevel / 17) * (iLevel / 17) ) );

	return iRet;
}

int CGame::_iCalcSkillSSNpoint(int iLevel)
{
 int iRet;

	if (iLevel < 1) return 1;
	
	if (iLevel <= 50) 
		iRet = iLevel;
	else if (iLevel > 50) {
		iRet = ( iLevel * iLevel ) / 10;
	}

	return iRet;
}

BOOL CGame::bCheckLevelUp(int iClientH)
{
 BOOL bStr, bVit, bDex, bInt, bMag, bChr;
 char cLoopCnt;
 int bobdole;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	// ÃƒÃ–Â´Ã« Â·Â¹ÂºÂ§ ÃÂ¦Ã‡Ã‘ 
	if (m_pClientList[iClientH]->m_iLevel >= m_iPlayerMaxLevel) return FALSE;
	if (m_pClientList[iClientH]->m_iExp < m_pClientList[iClientH]->m_iNextLevelExp) return FALSE;
	
	bStr = bVit = bDex = bInt = bMag = bChr = FALSE;
	// Â¸Â¸Â¾Ã  ÃƒÂ¼Ã‡Ã¨Ã†Ã‡ Â»Ã§Â¿Ã«Ã€ÃšÂ¶Ã³Â¸Ã© Â·Â¹ÂºÂ§ 10Ã€ÃŒÂ»Ã³Ã€Ã‡ Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â°Â¡ÃÃºÂ¼Ã¶Â´Ã‚ Â¾Ã¸Â´Ã™. Account Status: 1-ÃƒÂ¼Ã‡Ã¨Ã†Ã‡ Â»Ã§Â¿Ã«Ã€Ãš  2-ÃÂ¤Â½Ã„ Â»Ã§Â¿Ã«Ã€Ãš 3-ÃÂ¤Â½Ã„ Â»Ã§Â¿Ã«Ã€Ãš Â»Ã§Â¿Ã«ÃÃŸÃÃ¶ 
	cLoopCnt = 0;
	while (1) {
		if (cLoopCnt++ > 100) return FALSE; // Â¹Â«Â¾Ã°Â°Â¡ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡Ã‘ Â°Ã Â°Â°Â´Ã™. Ã‡Ã˜Ã…Â·ÂµÃ®Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Ã†Ã„Ã€Ã ÃÂ¶Ã€Ã› 
		if (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp) {
			// Â·Â¹ÂºÂ§Ã€ÃŒ Â¿ÃƒÂ¶ÃºÂ´Ã™.
			m_pClientList[iClientH]->m_iLevel++;
			m_pClientList[iClientH]->m_iLU_Pool += 3;
			// Â·Â¹ÂºÂ§Ã€ÃŒ Â¿Ã€Â¸Â¥Â°ÃÂ¿Â¡ Â´Ã«Ã‡Ã‘ Ã†Â¯Â¼ÂºÃ„Â¡ Ã†Ã·Ã€ÃÃ†Â®Â¸Â¦ ÃÃµÂ°Â¡Â½ÃƒÃ„Ã‘Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
//			if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
//	  		      m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) <= DEF_TOTALLEVELUPPOINT) {
				// Â·Â¹ÂºÂ§ Â¾Ã· Â¼Â¼Ã†ÃƒÃ€ÃŒ 3ÂºÂ¸Â´Ã™ Â°Â°Â°Ã…Â³Âª Ã€Ã›Â¾Ã†Â¾ÃŸ Ã€Â¯ÃˆÂ¿Ã‡ÃÂ´Ã™. 

/*
				if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iStr  += m_pClientList[iClientH]->m_cLU_Str;
					bStr = TRUE;
				}
				if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iVit  += m_pClientList[iClientH]->m_cLU_Vit;
					bVit = TRUE;
				}
				if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iDex  += m_pClientList[iClientH]->m_cLU_Dex;
					bDex = TRUE;
				}
				if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iInt  += m_pClientList[iClientH]->m_cLU_Int;
					bInt = TRUE;
				}
				if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iMag  += m_pClientList[iClientH]->m_cLU_Mag;
					bMag = TRUE;
				}
				if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iCharisma += m_pClientList[iClientH]->m_cLU_Char;
					bChr = TRUE;
				}
				*/
//			}

			// Â¼Â³ÃÂ¤Ã„Â¡Â¸Â¦ ÃˆÂ®Ã€ÃÃ‡Ã‘Â´Ã™. 
			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iStr = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iDex = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iVit = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iInt = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iMag = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iCharisma = DEF_CHARPOINTLIMIT;

			// New 17/05/2004
			if (m_pClientList[iClientH]->m_iLevel > 100)
				if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
					ForceChangePlayMode(iClientH, TRUE);

			// Â·Â¹ÂºÂ§Ã€ÃŒ Â¿Ã€Â¸Â¥Â°ÃÃ€Â» Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);

			// Â´Ã™Ã€Â½ Â·Â¹ÂºÂ§Â·ÃÃ€Ã‡ Â°Ã¦Ã‡Ã¨Ã„Â¡Â°Âª Â°Ã¨Â»Ãª, Ã‡Ã’Â´Ã§.
			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);
		
			// Ã†Â¯Â¼ÂºÃ„Â¡ Ã€Ã§ Â°Ã¨Â»Ãª. 
			CalcTotalItemEffect(iClientH, -1, FALSE);

			//v1.4 Â´Ã™Ã€Â½ Â·Â¹ÂºÂ§ 
			wsprintf(G_cTxt, "(!) Level up: Player (%s) Level (%d) Experience(%d) Next Level Experience(%d)", m_pClientList[iClientH]->m_cCharName,m_pClientList[iClientH]->m_iLevel, m_pClientList[iClientH]->m_iExp, m_pClientList[iClientH]->m_iNextLevelExp);
			PutLogFileList(G_cTxt);
		}
		else { return TRUE; }
	}
	bobdole = 3;
	return FALSE;
}
// 2003-04-14 ÃÃ¶ÃÂ¸ Ã†Ã·Ã€ÃÃ†Â®Â¸Â¦ Â·Â¹ÂºÂ§ Â¼Ã¶ÃÂ¤Â¿Â¡ Â¾ÂµÂ¼Ã¶ Ã€Ã–Â´Ã™...
/////////////////////////////////////////////////////////////////////////////////////
//  StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize)
//  desc		 :: ÃÃ¶ÃÂ¸Ã†Ã·Ã€ÃÃ†Â®Â¸Â¦ Â·Â¹ÂºÂ§Â¾Ã· Ã†Ã·Ã€ÃÃ†Â®Â·Ã ÂµÂ¹Â¸Â°Â´Ã™...
//	return value :: void
//  date		 :: [2003-04-14]    stupid koreans
/////////////////////////////////////////////////////////////////////////////////////
void CGame::StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cStateChange1, cStateChange2, cStateChange3;
 char cStr, cVit, cDex, cInt, cMag, cChar;
 char cStateTxt[512];
 int iOldStr, iOldVit, iOldDex, iOldInt, iOldMag, iOldChar;
 int iTotalSetting = 0;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;

	cStr = cVit = cDex = cInt = cMag = cChar = 0;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cStateChange1 = *cp;
	cp++;

	cStateChange2 = *cp;
	cp++;

	cStateChange3 = *cp;
	cp++;

	iOldStr	= m_pClientList[iClientH]->m_iStr;
	iOldVit	= m_pClientList[iClientH]->m_iVit;
	iOldDex = m_pClientList[iClientH]->m_iDex;
	iOldInt = m_pClientList[iClientH]->m_iInt;
	iOldMag = m_pClientList[iClientH]->m_iMag;
	iOldChar = m_pClientList[iClientH]->m_iCharisma;
	
	
	wsprintf(G_cTxt, "(*) Char(%s) Str(%d) Vit(%d) Dex(%d) Int(%d) Mag(%d) Chr(%d) ", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iStr, m_pClientList[iClientH]->m_iVit, m_pClientList[iClientH]->m_iDex, m_pClientList[iClientH]->m_iInt, m_pClientList[iClientH]->m_iMag, m_pClientList[iClientH]->m_iCharisma);
	PutLogList(G_cTxt);
//	wsprintf(G_cTxt, "(*)   ");
//	PutLogList(G_cTxt);
//	wsprintf(G_cTxt, "(*) Char(%s) Str(%d) Vit(%d) Dex(%d) Int(%d) Mag(%d) Chr(%d) ", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iStr, m_pClientList[iClientH]->m_iVit, m_pClientList[iClientH]->m_iDex, m_pClientList[iClientH]->m_iInt, m_pClientList[iClientH]->m_iMag, m_pClientList[iClientH]->m_iCharisma,  );
//	PutLogList(G_cTxt);
	
	
	if(!bChangeState(cStateChange1,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{
		//Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â¼Â­ Â°ÂªÃ€Â» Ã€ÃŸÂ¸Ã¸ ÂºÂ¸Â³Â»Â¿Ã‚ÂµÃ­...
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if(!bChangeState(cStateChange2,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{
		//Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â¼Â­ Â°ÂªÃ€Â» Ã€ÃŸÂ¸Ã¸ ÂºÂ¸Â³Â»Â¿Ã‚ÂµÃ­...
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if(!bChangeState(cStateChange3,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{
		//Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â¼Â­ Â°ÂªÃ€Â» Ã€ÃŸÂ¸Ã¸ ÂºÂ¸Â³Â»Â¿Ã‚ÂµÃ­...
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	//Â±Ã¦ÂµÃ¥ Â¸Â¶Â½ÂºÃ…ÃÂ¸Ã© cCharÂ¸Â¦ Â¸Ã¸ Â³Â»Â¸Â°Â´Ã™..
	if(m_pClientList[iClientH]->m_iGuildRank == 0 )
	{
		if(m_pClientList[iClientH]->m_iCharisma - cChar < 20)
		{
			//Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â¼Â­ Â°ÂªÃ€Â» Ã€ÃŸÂ¸Ã¸ ÂºÂ¸Â³Â»Â¿Ã‚ÂµÃ­...
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}
	}

	//Ã†Â¯Â¼ÂºÃ„Â¡ Â°ÂªÃ€ÃŒ Â·Â¹ÂºÂ§Â°Ãº Â¸Ã‚ÃÃ¶ Â¾ÃŠÂ´Ã™Â¸Ã© Â³Â»Â¸Â±Â¼Ã¶ Â¾Ã¸Â´Ã™..
	if(iOldStr +iOldVit	+iOldDex +iOldInt +iOldMag +iOldChar != (179*3 + 70))
	{
		//Ã‡Ã˜Ã…Â·Ã€ÃŒÂ´Ã™... Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â¼Â­ Â¸Ã¸ÂºÂ¸Â³Â»Â°Ã” ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™ Â±Ã™ÂµÂ¥ Â¿Ã”Â´Ã™Â¸Ã© Ã‡Ã˜Ã…Â·...
		return;
	}


	if(cStr < 0 || cVit < 0 || cDex < 0 || cInt < 0 || cMag < 0 || cChar < 0
		|| cStr + cVit + cDex + cInt + cMag + cChar != 3)
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	// Ã†Â¯Â¼ÂºÃ„Â¡Â°ÂªÃ€ÃŒ 10Ã€ÃŒÃ‡ÃÂ·Ã Â¸Ã¸Â³Â»Â·Ã Â°Â£Â´Ã™... ÃÂ¦Ã‡Ã‘Ã€Â» Â³Ã‘Ã€Â»Â¼Ã¶ÂµÂµ Â¾Ã¸Â´Ã™...
	if ((m_pClientList[iClientH]->m_iStr - cStr > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iStr - cStr < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iDex - cDex > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iDex - cDex < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iInt - cInt > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iInt - cInt < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iVit - cVit > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iVit - cVit < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iMag - cMag > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iMag - cMag < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iCharisma - cChar > DEF_CHARPOINTLIMIT)
		 || (m_pClientList[iClientH]->m_iCharisma - cChar < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if (m_pClientList[iClientH]->m_iLU_Pool < 3) m_pClientList[iClientH]->m_iLU_Pool = 3;

	// Â¿Ã€Â·Ã¹Â°Â¡ Â¾Ã¸Ã€Â¸Â¸Ã© Â°ÂªÃ€Â» Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™.
	//m_pClientList[iClientH]->m_iLU_Pool += 3;
	
	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;

	m_pClientList[iClientH]->m_iStr  -= cStr;
	m_pClientList[iClientH]->m_iVit  -= cVit;
	m_pClientList[iClientH]->m_iDex  -= cDex;
	m_pClientList[iClientH]->m_iInt  -= cInt;
	//2003-04-22Ã€Ã Â¸Â¶Â¹Ã½Ã€Â» Â»Ã¨ÃÂ¦ Â½ÃƒÃ…Â²Â´Ã™.... Ã€ÃÃ†Â®Â°Â¡ Â³Â»Â·ÃÂ°Â¡Â°Ã­ Â³ÂªÂ¼Â­ ÂµÂ¹Â¾Ã†Â°Â¡Â¾ÃŸ Ã‡Ã‘Â´Ã™...
	if(cInt > 0)
		bCheckMagicInt(iClientH);
	m_pClientList[iClientH]->m_iMag  -= cMag;
	m_pClientList[iClientH]->m_iCharisma -= cChar;

	ZeroMemory(cStateTxt,sizeof(cStateTxt));

	wsprintf(cStateTxt, "STR(%d->%d)VIT(%d->%d)DEX(%d->%d)INT(%d->%d)MAG(%d->%d)CHARISMA(%d->%d)",
		iOldStr, m_pClientList[iClientH]->m_iStr,
		iOldVit, m_pClientList[iClientH]->m_iVit,
		iOldDex, m_pClientList[iClientH]->m_iDex,
		iOldInt, m_pClientList[iClientH]->m_iInt,
		iOldMag, m_pClientList[iClientH]->m_iMag,
		iOldChar,m_pClientList[iClientH]->m_iCharisma				
		);

	//_bCustomLog(DEF_ITEMLOG_CUSTOM,iClientH,NULL,cStateTxt);

	//2003-04-22Ã€Ã Â½ÂºÃ…Â³Ã€Â» Â³Â»Â·ÃÂ°Â¡Â°Ã” Ã‡Ã‘Â´Ã™... 
	//bCheckSkillState(iClientH);

	//Â¼ÂºÂ°Ã¸..!!!
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
}

// 2003-04-21 Ã€ÃÃ†Â®Â¿Â¡ ÂµÃ»Â¸Â¥ Â¸Â¶Â¹Ã½Ã€Â» Â»Ã¨ÃÂ¦ Â½ÃƒÃ„Ã‘ÃÃ˜Â´Ã™...
/////////////////////////////////////////////////////////////////////////////////////
//  BOOL CGame::bCheckMagicInt(int iClientH)  //another retarded korean function
//  desc		 :: Ã€ÃÃ†Â®Â°Â¡ Â³Â»Â·ÃÂ°Â¬Ã€Â»Â¶Â§ Â»Ã¨ÃÂ¦Ã‡Ã’ Â¸Â¶Â¹Ã½Ã€Â» ÃƒÂ³Â¸Â®Ã‡Ã‘Â´Ã™... ÃƒÂ¼Ã…Â©Â¸Â¸...
//	return value :: Â¹Â«ÃÂ¶Â°Ã‡ TRUE   // ....dumbass koreans
//  date		 :: 2003-04-21
/////////////////////////////////////////////////////////////////////////////////////
BOOL CGame::bCheckMagicInt(int iClientH)
{

	for(int i = 0;i < DEF_MAXMAGICTYPE ;i++)
	{
		if(m_pMagicConfigList[i] != NULL)
		if(m_pMagicConfigList[i]->m_sIntLimit > m_pClientList[iClientH]->m_iInt)
		{
			m_pClientList[iClientH]->m_cMagicMastery[i] = 0;	
		}
	}

	return TRUE;
}

// 2003-04-14 ÃÃ¶ÃÂ¸ Ã†Ã·Ã€ÃÃ†Â®Â¸Â¦ Â·Â¹ÂºÂ§ Â¼Ã¶ÃÂ¤Â¿Â¡ Â¾ÂµÂ¼Ã¶ Ã€Ã–Â´Ã™...
/////////////////////////////////////////////////////////////////////////////////////
//  bChangeState(char cStateChange 
//  		  ,char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
//  desc		 :: ÃÃ¶ÃÂ¸ Ã†Ã·Ã€ÃÃ†Â®Â·Ã Ã†Â¯Â¼ÂºÂ°Âª Â¹Ã™Â²ÃœÆ’â€Ã€Â» Â´ÃµÃ‡Ã˜ ÃÃ˜Â´Ã™...
//	return value :: BOOLÃ‡Ã¼ 0(FASLE) Â¿Â¡Â·Â¯ Â·Â¹ÂºÂ§ Â¼Ã¶ÃÂ¤ ÂºÃ’Â°Â¡...
//  date		 :: [2003-04-14] 
/////////////////////////////////////////////////////////////////////////////////////
BOOL CGame::bChangeState(char cStateChange, char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
{
	if(cStateChange == DEF_STR)
	{
		*cStr += 1;
	}
	else if(cStateChange == DEF_VIT)
	{
		*cVit += 1;
//		if(m_pClientList[iClientH]->m_iStr - cVit < 10 || m_pClientList[iClientH]->cVit - cVit < DEF_CHARPOINTLIMIT )
//			return 0;
	}
	else if(cStateChange == DEF_DEX)
	{
		*cDex += 1;
	}
	else if(cStateChange == DEF_INT)
	{
		*cInt += 1;
	}
	else if(cStateChange == DEF_MAG)
	{
		*cMag += 1;
	}
	else if(cStateChange == DEF_CHR)
	{
		*cChar += 1;
	}
	else
	{
		//Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â°Â¡ Ã€ÃŸÂ¸Ã¸ÂµÃˆ Â°ÂªÃ€Â» ÂºÂ¸Â³Â» Â¿Ã”Â´Ã™..
//		::MessageBox(NULL, "Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â¹Ã¶Â±Ã—? - í´ë¼ì´ì–¸íŠ¸ ë²„ê·¸?","debug", MB_ICONEXCLAMATION | MB_YESNO) ;
		return 0;
	}

	return cStateChange;
}

void CGame::LevelUpSettingsHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char * cp, cStr, cVit, cDex, cInt, cMag, cChar;
	int iTotalSetting = 0;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iLU_Pool <= 0) 
	{
		//Ã‡Ã˜Ã„Â¿Ã€ÃÂ°Â¡??
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return ;
	}
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cStr = *cp;
	cp++;

	cVit = *cp;
	cp++;

	cDex = *cp;
	cp++;

	cInt = *cp;
	cp++;

	cMag = *cp;
	cp++;

	cChar = *cp;
	cp++;

//	if(m_pClientList[iClientH]->m_iLU_Pool < 3) {
//		m_pClientList[iClientH]->m_iLU_Pool = 3;
//	}


	if ( (cStr + cVit + cDex + cInt + cMag + cChar) > m_pClientList[iClientH]->m_iLU_Pool) { // -3
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
			return;
	}

	// Level-Up SettingÂ°ÂªÂ¿Â¡ Â¿Ã€Â·Ã¹Â°Â¡ Ã€Ã–Â´Ã‚ÃÃ¶ Â°Ã‹Â»Ã§Ã‡Ã‘Â´Ã™.
	if ((m_pClientList[iClientH]->m_iStr + cStr > DEF_CHARPOINTLIMIT) || (cStr < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iDex + cDex > DEF_CHARPOINTLIMIT) || (cDex < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iInt + cInt > DEF_CHARPOINTLIMIT) || (cInt < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iVit + cVit > DEF_CHARPOINTLIMIT) || (cVit < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iMag + cMag > DEF_CHARPOINTLIMIT) || (cMag < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iCharisma + cChar > DEF_CHARPOINTLIMIT) || (cChar < 0)) 
		return;

	iTotalSetting = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit + 
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	//(Â·Â¹ÂºÂ§ Ã†Â¯Â¼ÂºÂ°Âª + Â·Â¹ÂºÂ§Â¾Ã· Ã†Ã·Ã€ÃÃ†Â® > Â·Â¹ÂºÂ§Â¾Ã· Ã†Â¯Â¼ÂºÂ°Âª ÃÂ¤Â»Ã³Ã„Â¡)Â¸Ã© ÂºÃ±ÃÂ¤Â»Ã³Ã€ÃŒÂ´Ã™.. ÃƒÂ³Â¸Â® ÂºÃ’Â°Â¡.. Â·Â¹ÂºÂ§Â¾Ã· Ã†Ã·Ã€ÃÃ†Â®Â¸Â¦ ÃÂ¤Â»Ã³Ã„Â¡Â·Ã Â¸Â¶ÃƒÃŸÂ°Ã­ ÃƒÂ³Â¸Â® ÂºÃ’Â°Â¡..
	if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool -3 > ((m_pClientList[iClientH]->m_iLevel-1)*3 + 70))
	{
		int bobdole;
		bobdole = 3;
		m_pClientList[iClientH]->m_iLU_Pool = /*m_cLU_Str ÃƒÃŠÂ±Ã¢Â°Âª*/3 + (m_pClientList[iClientH]->m_iLevel-1)*3 + 70 - iTotalSetting;

		//iTotalSettingÂ°ÂªÃ€ÃŒ Ã€ÃŸÂ¸Ã¸ÂµÃˆ Â°Ã¦Â¿Ã¬Â´Ã™...
		if(m_pClientList[iClientH]->m_iLU_Pool < 3)
			m_pClientList[iClientH]->m_iLU_Pool = 3;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return ;
	}

	//(Â·Â¹ÂºÂ§ Ã†Â¯Â¼ÂºÂ°Âª + Â·Â¹ÂºÂ§Â¾Ã· Â½ÃƒÃ…Â³ Ã†Ã·Ã€ÃÃ†Â® ÃD > Â·Â¹ÂºÂ§Â¾Ã· Ã†Â¯Â¼ÂºÂ°Âª ÃÂ¤Â»Ã³Ã„Â¡)Ã€ÃŒÂ¸Ã© ÃƒÂ³Â¸Â® ÂºÃ’Â°Â¡..
	if (iTotalSetting + (cStr + cVit + cDex + cInt + cMag + cChar)
		>	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (cStr + cVit + cDex + cInt + cMag + cChar);

	// Â¿Ã€Â·Ã¹Â°Â¡ Â¾Ã¸Ã€Â¸Â¸Ã© Â°ÂªÃ€Â» Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™.
	m_pClientList[iClientH]->m_iStr  += cStr;
	m_pClientList[iClientH]->m_iVit  += cVit;
	m_pClientList[iClientH]->m_iDex  += cDex;
	m_pClientList[iClientH]->m_iInt  += cInt;
	m_pClientList[iClientH]->m_iMag  += cMag;
	m_pClientList[iClientH]->m_iCharisma += cChar;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);

}

/*
void CGame::LevelUpSettingsHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char * cp, cStr, cVit, cDex, cInt, cMag, cChar;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	m_pClientList[iClientH]->m_iLU_Pool += DEF_TOTALLEVELUPPOINT;
	wsprintf(G_cTxt, "(*) Level Up: Char(%s) Level (%d) DEF_TOTALLEVELUPPOINT (%d) m_pClientList[iClientH]->m_iLU_Pool (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iLevel, DEF_TOTALLEVELUPPOINT, m_pClientList[iClientH]->m_iLU_Pool);		
	PutLogList(G_cTxt);

	cStr = *cp;
	cp++;

	cVit = *cp;
	cp++;

	cDex = *cp;
	cp++;

	cInt = *cp;
	cp++;

	cMag = *cp;
	cp++;

	cChar = *cp;
	cp++;

	// Level-Up SettingÂ°ÂªÂ¿Â¡ Â¿Ã€Â·Ã¹Â°Â¡ Ã€Ã–Â´Ã‚ÃÃ¶ Â°Ã‹Â»Ã§Ã‡Ã‘Â´Ã™.
	if ((cStr > DEF_TOTALLEVELUPPOINT) || (cStr < 0)) 
		return;

	if ((cDex > DEF_TOTALLEVELUPPOINT) || (cDex < 0)) 
		return;

	if ((cInt > DEF_TOTALLEVELUPPOINT) || (cInt < 0)) 
		return;

	if ((cVit > DEF_TOTALLEVELUPPOINT) || (cVit < 0)) 
		return;

	if ((cMag > DEF_TOTALLEVELUPPOINT) || (cMag < 0)) 
		return;

	if ((cChar > DEF_TOTALLEVELUPPOINT) || (cChar < 0)) 
		return;

	if ( (cStr + cVit + cDex + cInt + cMag + cChar) > DEF_TOTALLEVELUPPOINT) 
		return;

	// Â¿Ã€Â·Ã¹Â°Â¡ Â¾Ã¸Ã€Â¸Â¸Ã© Â°ÂªÃ€Â» Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™.

	//m_pClientList[iClientH]->m_cLU_Str  = cStr;
	//m_pClientList[iClientH]->m_cLU_Vit  = cVit;
	//m_pClientList[iClientH]->m_cLU_Dex  = cDex;
	//m_pClientList[iClientH]->m_cLU_Int  = cInt;
	//m_pClientList[iClientH]->m_cLU_Mag  = cMag;
	//m_pClientList[iClientH]->m_cLU_Char = cChar;

	/*
	m_pClientList[iClientH]->m_cLU_Str = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Vit = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Dex = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Int = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Mag = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Char = *cp;
	cp++;

	if ((m_pClientList[iClientH]->m_cLU_Str > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Str < 0)) 
	m_pClientList[iClientH]->m_cLU_Str = 0;

	if ((m_pClientList[iClientH]->m_cLU_Vit > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Vit < 0)) 
	m_pClientList[iClientH]->m_cLU_Vit = 0;

	if ((m_pClientList[iClientH]->m_cLU_Dex > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Dex < 0)) 
	m_pClientList[iClientH]->m_cLU_Dex = 0;

	if ((m_pClientList[iClientH]->m_cLU_Int > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Int < 0)) 
	m_pClientList[iClientH]->m_cLU_Int = 0;

	if ((m_pClientList[iClientH]->m_cLU_Mag > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Mag < 0)) 
	m_pClientList[iClientH]->m_cLU_Mag = 0;

	if ((m_pClientList[iClientH]->m_cLU_Char > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Char < 0)) 
	m_pClientList[iClientH]->m_cLU_Char = 0;

	if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
	m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) > DEF_TOTALLEVELUPPOINT) {
	// Level-Up SettingÂ°ÂªÂ¿Â¡ Â¿Ã€Â·Ã¹Â°Â¡ Ã€Ã–Â´Ã™.
	m_pClientList[iClientH]->m_cLU_Str = m_pClientList[iClientH]->m_cLU_Vit = m_pClientList[iClientH]->m_cLU_Dex =  
	m_pClientList[iClientH]->m_cLU_Int = m_pClientList[iClientH]->m_cLU_Mag = m_pClientList[iClientH]->m_cLU_Char = 0;
	}
	*/
//}

// v1.4311-3 ÃƒÃŸÂ°Â¡ Â»Ã§Ã…ÃµÃ€Ã¥ Â¿Â¹Â¾Ã  Ã‡Ã”Â¼Ã¶ FightzoneReserveHandler
void CGame::FightzoneReserveHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char cData[100];
 int iFightzoneNum ,* ip ,  iEnableReserveTime ;
 DWORD * dwp, dwGoldCount ;
 WORD  * wp, wResult;
 int     iRet, iResult=1, iCannotReserveDay;
 SYSTEMTIME SysTime;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
 
	GetLocalTime(&SysTime);
	
	// Â¿Â¹Â¾Ã  Â°Â¡Â´Ã‰Ã‡Ã‘ Â½ÃƒÂ°Â£ : ÂµÃÂ½ÃƒÂ°Â£ Â°Â£Â°ÃÃ€Â¸Â·Ã Â¿Â¹Â¾Ã Ã€ÃŒ Â°Â¡Â´Ã‰Ã‡ÃÂ¸Ã§ Â»Ã§Â¿Ã«Â¿ÃÂ·Ã¡ 5ÂºÃÃ€Ã¼Â¿Â¡Â´Ã‚ Â¿Â¹Â¾Ã Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™.
	iEnableReserveTime  = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 5*20;
	
	dwGoldCount = dwGetItemCount(iClientH, "Gold");
		
	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	// Â¿Â¹Â¾Ã Ã€Â» Â¿Ã¸Ã‡ÃÂ´Ã‚ Â»Ã§Ã…ÃµÃ€Ã¥ Â¹Ã¸ÃˆÂ£Â¸Â¦ Â¹ÃÂ´Ã‚Â´Ã™.
	iFightzoneNum = *ip;

	// Ã€ÃŸÂ¸Ã¸ÂµÃˆ fightzone Â¹Ã¸ÃˆÂ£Â¸Â¦ Â°Ã‰Â·Â¯Â³Â½Â´Ã™.
	if ((iFightzoneNum < 1) || (iFightzoneNum > DEF_MAXFIGHTZONE)) return;

	// Â»Ã§Ã…ÃµÃ€Ã¥Ã€ÃŒ ÃÃŸÂºÂ¹ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ°Ã” Ã‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã˜ Â¿Ã¤Ã€ÃÂ¿Â¡ ÂµÃ»Â¶Ã³ Â»Ã§Â¿Ã«Ã‡Ã’Â¼Ã¶ Ã€Ã–Â´Ã‚ Â»Ã§Ã…ÃµÃ€Ã¥Ã€ÃŒ Â´Ã™Â¸Â£Â°Ã” Ã‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã‘ ÂºÂ¯Â¼Ã¶Â´Ã™.
	// ÃˆÂ¦Â¼Ã¶Â³Â¯Â¿Â¡Â´Ã‚ Â¾Ã†Â·Â¹Â½ÂºÂµÂ§ 2 4 6 8 Â¿Â¤Â¹Ã™Ã€ÃÃ€ÃŒ 1 3 5 7  Â»Ã§Ã…ÃµÃ€Ã¥Ã€ÃŒ Â»Ã§Â¿Ã«Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™ 
    //             ex) 1Ã€ÃÃ€ÃÂ°Ã¦Â¿Ã¬ => {1 + 1 (Â¾Ã†Â·Â¹Â½ÂºÂµÂ§) + 1 (Â»Ã§Ã…ÃµÃ€Ã¥ Â¹Ã¸ÃˆÂ£ )} %2 == 1 Ã€ÃŒÂ¹Ã‡Â·Ã 
	//                            Â¾Ã†Â·Â¹Â½ÂºÂµÂ§Ã€Âº ÃˆÂ¦Â¼Ã¶Â³Â¯ ÃˆÂ¦Â¼Ã¶ Â»Ã§Ã…ÃµÃ€Ã¥Ã€Â»  Â¿Â¹Â¾Ã  Ã‡Ã’Â¼Ã¶ Â¾Ã¸Â´Ã™. 

	iCannotReserveDay = (SysTime.wDay + m_pClientList[iClientH]->m_cSide + iFightzoneNum ) % 2 ;
	if (iEnableReserveTime <= 0 ){
		// Â¿Â¹Â¾Ã Â¿Â¡ Â½Ã‡Ã†ÃÃ‡ÃŸÂ´Ã™. 
		// Â¸Â¸Â¾Ã  Â¿Â¹Â¾Ã  Â°Â¡Â´Ã‰Ã‡Ã‘ Â½ÃƒÂ°Â£Ã€ÃŒ Â¾Ã†Â´ÃÂ¸Ã© 0 Â°ÂªÃ€Â» Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡ ÂºÂ¸Â³Â»Â°Ã­ 
		wResult = DEF_MSGTYPE_REJECT;
		iResult = 0 ;
	} else if (m_iFightZoneReserve[iFightzoneNum-1] != 0){
		// Â»Ã§Ã…ÃµÃ€Ã¥Ã€ÃŒ Â¿Â¹Â¾Ã  ÂµÃ‡Â¾Ã® Ã€Ã–Ã€Â¸Â¸Ã©  -1 Â°ÂªÃ€Â» Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡ ÂºÂ¸Â³Â½Â´Ã™.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -1 ;
	} else if ( dwGoldCount < 1500 ) {
		// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â°Â®Â°Ã­Ã€Ã–Â´Ã‚ GoldÂ°Â¡ Ã€Ã”Ã€Ã¥Â±Ã‡ Â°Â¡Â°ÃÂ¿Â¡ ÂºÃ±Ã‡Ã˜ Ã€Ã»Â´Ã™.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -2 ;	           // ÂµÂ·Ã€ÃŒ Ã€Ã»Ã€Â¸Â¸Ã© -2 Â°ÂªÃ€Â» Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” ÂºÂ¸Â³Â½Â´Ã™.
	} else if( iCannotReserveDay ) {
		// Â¿Ã€Â´ÃƒÃ€Âº Â¿Â¹Â¾Ã Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â³Â¯Ã€ÃŒÂ´Ã™. Ã€ÃŒÂ¶Â§Â´Ã‚ -3 Â°ÂªÃ€Â» Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡ ÂºÂ¸Â³Â½Â´Ã™.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -3 ;
	} else if( m_pClientList[iClientH]-> m_iFightzoneNumber != 0 ) {
		// Ã€ÃŒÂ¹ÃŒ Â´Ã™Â¸Â¥ Â»Ã§Ã…ÃµÃ€Ã¥Ã€Â» Â¿Â¹Â¾Ã Ã‡ÃŸÂ´Ã™. Ã€ÃŒÂ¶Â§Â´Ã‚ -4 Â°ÂªÃ€Â» Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡ ÂºÂ¸Â³Â½Â´Ã™.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -4 ;
	} else {
		// Â»Ã§Â¿Ã«Ã€ÃšÂ°Â¡ Â°Ã­Â¸Â¥ Â»Ã§Ã…ÃµÃ€Ã¥Ã€ÃŒ Â¿Â¹Â¾Ã Ã€ÃŒ ÂµÃ‡Â¾Ã® Ã€Ã–ÃÃ¶ Â¾ÃŠÂ°Ã­ 
		// Â¿Â¹Â¾Ã Â¿Â¡ Ã‡ÃŠÂ¿Ã¤Ã‡Ã‘ Â±ÃÂ¾Ã—ÂµÂµ Â°Â¡ÃÃ¶Â°Ã­ Ã€Ã–Â°Ã­
		// Â¿Â¹Â¾Ã  Â°Â¡Â´Ã‰Ã‡Ã‘ Â½ÃƒÂ°Â£Ã€ÃŒÂ¸Ã©  Â¿Â¹Â¾Ã Ã‡Ã‘Â´Ã™.
	
		// Â¿Â¹Â¾Ã Â¿Â¡ Â¼ÂºÂ°Ã¸ Ã‡ÃŸÂ´Ã™. 
		wResult = DEF_MSGTYPE_CONFIRM;

		// Â»Ã§Ã…ÃµÃ€Ã¥ Â¿Â¹Â¾Ã Ã€Â» Ã€Â§Ã‡Ã‘ Â±ÃÂ¾Ã—Ã€Â» Â°Â¨Â¼Ã’ Â½ÃƒÃ…Â²Â´Ã™.
		SetItemCount(iClientH, "Gold", dwGoldCount - 1500);
		iCalcTotalWeight(iClientH);
		
		// Â»Ã§Ã…ÃµÃ€Ã¥Ã€Â» Â¿Â¹Â¾Ã Ã‡Ã‘ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Ã€Ã‡ IDÂ¸Â¦ Â³Ã–Â´Ã‚Â´Ã™.
		m_iFightZoneReserve[iFightzoneNum-1] = iClientH;
		
		m_pClientList[iClientH]->m_iFightzoneNumber  = iFightzoneNum ;
		m_pClientList[iClientH]->m_iReserveTime	 =  SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour ;  

		if (SysTime.wHour%2 )	m_pClientList[iClientH]->m_iReserveTime  += 1  ;	// ÃˆÂ¦Â¼Ã¶ Â½ÃƒÂ°Â£Â´Ã«Ã€ÃŒÂ¸Ã© Ã‡Ã‘Â½ÃƒÂ°Â£ ÃˆÃ„Â±Ã®ÃÃ¶ Â¿Â¹Â¾Ã ÂµÃˆÂ´Ã™.
		else					m_pClientList[iClientH]->m_iReserveTime  += 2  ;    // Ã‚Â¦Â¼Ã¶ Â½ÃƒÂ°Â£Â´Ã«Ã€ÃŒÂ¸Ã© ÂµÃ Â½ÃƒÂ°Â£ ÃˆÃ„Â±Ã®ÃÃ¶ Â¿Â¹Â¾Ã ÂµÃˆÂ´Ã™.
		wsprintf(G_cTxt, "(*) Reserve FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iReserveTime);		
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);

		m_pClientList[iClientH]->m_iFightZoneTicketNumber  = 50 ;  
		iResult = 1 ;
	}  

	ZeroMemory(cData, sizeof(cData));

	dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_FIGHTZONE_RESERVE;

	wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp =  wResult ;

	ip  = (int *)(cData + DEF_INDEX2_MSGTYPE+2) ; 
	*ip =  iResult ;
	ip+= 4;
	
	// Â»Ã§Ã…ÃµÃ€Ã¥ Â¿Â¹Â¾Ã  Ã€Ã€Â´Ã¤ Â¸ÃÂ¼Â¼ÃÃ¶  Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Ã€Ã¼Â¼Ã›
		
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
 
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}



BOOL CGame::bCheckLimitedUser(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;
	
	if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && 
		 (m_pClientList[iClientH]->m_iExp >= m_iLevelExp20 ) ) {
		// Â¿Â©Ã‡Ã Ã€ÃšÂ°Â¡ Â·Â¹ÂºÂ§ 20 Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â¾Ã²Â¾ÃºÂ´Ã™Â¸Ã© 19Â¼Ã¶ÃÃ˜Ã€Â¸Â·Ã ÃˆÂ¯Â¿Ã¸. 

		m_pClientList[iClientH]->m_iExp = m_iLevelExp20 - 1;	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TRAVELERLIMITEDLEVEL, NULL, NULL, NULL, NULL);
		return TRUE;
	}


	return FALSE;
}

void CGame::RequestCivilRightHandler(int iClientH, char *pData)
{
 char * cp, cData[100];
 DWORD * dwp;
 WORD * wp, wResult;
 int  iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;

	// ?íš‘ì¨”íš‘ íš‰íš— ì¨ì¨‹?ì¨©?íš‰ ì©Œíš˜ì©Œíš™?íš‘ ?íšœì¨ˆíš¢ì¨ì±• ì©íš„ì¨”íš“ì§¹íš‰?ì¨© ì§¸ì§•íšì²¬ ì©Œì²  ì©ì²©ì¨ˆíš¢. 
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) wResult = 0;
	else wResult = 1;

	// ì¨Œì¨”ì¨˜ì§ ?íš‘ 5 ?íš‘íš‰íš•ì¨‹ì²˜ì¨‰ì¨‰ ì©íš„ì¨”íš“ì§¹íš‰?ì¨© ì©ì±µ?ì¨© ì©Œì²  ì©ì²©ì¨ˆíš¢. 
	if (m_pClientList[iClientH]->m_iLevel < 5) wResult = 0;
	
	if (wResult == 1) {
		// íš‰ì² ?ì±Œ ì¨íš?íš‰ ?íš‘ì¨ì§ ?ì¨© íš‰íš˜ì¨ˆì±Œíš‰íš—ì¨ˆíš¢.
		ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
		strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
	}

	// Side íš‰íš˜ì¨ˆì±Œ
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) 
		m_pClientList[iClientH]->m_cSide = 1;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) 
		m_pClientList[iClientH]->m_cSide = 2;

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_CIVILRIGHT;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wResult;

	// v1.41 ì¨íš ?íš‘ì¨ì§  ì©íšì¨Œíšíšíš¥ 
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp += 10;

	// ??ì¨ˆì±„ ì¨íš§ì©íš„íšì² ì¨ì§ íš‡ì§­ì¨‹ì²˜?íš‘ì©ì±¨íšˆì§°ì©”ì§•ì§¸íšš ?ì²´ì©Œíš¤
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ì¨íš§ì©íš„íšì² ì¨ì§ ì¨˜ì¨ì¨€ì©ì¨‹ì§  ì©”ì§•ì¨Œì§±ì§¸ì§• ì¨”íš©ì¨©ì²µíš‰íš©ì¨ˆíš¢ì¨ì±• íšì§ì§¸íš‡íš‰íš—ì¨ˆíš¢.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	// íšˆì§±ì©Œì¨˜?íš‘ ì¨”íš¢ì§¼ì±¤ì¨”íš‰ì¨Œíš“ ì©”íš¥ì©ì±Œ?ì¨© ì¨©ì²œì¨Œíš“ ì¨˜ì¨ì¨€ì©ì¨ˆíš¢. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}



void CGame::RequestRetrieveItemHandler(int iClientH, char *pData)
{
 char * cp, cBankItemIndex, cMsg[100];
 register int i, j, iRet, iItemWeight;
 DWORD * dwp;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cBankItemIndex = *cp;
	if (m_pClientList[iClientH]->m_bIsInsideWarehouse == FALSE) return;

	if ((cBankItemIndex < 0) || (cBankItemIndex >= DEF_MAXBANKITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] == NULL) {
		// Â¿Ã€Â·Ã¹Â´Ã™. 
		ZeroMemory(cMsg, sizeof(cMsg));
			
		dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_RETRIEVEITEM;
		wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
	}
	else {
		// ÃÃŸÂ·Â®Â°Ã¨Â»Ãª 
		/*
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			//iItemWeight = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight * m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount;
			iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		}
		else iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], 1); //m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight;
		*/
		// v1.432
		iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		
		if ( (iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
			// Ã‡Ã‘Â°Ã¨ÃÃŸÂ·Â® ÃƒÃŠÂ°Ãº, Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃƒÂ£Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™. 
			// Â½Ã‡Ã†Ã Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
			ZeroMemory(cMsg, sizeof(cMsg));
			
			// Â´ÃµÃ€ÃŒÂ»Ã³ Â°Â¡ÃÃºÂ¼Ã¶ Â¾Ã¸Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
			return;
		}
		
		//!!!
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			// ÃÃŸÂºÂ¹Ã€ÃŒ Â°Â¡Â´Ã‰Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¶Ã³Â¸Ã© Â¼Ã¶Â·Â®Â¸Â¸ ÃÃµÂ°Â¡Â½ÃƒÃ…Â²Â´Ã™.	
			for (i = 0; i < DEF_MAXITEMS; i++)
			if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
				 (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType) && 
			 	 (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cName, 20) == 0) ) {
				// Â°Â°Ã€Âº Ã‡Ã¼Â½Ã„Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃƒÂ£Â¾Ã’Â´Ã™. Â¼Ã¶Â·Â®Ã€Â» ÃÃµÂ°Â¡Â½ÃƒÃ…Â²Â´Ã™.
				// v1.41 !!! 
				SetItemCount(iClientH, i, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount + m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
				
				// Â¹Ã°Ã…Â© Â¾Ã†Ã€ÃŒÃ…Ã› Â»Ã¨ÃÂ¦ 
				delete m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;

				// ÂºÃ³ Â°Ã¸Â°Â£Ã€Â» Â¾Ã¸Â¾Ã˜Â´Ã™. 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
					}
				}
				
				// Â¼ÂºÂ°Ã¸ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
			
				// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
				iCalcTotalWeight(iClientH);
				// ÃˆÂ­Â»Ã¬ Ã‡Ã’Â´Ã§
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
								
				// Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã› 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}

			// Â°Â°Ã€Âº Ã€ÃŒÂ¸Â§Ã€Â» Â°Â®Â°Ã­ Ã€Ã–Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¾Ã¸Â´Ã™. Â»ÃµÂ·Ã ÃƒÃŸÂ°Â¡Ã‡Ã˜Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
			goto RRIH_NOQUANTITY;
		} 
		else {
RRIH_NOQUANTITY:;
			// Â¼Ã¶Â·Â®Â°Â³Â³Ã¤Ã€ÃŒ Â¾Ã¸Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã› 
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
				// ÂºÃ³ Â°Ã¸Â°Â£Ã€Â» ÃƒÂ£Â¾Ã’Â´Ã™. 
				// Â¸Ã•Ã€Ãº ÃÃ–Â¼Ã’Â¸Â¦ Â¿Ã…Â±Ã¤Â´Ã™. 
				m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				// v1.3 1-27 12:22
				m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
				m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
			
				m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
				
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;
				
				// ÂºÃ³ Â°Ã¸Â°Â£Ã€Â» Â¾Ã¸Â¾Ã˜Â´Ã™. 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
					}
				}
								
				// Â¼ÂºÂ°Ã¸ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
					
				// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
				iCalcTotalWeight(iClientH);
		
				// ÃˆÂ­Â»Ã¬ Ã‡Ã’Â´Ã§
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
					
				// Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã› 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÂµÃ‡ÃƒÂ£Ã€Â» Â°Ã¸Â°Â£Ã€ÃŒ Â¾Ã¸Â´Ã™. Â¿Ã€Â·Ã¹
			ZeroMemory(cMsg, sizeof(cMsg));
			
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_RETRIEVEITEM;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_MSGTYPE_REJECT;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
		}
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

BOOL CGame::bSetItemToBankItem(int iClientH, short sItemIndex)
{
 register int i, iRet;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 char cData[100];
 class CItem * pItem;
	
	// Â¼Ã’ÃÃ¶Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÂºÂ¸Â°Ã¼Ã‡Ã‘Â´Ã™.
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsInsideWarehouse == FALSE) return FALSE;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		// ÂºÃ±Â¾Ã®Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™.
				
		m_pClientList[iClientH]->m_pItemInBankList[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
		pItem = m_pClientList[iClientH]->m_pItemInBankList[i];
		// !!! Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Ã†Ã·Ã€ÃÃ…ÃÂ¸Â¦ Ã€ÃŒÂµÂ¿Ã‡ÃŸÃ€Â¸Â´Ã Â±Ã¢ÃÂ¸Ã€Ã‡ Ã†Ã·Ã€ÃÃ…ÃÂ´Ã‚ NULLÂ°ÂªÃ€Â¸Â·Ã Ã‡Ã’Â´Ã§. 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		
		// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
		iCalcTotalWeight(iClientH);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);			   
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);		       
		*wp  = DEF_NOTIFY_ITEMTOBANK;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		*cp = i; // Ã€Â§Ã„Â¡ Ã€ÃºÃ€Ã¥ 
		cp++;

		// 1Â°Â³.
		*cp = 1;
		cp++;						    

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; 
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
	
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		// v1.432
		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		// v1.42
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™. v1.41 ÃÂ¦Â°Ã…Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
			// DeleteClient(iClientH, TRUE, TRUE);
			return TRUE; // v1.41 FALSEÂ¸Â¦ Â¹ÃÃˆÂ¯Ã‡ÃÂ¸Ã© Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¹Ã™Â´ÃšÂ¿Â¡ ÂºÂ¹Â»Ã§ÂµÃˆÂ´Ã™.
		}

		return TRUE;
	}

	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÂºÂ¸Â°Ã¼Ã‡Ã’ Â¿Â©Ã€Â¯Â°Ã¸Â°Â£Ã€ÃŒ Â¾Ã¸Â´Ã™.
	return FALSE;
}
// 05/21/2004 - Hypnotoad - send player to jail
void CGame::ApplyPKpenalty(short sAttackerH, short sVictumH)
{
	int iV1, iV2;

	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictumH] == NULL) return;
	// Â¾ÃˆÃ€Ã¼ Â°Ã¸Â°Ã Â¸Ã°ÂµÃ¥Â°Â¡ Ã„Ã‘ÃÃ¸ Â»Ã³Ã…Ã‚Â¿Â¡Â¼Â­ Â°Ã¸Â°ÃÃ€Â¸Â·Ã Ã€ÃÃ‡Ã˜ Â°Â°Ã€Âº Ã†Ã­Ã€ÃŒ ÃÃ—Ã€Â»Â¼Ã¶Â´Ã‚ Â¾Ã¸ÃÃ¶Â¸Â¸ Â¸Â¸Â¾Ã  Ã€Ã–Ã€Â»Â°Ã¦Â¿Ã¬ Â¹Â«Â½Ãƒ 
	// Â´Ãœ Â°Ã¸Â°ÃÃ€ÃšÂ°Â¡ Â¹Ã¼ÃÃ‹Ã€ÃšÂ°Â¡ Â¾Ã†Â´ÃÂ¾Ã®Â¾ÃŸÂ¸Â¸ Ã‡Ã˜Â´Ã§ÂµÃˆÂ´Ã™.
	if ((m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) && (m_pClientList[sAttackerH]->m_iPKCount == 0)) return; 

	// PK Count ÃÃµÂ°Â¡  
	m_pClientList[sAttackerH]->m_iPKCount++;

	_bPKLog(DEF_PKLOG_BYPK,sAttackerH,sVictumH,NULL) ;

	// Â°Ã¦Ã‡Ã¨Ã„Â¡ Â°Â¨Â¼Ã’ 
	iV1 = iDice((m_pClientList[sVictumH]->m_iLevel/2)+1, 50); 
	iV2 = iDice((m_pClientList[sAttackerH]->m_iLevel/2)+1, 50);

	m_pClientList[sAttackerH]->m_iExp -= iV1; 
	m_pClientList[sAttackerH]->m_iExp -= iV2;
	if (m_pClientList[sAttackerH]->m_iExp < 0) m_pClientList[sAttackerH]->m_iExp = 0;

	// Ã†Ã¤Â³ÃÃ†Â¼Â¸Â¦ Â¸Ã”Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
	SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	

	// Ã†Â¯Â¼ÂºÃ€ÃŒ Â¹Ã™Â²Ã®Â¹Ã‡Â·Ã Â¿ÃœÂ¾Ã§Ã€Â» Â»ÃµÂ·Ã ÂºÂ¸Â³Â½Â´Ã™. 
	SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	// v1.4 Â·ÃÂ±Ã— Ã†Ã„Ã€ÃÂ¿Â¡ Â±Ã¢Â·Ã 
	//wsprintf(G_cTxt, "(!) PK-penalty: Â°Ã¸Â°ÃÃ€Ãš(%s) Â¼Ã•Â½Ã‡ Â°Ã¦Ã‡Ã¨Ã„Â¡(%d) Â°Ã¦Ã‡Ã¨Ã„Â¡(%d) ", m_pClientList[sAttackerH]->m_cCharName, iV1+iV2, m_pClientList[sAttackerH]->m_iExp);
	//PutLogFileList(G_cTxt);

	// v1.4 Ã…Â©Â¶Ã³Ã€Ã“ ÃˆÂ½Â¼Ã¶ ÃÃµÂ°Â¡ 
	m_stCityStatus[m_pClientList[sAttackerH]->m_cSide].iCrimes++;

	// v1.41 Rating Ã‡ÃÂ¶Ã´ 
	m_pClientList[sAttackerH]->m_iRating -= 10;
	if (m_pClientList[sAttackerH]->m_iRating > 10000)  m_pClientList[sAttackerH]->m_iRating =  10000;
	if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = -10000;


	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "aresden") == 0) {
		if ( (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk11") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk12") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk21") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk22") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "aresden") == 0)   ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone2") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "areuni") == 0)    ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arefarm") == 0)) {

				// Â¾Ã†Â·Â¹Â½ÂºÂµÂ§ Â±Ã™Â±Â³Â¿Â¡Â¼Â­ PKÂ¸Â¦ Ã‡ÃŸÂ´Ã™. ÂºÃ­Â¸Â®ÂµÃ¹ Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® 5ÂºÃ
				// v2.16 Â¼ÂºÃˆÃ„Â´Ã Â¼Ã¶ÃÂ¤
				ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
				strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "arejail");
				m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
				RequestTeleportHandler(sAttackerH, "2   ", "arejail", -1, -1);
				return;		
			}
	}

	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "elvine") == 0) {
		if ( (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk11") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk12") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk21") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk22") == 0)  ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvine") == 0)    ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone1") == 0) ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvuni") == 0)    ||
			(strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {

				// Â¿Â¤Â¹Ã™Ã€Ã Â±Ã™Â±Â³Â¿Â¡Â¼Â­ PKÂ¸Â¦ Ã‡ÃŸÂ´Ã™. ÂºÃ­Â¸Â®ÂµÃ¹ Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® 5ÂºÃ
				ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
				strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "elvjail");
				m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
				RequestTeleportHandler(sAttackerH, "2   ", "elvjail", -1, -1);
				return;		
			}
	}
}


// 05/17/2004 - Hypnotoad - register pk log
void CGame::PK_KillRewardHandler(short sAttackerH, short sVictumH)
{
	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictumH] == NULL)   return;

	_bPKLog(DEF_PKLOG_BYPLAYER,sAttackerH,sVictumH,NULL) ;

	if (m_pClientList[sAttackerH]->m_iPKCount != 0) {
		// PKÂ¸Â¦ Ã€Ã¢Ã€Âº Â»Ã§Â¶Ã·Ã€ÃŒ PKÂ¸Ã© Â¾Ã†Â¹Â«Â·Â± ÂµÃ¦Ã€ÃŒ Â¾Ã¸Â´Ã™.

	}
	else {
		// Ã†Ã·Â»Ã³Â±ÃÂ¸Â¸ Â´Â©Ã€Ã». Â°Ã¦Ã‡Ã¨Ã„Â¡Â´Ã‚ Â¿Ã€Â¸Â£ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 
		m_pClientList[sAttackerH]->m_iRewardGold += iGetExpLevel(m_pClientList[sVictumH]->m_iExp) * 3;


		if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
			m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[sAttackerH]->m_iRewardGold < 0) 
			m_pClientList[sAttackerH]->m_iRewardGold = 0;

		SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKCAPTURED, m_pClientList[sVictumH]->m_iPKCount, m_pClientList[sVictumH]->m_iLevel, NULL, m_pClientList[sVictumH]->m_cCharName);
	}
}

void CGame::EnemyKillRewardHandler(int iAttackerH, int iClientH)
{
	// enemy-kill-mode = 1 | 0
	// if m_bEnemyKillMode is true than death match mode

	// DEATHMATCH MODE:
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and gets an EK 
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and gets an EK

	// CLASSIC MODE:
	// Aresden kills Elvine in Aresden and gets EK
	// Elvine kills Aresden in Aresden and doesnt get an EK 
	// Elvine kills Aresden in Elvine and gets an EK
	// Aresden kills Elvine in Elvine and doesnt get an EK

	int iRewardExp, iEK_Level;
	
	// if the attacker doesnt exist no result
	if (m_pClientList[iAttackerH] == NULL) return;
	// if the target doesnt exist no result
	if (m_pClientList[iClientH] == NULL)   return;

	// Log the EK (killed by enemy)
	_bPKLog(DEF_PKLOG_BYENERMY,iAttackerH,iClientH,NULL) ;
	
	// set EK level to 30
	iEK_Level = 30;
	// if attacker's level is greater than 80, set ek level to 80
	if (m_pClientList[iAttackerH]->m_iLevel >= 80) iEK_Level = 80;
	// check if attacker level is less than or equal to max level
	if (m_pClientList[iAttackerH]->m_iLevel >= m_iPlayerMaxLevel) {
		// if the
		if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
			// ÃˆÃ±Â»Ã½Ã€ÃšÃ€Ã‡ Â·Â¹ÂºÂ§Ã€ÃŒ 80Ã€ÃŒÂ»Ã³Ã€ÃŒÂ°Ã­
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) 
				&& (m_bEnemyKillMode == FALSE)) {
				// ÃˆÃ±Â»Ã½Ã€ÃšÂ°Â¡ ÃÃ—Ã€Âº Â°Ã·Ã€ÃŒ Ã€ÃšÂ½Ã…Ã€Ã‡ Â¸Â¶Ã€Â»Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© EKÂ·Ã Ã€ÃÃÂ¤ 
				m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
			}
			
			if (m_bEnemyKillMode == TRUE) {
				// ÃˆÃ±Â»Ã½Ã€ÃšÂ°Â¡ ÃÃ—Ã€Âº Â°Ã·Ã€ÃŒ Ã€ÃšÂ½Ã…Ã€Ã‡ Â¸Â¶Ã€Â»Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© EKÂ·Ã Ã€ÃÃÂ¤ 
				m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
			}
		}
		// Ã†Ã·Â»Ã³Â±Ã Â´Â©Ã€Ã» 
		m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
		if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
			m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
			m_pClientList[iAttackerH]->m_iRewardGold = 0;

		// Ã€Ã»Ã€Â» Ã€Ã¢Â¾Ã’Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ ÂºÂ¸Â³Â¿ 
		SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);
		return;
	}

	if (m_pClientList[iAttackerH]->m_iPKCount != 0) {
		// Ã€Ã»Ã€Â» Ã€Ã¢Ã€Âº Â»Ã§Â¶Ã·Ã€ÃŒ PKÂ¸Ã© Â¾Ã†Â¹Â«Â·Â± ÂµÃ¦Ã€ÃŒ Â¾Ã¸Â´Ã™.
	}	
	else {
		// ÃˆÃ±Â»Ã½Ã€ÃšÃ€Ã‡ Â½ÃƒÂ¹Ã, Â±Ã¦ÂµÃ¥Â¿Ã¸ Â¿Â©ÂºÃÂ¿Â¡ ÂµÃ»Â¶Ã³ Ã†Ã·Â»Ã³Ã€ÃŒ Â´ÃÂ¶Ã³ÃÃ¸Â´Ã™. 
		if (m_pClientList[iClientH]->m_iGuildRank == -1) {
			// Â±Ã¦ÂµÃ¥Â¿Ã¸Ã€ÃŒ Â¾Ã†Â´ÃÂ¹Ã‡Â·Ã Â½ÃƒÂ¹Ã. (Â¿Â©Ã‡Ã Ã€ÃšÃ€Ã‡ Â°Ã¦Â¿Ã¬Â¿Â¡Â´Ã‚ Ã€ÃŒ Ã‡Ã”Â¼Ã¶Â°Â¡ ÃˆÂ£ÃƒÃ¢ÂµÃ‡ÃÃ¶ Â¾ÃŠÃ€Â¸Â¹Ã‡Â·Ã)
			// v2.15 Ã€Ã»Ã€Â» ÃÃ—Â¿Â´Ã€Â»Â¶Â§ Ã†Ã²Â±Ã•Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â¾Ã²Â±Ã¢Ã€Â§Ã‡Ã˜ 
			iRewardExp = (iDice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;

			if (m_bIsCrusadeMode == TRUE) {
				// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â¸Ã°ÂµÃ¥Â¶Ã³Â¸Ã© Â°Ã¦Ã‡Ã¨Ã„Â¡Ã€Ã‡ (1/3)*3Ã€Â» Â¸Ã•Ã€Ãº ÃÃ–Â°Ã­ Â³ÂªÂ¸Ã“ÃÃ¶Â´Ã‚ 6Â¹Ã¨Â·Ã Ã€Ã¼Ã€Ã¯ Â°Ã¸Ã‡Ã¥ÂµÂµÂ¿Â¡ Â´Â©Ã€Ã» 
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp/3)*4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp/3))*12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				//testcode
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp/3))*6);
				PutLogList(G_cTxt);

				// Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
				SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);

				// ÃˆÃ±Â»Ã½Ã€ÃšÃ€Ã‡ Â·Â¹ÂºÂ§Ã€ÃŒ 80 Ã€ÃŒÂ»Ã³Ã€Ã Â°Ã¦Â¿Ã¬ Enemy Kill countÂ¸Â¦ Â¿ÃƒÂ¸Â°Â´Ã™.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// ÃˆÃ±Â»Ã½Ã€ÃšÃ€Ã‡ Â·Â¹ÂºÂ§Ã€ÃŒ 80Ã€ÃŒÂ»Ã³Ã€ÃŒÂ°Ã­
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) {
						// ÃˆÃ±Â»Ã½Ã€ÃšÂ°Â¡ ÃÃ—Ã€Âº Â°Ã·Ã€ÃŒ Ã€ÃšÂ½Ã…Ã€Ã‡ Â¸Â¶Ã€Â»Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© EKÂ·Ã Ã€ÃÃÂ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
					if (m_bEnemyKillMode == TRUE) {
						// ÃˆÃ±Â»Ã½Ã€ÃšÂ°Â¡ ÃÃ—Ã€Âº Â°Ã·Ã€ÃŒ Ã€ÃšÂ½Ã…Ã€Ã‡ Â¸Â¶Ã€Â»Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© EKÂ·Ã Ã€ÃÃÂ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				// Ã†Ã·Â»Ã³Â±Ã Â´Â©Ã€Ã» 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				// Ã€ÃÂ¹Ã Â¸Ã°ÂµÃ¥.
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// ÃˆÃ±Â»Ã½Ã€ÃšÃ€Ã‡ Â·Â¹ÂºÂ§Ã€ÃŒ 80 Ã€ÃŒÂ»Ã³Ã€Ã Â°Ã¦Â¿Ã¬ Enemy Kill countÂ¸Â¦ Â¿ÃƒÂ¸Â°Â´Ã™.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// ÃˆÃ±Â»Ã½Ã€ÃšÃ€Ã‡ Â·Â¹ÂºÂ§Ã€ÃŒ 80Ã€ÃŒÂ»Ã³Ã€ÃŒÂ°Ã­
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) 
						&& (m_bEnemyKillMode == FALSE)) {
						// ÃˆÃ±Â»Ã½Ã€ÃšÂ°Â¡ ÃÃ—Ã€Âº Â°Ã·Ã€ÃŒ Ã€ÃšÂ½Ã…Ã€Ã‡ Â¸Â¶Ã€Â»Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© EKÂ·Ã Ã€ÃÃÂ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
					
					if (m_bEnemyKillMode == TRUE) {
						// ÃˆÃ±Â»Ã½Ã€ÃšÂ°Â¡ ÃÃ—Ã€Âº Â°Ã·Ã€ÃŒ Ã€ÃšÂ½Ã…Ã€Ã‡ Â¸Â¶Ã€Â»Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© EKÂ·Ã Ã€ÃÃÂ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				// Ã†Ã·Â»Ã³Â±Ã Â´Â©Ã€Ã» 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}
		else {
			// v2.15 Ã€Ã»Ã€Â» ÃÃ—Â¿Â´Ã€Â»Â¶Â§ Ã†Ã²Â±Ã•Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â¾Ã²Â±Ã¢Ã€Â§Ã‡Ã˜ 
			iRewardExp = (iDice(3, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp))/ 3 ;

			// Â±Ã¦ÂµÃ¥Â¿Ã¸Ã€ÃŒÂ´Ã™.
			if (m_bIsCrusadeMode == TRUE) {
				// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â¸Ã°ÂµÃ¥.
				// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â¸Ã°ÂµÃ¥Â¶Ã³Â¸Ã© Â°Ã¦Ã‡Ã¨Ã„Â¡Ã€Ã‡ 1/3Ã€Â» Â¸Ã•Ã€Ãº ÃÃ–Â°Ã­ Â³ÂªÂ¸Ã“ÃÃ¶Â´Ã‚ 2Â¹Ã¨Â·Ã Ã€Ã¼Ã€Ã¯ Â°Ã¸Ã‡Ã¥ÂµÂµÂ¿Â¡ Â´Â©Ã€Ã» 
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp/3)*4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp/3))*12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				//testcode
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp/3))*6);
				PutLogList(G_cTxt);

				// Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
				SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);

				// ÃˆÃ±Â»Ã½Ã€ÃšÃ€Ã‡ Â·Â¹ÂºÂ§Ã€ÃŒ 80 Ã€ÃŒÂ»Ã³Ã€Ã Â°Ã¦Â¿Ã¬ Enemy Kill countÂ¸Â¦ Â¿ÃƒÂ¸Â°Â´Ã™.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// ÃˆÃ±Â»Ã½Ã€ÃšÃ€Ã‡ Â·Â¹ÂºÂ§Ã€ÃŒ 80Ã€ÃŒÂ»Ã³Ã€ÃŒÂ°Ã­
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) 
						&& (m_bEnemyKillMode == FALSE)) {
						// ÃˆÃ±Â»Ã½Ã€ÃšÂ°Â¡ ÃÃ—Ã€Âº Â°Ã·Ã€ÃŒ Ã€ÃšÂ½Ã…Ã€Ã‡ Â¸Â¶Ã€Â»Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© EKÂ·Ã Ã€ÃÃÂ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
					
					if (m_bEnemyKillMode == TRUE) {
						// ÃˆÃ±Â»Ã½Ã€ÃšÂ°Â¡ ÃÃ—Ã€Âº Â°Ã·Ã€ÃŒ Ã€ÃšÂ½Ã…Ã€Ã‡ Â¸Â¶Ã€Â»Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© EKÂ·Ã Ã€ÃÃÂ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}
				// Ã†Ã·Â»Ã³Â±Ã Â´Â©Ã€Ã» 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				// Ã€ÃÂ¹Ã Â¸Ã°ÂµÃ¥.
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// Enemy Kill countÂ¸Â¦ Â¿ÃƒÂ¸Â°Â´Ã™.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= iEK_Level) {
					// ÃˆÃ±Â»Ã½Ã€ÃšÃ€Ã‡ Â·Â¹ÂºÂ§Ã€ÃŒ 80Ã€ÃŒÂ»Ã³Ã€ÃŒÂ°Ã­
					if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) 
						&& (m_bEnemyKillMode == FALSE)) {
						// ÃˆÃ±Â»Ã½Ã€ÃšÂ°Â¡ ÃÃ—Ã€Âº Â°Ã·Ã€ÃŒ Ã€ÃšÂ½Ã…Ã€Ã‡ Â¸Â¶Ã€Â»Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© EKÂ·Ã Ã€ÃÃÂ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
					
					if (m_bEnemyKillMode == TRUE) {
						// ÃˆÃ±Â»Ã½Ã€ÃšÂ°Â¡ ÃÃ—Ã€Âº Â°Ã·Ã€ÃŒ Ã€ÃšÂ½Ã…Ã€Ã‡ Â¸Â¶Ã€Â»Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© EKÂ·Ã Ã€ÃÃÂ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount += m_iEnemyKillAdjust;
					}
				}	
				// Ã†Ã·Â»Ã³Â±Ã Â´Â©Ã€Ã» 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}

		// Ã€Ã»Ã€Â» Ã€Ã¢Â¾Ã’Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ ÂºÂ¸Â³Â¿ 
		SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);

		if (bCheckLimitedUser(iAttackerH) == FALSE) {
			// ÃƒÂ¼Ã‡Ã¨Ã†Ã‡ Â»Ã§Â¿Ã«Ã€Ãš ÃÂ¦Ã‡Ã‘Â¿Â¡ Ã‡Ã˜Â´Ã§ÂµÃ‡ÃÃ¶ Â¾ÃŠÃ€Â¸Â¸Ã© Â°Ã¦Ã‡Ã¨Ã„Â¡Â°Â¡ Â¿ÃƒÂ¶ÃºÂ´Ã™Â´Ã‚ Ã…Ã«ÂºÂ¸Â¸Â¦ Ã‡Ã‘Â´Ã™.
			SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
		}
		// Â·Â¹ÂºÂ§Ã€ÃŒ Â¿ÃƒÂ¶ÃºÂ´Ã‚ÃÃ¶Â¸Â¦ Â°Ã‹Â»Ã§Ã‡Ã‘Â´Ã™.
		bCheckLevelUp(iAttackerH);

		//v1.4 Â±Â³Ã€Ã¼Â¿Â¡Â¼Â­ Ã€ÃŒÂ±Ã¤ Ã„Â«Â¿Ã®Ã†Â®Â¸Â¦ Â¿ÃƒÂ¸Â°Â´Ã™.
		m_stCityStatus[m_pClientList[iAttackerH]->m_cSide].iWins++;
	}
}

// 05/22/2004 - Hypnotoad - register in pk log
void CGame::ApplyCombatKilledPenalty(int iClientH, int cPenaltyLevel, BOOL bIsSAattacked)
{  
	int iExp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// Crusade
	if (m_bIsCrusadeMode == TRUE) {
		// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â¸Ã°ÂµÃ¥Ã€Ã Â°Ã¦Â¿Ã¬ Ã€Ã¼Ã€Ã¯ÃÃŸÂ¿Â¡ ÃÃ—Â¾Ã®ÂµÂµ Â¾Ã†Â¹Â«Â·Â± Ã†Ã¤Â³ÃÃ†Â¼Â°Â¡ Â¾Ã¸Â´Ã™.
		// PKcountÂ¸Â¸ Â°Â¨Â¼Ã’ 
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	
			// v2.15 
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL,NULL,iClientH,NULL) ;

		}
		return;
	}
	else {
		// PKcount Â°Â¨Â¼Ã’ 
		if (m_pClientList[iClientH]->m_iPKCount > 0) {
			m_pClientList[iClientH]->m_iPKCount--;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	
			// v2.15
			_bPKLog(DEF_PKLOG_REDUCECRIMINAL,NULL,iClientH,NULL) ;
		}

		// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â·ÃÂºÃÃ…ÃÃ€Ã‡ Â°Ã¸Â°ÃÃ€Â» Â¹ÃÂ°Ã­ Ã€Ã¼Ã€Ã¯ÃÃŸ Â»Ã§Â¸ÃÃ‡ÃŸÂ´Ã™.
		iExp = iDice(1, (5*cPenaltyLevel*m_pClientList[iClientH]->m_iLevel));

		// ÃÃŸÂ¸Â³Ã€Ã Â°Ã¦Â¿Ã¬ ÃÃ—Â¾ÃºÃ€Â» Â¶Â§ Â¶Â³Â¾Ã®ÃÃ¶Â´Ã‚ Â°Ã¦Ã‡Ã¨Ã„Â¡Â´Ã‚ 1/3
		if (m_pClientList[iClientH]->m_bIsNeutral == TRUE) iExp = iExp / 3;

		// v2.17 2002-7-31 ÃƒÃ–Â°Ã­Â·Â¾Ã€Âº ÃÃ—Â¾ÃºÃ€Â»Â¶Â§ Â°Ã¦Ã„Â¡Â°Â¡ Â¶Â³Â¾Ã®ÃÃ¶ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. Â¼Ã¶ÃÂ¤ 
		// if (m_pClientList[iClientH]->m_iLevel == DEF_PLAYERMAXLEVEL) iExp = 0;

		m_pClientList[iClientH]->m_iExp -= iExp;
		if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);

		// v1.41 ÃÃŸÂ¸Â³Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¶ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
		if (m_pClientList[iClientH]->m_bIsNeutral != TRUE) {
			if (m_pClientList[iClientH]->m_iLevel < 80) {
				// Â·Â¹ÂºÂ§ 80 Â¹ÃŒÂ¸Â¸Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Ã‡ÃÂ³Âª Ã€Ã»Â°Ã” Â¶Â³Â¾Ã®ÃÃ¸Â´Ã™.
				// v2.03 60 -> 80
				cPenaltyLevel--;
				if (cPenaltyLevel <= 0) cPenaltyLevel = 1;
				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
			}
			else _PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
		}
	}
}

// 05/29/2004 - Hypnotoad - Limits some items from not dropping
void CGame::_PenaltyItemDrop(int iClientH, int iTotal, BOOL bIsSAattacked)
{
 register int i, j, iRemainItem;
 char cItemIndexList[DEF_MAXITEMS], cItemIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((m_pClientList[iClientH]->m_iAlterItemDropIndex != -1) && (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex] != NULL)) {
		// Testcode
		if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) {
			// v2.04 Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª Â»ÃµÃ…Â©Â¸Â®Ã†Ã„Ã€ÃŒÂ½ÂºÂ°Â¡ Â¸Ã‚Â´Ã‚ÃÃ¶ ÃˆÂ®Ã€Ã
			// Â´Ã«ÃƒÂ¼Ã€Ã»Ã€Â¸Â·Ã Â¶Â³Â¾Ã®ÃÃ¶Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© Â´Ã™Â¸Â¥ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¶ÃÃ¶ Â¾ÃŠÂ°Ã­ Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã›Â¸Â¸ Â¶Â³Â¾Ã®ÃÃ¸Â´Ã™. 
			if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
				m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;

			DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);

			m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
		}
		else {
			// v2.04 testcode
			PutLogFileList("Alter Drop Item Index Error1");
			// Â´Ã™Â½Ãƒ Â°Ã‹Â»Ã¶ 
			for (i = 0; i < DEF_MAXITEMS; i++) 
			if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (m_pClientList[iClientH]->m_pItemList[i]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
				m_pClientList[iClientH]->m_iAlterItemDropIndex = i;
				if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
					m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;

				DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);	
				m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
				return;
			}

			// Â¿Ã€Â·Ã¹Â¹ÃŸÂ»Ã½! ÃˆÃ±Â»Ã½Â¼Â®Ã€ÃŒ Â¾Ã¸Â´Ã™. 
			goto PID_DROP;
		}
		return;
	}

PID_DROP:;

	for (i = 1; i <= iTotal; i++) {
		iRemainItem = 0;
		ZeroMemory(cItemIndexList, sizeof(cItemIndexList));
		
		for (j = 0; j < DEF_MAXITEMS; j++) 
		if (m_pClientList[iClientH]->m_pItemList[j] != NULL) {
			cItemIndexList[iRemainItem] = j;
			iRemainItem++;
		}
		
		if (iRemainItem == 0) return;
		cItemIndex = cItemIndexList[ iDice(1, iRemainItem) - 1 ];
		
	
		if ((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectType != 0) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
			// Â°Â³Ã€ÃÂ¿Â¡Â°Ã” Â¼Ã“Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â¸Â·Ã Â¶Â³Â¾Ã®ÃÃ¶ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. Â¸ÃÃ…Ã¤Â°Â°Ã€Âº Â°Â³Ã€ÃÂ¿Ã« Â¾Ã†Ã€ÃŒÃ…Ã› 
		}

		else if (
				 (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum >= 400) && 
				 (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum != 402) && 
				 (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sIDnum <= 428)) {
		}

		else if (((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) ||
			     (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) &&
			     (bIsSAattacked == FALSE)) {
			// Ã†Â¯Â¼Ã¶ Â´Ã‰Â·Ã‚Ã€Â» Â°Â¡ÃÃ¸ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Ã†Â¯Â¼Ã¶ Â°Ã¸Â°ÃÃ€Â» Â¹ÃÃ€ÂºÂ°Ã” Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© Â¶Â³Â¾Ã®ÃÃ¶ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
		}

		else if ((m_pClientList[iClientH]->m_bIsLuckyEffect == TRUE) && (iDice(1,10) == 5)) {
			// Ã„Â³Â¸Â¯Ã…ÃÂ¿Â¡Â°Ã” Ã‡Ã Â¿Ã®ÃˆÂ¿Â°ÃºÂ°Â¡ Ã€Ã–Ã€Â¸Â¸Ã© 10% ÃˆÂ®Â·Ã¼Â·Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¶ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
		}

		else DropItemHandler(iClientH, cItemIndex, -1, m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_cName);
	}
}

void CGame::GetRewardMoneyHandler(int iClientH)		    
{
 int iRet, iEraseReq, iWeightLeft, iRewardGoldLeft;
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cData[100], cItemName[21];
 class CItem * pItem;
 short * sp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	
	// Â³Â²Ã€Âº ÃÃŸÂ·Â®Ã€Â» Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™. 
	iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
		
	if (iWeightLeft <= 0) return;
	// ÃÃŸÂ·Â®Ã€Â» Â¹ÃÃ€Â¸Â·Ã Â³ÂªÂ´Â«Â´Ã™. <- ÃƒÂ£Ã€Âº ÂµÂ·Ã€Â¸Â·Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â»Ã¬ Â°Ã¸Â°Â£Ã€Âº Â¸Â¶Â·ÃƒÃ‡Ã˜ ÂµÃ–Â¾ÃŸ Ã‡ÃÂ¹Ã‡Â·Ã.
	iWeightLeft = iWeightLeft / 2;
	if (iWeightLeft <= 0) return;

	pItem = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItem, cItemName);
	//pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
	
	// (iWeightLeft / pItem->m_wWeight)Â°Â¡ ÃƒÃ–Â´Ã« Â¹ÃÃ€Â» Â¼Ã¶ Ã€Ã–Â´Ã‚ GoldÂ°Â¹Â¼Ã¶. Â°Â®Â°Ã­Ã€Ã–Â´Ã‚ Ã†Ã·Â»Ã³Â±ÃÂ°Ãº ÂºÃ±Â±Â³Ã‡Ã‘Â´Ã™. 
	if ((iWeightLeft / iGetItemWeight(pItem, 1)) >= m_pClientList[iClientH]->m_iRewardGold) {
		// Ã†Ã·Â»Ã³Â±ÃÃ€Â» Â¸Ã°ÂµÃ Â¹ÃÃ€Â» Â¼Ã¶ Ã€Ã–Â´Ã™. 
		pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
		iRewardGoldLeft = 0;
	}
	else {
		// (iWeightLeft / pItem->m_wWeight)Â¸Â¸ Â¹ÃÂ´Ã‚Â´Ã™.
		pItem->m_dwCount = (iWeightLeft / iGetItemWeight(pItem, 1));
		iRewardGoldLeft = m_pClientList[iClientH]->m_iRewardGold - (iWeightLeft / iGetItemWeight(pItem, 1));
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™.
		
		// Â³Â²Ã€Âº Ã†Ã·Â»Ã³Â±Ã Â³Â»Â¿Âª Â°Ã¨Â»Ãª.
		m_pClientList[iClientH]->m_iRewardGold = iRewardGoldLeft;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		// 1Â°Â³ ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™. <- Â¿Â©Â±Ã¢Â¼Â­ 1Â°Â³Â¶Ãµ Ã„Â«Â¿Ã®Ã†Â®Â¸Â¦ Â¸Â»Ã‡ÃÂ´Ã‚ Â°ÃÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™
		*cp = 1;
		cp++;

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; // Â¾Ã²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;

		*cp = pItem->m_cGenderLimit;
		cp++;

		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃ 
		cp++;
		*/

		if (iEraseReq == 1) delete pItem;
		
		// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
						
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
			// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}

		// Â±Ã— Â´Ã™Ã€Â½ Â³Â²Ã€Âº Ã†Ã·Â»Ã³Â±ÃÃ€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
	}
	else {
		// Â¹ÃÃ€Â» Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â°Ã¦Â¿Ã¬Â´Ã‚ Â¾Ã†Â¹Â«Â·Â± ÃƒÂ³Â¸Â®Â¸Â¦ Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. 

	}
}


int CGame::_iCalcMaxLoad(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return 0;

	return (m_pClientList[iClientH]->m_iStr * 500 + m_pClientList[iClientH]->m_iLevel*500);
}

int CGame::iAddDynamicObjectList(short sOwner, char cOwnerType, short sType, char cMapIndex, short sX, short sY, DWORD dwLastTime, int iV1)
{
 register int i;
 short sPreType;
 DWORD dwTime, dwRegisterTime;

	m_pMapList[cMapIndex]->bGetDynamicObject(sX, sY, &sPreType, &dwRegisterTime);
	if (sPreType != NULL) return NULL;

	switch (sType) {	
	case DEF_DYNAMICOBJECT_FIRE3:
	case DEF_DYNAMICOBJECT_FIRE:
		if (m_pMapList[cMapIndex]->bGetIsMoveAllowedTile(sX, sY) == FALSE)
			return NULL;
		if (dwLastTime != NULL)  {
			switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
			case 1:	dwLastTime = dwLastTime - (dwLastTime / 2);       break;
			case 2:	dwLastTime = (dwLastTime / 2) - (dwLastTime / 3); break;
			case 3:	dwLastTime = (dwLastTime / 3) - (dwLastTime / 4); break;
			}

			if (dwLastTime == NULL) dwLastTime = 1000;
		}
		break;
	
	case DEF_DYNAMICOBJECT_FISHOBJECT:
	case DEF_DYNAMICOBJECT_FISH:
		if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE)
			return NULL;
		break;

	case DEF_DYNAMICOBJECT_ARESDENFLAG1:
	case DEF_DYNAMICOBJECT_ELVINEFLAG1:
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == FALSE)
			return NULL;
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, FALSE);
		break;

	}
   	
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] == NULL) {
		dwTime = timeGetTime();
		
		if (dwLastTime != NULL) 
			dwLastTime += (iDice(1,4)*1000);

		m_pDynamicObjectList[i] = new class CDynamicObject(sOwner, cOwnerType, sType, cMapIndex, sX, sY, dwTime, dwLastTime, iV1);
		m_pMapList[cMapIndex]->SetDynamicObject(i, sType, sX, sY, dwTime);
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_CONFIRM, cMapIndex, sX, sY, sType, i, NULL);

		return i;
	}
	return NULL;
}

void CGame::CheckDynamicObjectList()
{
 register int i;
 DWORD dwTime = timeGetTime(), dwRegisterTime;
 short sType;

	// Â³Â¯Â¾Â¾ ÃˆÂ¿Â°ÃºÂ¿Â¡ ÂµÃ»Â¸Â¥ ÂµÂ¿Ã€Ã» Â°Â´ÃƒÂ¼Ã€Ã‡ ÃÃ¶Â¼Ã“Â½ÃƒÂ°Â£ Â´ÃœÃƒÃ Ã€Â» Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) { 
		if ( (m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) ) {
		
			switch (m_pDynamicObjectList[i]->m_sType) {
			case DEF_DYNAMICOBJECT_FIRE3:
			case DEF_DYNAMICOBJECT_FIRE:
				// ÂºÃ’Ã€Ã‡ Â°Ã¦Â¿Ã¬ ÂºÃ±Â°Â¡ Â¿ÃˆÃ€Â¸Â·Ã Ã€ÃÃ‡Ã˜ Â¼Ã¶Â¸Ã­Ã€ÃŒ Â±ÃÂ°ÃÃˆÃ· Â´ÃœÃƒÃ ÂµÃˆÂ´Ã™.
				switch (m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus) {
				case 0: break;
				case 1: 
				case 2:
				case 3:
					// (Â³Â²Ã€Âº Â½ÃƒÂ°Â£/10)*ÂºÃ±Â¿Ã€Â´Ã‚ Â»Ã³Ã…Ã‚ Â¸Â¸Ã…Â­ Â½ÃƒÂ°Â£Ã€Â» Â»Â«Â´Ã™.
					m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime - 
						                                    (m_pDynamicObjectList[i]->m_dwLastTime/10) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
					break;
				}
				break;
			}
		}
	}

	// Â½ÃƒÂ°Â£Ã€ÃŒ Â¸Â¸Â·Ã¡ÂµÃˆ Â°Â´ÃƒÂ¼Â¸Â¦ ÃÂ¾Â·Ã¡Â½ÃƒÃ…Â²Â´Ã™. ÃÃ¶Â¼Ã“Â½ÃƒÂ°Â£Ã€ÃŒ NULLÃ€ÃŒÂ¸Ã© Â¿ÂµÂ¿Ã¸ÃˆÃ· Â³Â²Â¾Ã†Ã€Ã–Â´Ã‚ ÂµÂ¿Ã€Ã» Â°Â´ÃƒÂ¼Ã€ÃŒÂ´Ã™.
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) { 
		if ( (m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) && 
			 ((dwTime - m_pDynamicObjectList[i]->m_dwRegisterTime) >= m_pDynamicObjectList[i]->m_dwLastTime) ) {
		
			// ÃÃ¶Â¼Ã“Â½ÃƒÂ°Â£Ã€ÃŒ Â°Ã¦Â°ÃºÃ‡Ã‘ ÂµÂ¿Ã€Ã» Â°Â´ÃƒÂ¼Â¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™.
			m_pMapList[ m_pDynamicObjectList[i]->m_cMapIndex ]->bGetDynamicObject( m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime );
			// ÂµÃ®Â·ÃÂ½ÃƒÂ°Â£Ã€ÃŒ Ã€ÃÃ„Â¡Ã‡Ã‘Â´Ã™Â¸Ã© Â°Â´ÃƒÂ¼Â°Â¡ Â»Ã§Â¶Ã³ÃÃ¸Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»ÃÃ Â¾ÃŸ Ã‡Ã‘Â´Ã™.
			
			if (dwRegisterTime == m_pDynamicObjectList[i]->m_dwRegisterTime) {
				SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, NULL);
				// Â¸ÃŠÂ¿Â¡Â¼Â­ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
			}

			switch (sType) {
			case DEF_DYNAMICOBJECT_FISHOBJECT:
			case DEF_DYNAMICOBJECT_FISH:
				// Â¹Â°Â°Ã­Â±Ã¢ Â¿Ã€ÂºÃªÃÂ§Ã†Â®Â°Â¡ Â»Ã§Â¶Ã³ÃÂ³Ã€Â¸Â¹Ã‡Â·Ã ÃƒÂ³Â¸Â®Ã‡Ã‘Â´Ã™.
				bDeleteFish(m_pDynamicObjectList[i]->m_sOwner, 2); // Â½ÃƒÂ°Â£Ã€ÃŒ ÃÃ¶Â³ÂªÂ¼Â­ Â¹Â°Â°Ã­Â±Ã¢Â°Â¡ Â»Ã§Â¶Ã³ÃÃ¸Â´Ã™.
				break;
			}
	
			// Â¸Â®Â½ÂºÃ†Â®Â¸Â¦ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
			delete m_pDynamicObjectList[i];
			m_pDynamicObjectList[i] = NULL;
		}
	}
}

void CGame::CalculateSSN_ItemIndex(int iClientH, short sWeaponIndex, int iValue)
{
 short sSkillIndex;
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sWeaponIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	
	sSkillIndex = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_sRelatedSkill;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		 (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {
		
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 
		
		switch (sSkillIndex) {
		case 0:  // Mining
		case 5:  // Hand-Attack
		case 13: // Manufacturing
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iStr * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3: // Magic-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:  // Magic
		case 21: // Staff-Attack
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iMag * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:  // Fishing
		case 6:  // Archery
		case 7:  // Short-Sword
		case 8:  // Long-Sword
		case 9:  // Fencing 
		case 10: // Axe-Attack
		case 11: // Shield        	
		case 14: // Hammer 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iDex * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:	 // Farming
		case 12: // Alchemy
		case 15: // ÀÀ±ŞÃ³Ä¡
		case 19: // Pretend-Corpse
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iInt * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // Poison-Resistance
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		// ¸¸¾à ¹«±â¿Í °ü·ÃÀÖ´Â ½ºÅ³ÀÌ ¿Ã¶ú°í ÇöÀç ±× ¹«±â¸¦ »ç¿ë ÁßÀÌ¶ó¸é ÇöÀç ¸íÁß·ü¿¡ 1À» ´õÇÑ´Ù. 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// Ä«¿îÆ®°¡ 0ÀÌ¸é ½ºÅ³ÀÌ Á¤»óÀûÀ¸·Î ¿Ã¶ú´Ù´Â ÀÇ¹Ì. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// È°·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// °ËÀÌ³ª Mace·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
	 		
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKillÀÇ ÃÑÇÕÀÌ 600À» ³ÑÀ¸¸é ´Ù¸¥ ½ºÅ³Áß ÇÏ³ª¸¦ 1 ³»¸°´Ù. 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
			// SkillÀÌ ¿Ã¶ú´Ù´Â °ÍÀ» Å¬¶óÀÌ¾ğÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}

/*void CGame::CalculateSSN_ItemIndex(int iClientH, short sWeaponIndex, int iValue)
{
 short sSkillIndex;
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sWeaponIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	
	sSkillIndex = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_sRelatedSkill;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	// Â½ÂºÃ…Â³ Â¼Ã¶ÃÃ˜Ã€ÃŒ 0Ã€ÃŒÂ¶Ã³Â¸Ã© Ã„Â«Â¿Ã®Ã†Â®Â°Â¡ Â¿Ã€Â¸Â£ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

#ifdef DEF_TESTSERVER
	iValue = iValue * 100;
#endif

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	// Â¸Â¸Â¾Ã  SkillSSNÃ€ÃŒ ÃÂ¦Ã‡Ã‘Ã„Â¡Â¸Â¦ Â³Ã‘Â¾Ã®Â¼Â¹Â´Ã™Â¸Ã© SkillÂ°ÂªÃ€ÃŒ ÃÃµÂ°Â¡Ã‡Ã‘Â´Ã™. 
	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		 (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {
		
		// Â½ÂºÃ…Â³Ã€ÃŒ Â¿ÃƒÂ¶ÃºÂ´Ã™.
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 
		// Ã†Â¯Â¼ÂºÃ„Â¡ ÃÂ¦Ã‡Ã‘Ã€ÃŒ Ã€Ã–Â´Ã‚ SkillÃ€Â» ÃƒÂ³Â¸Â®Ã‡Ã‘Â´Ã™.
		
		switch (sSkillIndex) {
		case 0:
		case 2:
		case 5:
		case 13:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iStr * 2)) {
				// ÃÂ¦Ã‡Ã‘Ã„Â¡ÂºÂ¸Â´Ã™ Ã„Â¿ÃÂ³Â´Ã™. Â¹Â«ÃˆÂ¿Ã€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒÃ€Ã¼Â»Ã³Ã…Ã‚Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3:
			// Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Ã€Ã‡ ÃƒÃ–Â´Ã«Ã„Â¡Â´Ã‚ Level*2
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				// ÃÂ¦Ã‡Ã‘Ã„Â¡ÂºÂ¸Â´Ã™ Ã„Â¿ÃÂ³Â´Ã™. Â¹Â«ÃˆÂ¿Ã€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒÃ€Ã¼Â»Ã³Ã…Ã‚Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:
		case 21: // ÃÃ¶Ã†ÃÃ€ÃŒ Â°Ã¸Â°Ã 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iMag * 2)) {
				// ÃÂ¦Ã‡Ã‘Ã„Â¡ÂºÂ¸Â´Ã™ Ã„Â¿ÃÂ³Â´Ã™. Â¹Â«ÃˆÂ¿Ã€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒÃ€Ã¼Â»Ã³Ã…Ã‚Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 14:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iDex * 2)) {
				// ÃÂ¦Ã‡Ã‘Ã„Â¡ÂºÂ¸Â´Ã™ Ã„Â¿ÃÂ³Â´Ã™. Â¹Â«ÃˆÂ¿Ã€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒÃ€Ã¼Â»Ã³Ã…Ã‚Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 12:
		case 14:
		case 15:
		case 19:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iInt * 2)) {
				// ÃÂ¦Ã‡Ã‘Ã„Â¡ÂºÂ¸Â´Ã™ Ã„Â¿ÃÂ³Â´Ã™. Â¹Â«ÃˆÂ¿Ã€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒÃ€Ã¼Â»Ã³Ã…Ã‚Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // ÂµÂ¶Â¼Âº Ã€ÃºÃ‡Ã— 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				// ÃÂ¦Ã‡Ã‘Ã„Â¡ÂºÂ¸Â´Ã™ Ã„Â¿ÃÂ³Â´Ã™. Â¹Â«ÃˆÂ¿Ã€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒÃ€Ã¼Â»Ã³Ã…Ã‚Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		// Â¸Â¸Â¾Ã  Â¹Â«Â±Ã¢Â¿Ã Â°Ã¼Â·ÃƒÃ€Ã–Â´Ã‚ Â½ÂºÃ…Â³Ã€ÃŒ Â¿ÃƒÂ¶ÃºÂ°Ã­ Ã‡Ã¶Ã€Ã§ Â±Ã— Â¹Â«Â±Ã¢Â¸Â¦ Â»Ã§Â¿Ã« ÃÃŸÃ€ÃŒÂ¶Ã³Â¸Ã© Ã‡Ã¶Ã€Ã§ Â¸Ã­ÃÃŸÂ·Ã¼Â¿Â¡ 1Ã€Â» Â´ÃµÃ‡Ã‘Â´Ã™. 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// Ã„Â«Â¿Ã®Ã†Â®Â°Â¡ 0Ã€ÃŒÂ¸Ã© Â½ÂºÃ…Â³Ã€ÃŒ ÃÂ¤Â»Ã³Ã€Ã»Ã€Â¸Â·Ã Â¿ÃƒÂ¶ÃºÂ´Ã™Â´Ã‚ Ã€Ã‡Â¹ÃŒ. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// Â¾Ã§Â¼Ã•Â¹Â«Â±Ã¢Â°Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã™. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// ÃˆÂ°Â·Ã¹Ã€Ã‡ Â»Ã§Â¿Ã«Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Â½ÂºÃ…Â³Ã€Ã‡ Â»Ã³Â½Ã‚Ã€ÃŒÂ¾ÃºÂ´Ã™. Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» 1 Â¿ÃƒÂ¸Â°Â´Ã™. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// Â¹Â«Â±Ã¢Â°Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã™. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// Â°Ã‹Ã€ÃŒÂ³Âª MaceÂ·Ã¹Ã€Ã‡ Â»Ã§Â¿Ã«Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Â½ÂºÃ…Â³Ã€Ã‡ Â»Ã³Â½Ã‚Ã€ÃŒÂ¾ÃºÂ´Ã™. Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» 1 Â¿ÃƒÂ¸Â°Â´Ã™. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
	 		
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKillÃ€Ã‡ ÃƒÃ‘Ã‡Ã•Ã€ÃŒ 600Ã€Â» Â³Ã‘Ã€Â¸Â¸Ã© Â´Ã™Â¸Â¥ Â½ÂºÃ…Â³ÃÃŸ Ã‡ÃÂ³ÂªÂ¸Â¦ 1 Â³Â»Â¸Â°Â´Ã™. 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
			// SkillÃ€ÃŒ Â¿ÃƒÂ¶ÃºÂ´Ã™Â´Ã‚ Â°ÃÃ€Â» Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}*/


void CGame::CalculateSSN_SkillIndex(int iClientH, short sSkillIndex, int iValue)
{
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	// Â±Ã¢Â¼Ãº Â¼Ã¶ÃÃ˜Ã€ÃŒ 0Ã€ÃŒÂ¶Ã³Â¸Ã© Â½ÂºÃ…Â³Ã€Âº Â¿Ã€Â¸Â£ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

#ifdef DEF_TESTSERVER
	iValue = iValue *100;
#endif

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	// Â¸Â¸Â¾Ã  SkillSSNÃ€ÃŒ ÃÂ¦Ã‡Ã‘Ã„Â¡Â¸Â¦ Â³Ã‘Â¾Ã®Â¼Â¹Â´Ã™Â¸Ã© SkillÂ°ÂªÃ€ÃŒ ÃÃµÂ°Â¡Ã‡Ã‘Â´Ã™. 
	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		(m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {
		
		// Â½ÂºÃ…Â³Ã€ÃŒ Â¿ÃƒÂ¶ÃºÂ´Ã™.
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 
		// Ã†Â¯Â¼ÂºÃ„Â¡ ÃÂ¦Ã‡Ã‘Ã€ÃŒ Ã€Ã–Â´Ã‚ SkillÃ€Â» ÃƒÂ³Â¸Â®Ã‡Ã‘Â´Ã™.
		switch (sSkillIndex) {
		case 0:
		case 5:
		case 13:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iStr * 2)) {
				// ÃÂ¦Ã‡Ã‘Ã„Â¡ÂºÂ¸Â´Ã™ Ã„Â¿ÃÂ³Â´Ã™. Â¹Â«ÃˆÂ¿Ã€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒÃ€Ã¼Â»Ã³Ã…Ã‚Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3:
			// Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Ã€Âº ÃƒÃ–Â´Ã« Level*2Â¸Â¸Ã…Â­ Â¿Ã€Â¸Â¥Â´Ã™.
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				// ÃÂ¦Ã‡Ã‘Ã„Â¡ÂºÂ¸Â´Ã™ Ã„Â¿ÃÂ³Â´Ã™. Â¹Â«ÃˆÂ¿Ã€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒÃ€Ã¼Â»Ã³Ã…Ã‚Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:
		case 21:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iMag * 2)) {
				// ÃÂ¦Ã‡Ã‘Ã„Â¡ÂºÂ¸Â´Ã™ Ã„Â¿ÃÂ³Â´Ã™. Â¹Â«ÃˆÂ¿Ã€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒÃ€Ã¼Â»Ã³Ã…Ã‚Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iDex * 2)) {
				// ÃÂ¦Ã‡Ã‘Ã„Â¡ÂºÂ¸Â´Ã™ Ã„Â¿ÃÂ³Â´Ã™. Â¹Â«ÃˆÂ¿Ã€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒÃ€Ã¼Â»Ã³Ã…Ã‚Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 2:
		case 12:
		case 14:
		case 15:
		case 19:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iInt * 2)) {
				// ÃÂ¦Ã‡Ã‘Ã„Â¡ÂºÂ¸Â´Ã™ Ã„Â¿ÃÂ³Â´Ã™. Â¹Â«ÃˆÂ¿Ã€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒÃ€Ã¼Â»Ã³Ã…Ã‚Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // ÂµÂ¶Â¼Âº Ã€ÃºÃ‡Ã— 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				// ÃÂ¦Ã‡Ã‘Ã„Â¡ÂºÂ¸Â´Ã™ Ã„Â¿ÃÂ³Â´Ã™. Â¹Â«ÃˆÂ¿Ã€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒÃ€Ã¼Â»Ã³Ã…Ã‚Â·Ã ÂµÃ‡ÂµÂ¹Â¸Â°Â´Ã™.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		// Â¸Â¸Â¾Ã  Â¹Â«Â±Ã¢Â¿Ã Â°Ã¼Â·ÃƒÃ€Ã–Â´Ã‚ Â½ÂºÃ…Â³Ã€ÃŒ Â¿ÃƒÂ¶ÃºÂ°Ã­ Ã‡Ã¶Ã€Ã§ Â±Ã— Â¹Â«Â±Ã¢Â¸Â¦ Â»Ã§Â¿Ã« ÃÃŸÃ€ÃŒÂ¶Ã³Â¸Ã© Ã‡Ã¶Ã€Ã§ Â¸Ã­ÃÃŸÂ·Ã¼Â¿Â¡ 1Ã€Â» Â´ÃµÃ‡Ã‘Â´Ã™. 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// Ã„Â«Â¿Ã®Ã†Â®Â°Â¡ 0Ã€ÃŒÂ¸Ã© Â½ÂºÃ…Â³Ã€ÃŒ ÃÂ¤Â»Ã³Ã€Ã»Ã€Â¸Â·Ã Â¿ÃƒÂ¶ÃºÂ´Ã™Â´Ã‚ Ã€Ã‡Â¹ÃŒ. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// Â¾Ã§Â¼Ã•Â¹Â«Â±Ã¢Â°Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã™. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// ÃˆÂ°Â·Ã¹Ã€Ã‡ Â»Ã§Â¿Ã«Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Â½ÂºÃ…Â³Ã€Ã‡ Â»Ã³Â½Ã‚Ã€ÃŒÂ¾ÃºÂ´Ã™. Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» 1 Â¿ÃƒÂ¸Â°Â´Ã™. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// Â¹Â«Â±Ã¢Â°Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã™. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// Â°Ã‹Ã€ÃŒÂ³Âª MaceÂ·Ã¹Ã€Ã‡ Â»Ã§Â¿Ã«Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Â½ÂºÃ…Â³Ã€Ã‡ Â»Ã³Â½Ã‚Ã€ÃŒÂ¾ÃºÂ´Ã™. Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» 1 Â¿ÃƒÂ¸Â°Â´Ã™. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
			
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKillÃ€Ã‡ ÃƒÃ‘Ã‡Ã•Ã€ÃŒ 700Ã€Â» Â³Ã‘Ã€Â¸Â¸Ã© Â´Ã™Â¸Â¥ Â½ÂºÃ…Â³ÃÃŸ Ã‡ÃÂ³ÂªÂ¸Â¦ 1 Â³Â»Â¸Â°Â´Ã™. 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
		
			// SkillÃ€ÃŒ Â¿ÃƒÂ¶ÃºÂ´Ã™Â´Ã‚ Â°ÃÃ€Â» Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}

void CGame::MobGenerator()
{
	register int i, x, j, iNamingValue, iResult, iTotalMob;
	char cNpcName[21], cName_Master[11], cName_Slave[11], cWaypoint[11];
	char cSA;
	int  pX, pY, iMapLevel, iProbSA, iKindSA, iResultNum, iNpcID;
	BOOL bMaster, bFirmBerserk, bIsSpecialEvent;

	if (m_bOnExitProcess == TRUE) return;

	for (i = 0; i < DEF_MAXMAPS; i++) {
		// Random Mob Generator

		/*
		iResultNum = 0;
		// v1.432 ??? ??????????????? ?????? ??? ?????? ??? ??????. 1000???????? 100%  ??? 50%
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE)) {
		// ???????? ?????? ??? ????? ???.
		if (m_iTotalGameServerClients >= 1000) {
		iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
		}
		else {
		dV2 = (double)m_iTotalGameServerClients;
		dV3 = (m_pMapList[i]->m_iMaximumObject - 30);

		dV1 = (dV2 / 1000.0f)*dV3;
		iResultNum = (int)dV1;
		}

		// v1.432 ??? ???
		iMin = (m_pMapList[i]->m_iMaximumObject - 30) - ((m_pMapList[i]->m_iMaximumObject - 30)/3);
		if (iResultNum > (m_pMapList[i]->m_iMaximumObject - 30)) iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
		if (iResultNum < iMin) iResultNum = iMin;
		}
		*/

		//if ( (m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE) && 
		//	 ((m_pMapList[i]->m_iMaximumObject - 30) > m_pMapList[i]->m_iTotalActiveObject) ) {

		if (m_pMapList[i] != NULL) {
			//if (m_bIsCrusadeMode == TRUE) 
			//	 iResultNum = (m_pMapList[i]->m_iMaximumObject - 30) / 3;
			//else iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
			iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
		}

		if ( (m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE) && (iResultNum > m_pMapList[i]->m_iTotalActiveObject) ) {
			if ((m_iMiddlelandMapIndex != -1) && (m_iMiddlelandMapIndex == i) && (m_bIsCrusadeMode == TRUE)) break;

			iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
			if (iNamingValue != -1) {
				// Master Mob????????.
				ZeroMemory(cName_Master, sizeof(cName_Master));
				wsprintf(cName_Master, "XX%d", iNamingValue);
				cName_Master[0] = '_';
				cName_Master[1] = i + 65;

				ZeroMemory(cNpcName, sizeof(cNpcName));

				bFirmBerserk = FALSE;
				iResult = iDice(1,100);
				switch (m_pMapList[i]->m_cRandomMobGeneratorLevel) {

				case 1: // arefarm, elvfarm, aresden, elvine
					if ((iResult >= 1) && (iResult < 20)) {
						iResult = 1; // Slime
					}
					else if ((iResult >= 20) && (iResult < 40)) {
						iResult = 2; // Giant-Ant
					}
					else if ((iResult >= 40) && (iResult < 85)) {
						iResult = 24; // Rabbit
					}
					else if ((iResult >= 85) && (iResult < 95)) {
						iResult = 25; // Cat
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						iResult = 3; // Orc
					}
					iMapLevel = 1;
					break;

				case 2:
					if ((iResult >= 1) && (iResult < 40)) {
						iResult = 1;
					}
					else if ((iResult >= 40) && (iResult < 80)) {
						iResult = 2;
					}
					else iResult = 10;
					iMapLevel = 1;
					break;

				case 3:     // v1.4334 ????????? ????
					if ((iResult >= 1) && (iResult < 20)) {
						switch (iDice(1,2)) {
				case 1: iResult = 3;  break;
				case 2: iResult = 4;  break;
						}
					}
					else if ((iResult >= 20) && (iResult < 25)) {
						iResult = 30;
					}
					else if ((iResult >= 25) && (iResult < 50)) {
						switch (iDice(1,3)) {	
				case 1: iResult = 5;  break;
				case 2: iResult = 6;  break;
				case 3:	iResult = 7;  break;
						}
					}
					else if ((iResult >= 50) && (iResult < 75)) {
						switch (iDice(1,7)) {
				case 1:
				case 2:	iResult = 8;  break;
				case 3:	iResult = 11; break;
				case 4: iResult = 12; break;
				case 5:	iResult = 18; break;
				case 6:	iResult = 26; break;
				case 7: iResult = 28; break;
						}
					}
					else if ((iResult >= 75) && (iResult <= 100)) {
						switch (iDice(1,5)) {	
				case 1:
				case 2: iResult = 9;  break;
				case 3:	iResult = 13; break;
				case 4: iResult = 14; break;
				case 5:	iResult = 27; break;
						}
					}
					iMapLevel = 3;
					break;

				case 4:
					if ((iResult >= 1) && (iResult < 50)) {
						switch (iDice(1,2)) {
				case 1:	iResult = 2;  break;
				case 2: iResult = 10; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						switch (iDice(1,2)) {
				case 1: iResult = 8;  break;
				case 2: iResult = 11; break;
						}
					}
					else if ((iResult >= 80) && (iResult <= 100)) {
						switch (iDice(1,2)) {
				case 1: iResult = 14; break;
				case 2:	iResult = 9;  break;
						}
					}
					iMapLevel = 2;
					break;

				case 5:
					if ((iResult >= 1) && (iResult < 30)) {
						switch (iDice(1,5)) {
				case 1:
				case 2: 
				case 3:
				case 4: 
				case 5: iResult = 2;  break;
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch (iDice(1,2)) {
				case 1: iResult = 3;  break;
				case 2: iResult = 4;  break;
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch (iDice(1,2)) {
				case 1: iResult = 5;  break;
				case 2: iResult = 7;  break;
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch (iDice(1,3)) {
				case 1:
				case 2: iResult = 8;  break;
				case 3:	iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch (iDice(1,3)) {
				case 1: iResult = 11; break;
				case 2: iResult = 14; break;
				case 3: iResult = 9;  break;
						}
					}
					iMapLevel = 3;
					break;

				case 6: // huntzone3, huntzone4
					if ((iResult >= 1) && (iResult < 60)) {
						switch (iDice(1,4)) {
				case 1: iResult = 5;  break; // Skeleton
				case 2:	iResult = 6;  break; // Orc-Mage
				case 3: iResult = 12; break; // Cyclops
				case 4: iResult = 11; break; // Troll
						}
					}
					else if ((iResult >= 60) && (iResult < 90)) {
						switch (iDice(1,5)) {
				case 1:
				case 2: iResult = 8;  break; // Stone-Golem
				case 3:	iResult = 11; break; // Troll
				case 4:	iResult = 12; break; // Cyclops 
				case 5:	iResult = 43; break; // Tentocle
						}
					}
					else if ((iResult >= 90) && (iResult <= 100)) {
						switch (iDice(1,9)) {
				case 1:	iResult = 26; break;
				case 2:	iResult = 9;  break;
				case 3: iResult = 13; break;
				case 4: iResult = 14; break;
				case 5:	iResult = 18; break;
				case 6:	iResult = 28; break;
				case 7: iResult = 27; break;
				case 8: iResult = 29; break;
						}
					}
					iMapLevel = 4;
					break;

				case 7: // areuni, elvuni
					if ((iResult >= 1) && (iResult < 50)) {
						switch (iDice(1,5)) {
						case 1: iResult = 3;  break; // Orc
						case 2: iResult = 6;  break; // Orc-Mage
						case 3: iResult = 10; break; // Amphis
						case 4: iResult = 3;  break; // Orc
						case 5: iResult = 50; break; // Giant-Tree
						}
					}
					else if ((iResult >= 50) && (iResult < 60)) { 
						iResult = 29; // Rudolph
					}
					else if ((iResult >= 60) && (iResult < 85)) { 
						switch (iDice(1,4)) {
						case 1: iResult = 50; break; // Giant-Tree
						case 2: 
						case 3: iResult = 6;  break; // Orc-Mage
						case 4: iResult = 12; break; // Troll
						}
					}
					else if ((iResult >= 85) && (iResult <= 100)) {
						switch (iDice(1,4)) {
				case 1: iResult = 12;  break; // Troll
				case 2:
				case 3:
					if (iDice(1,100) < 3) 
						iResult = 17; // Unicorn
					else iResult = 12; // Troll
					break;
				case 4: iResult = 29;  break; // Cannibal-Plant
						}
					}
					iMapLevel = 4;
					break;

				case 8:
					if ((iResult >= 1) && (iResult < 70)) {
						switch (iDice(1,2)) {
						case 1:	iResult = 4;  break;
						case 2: iResult = 5;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch (iDice(1,2)) {
						case 1: iResult = 8;  break;
						case 2: iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						iResult = 14; break;
					}
					iMapLevel = 4;
					break;

				case 9:
					if ((iResult >= 1) && (iResult < 70)) {
						switch (iDice(1,2)) {
				case 1:	iResult = 4;  break;
				case 2: iResult = 5;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch (iDice(1,3)) {
				case 1: iResult = 8;  break;
				case 2: iResult = 9;  break;
				case 3: iResult = 13; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch (iDice(1,6)) {
				case 1: 
				case 2: 
				case 3: iResult = 9;  break;
				case 4: 
				case 5: iResult = 14; break;
				case 6: iResult = 15; break;
						}
					}

					if ((iDice(1,3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;
					iMapLevel = 5;
					break;

				case 10:
					if ((iResult >= 1) && (iResult < 70)) {
						switch (iDice(1,3)) {
				case 1:	iResult = 9; break;
				case 2: iResult = 5; break;
				case 3: iResult = 8; break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch (iDice(1,3)) {
				case 1:
				case 2:	iResult = 13; break;
				case 3: iResult = 14; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch (iDice(1,3)) {
				case 1:
				case 2: iResult = 14; break;
				case 3: iResult = 15; break;
						}
					}
					// Demon?? Berserk ????? ??? ?????
					if ((iDice(1,3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;
					iMapLevel = 5;
					break;

				case 11:
					if ((iResult >= 1) && (iResult < 30)) {
						switch (iDice(1,5)) {
				case 1:
				case 2: 
				case 3:
				case 4: 
				case 5: iResult = 2; break;
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch (iDice(1,2)) {
				case 1: iResult = 3; break;
				case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch (iDice(1,2)) {
				case 1: iResult = 5; break;
				case 2: iResult = 7; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch (iDice(1,3)) {
				case 1:
				case 2: iResult = 10;  break;
				case 3:	iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch (iDice(1,3)) {
				case 1: iResult = 11; break;
				case 2: iResult = 7; break;
				case 3: iResult = 8; break;
						}
					}
					iMapLevel = 4;
					break;

				case 12:
					if ((iResult >= 1) && (iResult < 50)) {
						switch (iDice(1,3)) {
				case 1:	iResult = 1 ; break;
				case 2: iResult = 2 ; break;
				case 3: iResult = 10; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 85)) {
						switch (iDice(1,2)) {
				case 1: iResult = 5; break;
				case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 85) && (iResult <= 100)) {
						switch (iDice(1,3)) {
				case 1: iResult = 8; break;
				case 2: iResult = 11; break;
				case 3: iResult = 26; break;
						}
					}
					iMapLevel = 4;
					break;

				case 13:
					if ((iResult >= 1) && (iResult < 15)) {
						iResult = 4;
						bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
						break;
					}
					else if ((iResult >= 15) && (iResult < 40)) {
						iResult = 14;
						bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
						break;
					}
					else if ((iResult >= 40) && (iResult < 60)) {
						iResult = 9;
						bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
						break;
					}						
					else if ((iResult >= 60) && (iResult < 75)) {
						iResult = 13;
						bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
						break;
					}
					else if ((iResult >= 75) && (iResult < 95)) {
						iResult = 23;
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						iResult = 22;
					}
					iMapLevel = 5;
					break;

				case 14: // icebound
					if ((iResult >= 1) && (iResult < 30)) {
						iResult = 23; // Dark-Elf
					}
					else if ((iResult >= 30) && (iResult < 50)) {
						iResult = 31; // Ice-Golem
					}
					else if ((iResult >= 50) && (iResult < 70)) {
						iResult = 22; // Beholder
						bFirmBerserk = TRUE;
						iTotalMob = 4 - (iDice(1,2) - 1);
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						iResult = 32; // DireBoar
					}
					else if ((iResult >= 90) && (iResult <= 100)) {
						iResult = 33; // Frost
					}
					iMapLevel = 5;
					break;

				case 15:
					if ((iResult >= 1) && (iResult < 35)) {
						iResult = 23; 
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 35) && (iResult < 50)) {
						iResult = 22;
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						iResult = 15;
					}
					else if ((iResult >= 80) && (iResult <= 100)) {
						iResult = 21;
					}
					iMapLevel = 4;
					break;

				case 16: // 2ndmiddle, huntzone1, huntzone2, 
					if ((iResult >= 1) && (iResult < 40)) {
						switch (iDice(1,3)) {
						case 1:	iResult = 7;  break; // Scorpion
						case 2: iResult = 2;  break; // Giant-Ant
						case 3: iResult = 10; break; // Amphis
						}
					}
					else if ((iResult >= 40) && (iResult < 50)) {
						iResult = 30; // Rudolph
					}
					else if ((iResult >= 50) && (iResult < 85)) {
						switch (iDice(1,2)) {
						case 1: iResult = 5;  break; // Skeleton
						case 2: iResult = 4;  break; // Zombie
						}
					}
					else if ((iResult >= 85) && (iResult <= 100)) {
						switch (iDice(1,3)) {
						case 1: iResult = 8;  break; // Stone-Golem
						case 2: iResult = 11; break; // Clay-Golem
						case 3: iResult = 7;  break; // Scorpion
						}
					}
					iMapLevel = 1;
					break;

				case 17:
					if ((iResult >= 1) && (iResult < 30)) {
						switch (iDice(1,4)) {
						case 1:	iResult = 22;  break; // Giant-Frog
						case 2: iResult = 8;   break; // Stone-Golem
						case 3: iResult = 24;  break; // Rabbit
						case 4: iResult = 5;   break;
						}
					}
					else if ((iResult >= 30) && (iResult < 40)) {
						iResult = 30;
					}
					else if ((iResult >= 40) && (iResult < 70)) {
						iResult = 32;
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						iResult = 31;
						if (iDice(1,5) == 1) {
							bFirmBerserk = TRUE;
						}
					}
					else if ((iResult >= 90) && (iResult <= 100)) {
						iResult = 33;
					}
					iMapLevel = 1;
					break;

				case 18: // druncncity
					if ((iResult >= 1) && (iResult < 2)) {
						iResult = 39; // Tentocle
					}
					else if ((iResult >= 2) && (iResult < 12)) {
						iResult = 44; // ClawTurtle
					}
					else if ((iResult >= 12) && (iResult < 50)) {
						iResult = 48; // Nizie
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						iResult = 45; // Giant-Crayfish
					}
					else if ((iResult >= 80) && (iResult < 90)) {
						iResult = 34; // Stalker
					}			
					else if ((iResult >= 90) && (iResult <= 100)) {
						iResult = 26; // Giant-Frog
					}					
					iMapLevel = 4;
					break;

				case 19:
					if ((iResult >= 1) && (iResult < 15)) {
						iResult = 44;
					}
					else if ((iResult >= 15) && (iResult < 25)) {
						iResult = 46;
					}
					else if ((iResult >= 25) && (iResult < 35)) {
						iResult = 21;
					}
					else if ((iResult >= 35) && (iResult < 60)) {
						iResult = 43;
					}				
					else if ((iResult >= 60) && (iResult < 85)) {
						iResult = 23;
					}		
					else if ((iResult >= 85) && (iResult <= 100)) {
						iResult = 22;
					}
					iMapLevel = 4;
					break;

				case 20:
					if ((iResult >= 1) && (iResult < 2)) {
						iResult = 41;
					}
					else if ((iResult >= 2) && (iResult < 3)) {
						iResult = 40;
					}
					else if ((iResult >= 3) && (iResult < 8)) {
						iResult = 53;
					}
					else if ((iResult >= 8) && (iResult < 9)) {
						iResult = 39;
					}
					else if ((iResult >= 9) && (iResult < 20)) {
						iResult = 21;
					}
					else if ((iResult >= 20) && (iResult < 35)) {
						iResult = 16;
					}
					else if ((iResult >= 35) && (iResult < 45)) {
						iResult = 44;
					}
					else if ((iResult >= 45) && (iResult < 55)) {
						iResult = 45;
					}
					else if ((iResult >= 55) && (iResult < 75)) {
						iResult = 28;
					}
					else if ((iResult >= 75) && (iResult < 95)) {
						iResult = 43;
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						iResult = 22;
					}
					iMapLevel = 4;
					break;

				case 21:
					if ((iResult >= 1) && (iResult < 94)) {
						iResult = 17; // Unicorn
						bFirmBerserk = TRUE;
					}
					else if ((iResult >= 94) && (iResult < 95)) {
						iResult = 36; // Wyvern
					}
					else if ((iResult >= 95) && (iResult < 96)) {
						iResult = 37; // Fire-Wyvern
					}
					else if ((iResult >= 96) && (iResult < 97)) {
						iResult = 47; // MasterMage-Orc
					}
					else if ((iResult >= 97) && (iResult < 98)) {
						iResult = 35; // Hellclaw
					}				
					else if ((iResult >= 98) && (iResult < 99)) {
						iResult = 49; // Tigerworm
					}		
					else if ((iResult >= 99) && (iResult <= 100)) {
						iResult = 51; // Abaddon
					}
					iMapLevel = 4;
					break;
	
				}			

				pX = NULL;
				pY = NULL;

//				bIsSpecialEvent = TRUE;
				if ((m_bIsSpecialEventTime == TRUE) && (iDice(1,10) == 3)) bIsSpecialEvent = TRUE;

				if (bIsSpecialEvent == TRUE) {
					switch (m_cSpecialEventType) {
					case 1:
						if (m_pMapList[i]->m_iMaxPx != 0) {
							pX = m_pMapList[i]->m_iMaxPx*20 +10;
							pY = m_pMapList[i]->m_iMaxPy*20 +10;

							if (pX < 0) pX = 0;
							if (pY < 0) pY = 0;

							if (m_bIsCrusadeMode == TRUE) {
								if (strcmp(m_pMapList[i]->m_cName, "aresden") == 0)
									switch(iDice(1,6)) {
									case 1: iResult = 20; break;
									case 2: iResult = 53; break;
									case 3: iResult = 55; break;
									case 4: iResult = 57; break;
									case 5: iResult = 59; break;
									case 6: iResult = 61; break;
								}
								else if (strcmp(m_pMapList[i]->m_cName, "elvine") == 0)
									switch(iDice(1,6)) {
									case 1: iResult = 19; break;
									case 2: iResult = 52; break;
									case 3: iResult = 54; break;
									case 4: iResult = 56; break;
									case 5: iResult = 58; break;
									case 6: iResult = 60; break;
								}
							}
							wsprintf(G_cTxt, "(!) Mob-Event Map(%s)[%d (%d,%d)]", m_pMapList[i]->m_cName, iResult, pX, pY);
						}
						break;

					case 2:
						if (iDice(1,3) == 2) {
							if ((memcmp(m_pMapList[i]->m_cLocationName, "aresden", 7)   == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "middled1n", 9) == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "arefarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "elvfarm", 7) == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "elvine", 6)    == 0)) {
									if (iDice(1,30) == 5) 
										iResult = 16;
									else iResult = 5;
								}
							else iResult = 16;
						}
						else iResult = 17;

						m_bIsSpecialEventTime = FALSE;
						break;
					}
				}

				ZeroMemory(cNpcName, sizeof(cNpcName));
				//Random Monster Spawns
				switch (iResult) {
				case 1:  strcpy(cNpcName, "Slime");				iNpcID = 10; iProbSA = 5;  iKindSA = 1; break;
				case 2:  strcpy(cNpcName, "Giant-Ant");			iNpcID = 16; iProbSA = 10; iKindSA = 2; break;
				case 3:  strcpy(cNpcName, "Orc");				iNpcID = 14; iProbSA = 15; iKindSA = 1; break;
				case 4:  strcpy(cNpcName, "Zombie");			iNpcID = 18; iProbSA = 15; iKindSA = 3; break;
				case 5:  strcpy(cNpcName, "Skeleton");			iNpcID = 11; iProbSA = 35; iKindSA = 8; break;
				case 6:  strcpy(cNpcName, "Orc-Mage");			iNpcID = 14; iProbSA = 30; iKindSA = 7; break;
				case 7:  strcpy(cNpcName, "Scorpion");			iNpcID = 17; iProbSA = 15; iKindSA = 3; break;
				case 8:  strcpy(cNpcName, "Stone-Golem");		iNpcID = 12; iProbSA = 25; iKindSA = 5; break;
				case 9:  strcpy(cNpcName, "Cyclops");			iNpcID = 13; iProbSA = 35; iKindSA = 8; break;
				case 10: strcpy(cNpcName, "Amphis");			iNpcID = 22; iProbSA = 20; iKindSA = 3; break;
				case 11: strcpy(cNpcName, "Clay-Golem");		iNpcID = 23; iProbSA = 20; iKindSA = 5; break;
				case 12: strcpy(cNpcName, "Troll");				iNpcID = 28; iProbSA = 25; iKindSA = 3; break; 
				case 13: strcpy(cNpcName, "Orge");				iNpcID = 29; iProbSA = 25; iKindSA = 1; break;
				case 14: strcpy(cNpcName, "Hellbound");			iNpcID = 27; iProbSA = 25; iKindSA = 8; break;
				case 15: strcpy(cNpcName, "Liche");				iNpcID = 30; iProbSA = 30; iKindSA = 8; break;
				case 16: strcpy(cNpcName, "Demon");				iNpcID = 31; iProbSA = 20; iKindSA = 8; break;
				case 17: strcpy(cNpcName, "Unicorn");			iNpcID = 32; iProbSA = 35; iKindSA = 7; break;
				case 18: strcpy(cNpcName, "WereWolf");			iNpcID = 33; iProbSA = 25; iKindSA = 1; break;
				case 19: strcpy(cNpcName, "YB-Aresden");		iNpcID = -1;  iProbSA = 15; iKindSA = 1; break;
				case 20: strcpy(cNpcName, "YB-Elvine");			iNpcID = -1;  iProbSA = 15; iKindSA = 1; break;
				case 21: strcpy(cNpcName, "Gagoyle");			iNpcID = 52; iProbSA = 20; iKindSA = 8; break;
				case 22: strcpy(cNpcName, "Beholder");			iNpcID = 53; iProbSA = 20; iKindSA = 5; break;
				case 23: strcpy(cNpcName, "Dark-Elf");			iNpcID = 54; iProbSA = 20; iKindSA = 3; break;
				case 24: strcpy(cNpcName, "Rabbit");			iNpcID = -1; iProbSA = 5;  iKindSA = 1; break;
				case 25: strcpy(cNpcName, "Cat");				iNpcID = -1; iProbSA = 10; iKindSA = 2; break;
				case 26: strcpy(cNpcName, "Giant-Frog");		iNpcID = 57; iProbSA = 10; iKindSA = 2; break;
				case 27: strcpy(cNpcName, "Mountain-Giant");	iNpcID = 58; iProbSA = 25; iKindSA = 1; break;
				case 28: strcpy(cNpcName, "Ettin");				iNpcID = 59; iProbSA = 20; iKindSA = 8; break;
				case 29: strcpy(cNpcName, "Cannibal-Plant");	iNpcID = 60; iProbSA = 20; iKindSA = 5; break;
				case 30: strcpy(cNpcName, "Rudolph");			iNpcID = -1; iProbSA = 20; iKindSA = 5; break;
				case 31: strcpy(cNpcName, "Ice-Golem");			iNpcID = 65; iProbSA = 35; iKindSA = 8; break;
				case 32: strcpy(cNpcName, "DireBoar");			iNpcID = 62; iProbSA = 20; iKindSA = 5; break;
				case 33: strcpy(cNpcName, "Frost");				iNpcID = 63; iProbSA = 30; iKindSA = 8; break;
				case 34: strcpy(cNpcName, "Stalker");           iNpcID = 48; iProbSA = 20; iKindSA = 1; break;
				case 35: strcpy(cNpcName, "Hellclaw");			iNpcID = 49; iProbSA = 20; iKindSA = 1; break;
				case 36: strcpy(cNpcName, "Wyvern");			iNpcID = 66; iProbSA = 20; iKindSA = 1; break;
				case 37: strcpy(cNpcName, "Fire-Wyvern");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break; 
				case 38: strcpy(cNpcName, "Barlog");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 39: strcpy(cNpcName, "Tentocle");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 40: strcpy(cNpcName, "Centaurus");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 41: strcpy(cNpcName, "Giant-Lizard");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 42: strcpy(cNpcName, "Minotaurs");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 43: strcpy(cNpcName, "Tentocle");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 44: strcpy(cNpcName, "Claw-Turtle");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 45: strcpy(cNpcName, "Giant-Crayfish");	iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 46: strcpy(cNpcName, "Giant-Plant");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 47: strcpy(cNpcName, "MasterMage-Orc");	iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 48: strcpy(cNpcName, "Nizie");				iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 49: strcpy(cNpcName, "Tigerworm");			iNpcID = 50; iProbSA = 20; iKindSA = 1; break;
				case 50: strcpy(cNpcName, "Giant-Plant");		iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 51: strcpy(cNpcName, "Abaddon");			iNpcID = -1; iProbSA = 20; iKindSA = 1; break;
				case 52: strcpy(cNpcName, "YW-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 53: strcpy(cNpcName, "YW-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 54: strcpy(cNpcName, "YY-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 55: strcpy(cNpcName, "YY-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 56: strcpy(cNpcName, "XB-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 57: strcpy(cNpcName, "XB-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 58: strcpy(cNpcName, "XW-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 59: strcpy(cNpcName, "XW-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 60: strcpy(cNpcName, "XY-Aresden");		iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				case 61: strcpy(cNpcName, "XY-Elvine");			iNpcID = -1; iProbSA = 15; iKindSA = 1; break;
				default: strcpy(cNpcName, "Orc");				iNpcID = 14; iProbSA = 15; iKindSA = 1; break;
				}

				cSA = 0;
				if (iDice(1,100) <= iProbSA) {
					cSA = _cGetSpecialAbility(iKindSA);
				}

				if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk, TRUE)) == FALSE) {
					m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
				}
				else {

				}
			}	

			switch (iResult) {
			case 1:	 iTotalMob = iDice(1,5)-1; break;
			case 2:	 iTotalMob = iDice(1,5)-1; break;
			case 3:	 iTotalMob = iDice(1,5)-1; break;
			case 4:	 iTotalMob = iDice(1,3)-1; break;
			case 5:	 iTotalMob = iDice(1,3)-1; break;

			case 6:  iTotalMob = iDice(1,3)-1; break;
			case 7:  iTotalMob = iDice(1,3)-1; break;
			case 8:  iTotalMob = iDice(1,2)-1; break;
			case 9:  iTotalMob = iDice(1,2)-1; break;
			case 10: iTotalMob = iDice(1,5)-1; break;
			case 11: iTotalMob = iDice(1,3)-1; break;
			case 12: iTotalMob = iDice(1,5)-1; break;
			case 13: iTotalMob = iDice(1,3)-1; break;
			case 14: iTotalMob = iDice(1,2)-1; break;
			case 15: iTotalMob = iDice(1,3)-1; break;
			case 16: iTotalMob = iDice(1,2)-1; break;
			case 17: iTotalMob = iDice(1,2)-1; break;

			case 18: iTotalMob = iDice(1,5)-1; break;
			case 19: iTotalMob = iDice(1,2)-1; break;
			case 20: iTotalMob = iDice(1,2)-1; break;
			case 21: iTotalMob = iDice(1,5)-1; break;
			case 22: iTotalMob = iDice(1,2)-1; break;
			case 23: iTotalMob = iDice(1,2)-1; break;

			case 24: iTotalMob = iDice(1,4)-1; break;
			case 25: iTotalMob = iDice(1,2)-1; break;
			case 26: iTotalMob = iDice(1,3)-1; break;
			case 27: iTotalMob = iDice(1,3)-1; break;

			case 28: iTotalMob = iDice(1,3)-1; break;
			case 29: iTotalMob = iDice(1,5)-1; break;
			case 30: iTotalMob = iDice(1,3)-1; break;
			case 31: iTotalMob = iDice(1,3)-1; break;

			case 32: iTotalMob = 1; break;
			case 33: iTotalMob = 1; break;
			case 34: iTotalMob = 1; break;
			case 35: iTotalMob = 1; break;
			case 36: iTotalMob = 1; break;

			case 37: iTotalMob = 1; break;
			case 38: iTotalMob = 1; break;
			case 39: iTotalMob = 1; break;
			case 40: iTotalMob = 1; break;
			case 41: iTotalMob = 1; break;

			case 42: iTotalMob = iDice(1,3)-1; break;
			case 43: iTotalMob = 1; break;
			case 44: iTotalMob = iDice(1,3)-1; break; 
			case 45: iTotalMob = 1; break;
			default: iTotalMob = 0; break;
			}

			if (bMaster == FALSE) iTotalMob = 0;

			if (iTotalMob > 2) {
				switch (iResult) {
				case 1:  // Slime 
				case 2:  // Giant-Ant
				case 3:  // Orc
				case 4:  // Zombie
				case 5:  // Skeleton
				case 6:  // Orc-Mage
				case 7:  // Scorpion
				case 8:  // Stone-Golem
				case 9:  // Cyclops
				case 10: // Amphis
				case 11: // Clay-Golem
				case 12: // Troll
				case 13: // Orge
				case 14: // Hellbound
				case 15: // Liche
				case 16: // Demon
				case 17: // Unicorn
				case 18: // WereWolf
				case 19:
				case 20:
				case 21:
				case 22:
				case 23:
				case 24:
				case 25:
				case 26:
				case 27:
				case 28:
				case 29:
				case 30:
				case 31:
				case 32:
					if (iDice(1,5) == 1) iTotalMob = 0;  // 75% ???????? ???.
					break;

				case 33:
				case 34:
				case 35:
				case 36:
				case 37:
				case 38:
				case 39:
				case 40:
				case 41:
				case 42:
				case 44:
				case 45:
				case 46:
				case 47:
				case 48:
				case 49:
					if (iDice(1,5) != 1) iTotalMob = 0;  // 75% ???????????????
					break;
				}
			}

			if (bIsSpecialEvent == TRUE) {
				switch (m_cSpecialEventType) {
				case 1:
					if ((iResult != 35) && (iResult != 36) && (iResult != 37) && (iResult != 49) 
						&& (iResult != 51) && (iResult != 15) && (iResult != 16) && (iResult != 21)) iTotalMob = 12;
					for (x = 1; x < DEF_MAXCLIENTS; x++)
					if ((iNpcID != -1) && (m_pClientList[x] != NULL) && (m_pClientList[x]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, x, DEF_NOTIFY_SPAWNEVENT, pX, pY, iNpcID, NULL, NULL, NULL);
					}
					break;

				case 2:
					if ((memcmp(m_pMapList[i]->m_cLocationName, "aresden", 7) == 0) ||
						(memcmp(m_pMapList[i]->m_cLocationName, "elvine",  6) == 0) ||
						(memcmp(m_pMapList[i]->m_cLocationName, "elvfarm",  7) == 0) ||
						(memcmp(m_pMapList[i]->m_cLocationName, "arefarm",  7) == 0) ) {
							iTotalMob = 0;
						}
						break;
				}
				m_bIsSpecialEventTime = FALSE;
			}

			for (j = 0; j < iTotalMob; j++) {
				iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					ZeroMemory(cName_Slave, sizeof(cName_Slave));
					wsprintf(cName_Slave, "XX%d", iNamingValue);
					cName_Slave[0] = 95; // original '_';
					cName_Slave[1] = i + 65;

					cSA = 0;

					if (iDice(1,100) <= iProbSA) {
						cSA = _cGetSpecialAbility(iKindSA);
					}

					if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
						m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
					}
					else {
						bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
					}
				}
			}
		}

		if ( (m_pMapList[i] != NULL) && ((m_pMapList[i]->m_iMaximumObject) > m_pMapList[i]->m_iTotalActiveObject) ) {
			for (j = 1; j < DEF_MAXSPOTMOBGENERATOR; j++)
				if ( (iDice(1,3) == 2) && (m_pMapList[i]->m_stSpotMobGenerator[j].bDefined == TRUE) &&
					(m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs > m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs) ) {
						iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {

							ZeroMemory(cNpcName, sizeof(cNpcName));
							switch (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType) {
								// spot-mob-generator
									case 10:  strcpy(cNpcName,"Slime");				iProbSA = 5;  iKindSA = 1;  break;
									case 16:  strcpy(cNpcName,"Giant-Ant");			iProbSA = 10; iKindSA = 2;  break;
									case 14:  strcpy(cNpcName,"Orc");				iProbSA = 15; iKindSA = 1;  break;
									case 18:  strcpy(cNpcName,"Zombie");			iProbSA = 15; iKindSA = 3;  break;
									case 11:  strcpy(cNpcName,"Skeleton");			iProbSA = 35; iKindSA = 8;  break;
									case 6:   strcpy(cNpcName,"Orc-Mage");			iProbSA = 30; iKindSA = 7;  break;
									case 17:  strcpy(cNpcName,"Scorpion");			iProbSA = 15; iKindSA = 3;  break;
									case 12:  strcpy(cNpcName,"Stone-Golem");		iProbSA = 25; iKindSA = 5;  break;
									case 13:  strcpy(cNpcName,"Cyclops");			iProbSA = 35; iKindSA = 8;  break;
									case 22:  strcpy(cNpcName,"Amphis");			iProbSA = 20; iKindSA = 3;  break;
									case 23:  strcpy(cNpcName,"Clay-Golem");		iProbSA = 20; iKindSA = 5;  break;
									case 24:  strcpy(cNpcName,"Guard-Aresden");		iProbSA = 20; iKindSA = 1;  break;
									case 25:  strcpy(cNpcName,"Guard-Elvine");		iProbSA = 20; iKindSA = 1;  break;
									case 26:  strcpy(cNpcName,"Guard-Neutral");		iProbSA = 20; iKindSA = 1;  break;
									case 27:  strcpy(cNpcName,"Hellbound");			iProbSA = 20; iKindSA = 1;  break;
									case 29:  strcpy(cNpcName,"Orge");              iProbSA = 20; iKindSA = 1;  break;
									case 30:  strcpy(cNpcName,"Liche");				iProbSA = 30; iKindSA = 8;  break;
									case 31:  strcpy(cNpcName,"Demon");				iProbSA = 20; iKindSA = 8;  break;
									case 32:  strcpy(cNpcName,"Unicorn");			iProbSA = 35; iKindSA = 7;  break;
									case 33:  strcpy(cNpcName,"WereWolf");			iProbSA = 25; iKindSA = 1;  break;
									case 34:  strcpy(cNpcName,"Dummy");				iProbSA = 5;  iKindSA = 1;  break;
									case 35:  strcpy(cNpcName,"Attack-Dummy");		iProbSA = 5;  iKindSA = 1;  break;
									case 48:  strcpy(cNpcName,"Stalker");			iProbSA = 20; iKindSA = 3;  break;
										/*									case 49:  
										if (iDice(1,144000) == 13) {
										strcpy(cNpcName,"Hellclaw");
										iProbSA = 20;
										iKindSA = 8;
										}
										break;
										case 50:  
										if (iDice(1, 3606) == 135) {
										strcpy(cNpcName,"Tigerworm");
										iProbSA = 20;
										iKindSA = 8;
										}
										else {
										strcpy(cNpcName, "Stalker");
										iProbSA = 15;
										iKindSA = 1;
										}
										break;*/
									case 49:  strcpy(cNpcName,"Hellclaw");			iProbSA = 20; iKindSA = 8;  break;
									case 50:  strcpy(cNpcName,"Tigerworm");			iProbSA = 20; iKindSA = 8;  break;
									case 54:  strcpy(cNpcName,"Dark-Elf");			iProbSA = 20; iKindSA = 8;  break;
									case 53:  strcpy(cNpcName,"Beholder");			iProbSA = 20; iKindSA = 8;  break;
									case 52:  strcpy(cNpcName,"Gagoyle");			iProbSA = 20; iKindSA = 8;  break;
										/*									case 40:  
										if (iDice(1, 3606) == 135) {
										strcpy(cNpcName,"Hellclaw");
										iProbSA = 20;
										iKindSA = 8;
										}
										break;*/
									case 57:  strcpy(cNpcName,"Giant-Frog");		iProbSA = 10; iKindSA = 2;  break;
									case 58:  strcpy(cNpcName,"Mountain-Giant");	iProbSA = 25; iKindSA = 1;  break;
									case 59:  strcpy(cNpcName,"Ettin");				iProbSA = 20; iKindSA = 8;  break;
									case 60:  strcpy(cNpcName,"Cannibal-Plant");	iProbSA = 20; iKindSA = 5;  break;
									case 61:  strcpy(cNpcName,"Rudolph");			iProbSA = 20; iKindSA = 1;  break;
									case 62:  strcpy(cNpcName,"DireBoar");			iProbSA = 20; iKindSA = 1;  break;
									case 63:  strcpy(cNpcName,"Frost");				iProbSA = 20; iKindSA = 8;  break;
									case 65:  strcpy(cNpcName,"Ice-Golem");			iProbSA = 20; iKindSA = 8;  break;
									case 66:  strcpy(cNpcName,"Wyvern");			iProbSA = 20; iKindSA = 1;  break;
									case 55:  strcpy(cNpcName,"Rabbit");			iProbSA = 20; iKindSA = 1;  break;
									case 67:  strcpy(cNpcName,"McGaffin");			iProbSA = 20; iKindSA = 1;  break;
									case 68:  strcpy(cNpcName,"Perry");				iProbSA = 20; iKindSA = 1;  break;
									case 69:  strcpy(cNpcName,"Devlin");			iProbSA = 20; iKindSA = 1;  break;
									case 73:  strcpy(cNpcName,"Fire-Wyvern");		iProbSA = 20; iKindSA = 1;  break;
									case 70:  strcpy(cNpcName,"Barlog");			iProbSA = 20; iKindSA = 1;  break;
									case 80:  strcpy(cNpcName,"Tentocle");			iProbSA = 20; iKindSA = 1;  break;
									case 71:  strcpy(cNpcName,"Centaurus");			iProbSA = 20; iKindSA = 1;  break;
									case 75:  strcpy(cNpcName,"Giant-Lizard");		iProbSA = 20; iKindSA = 1;  break;
									case 78:  strcpy(cNpcName,"Minotaurs");			iProbSA = 20; iKindSA = 1;  break;
									case 81:  strcpy(cNpcName,"Abaddon");			iProbSA = 20; iKindSA = 1;  break;
									case 72:  strcpy(cNpcName,"Claw-Turtle");		iProbSA = 20; iKindSA = 1;  break;
									case 74:  strcpy(cNpcName,"Giant-Crayfish");	iProbSA = 20; iKindSA = 1;  break;
									case 76:  strcpy(cNpcName,"Giant-Plant");		iProbSA = 20; iKindSA = 1;  break;
									case 77:  strcpy(cNpcName,"MasterMage-Orc");	iProbSA = 20; iKindSA = 1;  break;
									case 79:  strcpy(cNpcName,"Nizie");				iProbSA = 20; iKindSA = 1; break;
									default: 
										strcpy(cNpcName, "Orc");
										iProbSA = 15; 
										iKindSA = 1; 
										break;
							}						
							/* NPCs not spawning in pits: 
							case 56:  strcpy(cNpcName,"Cat");				iProbSA = 15; iKindSA = 6;  break;
							case 28:  strcpy(cNpcName, "Troll");			iProbSA = 25; iKindSA = 3; break; 

							// 15 ShopKeeper-W
							// 19 Gandlf          
							// 20 Howard
							// 36 Arrow Gaurd Tower Kit - Aresden, Elvine
							// 37 Cannon Gaurd Tower Kit - Aresden, Elvine
							// 38 Mana Collector Kit - Aresden, Elvine
							// 39 Detector Constructor Kit - Aresden, Elvine
							// 40 Energy Shield Generator - Aresden, Elvine
							// 41 Grand Master Generator - Aresden Elvine
							// 43 Light War Beetle - Aresden, Elvine
							// 44 God's Hand Knight
							// 45 Mounted God's Hand Knight
							// 46 Temple Knight
							// 47 Battle Golem
							// 51 Catapult
							// 64 Crops
							*/
							bFirmBerserk = FALSE;
							if ((iMapLevel == 5) && (iDice(1,3) == 1)) bFirmBerserk = TRUE;

							ZeroMemory(cName_Master, sizeof(cName_Master));
							wsprintf(cName_Master, "XX%d", iNamingValue);
							cName_Master[0] = 95; // original '_';
							cName_Master[1] = i + 65;

							cSA = 0;
							if ((m_pMapList[i]->m_stSpotMobGenerator[j].iMobType != 34) && (iDice(1,100) <= iProbSA)) {
								cSA = _cGetSpecialAbility(iKindSA);
							}

							switch (m_pMapList[i]->m_stSpotMobGenerator[j].cType) {
								case 1:
									if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMAREA, &pX, &pY, cWaypoint, &m_pMapList[i]->m_stSpotMobGenerator[j].rcRect, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
										m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
									}
									else {
										m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
									}
									break;

								case 2:
									if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMWAYPOINT, NULL, NULL, m_pMapList[i]->m_stSpotMobGenerator[j].cWaypoint, NULL, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
										m_pMapList[i]->SetNamingValueEmpty(iNamingValue);	
									}
									else {
										m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
									}
									break;
							}
						}
					}
		}
	}
}

void CGame::CalcNextWayPointDestination(int iNpcH)
{
 short sRange, sX, sY;
 register int i, j, iMapIndex;
 BOOL bFlag;

	switch (m_pNpcList[iNpcH]->m_cMoveType) {
	case DEF_MOVETYPE_GUARD:
		// ÃÃ¶ÃÂ¤ÂµÃˆ Ã€Â§Ã„Â¡Â¸Â¦ Â¹Ã¾Â¾Ã®Â³ÂªÃÃ¶ Â¾ÃŠÃ€Â¸Â¸Ã§ ÃƒÃŸÂ°ÃÃ€ÃŒ Â³Â¡Â³Â­ ÃˆÃ„Â¿Â¡ ÂµÂ¹Â¾Ã†Â¿Ã‚Â´Ã™.
		break;
	
	case DEF_MOVETYPE_SEQWAYPOINT: 

		m_pNpcList[iNpcH]->m_cCurWaypoint++;
		if (m_pNpcList[iNpcH]->m_cCurWaypoint >= m_pNpcList[iNpcH]->m_cTotalWaypoint)
			m_pNpcList[iNpcH]->m_cCurWaypoint = 1;
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMWAYPOINT:
	
		m_pNpcList[iNpcH]->m_cCurWaypoint = (short)((rand() % (m_pNpcList[iNpcH]->m_cTotalWaypoint - 1)) + 1);
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMAREA:
				
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.right - m_pNpcList[iNpcH]->m_rcRandomArea.left);
		m_pNpcList[iNpcH]->m_dX = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.left);
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.bottom - m_pNpcList[iNpcH]->m_rcRandomArea.top);
		m_pNpcList[iNpcH]->m_dY = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.top);
		break;

	case DEF_MOVETYPE_RANDOM:
		// Â¿ÃÃ€Ã¼ Â·Â£Â´Ã½ 
		//m_pNpcList[iNpcH]->m_dX = (rand() % (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX - 50)) + 15;
		//m_pNpcList[iNpcH]->m_dY = (rand() % (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY - 50)) + 15;
		iMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;

		for ( i = 0; i <= 30; i++) {
		// Â°Â¥ Â¼Ã¶ Ã€Ã–Â´Ã‚ ÃÃ‚Ã‡Â¥Â°Â¡ Â³ÂªÂ¿ÃƒÂ¶Â§ Â±Ã®ÃÃ¶ 30Â¹Ã¸ Â¹ÃÂºÂ¹ 
			sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
			sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

			bFlag = TRUE;
			for (j = 0; j < DEF_MAXMGAR; j++)
			if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left != -1) {
				// Ã‡Ã‡Ã‡Ã˜Â¾ÃŸ Ã‡Ã’ ÃÃ‚Ã‡Â¥Â°Â¡ Ã€Ã–Â´Ã™. 
				if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left) &&
					(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].right) &&
					(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].top) &&
					(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].bottom)) {
					// Avoid RectÂ¾ÃˆÃ€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒ Ã€Â§Ã„Â¡Â¿Â¡Â´Ã‚ Â»Ã½Â¼ÂºÂ½ÃƒÃ…Â³ Â¼Ã¶ Â¾Ã¸Â´Ã™.	
					bFlag = FALSE;
				}
			}
			if (bFlag == TRUE) goto CNW_GET_VALIDLOC_SUCCESS;
		}
		// Fail! 
		m_pNpcList[iNpcH]->m_tmp_iError  = 0; 
		return;

CNW_GET_VALIDLOC_SUCCESS:;
		m_pNpcList[iNpcH]->m_dX = sX;
		m_pNpcList[iNpcH]->m_dY = sY;
		break;
	}

	m_pNpcList[iNpcH]->m_tmp_iError  = 0; // @@@ !!! @@@
}

void CGame::DeleteNpc(int iNpcH)
{
	int  i, iNamingValue, iNumItem, iItemID, iItemIDs[MAX_NPCITEMDROP], iSlateID;
	char cTmp[21], cItemName[21];
	class CItem * pItem, * pItem2;
	DWORD dwCount, dwTime;
    POINT ItemPositions[MAX_NPCITEMDROP];
	char cTemp[256];
	SYSTEMTIME SysTime;
	if (m_pNpcList[iNpcH] == NULL) return;

	dwTime = timeGetTime();

	//Init number of items to 1 unless its a multidrop;
	iNumItem = 0;
	iItemID = 0; // No current item

	//Ã¬Â£Â½Ã¬â€“Â´Ã¬Å¾Ë†Ã«ÂËœ Ã¬Å“â€Ã¬Â¹ËœÃ¬â€”ÂÃ¬â€Å“ Ã¬â€šÂ­Ã¬Â Å“ 
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);

	ZeroMemory(cTmp, sizeof(cTmp));
	strcpy(cTmp, (char *)(m_pNpcList[iNpcH]->m_cName + 2));
	// NPCÃ¬ÂËœ NamigValueÃ«Â¥Â¼ Ã¬â€“Â»Ã¬â€“Â´Ã¬â„¢â‚¬ Ã¬â€šÂ¬Ã¬Å¡Â©Ã¬Â¤â€˜Ã¬ÂÂ¸ Ã­â€˜Å“Ã¬â€¹Å“Ã«Â¥Â¼ Ã­â€¢Â´Ã¬Â§â‚¬Ã­â€¢Å“Ã«â€¹Â¤.
	iNamingValue = atoi(cTmp);

	// NamingValueÃ«Â¥Â¼ Ã«Â¹â€Ã¬Å¡Â°ÃªÂ³Â  Ã«Ââ„¢Ã¬Å¾â€˜Ã¬Â¤â€˜Ã¬ÂÂ¸ ÃªÂ°Å“Ã¬Â²Â´ Ã¬Ë†ËœÃ«Â¥Â¼ ÃªÂ°ÂÃ¬â€ Å’Ã¬â€¹Å“Ã­â€šÂ¨Ã«â€¹Â¤.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalActiveObject--;

	// Spot-mob-generatorÃ¬Â â€¢Ã«Â³Â´ 
	if ( m_pNpcList[iNpcH]->m_iSpotMobIndex != NULL )
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stSpotMobGenerator[m_pNpcList[iNpcH]->m_iSpotMobIndex].iCurMobs--;

	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);

	// Ã­ÂÂ¬Ã«Â£Â¨Ã¬â€Â¸Ã¬ÂÂ´Ã«â€œÅ“Ã¬Å¡Â© ÃªÂ±Â´Ã¬Â¶â€¢Ã«Â¬Â¼Ã¬ÂÂ´Ã«ÂÂ¼Ã«Â©Â´ Ã¬Â§â‚¬Ã­Å“ËœÃªÂ´â‚¬ Ã­â€ ÂµÃ«Â³Â´Ã¬Å¡Â© ÃªÂ±Â´Ã¬Â¶â€¢Ã«Â¬Â¼ Ã«Â¦Â¬Ã¬Å Â¤Ã­Å Â¸Ã«Â¥Â¼ Ã­â€¢Â´Ã¬Â Å“
	switch (m_pNpcList[iNpcH]->m_sType) {
	case 36:
	case 37:
	case 38:
	case 39:
	case 42:
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCrusadeStructureInfo(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		// ÃªÂ¸Â¸Ã«â€œÅ“ ÃªÂ±Â´Ã¬Â¶â€¢Ã«Â¬Â¼ ÃªÂ°Å“Ã¬Ë†ËœÃ«Ââ€ ÃªÂ°ÂÃ¬â€ Å’Ã¬â€¹Å“Ã­â€šÂ´ 
		for (i = 0; i < DEF_MAXGUILDS; i++) 
			if (m_pGuildTeleportLoc[i].m_iV1 == m_pNpcList[iNpcH]->m_iGuildGUID) {
				m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				m_pGuildTeleportLoc[i].m_iV2--;
				if (m_pGuildTeleportLoc[i].m_iV2 < 0) m_pGuildTeleportLoc[i].m_iV2 = 0;
				break;	
			}
			break;
	case 64: m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCropsTotalSum(); break;

	}

	// DelayEventÃ«Â¥Â¼ Ã¬â€šÂ­Ã¬Â Å“ 
	bRemoveFromDelayEventList(iNpcH, DEF_OWNERTYPE_NPC, NULL);
	if ((m_pNpcList[iNpcH]->m_bIsSummoned == FALSE) && (m_pNpcList[iNpcH]->m_bIsUnsummoned == FALSE)) {
		// Ã¬â€ Å’Ã­â„¢ËœÃ«ÂªÂ¹Ã¬ÂÂ´ Ã¬â€¢â€Ã«â€¹Ë†Ã«ÂÂ¼Ã«Â©Â´ Ã¬â€”Â°ÃªÂ¸Ë† Ã¬Å¾Â¬Ã«Â£Å’ÃªÂ°â‚¬ Ã«â€šËœÃ¬ËœÂ¨Ã«â€¹Â¤.
		pItem = new class CItem;
		ZeroMemory(cItemName, sizeof(cItemName));
		switch (m_pNpcList[iNpcH]->m_sType) {

		case 10: // Slime
			if (iDice(1,25) == 1) iItemID = 220; break; // SlimeJelly 
			break;

		case 11: // Skeleton
			switch(iDice(1,2))	{
			case 1:if (iDice(1,20) == 1) iItemID = 219; break; // SkeletonBones
			case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;
			
		case 12: // Stone-Golem
		switch(iDice(1,2)){
			case 1:	if (iDice(1,30) == 1) iItemID = 221; break; // StoneGolemPiece
			case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}	
			break;

		case 13: // Cyclops
			switch(iDice(1,6)){
			case 1:	if (iDice(1,36) == 1) iItemID = 194; break; // CyclopsEye
			case 2:	if (iDice(1,40) == 1) iItemID = 195; break; // CyclopsHandEdge
			case 3:	if (iDice(1,30) == 1) iItemID = 196; break; // CyclopsHeart
			case 4:	if (iDice(1,22) == 1) iItemID = 197; break; // CyclopsMeat
			case 5:	if (iDice(1,40) == 1) iItemID = 198; break; // CyclopsLeather
			case 6:	bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 14: // Orc, Orc-Mage
			switch(iDice(1,4)){
			case 1:	if (iDice(1,11) == 1) iItemID = 206; break; // OrcMeat
			case 2:	if (iDice(1,20) == 1) iItemID = 207; break; // OrcLeather
			case 3:	if (iDice(1,21) == 1) iItemID = 208; break; // OrcTeeth
			case 4: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;
			
		case 16: //Giant-Ant
			switch(iDice(1,3)){
			case 1:	if (iDice(1,9) == 1) iItemID = 192; break; // AntLeg
			case 2:	if (iDice(1,10) == 1) iItemID = 193; break; // AntFeeler
			case 3:	bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 17: //Scorpion
			switch(iDice(1,5)){
			case 1:	if (iDice(1,50) == 1) iItemID = 215; break; // ScorpionPincers
			case 2:	if (iDice(1,20) == 1) iItemID = 216; break; // ScorpionMeat
			case 3: if (iDice(1,50) == 1) iItemID = 217; break; // ScorpionSting
			case 4: if (iDice(1,40) == 1) iItemID = 218; break; // ScorpionSkin
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 18: //Zombie
			bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			break;

		case 22: //Amphis
			switch(iDice(1,5)){
			case 1: if (iDice(1,15) == 1) iItemID = 188; break; // SnakeMeat
			case 2:	if (iDice(1,16) == 1) iItemID = 189; break; // SnakeSkin
			case 3:	if (iDice(1,16) == 1) iItemID = 190; break; // SnakeTeeth
			case 4:	if (iDice(1,17) == 1) iItemID = 191; break; // SnakeTongue
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 23: //Clay-Golem
			switch(iDice(1,2)){
			case 1: if (iDice(1,30) == 1) iItemID = 205; break; // LumpofClay
			case 2: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;


		case 27: //Hellbound
			switch(iDice(1,7)){
			case 1:	if (iDice(1,40) == 1) iItemID = 199; break; // HelboundHeart
			case 2:	if (iDice(1,38) == 1) iItemID = 200; break; // HelboundLeather
			case 3:	if (iDice(1,38) == 1) iItemID = 201; break; // HelboundTail
			case 4:	if (iDice(1,36) == 1) iItemID = 202; break; // HelboundTeeth
			case 5:	if (iDice(1,36) == 1) iItemID = 203; break; // HelboundClaw
			case 6:	if (iDice(1,50) == 1) iItemID = 204; break; // HelboundTongue
			case 7: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 28: //Troll
			switch(iDice(1,5)){
			case 1:	if (iDice(1,35) == 1) iItemID = 222; break; // TrollHeart
			case 2:	if (iDice(1,23) == 1) iItemID = 223; break; // TrollMeat
			case 3:	if (iDice(1,25) == 1) iItemID = 224; break; // TrollLeather
			case 4:	if (iDice(1,27) == 1) iItemID = 225; break; // TrollClaw
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 29: //Orge
			switch(iDice(1,7)){
			case 1:	if (iDice(1,20) == 1) iItemID = 209; break; // OgreHair
			case 2:	if (iDice(1,22) == 1) iItemID = 210; break; // OgreHeart
			case 3:	if (iDice(1,25) == 1) iItemID = 211; break; // OgreMeat
			case 4:	if (iDice(1,25) == 1) iItemID = 212; break; // OgreLeather
			case 5:	if (iDice(1,28) == 1) iItemID = 213; break; // OgreTeeth
			case 6:	if (iDice(1,28) == 1) iItemID = 214; break; // OgreClaw
			case 7: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 30: //Liche
			bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			break;

		case 31: //Demon
			switch(iDice(1,5)){
			case 1:	if (iDice(1,400) == 123) iItemID = 541; break; // DemonHeart
			case 2:	if (iDice(1,1000) == 123) iItemID = 542; break; // DemonMeat
			case 3:	if (iDice(1,200) == 123) iItemID = 543; break; // DemonLeather
			case 4:	if (iDice(1,300) == 123) iItemID = 540; break; // DemonEye
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 32: //Unicorn
			switch(iDice(1,5)){
			case 1:	if (iDice(1,3000) == 396) iItemID = 544; break; // UnicornHeart
			case 2:	if (iDice(1,500) == 3) iItemID = 545; break; // UnicornHorn
			case 3:	if (iDice(1,100) == 3) iItemID = 546; break; // UnicornMeat
			case 4:	if (iDice(1,200) == 3) iItemID = 547; break; // UnicornLeather
			case 5: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 33: //WereWolf
			switch(iDice(1,8)){
			case 1: if (iDice(1,30) == 3) iItemID = 551; break; // WerewolfTail
			case 2:	if (iDice(1,28) == 3) iItemID = 548; break; // WerewolfHeart
			case 3:	if (iDice(1,25) == 3) iItemID = 550; break; // WerewolfMeat
			case 4:	if (iDice(1,35) == 3) iItemID = 553; break; // WerewolfLeather
			case 5:	if (iDice(1,28) == 3) iItemID = 552; break; // WerewolfTeeth
			case 6:	if (iDice(1,28) == 3) iItemID = 554; break; // WerewolfClaw
			case 7:	if (iDice(1,38) == 3) iItemID = 549; break; // WerewolfNail
			case 8: bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 48: //Stalker
		case 49: //Hellclaw
		case 50: //Tigerworm
		case 52: //Gagoyle
		case 53: //Beholder
		case 54: //Dark-Elf
		case 55: //Rabbit
		case 56: //Cat
		case 57: //Giant-Frog
		case 58: //Mountain-Giant
		case 59: //Ettin
		case 60: //Cannibal-Plant
		case 61: //Rudolph
		case 62: //DireBoar
		case 63: //Frost
		case 65: //Ice
			bGetItemNameWhenDeleteNpc(iItemID, m_pNpcList[iNpcH]->m_sType); 
			break;

		// new 05/10/2004
		case 66: // Wyvern
			bGetMultipleItemNamesWhenDeleteNpc( m_pNpcList[iNpcH]->m_sType,	// NPC Type
												50,							// ÃˆÂ®Â·Ã¼( ÃƒÃ–Â¼Ã’ ~ ÃƒÃ–Â´Ã« Â»Ã§Ã€ÃŒÃ€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â³ÂªÂ¿Ãƒ ÃˆÂ®Â·Ã¼ , 100 Ã€ÃŒÂ¸Ã© ÃƒÃ–Â´Ã« Â°Â¹Â¼Ã¶ Â¸Â¸Ã…Â­ Â³ÂªÂ¿Ã‚Â´Ã™.)
												5,							// Â³ÂªÂ¿ÃÂ¾ÃŸ Ã‡ÃÂ´Ã‚ Item ÃƒÃ–Â¼Ã’ Â°Â³Â¼Ã¶
												15,							// Â³ÂªÂ¿ÃƒÂ¼Ã¶ Ã€Ã–Â´Ã‚ Item ÃƒÃ–Â´Ã« Â°Â³Â¼Ã¶
												m_pNpcList[iNpcH]->m_sX,	// Â±Ã¢ÃÃ˜ ÃÃ‚Ã‡Â¥ X
												m_pNpcList[iNpcH]->m_sY,	// Â±Ã¢ÃÃ˜ ÃÃ‚Ã‡Â¥ Y
												DEF_ITEMSPREAD_FIXED,		// Â¾Ã†Ã€ÃŒÃ…Ã› Â»Ã‘Â¸Â®Â´Ã‚ Â¹Ã¦Â¹Ã½ (RANDOM, FIXED)
												4,							// Â¾Ã†Ã€ÃŒÃ…Ã› Â»Ã‘Â¸Â± Â¹Ã¼Ã€Â§, DEF_ITEMSPREAD_RANDOM Ã€ÃÂ¶Â§Â¸Â¸ Â»Ã§Â¿Ã«
												iItemIDs,					// Â¹ÃÂ¾Ã†Â¿Ãƒ Â¾Ã†Ã€ÃŒÃ…Ã› IdÂµÃ©
												ItemPositions,				// Â¾Ã†Ã€ÃŒÃ…Ã›ÂµÃ©Ã€Ã‡ Ã€Â§Ã„Â¡
												&iNumItem);					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ ÃƒÃ‘ Â°Â¹Â¼Ã¶
			break;

		case 73: // Fire-Wyvern
			bGetMultipleItemNamesWhenDeleteNpc( m_pNpcList[iNpcH]->m_sType,	// NPC Type
												50,							// ÃˆÂ®Â·Ã¼( ÃƒÃ–Â¼Ã’ ~ ÃƒÃ–Â´Ã« Â»Ã§Ã€ÃŒÃ€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â³ÂªÂ¿Ãƒ ÃˆÂ®Â·Ã¼ , 100 Ã€ÃŒÂ¸Ã© ÃƒÃ–Â´Ã« Â°Â¹Â¼Ã¶ Â¸Â¸Ã…Â­ Â³ÂªÂ¿Ã‚Â´Ã™.)
												5,							// Â³ÂªÂ¿ÃÂ¾ÃŸ Ã‡ÃÂ´Ã‚ Item ÃƒÃ–Â¼Ã’ Â°Â³Â¼Ã¶
												15,							// Â³ÂªÂ¿ÃƒÂ¼Ã¶ Ã€Ã–Â´Ã‚ Item ÃƒÃ–Â´Ã« Â°Â³Â¼Ã¶
												m_pNpcList[iNpcH]->m_sX,	// Â±Ã¢ÃÃ˜ ÃÃ‚Ã‡Â¥ X
												m_pNpcList[iNpcH]->m_sY,	// Â±Ã¢ÃÃ˜ ÃÃ‚Ã‡Â¥ Y
												2,		// Â¾Ã†Ã€ÃŒÃ…Ã› Â»Ã‘Â¸Â®Â´Ã‚ Â¹Ã¦Â¹Ã½ (RANDOM, FIXED)
												4,							// Â¾Ã†Ã€ÃŒÃ…Ã› Â»Ã‘Â¸Â± Â¹Ã¼Ã€Â§, DEF_ITEMSPREAD_RANDOM Ã€ÃÂ¶Â§Â¸Â¸ Â»Ã§Â¿Ã«
												iItemIDs,					// Â¹ÃÂ¾Ã†Â¿Ãƒ Â¾Ã†Ã€ÃŒÃ…Ã› IdÂµÃ©
												ItemPositions,				// Â¾Ã†Ã€ÃŒÃ…Ã›ÂµÃ©Ã€Ã‡ Ã€Â§Ã„Â¡
												&iNumItem);					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ ÃƒÃ‘ Â°Â¹Â¼Ã¶
			break;
		case 81:
			bGetMultipleItemNamesWhenDeleteNpc( m_pNpcList[iNpcH]->m_sType,	// NPC Type
												50,							// ÃˆÂ®Â·Ã¼( ÃƒÃ–Â¼Ã’ ~ ÃƒÃ–Â´Ã« Â»Ã§Ã€ÃŒÃ€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â³ÂªÂ¿Ãƒ ÃˆÂ®Â·Ã¼ , 100 Ã€ÃŒÂ¸Ã© ÃƒÃ–Â´Ã« Â°Â¹Â¼Ã¶ Â¸Â¸Ã…Â­ Â³ÂªÂ¿Ã‚Â´Ã™.)
												12,							// Â³ÂªÂ¿ÃÂ¾ÃŸ Ã‡ÃÂ´Ã‚ Item ÃƒÃ–Â¼Ã’ Â°Â³Â¼Ã¶
												20,							// Â³ÂªÂ¿ÃƒÂ¼Ã¶ Ã€Ã–Â´Ã‚ Item ÃƒÃ–Â´Ã« Â°Â³Â¼Ã¶
												m_pNpcList[iNpcH]->m_sX,	// Â±Ã¢ÃÃ˜ ÃÃ‚Ã‡Â¥ X
												m_pNpcList[iNpcH]->m_sY,	// Â±Ã¢ÃÃ˜ ÃÃ‚Ã‡Â¥ Y
												DEF_ITEMSPREAD_FIXED,		// Â¾Ã†Ã€ÃŒÃ…Ã› Â»Ã‘Â¸Â®Â´Ã‚ Â¹Ã¦Â¹Ã½ (RANDOM, FIXED)
												65,							// Â¾Ã†Ã€ÃŒÃ…Ã› Â»Ã‘Â¸Â± Â¹Ã¼Ã€Â§, DEF_ITEMSPREAD_RANDOM Ã€ÃÂ¶Â§Â¸Â¸ Â»Ã§Â¿Ã«
												iItemIDs,					// Â¹ÃÂ¾Ã†Â¿Ãƒ Â¾Ã†Ã€ÃŒÃ…Ã› IdÂµÃ©
												ItemPositions,				// Â¾Ã†Ã€ÃŒÃ…Ã›ÂµÃ©Ã€Ã‡ Ã€Â§Ã„Â¡
												&iNumItem);
			break;
		}

		dwCount = 1;
		if (iNumItem > 0) {
			GetLocalTime(&SysTime);
			wsprintf(cTemp, "%d%02d%", SysTime.wMonth, SysTime.wDay);
			for(int j = 0; j < iNumItem; j++){
				if (pItem == NULL) {
					pItem = new class CItem;
				}
				if (_bInitItemAttr(pItem, iItemIDs[j]) == FALSE ||
					m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bGetIsMoveAllowedTile(ItemPositions[j].x, ItemPositions[j].y) == FALSE) {
					delete pItem;
					pItem = NULL;
				}
				else {
					if (iItemIDs[j] == 90) // Gold
						pItem->m_dwCount = iDice(10, 15000);
					else
						pItem->m_dwCount = dwCount;

					pItem->m_sTouchEffectType   = DEF_ITET_ID;
					pItem->m_sTouchEffectValue1 = iDice(1,100000);
					pItem->m_sTouchEffectValue2 = iDice(1,100000);
					pItem->m_sTouchEffectValue3 = (short)timeGetTime();
					m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(ItemPositions[j].x, ItemPositions[j].y, pItem);
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
												ItemPositions[j].x, ItemPositions[j].y,	pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
					_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem);
					pItem = NULL;
				}
			}
		}
		else{
			if (_bInitItemAttr(pItem, iItemID) == FALSE) {
					delete pItem;
					pItem = NULL;
				}
			else {
					pItem->m_dwCount = dwCount;

				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				pItem->m_sTouchEffectValue3 = (short)timeGetTime();
				m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
					m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor);
				_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem);
			}
		}

		if (iDice(1, 100000) < 10) {
			pItem2 = new class CItem;
			switch(iDice(1,4)){
				case 1:	iSlateID = 868; break;
				case 2: iSlateID = 869; break;
				case 3: iSlateID = 870; break;
				case 4: iSlateID = 871; break;
			}
			if (_bInitItemAttr(pItem2, iSlateID) == FALSE) {
					delete pItem2;
					pItem2 = NULL;
				}
			else {
				pItem2->m_dwCount = 1;

				pItem2->m_sTouchEffectType   = DEF_ITET_ID;
				pItem2->m_sTouchEffectValue1 = iDice(1,100000);
				pItem2->m_sTouchEffectValue2 = iDice(1,100000);
				pItem2->m_sTouchEffectValue3 = (short)timeGetTime();

				m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem2);
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
					m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem2->m_sSprite, pItem2->m_sSpriteFrame, pItem2->m_cItemColor);
				_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, m_pNpcList[iNpcH]->m_cNpcName, pItem2);
			}
		}
	}

    delete m_pNpcList[iNpcH];
	m_pNpcList[iNpcH] = NULL;
}

void CGame::RequestFullObjectData(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp, wObjectID;
 char  * cp, cData[100];
 short * sp, sX, sY;
 int     sTemp, sTemp2;
 int   * ip, iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wObjectID = *wp;
	
	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_EVENT_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTSTOP;
	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	if (wObjectID < 10000) {
		// Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ ÃÂ¤ÂºÂ¸Â¸Â¦ Â¿Ã¸Ã‡Ã‘Â´Ã™. 
		// Ã€ÃŸÂ¸Ã¸ÂµÃˆ Ã€ÃÂµÂ¦Â½ÂºÂ°ÂªÃ€ÃŒÂ°Ã…Â³Âª ÃÂ¸Ã€Ã§Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¶Ã³Â¸Ã© Â¹Â«Â½Ãƒ.
		if ( (wObjectID == 0) || (wObjectID >= DEF_MAXCLIENTS) ) return;
		if (m_pClientList[wObjectID] == NULL) return;
		
		wp  = (WORD *)cp;
		*wp = wObjectID;			// ObjectID
		cp += 2;
		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;
		//v1.4 ApprColor
		ip = (int *)cp;
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp += 4;
		
		ip  = (int *)cp;
		
		// m_pClientList[i]Â¿Ã m_pClientList[sOwnerH]Ã€Ã‡ Â°Ã¼Â°Ã¨Â¸Â¦ Ã€Ã”Â·Ã‚Ã‡Ã‘Â´Ã™.
		// sStatusÃ€Ã‡ Â»Ã³Ã€Â§ 4ÂºÃ±Ã†Â®Â°Â¡ FOE Â°Ã¼Â°Ã¨Â¸Â¦ Â³ÂªÃ…Â¸Â³Â½Â´Ã™. 
		sTemp = m_pClientList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp; // Â»Ã³Ã€Â§ 4ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã®
		sTemp2 = iGetPlayerABSStatus(wObjectID, iClientH); //(short)iGetPlayerRelationship(iClientH, wObjectID);
		sTemp  = (sTemp | (sTemp2 << 28));//Original : 12
		
		*ip = sTemp;
		//*sp = DEF_TEST;
		cp += 4;//Original 2
		
		if (m_pClientList[wObjectID]->m_bIsKilled == TRUE) // v1.4
			 *cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 41); // v1.4
	}
	else {
		// NPCÃ€Ã‡ ÃÂ¤ÂºÂ¸Â¸Â¦ Â¿Ã¸Ã‡Ã‘Â´Ã™.
		// Ã€ÃŸÂ¸Ã¸ÂµÃˆ Ã€ÃÂµÂ¦Â½Âº Â°ÂªÃ€ÃŒÂ°Ã…Â³Âª Â»Ã½Â¼ÂºÂµÃ‡ÃÃ¶ Â¾ÃŠÃ€Âº NPCÂ¶Ã³Â¸Ã© Â¹Â«Â½Ãƒ 
		if ( ((wObjectID - 10000) == 0) || ((wObjectID - 10000) >= DEF_MAXNPCS) ) return;
		if (m_pNpcList[wObjectID - 10000] == NULL) return;
		
		wp  = (WORD *)cp;
		*wp = wObjectID;			
		cp += 2;

		wObjectID -= 10000;

		sp  = (short *)cp;
		sX  = m_pNpcList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pNpcList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pNpcList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pNpcList[wObjectID]->m_cName, 5);
		cp += 5;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sAppr2;
		cp += 2;
		
		ip  = (int *)cp;
	
		sTemp = m_pNpcList[wObjectID]->m_iStatus;
		sTemp = 0x0FFFFFFF & sTemp;//Original : sTemp = 0x0FFF & sTemp; // Â»Ã³Ã€Â§ 4ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã®
		
		sTemp2 = iGetNpcRelationship(wObjectID, iClientH);
		sTemp  = (sTemp | (sTemp2 << 28));//Original : 12	
		*ip = sTemp;
		//*sp = DEF_TEST;
		cp += 4;//Original 2

		if (m_pNpcList[wObjectID]->m_bIsKilled == TRUE) // v1.4
			 *cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 27); // v1.4 //Original : 25
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

int CGame::_iGetArrowItemIndex(int iClientH)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return -1;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {

		// Arrow Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ 1Â°Â³ Ã€ÃŒÂ»Ã³ Ã€Ã–Ã€Â¸Â¸Ã© Ã€ÃÂµÂ¦Â½Âº Â°ÂªÃ€Â» Â¹ÃÃˆÂ¯Ã‡Ã‘Â´Ã™.
		if ( (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_ARROW) &&
			 (m_pClientList[iClientH]->m_pItemList[i]->m_dwCount > 0) )
			return i;	
	}

	return -1;
}

void CGame::ItemDepleteHandler(int iClientH, short sItemIndex, BOOL bIsUseItemResult)
{
	// Â¼Ã’Â¸Ã°Â¼Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Ã„Â«Â¿Ã®Ã†Â®Â°Â¡ 0Ã€ÃŒÂ¸Ã© Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™. ÃˆÂ¤Ã€Âº ÃÃŸÂ°Ã­ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã†ÃˆÂ¾Ã†Â¹Ã¶Â¸Â° Â°ÃÂ¿Ã¬  
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	
	// v1.411 Â·ÃÂ±Ã—Â¸Â¦ Â³Â²Â±Ã¤Â´Ã™. 
	_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

	// Â¸Ã•Ã€Ãº Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã™Â¸Ã© Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™. Ã€ÃŒÂ·Â± Â°Ã¦Â¿Ã¬Â´Ã‚ Â°Ã…Ã€Ã‡ Â¾Ã¸Ã€Â» ÂµÃ­ 
	ReleaseItemHandler(iClientH, sItemIndex, TRUE);
	
	// Ã€ÃŒÃÂ¦ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¸Â®Â½ÂºÃ†Â®Â¿Â¡Â¼Â­ Â»Ã¨ÃÂ¦Ã‡Ã’Â°ÃÃ€Â» Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™.
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMDEPLETED_ERASEITEM, sItemIndex, (int)bIsUseItemResult, NULL, NULL);

	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¸ÃÂ¸Ã°Â¸Â®Â¿Â¡Â¼Â­ Â»Ã¨ÃÂ¦ 
	delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;

	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	
	// !!! BUG POINT
	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Ã€ÃÂµÂ¦Â½ÂºÂ°Â¡ Â¹Ã™Â²Ã¯ Â»Ã³ÃˆÂ²Ã€ÃŒÂ´Ã™. ArrowIndexÂ¿Ã Â°Â°Ã€Âº Â°ÃÃ€Âº Â´Ã™Â½Ãƒ Ã‡Ã’Â´Ã§Ã‡Ã˜Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

	// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
	iCalcTotalWeight(iClientH);
}

void CGame::NpcBehavior_Stop(int iNpcH)
{
 char  cTargetType;
 short sTarget = NULL;
 BOOL  bFlag;

	if (m_pNpcList[iNpcH] == NULL) return; 

	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 5:		
		switch (m_pNpcList[iNpcH]->m_sType) {
		case 38:
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				bFlag = _bNpcBehavior_ManaCollector(iNpcH);
				if (bFlag == TRUE) {
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				}
			}
			break;

		case 39: // Detector
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				bFlag = _bNpcBehavior_Detector(iNpcH);
				
				if (bFlag == TRUE) {
					// ÀûÀ» ¹ß°ßÇß´Ù. °ø°İ µ¿ÀÛÀ¸·Î ¾Ë·Á¾ß ÇÑ´Ù.	
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				}
			}
			break;

		case 40: // Energy Shield Generator
			break;

		case 41: // Grand Magic Generator
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				_NpcBehavior_GrandMagicGenerator(iNpcH);
			}
			break;

		case 42: // ManaStone: v2.05 Á¤±âÀûÀ¸·Î ¸¶³ª½ºÅæÀÇ ¿¡³ÊÁö¸¦ 5¾¿ »ı¼ºÇÑ´Ù.
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_iV1 += 5;
			if (m_pNpcList[iNpcH]->m_iV1 >= 5) m_pNpcList[iNpcH]->m_iV1 = 5;
			break;

		default: 
			TargetSearch(iNpcH, &sTarget, &cTargetType);				
			break;
		}
		break;
	}
	
	if ((sTarget != NULL)) {

		// °ø°İ¸ñÇ¥ ¹ß°ß. 
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
		// ¿©±â¼­ Ç¥È¿ µ¿ÀÛ°°Àº°ÍÀ» À§ÇÑ ¸Ş½ÃÁö ¹ß¼Û. 
		return;
	}
}


void CGame::UseItemHandler(int iClientH, short sItemIndex, short dX, short dY, short sDestItemID)
{
 int iTemp, iMax, iV1, iV2, iV3, iSEV1, iEffectResult = 0;
 DWORD dwTime;
 short sTemp, sTmpType, sTmpAppr1;
 char cSlateType[20];

	dwTime = timeGetTime();
	ZeroMemory(cSlateType,sizeof(cSlateType));

	//testcode
	//wsprintf(G_cTxt, "%d", sDestItemID);
	//PutLogList(G_cTxt);

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;

	if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) || 
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) ) {
	}
	else return;
 	
	if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ) {
				
		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ ÃˆÂ¿Â°ÃºÂ¿Â¡ Â¸Ã‚Â´Ã‚ ÃƒÂ³Â¸Â®Â¸Â¦ Ã‡Ã‘Â´Ã™. 
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_WARM: // v2.172 2002-7-5 ÇØµ¿ ½Ã¾à. 

			// ³Ãµ¿ »óÅÂÀÎ °æ¿ì ÇØµ¿ µÇ¾ú´Ù´Â ¸Ş¼¼Áö¸¦ º¸³»ÁØ´Ù. 
			if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 1) {
			//	SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);

				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_ICE);

				// È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ıÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (1*1000), 
							                iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);

								
//				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_ICE, NULL, NULL, NULL);
			}

			m_pClientList[iClientH]->m_dwWarmEffectTime = dwTime;
			break;

		case DEF_ITEMEFFECTTYPE_LOTTERY:
			// ÂºÂ¹Â±Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã› EV1(ÃˆÂ®Â·Ã¼: ÃƒÃ–Ã€Ãº 100) EV2(Â»Ã³Ã‡Â° ÃÂ¾Â·Ã¹) EV3(Â»Ã³Ã‡Â° Â¼Ã¶Â·Â®)
			iTemp = iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1);
			if (iTemp == iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1)) {
				// Â´Ã§ÃƒÂ·!

			}
			else {
				// Â²Ã!
				
			}
			break;
		
		case DEF_ITEMEFFECTTYPE_SLATES:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
				// Full Ancient Slate ??
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sIDnum == 867) {
					// Slates dont work on Heldenian Map
					switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2){
						case 2: // Bezerk slate
							m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = TRUE;
							SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (1000 * 600),
								iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, 1, NULL, NULL);
							strcpy(cSlateType, "Berserk");
							break;

						case 1: // Invincible slate
							if (strlen(cSlateType) == 0) {
								strcpy(cSlateType, "Invincible");
							}
						case 3: // Mana slate
							if (strlen(cSlateType) == 0) {
								strcpy(cSlateType, "Mana");
							}
						case 4: // Exp slate
							if (strlen(cSlateType) == 0) {
								strcpy(cSlateType, "Exp");
							}
							SetSlateFlag(iClientH, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, TRUE);
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_ANCIENT_TABLET, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2, 
												dwTime + (1000 * 600), iClientH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
							switch(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2) {
							case 1:
								iEffectResult = 4;
								break;
							case 3:
								iEffectResult = 5;
								break;
							case 4:
								iEffectResult = 6;
								break;
							}
					}
					if(strlen(cSlateType) > 0)
						_bItemLog(DEF_ITEMLOG_USE, iClientH, strlen(cSlateType), m_pClientList[iClientH]->m_pItemList[sItemIndex]);
				}
			}
			break;
		case DEF_ITEMEFFECTTYPE_HP:
			iMax = iGetMaxHP(iClientH);
			if (m_pClientList[iClientH]->m_iHP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iHP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iHP > iMax) m_pClientList[iClientH]->m_iHP = iMax;
				if (m_pClientList[iClientH]->m_iHP <= 0)   m_pClientList[iClientH]->m_iHP = 1;

				iEffectResult = 1;
			}
			break;

		case DEF_ITEMEFFECTTYPE_MP:
			iMax = (2*m_pClientList[iClientH]->m_iMag) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->m_iInt/2);
		
			if (m_pClientList[iClientH]->m_iMP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else 
				{
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iMP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iMP > iMax) 
					m_pClientList[iClientH]->m_iMP = iMax;

				iEffectResult = 2;
			}
			break;

		case DEF_ITEMEFFECTTYPE_SP:
			iMax = (2*m_pClientList[iClientH]->m_iStr) + (2*m_pClientList[iClientH]->m_iLevel);
		
			if (m_pClientList[iClientH]->m_iSP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iSP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iSP > iMax) 
					m_pClientList[iClientH]->m_iSP = iMax;

				iEffectResult = 3;
			}

			if (m_pClientList[iClientH]->m_bIsPoisoned == TRUE) {
				// ÃÃŸÂµÂ¶ÂµÃˆ Â»Ã³Ã…Ã‚Â¿Â´Â´Ã™Â¸Ã© ÃÃŸÂµÂ¶Ã€Â» Ã‡Â¬Â´Ã™.
				m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
				// ÃÃŸÂµÂ¶Ã€ÃŒ Ã‡Â®Â·ÃˆÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
				SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE); // removes poison aura when using a revitalizing potion
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
			}
			break;

		case DEF_ITEMEFFECTTYPE_HPSTOCK:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
		
			m_pClientList[iClientH]->m_iHPstock += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHPstock < 0)   m_pClientList[iClientH]->m_iHPstock = 0;
			if (m_pClientList[iClientH]->m_iHPstock > 500) m_pClientList[iClientH]->m_iHPstock = 500;

			// Â¹Ã¨Â°Ã­Ã‡Ã„Ã€Â» Ã‡Ã˜Â°Ã¡Ã‡Ã‘Â´Ã™. 
			m_pClientList[iClientH]->m_iHungerStatus += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHungerStatus > 100) m_pClientList[iClientH]->m_iHungerStatus = 100;
			if (m_pClientList[iClientH]->m_iHungerStatus < 0)   m_pClientList[iClientH]->m_iHungerStatus = 0;
			break;

		case DEF_ITEMEFFECTTYPE_STUDYSKILL:
			// Â±Ã¢Â¼ÃºÃ€Â» Â¹Ã¨Â¿Ã®Â´Ã™.	
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iSEV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
			// iV1Ã€Âº Â¹Ã¨Â¿Ã¯ Skill Â¹Ã¸ÃˆÂ£. iV2Â´Ã‚ Â±Ã¢Â¼Ãº Â¼Ã¶ÃÃ˜, iSEV1Ã€Âº Â»Ã§Â¿Ã«Ã€Ãš ÃÂ¤Ã€Ã‡ Â±Ã¢Â¼Ãº Â¼Ã¶ÃÃ˜(Â¿Ã¬Â¼Â±Â¼Ã¸Ã€Â§) 
			if (iSEV1 == 0) {
				// Â»Ã§Â¿Ã«Ã€Ãš ÃÂ¤Ã€Ã‡ Â±Ã¢Â¼ÃºÂ¼Ã¶ÃÃ˜Ã€ÃŒ 0Ã€ÃŒÂ¶Ã³Â¸Ã© Ã‡Â¥ÃÃ˜ Â±Ã¢Â¼ÃºÂ¼Ã¶ÃÃ˜Â¿Â¡ ÂµÃ»Â¶Ã³ Â±Ã¢Â¼ÃºÃ€Â» Â¹Ã¨Â¿Ã¬Â°Ã” ÂµÃˆÂ´Ã™. 
				TrainSkillResponse(TRUE, iClientH, iV1, iV2);
			}
			else {
		   		TrainSkillResponse(TRUE, iClientH, iV1, iSEV1);
			}
			break;

		case DEF_ITEMEFFECTTYPE_STUDYMAGIC:
			// iV1Ã€Âº Â¹Ã¨Â¿Ã¯ Â¸Â¶Â¹Ã½ Â¹Ã¸ÃˆÂ£.
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pMagicConfigList[iV1] != NULL) 
				RequestStudyMagicHandler(iClientH, m_pMagicConfigList[iV1]->m_cName, FALSE);
			break;

		/*case DEF_ITEMEFFECTTYPE_LOTTERY:
			iLottery = iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->
			break;*/

		// New 15/05/2004 Changed
		case DEF_ITEMEFFECTTYPE_MAGIC:
			// Ã…ÃµÂ¸Ã­ Â¸Ã°ÂµÃ¥Â¿Â´Â´Ã™Â¸Ã© Â¸Â¶Â¹Ã½ ÃˆÂ¿Â°Ãº Â¾Ã†Ã€ÃŒÃ…Ã› Â»Ã§Â¿Ã«Â½ÃƒÂ¿Â¡ Ã‡Ã˜ÃÂ¦ÂµÃˆÂ´Ã™.
			if ( (m_pClientList[iClientH]->m_iStatus & 0x10) != 0 ) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
					SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
				
					bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
				}
			}

			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// Recall Â¸Â¶Â¹Ã½ ÃˆÂ¿Â°ÃºÂ°Â¡ Ã€Ã–Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›. 
				// testcode
				RequestTeleportHandler(iClientH, "1   ");
				break;

			case 2:
				// Ã…ÃµÂ¸Ã­ Â¸Â¶Â¹Ã½ÃˆÂ¿Â°ÃºÂ°Â¡ Ã€Ã–Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›. 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, TRUE);
				break;

			case 3:
				// Ã…ÃµÂ¸Ã­ Â¸Â¶Â¹Ã½ ÃƒÂ£Â±Ã¢. Â»Ã§Ã…ÃµÃ€Ã¥ Â³Â»ÂºÃÂ¸Ã© Â¼Ã’Â¿Ã«Â¾Ã¸Â´Ã™. 
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)
					PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 34, TRUE);
				break;

			case 4:
				// fixed location teleportation: Ã€Ã”Ã€Ã¥Â±Ã‡ ÂµÃ®ÂµÃ®
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2) {
				case 1:
					// ÂºÃ­Â¸Â®ÂµÃ¹ Â¾Ã†Ã€ÃÂ·Ã Â°Â£Â´Ã™ 
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) != 0) {
						//v1.42
						ItemDepleteHandler(iClientH, sItemIndex, TRUE);
						RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
					}
					break;
				
				case 11:	
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
				case 18:
				case 19:
					// Â°Ã¡Ã…ÃµÃ€Ã¥Ã€Â¸Â·Ã Â°Â£Â´Ã™. 
					SYSTEMTIME SysTime;

					GetLocalTime(&SysTime);
					// v1.4311-3 ÂºÂ¯Â°Ã¦ Ã€Ã”Ã€Ã¥Â±Ã‡ ÃƒÂ¼Ã…Â© Â´Ã/Â³Â¯Ã‚Â¥/Â½ÃƒÂ°Â£Ã€Â¸Â·Ã ÃƒÂ¼Ã…Â©Ã‡Ã‘Â´Ã™. 
					// Ã€Ã”Ã€Ã¥ Â°Â¡Â´Ã‰Ã‡Ã‘ Â½ÃƒÂ°Â£ÂºÂ¸Â´Ã™ Ã€Ã›Â°Ã…Â³Âª Â°Â°Ã€Â¸Â¸Ã© Ã€Ã”Ã€Ã¥Â±Ã‡Ã€ÃŒ Â»Ã§Â¶Ã³ÃÃ¸Â´Ã™.
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 != SysTime.wMonth) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 != SysTime.wDay) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 <= SysTime.wHour) ) {
						// Â³Â¯Ã‚Â¥Â°Â¡ ÃÂ¤ÃˆÂ®Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã™. Â¾Ã†Â¹Â«Â·Â± ÃˆÂ¿Â°ÃºÂ°Â¡ Â¾Ã¸Â°Ã­ Ã€Ã”Ã€Ã¥Â±Ã‡Ã€Âº Â»Ã§Â¶Ã³ÃÃ¸Â´Ã™.
					}
					else {
						char cDestMapName[11];
						ZeroMemory(cDestMapName, sizeof(cDestMapName));
						wsprintf(cDestMapName, "fightzone%d", m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 - 10);
						if (memcmp(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10) != 0) {
							//v1.42
							ItemDepleteHandler(iClientH, sItemIndex, TRUE);
							RequestTeleportHandler(iClientH, "2   ", cDestMapName, -1, -1);
						}
					}
					break;
				}
				break;

			case 5:
				// Â¼Ã’ÃˆÂ¯ÃˆÂ¿Â°ÃºÂ°Â¡ Ã€Ã–Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã› 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
					               m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2); 	         
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_FIRMSTAMINAR:
			m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar > 20*30) m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = 20*30; // ÃƒÃ–Â´Ã« 30ÂºÃÂ°Â£ 
			break;

		case DEF_ITEMEFFECTTYPE_CHANGEATTR:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// Â¸Ã“Â¸Â® Â»Ã¶Ã€Â» Â¹Ã™Â²Ã›Â´Ã™. 
				m_pClientList[iClientH]->m_cHairColor++;
				if (m_pClientList[iClientH]->m_cHairColor > 15) m_pClientList[iClientH]->m_cHairColor = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 2:
				// Â¸Ã“Â¸Â® Â½ÂºÃ…Â¸Ã€ÃÃ€Â» Â¹Ã™Â²Ã›Â´Ã™.
				m_pClientList[iClientH]->m_cHairStyle++;
				if (m_pClientList[iClientH]->m_cHairStyle > 7) m_pClientList[iClientH]->m_cHairStyle = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 3:
				// Ã‡Ã‡ÂºÃÂ»Ã¶Ã€Â» Â¹Ã™Â²Ã›Â´Ã™.
				// Â³Â»Â¿Ã«Ã€Â» Â¹Ã™Ã…ÃÃ€Â¸Â·Ã AppearanceÂ¸Â¦ Â°Ã¨Â»Ãª, Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™.
				m_pClientList[iClientH]->m_cSkin++;
				if (m_pClientList[iClientH]->m_cSkin > 3)
					m_pClientList[iClientH]->m_cSkin = 1;
				
				if (m_pClientList[iClientH]->m_cSex == 1)      sTemp = 1;
				else if (m_pClientList[iClientH]->m_cSex == 2) sTemp = 4; 
				
				switch (m_pClientList[iClientH]->m_cSkin) {
				case 2:	sTemp += 1; break;
				case 3:	sTemp += 2; break;
				}
				m_pClientList[iClientH]->m_sType  = sTemp;
				break;

			case 4:
				// Â¼ÂºÃ€Ã¼ÃˆÂ¯ - Â¸Â¸Â¾Ã  Â¿ÃŠÃ€Â» Ã€Ã”Â°Ã­ Ã€Ã–Â´Ã™Â¸Ã© Â½Ã‡Ã†ÃÃ‡Ã‘Â´Ã™. 
				sTemp = m_pClientList[iClientH]->m_sAppr3 & 0xFF0F;
				if (sTemp == 0) {
					// sTempÂ°Â¡ 0Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© Â°Ã‘Â¿ÃŠ, Â¼Ã“Â¿ÃŠ, Â¹Ã™ÃÃ¶ÃÃŸ Ã‡Ã‘Â°Â¡ÃÃ¶Â¸Â¦ Ã€Ã”Â°Ã­ Ã€Ã–Â´Ã‚ Â°ÃÃ€ÃŒÂ´Ã™. Â¼ÂºÃ€Ã¼ÃˆÂ¯Ã€Â» Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
					if (m_pClientList[iClientH]->m_cSex == 1) 
						 m_pClientList[iClientH]->m_cSex = 2;
					else m_pClientList[iClientH]->m_cSex = 1;

					// Â³Â»Â¿Ã«Ã€Â» Â¹Ã™Ã…ÃÃ€Â¸Â·Ã AppearanceÂ¸Â¦ Â°Ã¨Â»Ãª, Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™.
					if (m_pClientList[iClientH]->m_cSex == 1) {
						// Â³Â²Ã€ÃšÃ€ÃŒÂ´Ã™. 
						sTmpType = 1;
					}
					else if (m_pClientList[iClientH]->m_cSex == 2) {
						// Â¿Â©Ã€ÃšÃ€ÃŒÂ´Ã™.
						sTmpType = 4; 
					}

					switch (m_pClientList[iClientH]->m_cSkin) {
					case 1:
						// Â¹Ã©Ã€ÃÃ€ÃŒÂ¸Ã© Â±Ã—Â´Ã«Â·Ã.
						break;
					case 2:
						sTmpType += 1;
						break;
					case 3:
						sTmpType += 2;
						break;
					}

					sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
					m_pClientList[iClientH]->m_sType  = sTmpType;
					m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1; 
					//
				}
				break;
			}

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
		}
		// *** Request Teleport HandlerÂ°Â¡ Ã€Ã›ÂµÂ¿ÂµÃ‡Â¸Ã© Ã€ÃŒÂ¹ÃŒ ÂµÂ¥Ã€ÃŒÃ…Ã Ã€ÃºÃ€Ã¥Ã€ÃŒ Â¿Ã¤ÃƒÂ»ÂµÃˆ Â»Ã³Ã…Ã‚Ã€ÃŒÂ¹Ã‡Â·Ã Ã€ÃŒÃˆÃ„Â¿Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¾Ã¸Â¾Ã–ÂºÃÂ¾ÃŸ Â¼Ã’Â¿Ã«Ã€ÃŒ Â¾Ã¸Â´Ã™. 
		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¸Ã•Ã€Ãº Â¾Ã¸Â¾Ã˜Â´Ã™.
		ItemDepleteHandler(iClientH, sItemIndex, TRUE);
		
		switch (iEffectResult) {
		case 1:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
			break;
		case 2:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
			break;
		case 3:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			break;
		case 4: // Invincible
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_INVINCIBLE, NULL, NULL, NULL, NULL);
			break;
		case 5: // Mana
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_MANA, NULL, NULL, NULL, NULL);
			break;
		case 6: // EXP
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_EXP, NULL, NULL, NULL, NULL);
			break;
		default:
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) {
		// Â»Ã§Â¿Ã«Ã‡ÃÂ¸Ã©Â¼Â­ Â¸Ã±Ã‡Â¥ÃÃ¶ÃÂ¡Ã€Â» ÃÃ¶ÃÂ¤Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›.
		// dX, dYÃ€Ã‡ ÃÃ‚Ã‡Â¥Â°Â¡ Ã€Â¯ÃˆÂ¿ Â¹Ã¼Ã€Â§ Â³Â»Â¿Â¡ Ã€Ã–Â´Ã‚ÃÃ¶ ÃˆÂ®Ã€ÃÃ‡Ã˜Â¾ÃŸ Ã‡Ã‘Â´Ã™.
		if (_bDepleteDestTypeItemUseEffect(iClientH, dX, dY, sItemIndex, sDestItemID) == TRUE) 
			ItemDepleteHandler(iClientH, sItemIndex, TRUE); 
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) {
		// ÃˆÂ­Â»Ã¬Ã€Â» Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™. 
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) {
		// Â¿ÂµÂ±Â¸ÃˆÃ· Â¾Âµ Â¼Ã¶ Ã€Ã–Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›. ÃÃ¯ Â¾Â²Â°Ã­Â³ÂªÂµÂµ Â¾Ã¸Â¾Ã®ÃÃ¶ÃÃ¶ Â¾ÃŠÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›. (ex: ÃÃ¶ÂµÂµ) 
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_SHOWLOCATION:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			switch (iV1) {
			case 1:
				// Ã‡Ã¶Ã€Ã§ Ã€ÃšÂ½Ã…Ã€Ã‡ Ã€Â§Ã„Â¡Â¸Â¦ ÂºÂ¸Â¿Â©ÃÃ˜Â´Ã™. 
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0)
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 1, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0)
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 2, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "middleland") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 3, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 4, NULL, NULL);	
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone2") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 5, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone1") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 6, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone4") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 7, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone3") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 8, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "arefarm") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 9, NULL, NULL);
				else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvfarm") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 10, NULL, NULL);
				else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 0, NULL, NULL);
				break;
			}
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) {
		// Â±Ã¢Â¼ÃºÂ°Ãº Â°Ã¼Â·ÃƒÂµÃˆ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã‘Â´Ã™. Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Ã­Ã€Â» Â³Â·ÃƒÃŸÂ°Ã­ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¿Â¡ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™. 
		
		if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) || 
			 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) ||
			 (m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] == TRUE) ) {
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Ã­Ã€ÃŒ Â´Ã™ Ã‡ÃŸÂ°Ã…Â³Âª Â¾Ã¸Â°Ã…Â³Âª Â°Ã¼Â·Ãƒ Â½ÂºÃ…Â³Ã€Â» Â»Ã§Â¿Ã«ÃÃŸÃ€ÃŒÂ¶Ã³Â¸Ã© Â¹Â«Â½Ãƒ 
			return;
		}
		else {
			if ( m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan != 0 ) {
				// ÃƒÃ–Â´Ã« Â¼Ã¶Â¸Ã­Ã€ÃŒ 0Ã€ÃŒÂ¸Ã© Â»Ã§Â¿Ã«Ã‡Ã˜ÂµÂµ Â¼Ã¶Â¸Ã­Ã€ÃŒ ÃÃ™ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan--;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) {
					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Ã­Ã€ÃŒ Â´Ã™ ÂµÃ‡Â¾ÃºÂ´Ã™.
					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¸ÃÂ°Â¡ÃÂ³Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ <- Ã€ÃŒÂ°Ã‰ Â¹ÃÃ€Â¸Â¸Ã© Ã€Ã¥Ã‚Ã¸ÃˆÂ­Â¸Ã©Â¿Â¡Â¼Â­ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ„Ã‘Â¾ÃŸ Ã‡Ã‘Â´Ã™.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMLIFESPANEND, DEF_EQUIPPOS_NONE, sItemIndex, NULL, NULL);
				}
				else {
					// Â±Ã¢Â¼Ãº Â»Ã§Â¿Ã« Â½ÃƒÂ°Â£ IDÂ°ÂªÃ€Â» Â±Â¸Ã‡Ã‘Â´Ã™. v1.12
					int iSkillUsingTimeID = (int)timeGetTime();
					
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_USEITEM_SKILL, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill, 
			                     dwTime + m_pSkillConfigList[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]->m_sValue2*1000, 
								 iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_cMapIndex, dX, dY, 
								 m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ], iSkillUsingTimeID, NULL);
					
					// Â±Ã¢Â¼Ãº Â»Ã§Â¿Ã«ÃÃŸ 
					m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = TRUE;
					m_pClientList[iClientH]->m_iSkillUsingTimeID[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = iSkillUsingTimeID; //v1.12
		 		}
			}
		}
	}
}

void CGame::Effect_Damage_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{
 int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iExp, iMaxSuperAttack, iRepDamage;
 char cAttackerSide, cDamageMoveDir;
 DWORD dwTime;
 register double dTmp1, dTmp2, dTmp3;
 short sAtkX, sAtkY, sTgtX, sTgtY, dX, dY, sItemIndex;

 	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) && 
		(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1) && (m_bHeldenianInitiated == TRUE)) return;
	
	dwTime = timeGetTime();
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:	
		if ((m_bAdminSecurity == TRUE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return;
		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) iDamage += 4;
		if ((m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND] == -1) || (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] == -1)) {
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 861 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 862) {
					iDamage *= (int)1.3;
				}
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864) {
					if (m_pClientList[sAttackerH]->m_iRating > 0) {
						iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
						if (iRepDamage < 5) iRepDamage = 5;
						iDamage += iRepDamage;
					}
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != NULL) {
							if (m_pClientList[sTargetH]->m_iRating < 0) {
								iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
								if (iRepDamage > 10) iRepDamage = 10;
								iDamage += iRepDamage;
							}
						}
					}
				}
			}
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != NULL) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/20);
						if (iRepDamage > 5) iRepDamage = 5;
						iDamage += iRepDamage;
						}
					}
				}
			}
		}

		if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return;

		dTmp1 = (double)iDamage;
		if (m_pClientList[sAttackerH]->m_iMag <= 0)
			 dTmp2 = 1.0f;
		else dTmp2 = (double)m_pClientList[sAttackerH]->m_iMag;	
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);

		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;
		if (iDamage <= 0) iDamage = 0;

		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;

		if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage/3;
		}

		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
			if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
				iDamage += (iDamage*7)/10 ;
			} else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
				iDamage += iDamage/2;
			} else 
				iDamage += iDamage/3;
		}
		
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;

		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == FALSE) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation == TRUE)) return;
		
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		if ((m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) && (m_pClientList[sTargetH]->m_iAdminUserLevel == 0)) return;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {

				}
				else {
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}

			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		ClearSkillUsingStatus(sTargetH);
		
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				ItemDepleteHandler(sTargetH, iIndex, TRUE);
			}
			else {
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}

		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}
	
		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				return;
			}
		}
		
		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;

					iTemp = (2*m_pClientList[sTargetH]->m_iMag) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->m_iInt/2);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					if (iDice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}
				
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}

		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		
		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;

		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
			return;

		case 4:
			if (sTgtX == sAtkX) {
				if (sTgtY == sAtkY) return;
				else if (sTgtY > sAtkY) cDamageMoveDir = 5;
				else if (sTgtY < sAtkY) cDamageMoveDir = 1;
			}
			else if (sTgtX > sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 3;
				else if (sTgtY > sAtkY) cDamageMoveDir = 4;
				else if (sTgtY < sAtkY) cDamageMoveDir = 2;
			}
			else if (sTgtX < sAtkX) {
				if (sTgtY == sAtkY)     cDamageMoveDir = 7;
				else if (sTgtY > sAtkY) cDamageMoveDir = 6;
				else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
			}

			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
				cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];			
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}
						
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
				
			dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
			dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
					
			if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
				cDamageMoveDir = iDice(1,8);
				dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
				dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
				if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) return;
			}
						
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
			m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[sTargetH]->m_sX   = dX;
			m_pNpcList[sTargetH]->m_sY   = dY;
			m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

			if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) {
				DeleteNpc(sTargetH);
			}
			return;
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}

		switch (m_pNpcList[sTargetH]->m_sType) {
				case 67: // McGaffin
				case 68: // Perry
				case 69: // Devlin
				return;
		}
		
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return ;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
						
			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;

				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						iExp = iDamage;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
											
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE);
						else GetExp(sAttackerH, (iExp/2), TRUE);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
						
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE);
						else GetExp(sAttackerH, (iExp/2), TRUE);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_Damage_Spot_Type2(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{
 int iPartyID, iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iExp, iMaxSuperAttack, iRepDamage;
 char cAttackerSide, cDamageMoveDir, cDamageMinimum;
 DWORD dwTime;
 register double dTmp1, dTmp2, dTmp3;
 short sTgtX, sTgtY, sItemIndex;

	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] == NULL)) return;
	if ((cAttackerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sAttackerH] == NULL)) return;
	if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != 0) && 
		(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == 1) && (m_bHeldenianInitiated == TRUE)) return;
	
	dwTime = timeGetTime();
	sTgtX = 0;
	sTgtY = 0;
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		if ((m_bAdminSecurity == TRUE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return;
		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) iDamage += 4;
		if ((m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND] == -1) || (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] == -1)) {
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 861 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 862) {
					iDamage *= (int)1.3;
				}
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863 || m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864) {
					if (m_pClientList[sAttackerH]->m_iRating > 0) {
						iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
						if (iRepDamage < 5) iRepDamage = 5;
						iDamage += iRepDamage;
					}
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != NULL) {
							if (m_pClientList[sTargetH]->m_iRating < 0) {
								iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
								if (iRepDamage > 10) iRepDamage = 10;
								iDamage += iRepDamage;
							}
						}
					}
				}
			}
			sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
			if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
				if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
					if (cTargetType == DEF_OWNERTYPE_PLAYER) {
						if (m_pClientList[sTargetH] != NULL) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/20);
						if (iRepDamage > 5) iRepDamage = 5;
						iDamage += iRepDamage;
						}
					}
				}
			}
		}

		if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return;

		dTmp1 = (double)iDamage;
		if (m_pClientList[sAttackerH]->m_iMag <= 0)
			 dTmp2 = 1.0f;
		else dTmp2 = (double)m_pClientList[sAttackerH]->m_iMag;	
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);
		if (iDamage <= 0) iDamage = 0;
		// order switched with above
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;

		if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage/3;
		}

		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
			if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
				iDamage += (iDamage*7)/10 ;
			} else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
				iDamage += iDamage/2;
			} else 
				iDamage += iDamage/3;
		}
		
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		if (m_pClientList[sTargetH]->m_cMapIndex == -1) return;
		if ((m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) && (m_pClientList[sTargetH]->m_iAdminUserLevel == 0)) return;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == FALSE) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation == TRUE)) return;
		
		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {

				}
				else {
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {

						}
						else return;
					}
					else return;
				}
			}

			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		ClearSkillUsingStatus(sTargetH);
		
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337:
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				ItemDepleteHandler(sTargetH, iIndex, TRUE);
			}
			else {
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}

		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}
	
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;
		
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 5) break;

		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				return;
			}
		}
		
		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;

					iTemp = (2*m_pClientList[sTargetH]->m_iMag) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->m_iInt/2);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					if (iDice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}
				
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) {
					cDamageMinimum = 80;
				}
				else {
					cDamageMinimum = 50;
				}

				if (iDamage >= cDamageMinimum) {
					sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;
					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY) return;
							else if (sTgtY > sAtkY) cDamageMoveDir = 5;
							else if (sTgtY < sAtkY) cDamageMoveDir = 1;
						}
						else if (sTgtX > sAtkX) {
							if (sTgtY == sAtkY)     cDamageMoveDir = 3;
							else if (sTgtY > sAtkY) cDamageMoveDir = 4;
							else if (sTgtY < sAtkY) cDamageMoveDir = 2;
						}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}
					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, NULL, NULL);
				}

				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		
		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
		case 6:
			return;

		case 3:
		case 5:
			if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 40:
				case 41:
					if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
					break;
				}
			}
		}
	
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return ;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);		
			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				if ((m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						iExp = iDamage;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
											
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE);
						else GetExp(sAttackerH, (iExp/2), TRUE);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
						
						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp, TRUE);
						else GetExp(sAttackerH, (iExp/2), TRUE);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_Damage_Spot_DamageMove(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{
 int iDamage, iSideCondition, iIndex, iRemainLife, iTemp, iMaxSuperAttack;
 DWORD dwTime, wWeaponType;
 char cAttackerSide, cDamageMoveDir;
 register double dTmp1, dTmp2, dTmp3;
 int iPartyID, iMoveDamage;
 short sTgtX, sTgtY;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	dwTime = timeGetTime();
	sTgtX = 0;
	sTgtY = 0;
	
	// ÇØ´ç Å¸ÄÏ¿¡°Ô ´ë¹ÌÁö¸¦ ¸ÔÀÎ´Ù. 
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	iPartyID = 0;

	// °ø°İÀÚ°¡ ÇÃ·¹ÀÌ¾î¶ó¸é Mag¿¡ µû¸¥ º¸³Ê½º ´ë¹ÌÁö¸¦ °¡»ê 
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		if ((m_bAdminSecurity == TRUE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return ;
		dTmp1 = (double)iDamage;
		if (m_pClientList[sAttackerH]->m_iMag <= 0)
			 dTmp2 = 1.0f;
		else dTmp2 = (double)m_pClientList[sAttackerH]->m_iMag;
			
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);
		if (iDamage <= 0) iDamage = 0;

		// v1.432 2001 4 7 13 7
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		// v1.44 »çÅõÀåÀÌ¸é ´ë¹ÌÁö 1.33¹è 
		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;

		// Crusade : Àü¸éÀü ¸ğµåÀÏ¶§ ´ëÀÎ °ø°İ·Â 1.33¹è 
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
		{
 			// v2.15 Àú·¦ÀÇ °æ¿ì´Â µ¥¹ÌÁö°¡ Áõ°¡ÇÑ´Ù. 1.7 ¹è 
			if (m_pClientList[sAttackerH]->m_iLevel <= 80)
			{
				iDamage += (iDamage* 7)/10 ;
			} // v2.15 Àú·¦ÀÇ °æ¿ì´Â µ¥¹ÌÁö°¡ Áõ°¡ÇÑ´Ù. 1.5 ¹è 
			else if (m_pClientList[sAttackerH]->m_iLevel <= 100)
			{
				iDamage += iDamage/2;
			} else iDamage += iDamage/3;
		}

		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 2) {
			iDamage += 4;
		}

		wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 34) {
			iDamage += iDamage/3;
		}

		if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
			iDamage += iDamage/3;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// °ø°İ ´ë»óÀÌ Á¸ÀçÇÏÁö ¾ÊÀ¸¸é ¸®ÅÏ 
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsInitComplete == FALSE) return;
		// ÀÌ¹Ì Á×¾î ÀÖ´Ù¸é Ã³¸® ¾ÈÇÔ.
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
		// ·¢À¸·Î ÀÎÇØ º¸È£¸¦ ¹Ş¾Æ¾ß ÇÑ´Ù¸é 
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		// °ø°İÀÚ°¡ À§Ä¡ÇÑ ¸ÊÀÌ °ø°İ ºÒ°¡´É ¸ÊÀÌ¶ó¸é 
		// v2.03 ¼­¹ö ´Ù¿îµÇ¾î¼­ °íÄ§ 
		if (m_pClientList[sTargetH]->m_cMapIndex == -1) return;
		if ((m_pMapList[ m_pClientList[sTargetH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) && (m_pClientList[sTargetH]->m_iAdminUserLevel == 0)) return;
		// v1.41 °ø°İÀÚ°¡ Áß¸³ÀÌ¸é ´ëÀÎ °ø°İÀÌ ºÒ°¡´ÉÇÏ´Ù. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;

		// v2.172 °°ÀºÆí³¢¸®´Â ¸¶À»¿¡¼­ °ø°İ´çÇÏÁö ¾Ê´Â´Ù. ¹üÁËÀÚ¿Í NPC´Â ¿¹¿Ü Áß¸³µµ °ø°İ ¾ÊµÇ°Ô 
		if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return ;
		if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE)) return ;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return;

		// 01-12-17 °°Àº ÆÄÆ¼¿øÀÌ¸é °ø°İ ºÒ°¡ 
		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;

		// ¸¸¾à °ø°İÀÚ°¡ ÇÃ·¹ÀÌ¾îÀÌ°í °ø°İÀÚ°¡ ¾ÈÀü °ø°İ ¸ğµå¶ó¸é °ø°İÀÇ ÀÇ¹Ì°¡ ¾ø´Ù. 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
					// ¾Æ¹« È¿°ú ¾øÀ½. ¸¶³ª ¼Òºñ·®ÀÌ ÁÙ¾úÀ¸¹Ç·Î 
				}
				else {
					// °°Àº ÆíÀÌÁö¸¸ ¸¸¾à »çÅõÀå ³»¿¡¼­ ÆíÀÌ °°´Ù¸é °ø°İ Ã³¸®¸¦ ÇØ¾ßÇÑ´Ù.
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {
							// »çÅõÀå ³»¿¡¼­ ´Ù¸¥ ±æµå´Ù. °ø°İÀÌ °¡´ÉÇÏ´Ù. 
						}
						else return;
					}
					else return;
				}
			}

			// ¸¶¹ı º¸È£ È¤Àº ¾ÈÀü ¿µ¿ªÀÌ¶ó¸é °ø°İ ¼º°ø ¸øÇÔ 
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}
		
		// ½ºÅ³ÀÇ »ç¿ë»óÅÂ¸¦ ¸ğµÎ ¹«È¿È­ ÇÑ´Ù.
		ClearSkillUsingStatus(sTargetH);

		// v1.432 ¼Ó¼ºº° ´ë¹ÌÁö °¨¼Ò 
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}
		
		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			// ¸¶¹ı ´ë¹ÌÁö Àı°¨ È¿°ú¸¦ °¡Áø ¾ÆÀÌÅÛÀÌ´Ù.
			
			// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó ´ë¹ÌÁö¸¦ ÁÙÀÎ´Ù. 
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: // ¿¡¸Ó¶öµå ¹İÁö 20%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337: // ·çºñ ¹İÁö 10%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				// ¸¶¹ı µ¥¹ÌÁö Àı°¨ ¾ÆÀÌÅÛÀÌ ºÎ¼­Áø´Ù. 
				ItemDepleteHandler(sTargetH, iIndex, TRUE);
			}
			else {
				// ¸¶¹ı µ¥¹ÌÁö Àı°¨ ¾ÆÀÌÅÛÀÇ ¼ö¸í¸¸ ÁÙÀÎ´Ù. 
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}

		// v1.42 Ãß°¡µÈ °íÁ¤ ¸¶¹ı ´ë¹ÌÁö Àı°¨
		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		// v1.4 VIT¿¡ µû¸¥ ´ë¹ÌÁö °¨¼Ò 
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		// ¸¸¾à ¸¶¹ı º¸È£ÁßÀÌ¶ó¸é ´ë¹ÌÁö´Â 1/2 
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
	
		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			// Çà¿îÈ¿°ú·Î Á×À½À» ¸ğ¸éÇÑ´Ù.
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		// v1.432 Æ¯¼ö ´É·Â Áß ¸ğµç ´ë¹ÌÁö¸¦ ¸·´Â È¿°ú°¡ È°¼ºÈ­ µÈ °æ¿ì ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {
				// v2.04 Å¸°İÀ» ¹Ş¾Ò´Âµ¥ ¸¶³ª º¯È¯ Æ¯¼ºÄ¡°¡ ÀÖ¾ú´Ù¸é 
				if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
					dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
					dTmp2 = (double)iDamage;
					dTmp3 = (dTmp1/100.0f)*dTmp2 +1.0f;

					// ÃÖ´ë ¸¶³ªÄ¡ 
					iTemp = (2*m_pClientList[sTargetH]->m_iMag) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->m_iInt/2);
					m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
					if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
				}

				// v2.04 Å¸°İÀ» ¹Ş¾Ò´Âµ¥ ÇÊ»ì ÃæÀüÀÇ Æ¯¼ºÄ¡°¡ ÀÖ¾ú´Ù¸é 
				if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
					// È®·ü °è»ê¿¡ µû¶ó¼­ ÇÊ»ì±â°¡ ÃæÀüµÈ´Ù.
					if (iDice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
						iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
						if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
						// v1.12 ¼­¹ö¿Í Å¬¶óÀÌ¾ğÆ® °£¿¡ Ä«¿îÆ®°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â °æ¿ì°¡ ÀÖÀ» ¼ö ÀÖÀ¸¹Ç·Î °¡°¨¿¡ »ó°ü¾øÀÌ º¸³½´Ù.
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
					}
				}

				// v1.44 »çÅõÀåÀÌ¸é ´ë¹ÌÁö 80ÀÌ»óÀÏ¶§ ¹Ğ¸°´Ù.
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
					 iMoveDamage = 80;
				else iMoveDamage = 50;

				if (iDamage >= iMoveDamage) {
					// ´ë¹ÌÁö°¡ 50ÀÌ»óÀÌ¸é Æ¨±ä´Ù.
			///		char cDamageMoveDir;
					sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;

					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto EDSD_SKIPDAMAGEMOVE;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}

					// v1.44 ¹Ğ·Á³¯¶§ ´ë¹ÌÁö¸¦ ÀÔ·ÂÇÑ´Ù.
					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					// ¹ŞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					// Æ¨°Ü ³ª°¡¶ó´Â ¸Ş½ÃÁö ÀÔ·Â 	
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, NULL, NULL);
				}
				else {
EDSD_SKIPDAMAGEMOVE:;
					// ¹ŞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					// Ãæ°İÀ» ¹Ş¾Ò´Ù¸é Ãæ°İµ¿ÀÛ Àü¼Û 
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
				}

				// v1.4 Á×ÀºÃ´ÇÏ°í ÀÖ´Â °æ¿ì´Â Owner À§Ä¡¸¦ ¿Å±ä´Ù. 
				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. ¸¶¹ı°ø°İ ÆĞ·²¶óÀÌÁî µÈ °Íµµ Ç®¸°´Ù.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSide)) return;
		
		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
			return;
		}
		
		// ÀüÀï¿ë ±¸Á¶¹°Áß ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ´Â ¾Æ±ºÀÌ³ª Áß¸³ÀÇ °ø°İ¿¡ ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}

		switch (m_pNpcList[sTargetH]->m_sType) {
			case 67: // McGaffin
			case 68: // Perry
			case 69: // Devlin
				iDamage = 0;
			break;
		}
		
		// ¸ó½ºÅÍ°¡ ¸¶¹ı ´ë¹ÌÁö Èí¼ö·üÀÌ ÀÖ´Ù¸é(AbsDamage°¡ 0º¸´Ù Å©´Ù) ¿ø·¡ ¸¶¹ı ´ë¹ÌÁö¸¦ °¨¼Ò½ÃÅ²´Ù.
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		// ¸¸¾à ¸¶¹ı º¸È£ÁßÀÌ¶ó¸é ´ë¹ÌÁö´Â 1/2 
		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			// NPC°¡ »ç¸ÁÇß´Ù.
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			// °ø°İ´çÇßÁö¸¸ »ì¾ÆÀÖ´Ù. ¹İ°İÇÑ´Ù.

			// ÆíÀÌ °°À¸¸é ¹İ°İÇÏÁö ¾Ê´Â´Ù.
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				// v2.15 °æºñ´Â °°Àº Æíµµ ¹İ°İÇÑ´Ù.			
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) return;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			
			// Ãæ°İÀ» ¹Ş¾Ò´Ù¸é Ãæ°İµ¿ÀÛ Àü¼Û
			SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
			
			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {

				// µ¿Á·ÀÌ°í ÆíÀÌ °°À¸¸é ¹İ°İÇÏÁö ¾Ê´Â´Ù.
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				// ActionLimit°¡ 1ÀÌ¸é ¹İ°İÀ» ÇÏÁö ¾Ê´Â´Ù. ¿ÀÁ÷ ¿òÁ÷ÀÏ¼ö¸¸ ÀÖÀ¸´Ï.
				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
				
				// ¿©±â¼­ Ç¥È¿ µ¿ÀÛ°°Àº°ÍÀ» À§ÇÑ ¸Ş½ÃÁö ¹ß¼Û.

				// Damage¸¦ ÀÔÀº Ãæ°İÀ¸·Î ÀÎÇÑ Áö¿¬È¿°ú.
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. 	
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				//Crusade
				int iExp;

				// NPC¿¡ ´ëÇÑ °ø°İÀÌ ¼º°øÇßÀ¸¹Ç·Î °ø°İÀÚ°¡ ÇÃ·¹ÀÌ¾î¶ó¸é ÀÔÈù ´ë¹ÌÁö ¸¸Å­ÀÇ °æÇèÄ¡¸¦ °ø°İÀÚ¿¡°Ô ÁØ´Ù. 
				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
					// ExpStockÀ» ¿Ã¸°´Ù. ´Ü ¼ÒÈ¯¸÷ÀÎ °æ¿ì °æÇèÄ¡¸¦ ¿Ã¸®Áö ¾Ê´Â´Ù.
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						// Crusade
						iExp = iDamage;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						//v2.03 918 °æÇèÄ¡ Áõ°¡ 
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}
						
						// v2.17 2002-8-6 °ø°İÀÚÀÇ ·¹º§ÀÌ 100 ÀÌ»óÀÌ¸é Åä³¢³ª °í¾çÀÌ¸¦ ÀâÀ»¶§ °æÇèÄ¡°¡ ¿Ã¶ó°¡Áö ¾Ê´Â´Ù.
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}

						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
						else GetExp(sAttackerH, (iExp/2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						// Crusade
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						//v2.03 918 °æÇèÄ¡ Áõ°¡ 
						if (m_pClientList[sAttackerH]->m_iAddExp > 0) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						// v2.17 2002-8-6 °ø°İÀÚÀÇ ·¹º§ÀÌ 100 ÀÌ»óÀÌ¸é Åä³¢³ª °í¾çÀÌ¸¦ ÀâÀ»¶§ °æÇèÄ¡°¡ ¿Ã¶ó°¡Áö ¾Ê´Â´Ù.
						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0 ;
							break ;
							default: break;
							}
						}


						if (bExp == TRUE) 
							 GetExp(sAttackerH, iExp); //m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						else GetExp(sAttackerH, (iExp/2)); //m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_HpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iHP, iMaxHP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	iHP = iDice(sV1, sV2) + sV3;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
		iMaxHP = (3*m_pClientList[sTargetH]->m_iVit) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->m_iStr/2);
		if (m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown != 0) 
			iMaxHP = iMaxHP - (iMaxHP/m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown);
		if (m_pClientList[sTargetH]->m_iHP < iMaxHP) {
			m_pClientList[sTargetH]->m_iHP += iHP;
			if (m_pClientList[sTargetH]->m_iHP > iMaxHP) m_pClientList[sTargetH]->m_iHP = iMaxHP;
			if (m_pClientList[sTargetH]->m_iHP <= 0)     m_pClientList[sTargetH]->m_iHP = 1;
			SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return;
		iMaxHP = m_pNpcList[sTargetH]->m_iHitDice*4;
		if (m_pNpcList[sTargetH]->m_iHP < iMaxHP) {
			m_pNpcList[sTargetH]->m_iHP += iHP;
			if (m_pNpcList[sTargetH]->m_iHP > iMaxHP) m_pNpcList[sTargetH]->m_iHP = iMaxHP;
			if (m_pNpcList[sTargetH]->m_iHP <= 0)     m_pNpcList[sTargetH]->m_iHP = 1;
		}
		break;
	}
}

void CGame::Effect_SpDown_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iSP, iMaxSP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	// Ã‡Ã˜Â´Ã§ Ã…Â¸Ã„ÃÃ€Ã‡ SpÂ¸Â¦ Â³Â»Â¸Â°Â´Ã™.
	iSP = iDice(sV1, sV2) + sV3;
	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
	
		// New 19/05/2004
		// Is the user having an invincibility slate
		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return;

		iMaxSP = (2*m_pClientList[sTargetH]->m_iStr) + (2*m_pClientList[sTargetH]->m_iLevel);
		if (m_pClientList[sTargetH]->m_iSP > 0) {
			
			//v1.42 
			if (m_pClientList[sTargetH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[sTargetH]->m_iSP -= iSP;
				if (m_pClientList[sTargetH]->m_iSP < 0) m_pClientList[sTargetH]->m_iSP = 0;
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPCÂ´Ã‚ Â½ÂºÃ…Ã‚Â¹ÃŒÂ³ÃŠ Â°Â³Â³Ã¤Ã€ÃŒ Â¾Ã¸Â´Ã™.
		break;
	}
}


void CGame::Effect_SpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iSP, iMaxSP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	// Ã‡Ã˜Â´Ã§ Ã…Â¸Ã„ÃÃ€Ã‡ SpÂ¸Â¦ Â¿ÃƒÂ¸Â°Â´Ã™.
	iSP = iDice(sV1, sV2) + sV3;
	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
	
		iMaxSP = (2*m_pClientList[sTargetH]->m_iStr) + (2*m_pClientList[sTargetH]->m_iLevel);
		if (m_pClientList[sTargetH]->m_iSP < iMaxSP) {
			m_pClientList[sTargetH]->m_iSP += iSP;
			
			if (m_pClientList[sTargetH]->m_iSP > iMaxSP) 
				m_pClientList[sTargetH]->m_iSP = iMaxSP;

			SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPCÂ´Ã‚ Â½ÂºÃ…Ã‚Â¹ÃŒÂ³ÃŠ Â°Â³Â³Ã¤Ã€ÃŒ Â¾Ã¸Â´Ã™.
		break;
	}
}

/*********************************************************************************************************************
**  int BOOL CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio) **
**  description			:: calculates if a player resists magic														**
**  last updated		:: November 20, 2004; 8:42 PM; Hypnotoad													**
**	return value		:: BOOL																						**
**  commentary			::	-	hero armor for target mages adds 50 magic resistance								**
**							-	10000 or more it ratio will deduct 10000 hit ratio									**
**							-	invincible tablet is 100% magic resistance											**
**********************************************************************************************************************/
BOOL CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
 double dTmp1, dTmp2, dTmp3;
 int    iTargetMagicResistRatio, iDestHitRatio, iResult;
 char   cTargetDir, cProtect;								 

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return FALSE;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return FALSE;
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE;
		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return TRUE;
		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pClientList[sTargetH]->m_cSkillMastery[3] + m_pClientList[sTargetH]->m_iAddMR;
		if (m_pClientList[sTargetH]->m_iMag > 50) 
			iTargetMagicResistRatio += (m_pClientList[sTargetH]->m_iMag - 50);
		iTargetMagicResistRatio += m_pClientList[sTargetH]->m_iAddResistMagic;
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]; 
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return FALSE;
		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pNpcList[sTargetH]->m_cResistMagic;
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]; 
		break;
	}

	if (cProtect == 5) return TRUE;

	if ((iHitRatio < 1000) && (cProtect == 2)) return TRUE;
	if (iHitRatio >= 10000) iHitRatio -= 10000;
	if (iTargetMagicResistRatio < 1) iTargetMagicResistRatio = 1;
	if ((cAttackerDir != 0) && (m_pClientList[sTargetH] != NULL) && (m_pClientList[sTargetH]->m_cHeroArmourBonus == 2)) {
		iHitRatio += 50;
	}
	
	dTmp1 = (double)(iHitRatio);
	dTmp2 = (double)(iTargetMagicResistRatio);
	dTmp3 = (dTmp1 / dTmp2)*50.0f;
	iDestHitRatio = (int)(dTmp3); 
	
	if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
	if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;
	if (iDestHitRatio >= 100) return FALSE;
	
	iResult = iDice(1, 100);
	if (iResult <= iDestHitRatio) return FALSE;

	if (cTargetType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sTargetH, 3, 1);
	return TRUE;
}

BOOL CGame::bCheckResistingIceSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
 // ³Ãµ¿µÉ °ÍÀÎ°¡ÀÇ È®·ü °è»ê.
 int    iTargetIceResistRatio, iResult;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return FALSE;
		// v1.4 ¿î¿µÀÚ¿¡ ´ëÇÑ ³Ãµ¿°ø°İÀº ¹«ÀÇ¹Ì 
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE;
		iTargetIceResistRatio = m_pClientList[sTargetH]->m_iAddAbsWater*2; 
		// v2.172 ÇØµ¿ Æ÷¼ÇÀ» ¸Ô°í 30ÃÊ°£Àº ¾óÁö ¾Ê´Â´Ù.
		if (m_pClientList[sTargetH]->m_dwWarmEffectTime == NULL) {
		}
		else if ((timeGetTime() - m_pClientList[sTargetH]->m_dwWarmEffectTime) < 1000*30) return TRUE;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return FALSE;
		iTargetIceResistRatio = (m_pNpcList[sTargetH]->m_cResistMagic) - (m_pNpcList[sTargetH]->m_cResistMagic/3); // ¿©±â¿¡ ¾óÀ½ ¹æ¾î ¼öÄ¡ ÀÔ·Â. NPCÀÇ °æ¿ì ¸¶¹ı ÀúÇ×ÀÇ 70% ¼öÁØ 
		break;
	}
	
	if (iTargetIceResistRatio < 1) iTargetIceResistRatio = 1;
	
	iResult = iDice(1, 100);
	if (iResult <= iTargetIceResistRatio) return TRUE;

	return FALSE;
}

/*BOOL CGame::bCheckResistingIceSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
 // Â³ÃƒÂµÂ¿ÂµÃ‰ Â°ÃÃ€ÃÂ°Â¡Ã€Ã‡ ÃˆÂ®Â·Ã¼ Â°Ã¨Â»Ãª.
 int    iTargetIceResistRatio, iResult;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return FALSE;
		// v1.4 Â¿Ã®Â¿ÂµÃ€ÃšÂ¿Â¡ Â´Ã«Ã‡Ã‘ Â³ÃƒÂµÂ¿Â°Ã¸Â°ÃÃ€Âº Â¹Â«Ã€Ã‡Â¹ÃŒ 
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE;
		iTargetIceResistRatio = m_pClientList[sTargetH]->m_iAddAbsWater*2; 
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return FALSE;
		iTargetIceResistRatio = (m_pNpcList[sTargetH]->m_cResistMagic) - (m_pNpcList[sTargetH]->m_cResistMagic/3); // Â¿Â©Â±Ã¢Â¿Â¡ Â¾Ã³Ã€Â½ Â¹Ã¦Â¾Ã® Â¼Ã¶Ã„Â¡ Ã€Ã”Â·Ã‚. NPCÃ€Ã‡ Â°Ã¦Â¿Ã¬ Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—Ã€Ã‡ 70% Â¼Ã¶ÃÃ˜ 
		break;
	}
	
	if (iTargetIceResistRatio < 1) iTargetIceResistRatio = 1;
	
	iResult = iDice(1, 100);
	if (iResult <= iTargetIceResistRatio) return TRUE;
	
	return FALSE;
}*/


BOOL CGame::bSetItemToBankItem(int iClientH, class CItem * pItem)
{
 register int i, iRet;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 char cData[100];		   
	
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsInsideWarehouse == FALSE) return FALSE;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		
		m_pClientList[iClientH]->m_pItemInBankList[i] = pItem;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMTOBANK;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		*cp = i; // Ã€Â§Ã„Â¡ Ã€ÃºÃ€Ã¥ 
		cp++;

		// 1Â°Â³.
		*cp = 1;
		cp++;

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; 
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
	
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		// v1.432
		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		// v1.42
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™. v1.41 ÃÂ¦Â°Ã…Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
			// DeleteClient(iClientH, TRUE, TRUE);
			return TRUE; // v1.41 FALSEÂ¸Â¦ Â¹ÃÃˆÂ¯Ã‡ÃÂ¸Ã© Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¹Ã™Â´ÃšÂ¿Â¡ ÂºÂ¹Â»Ã§ÂµÃˆÂ´Ã™.
		}

		return TRUE;
	}

	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÂºÂ¸Â°Ã¼Ã‡Ã’ Â¿Â©Ã€Â¯Â°Ã¸Â°Â£Ã€ÃŒ Â¾Ã¸Â´Ã™.
	return FALSE;
}

BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 register int i;
 int iRemainPoint, iTotalPoints, iWeaponIndex, iDownSkillSSN, iDownPoint;
 short sDownSkillIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - DEF_MAXSKILLPOINTS;

	if (iRemainPoint > 0) {
		// Â½ÂºÃ…Â³Ã€Ã‡ Ã†Ã·Ã€ÃÃ†Â®Â°Â¡ ÃƒÃŠÂ°ÃºÂµÃ‡Â¾ÃºÂ´Ã™. ÃƒÃŠÂ°ÃºÂµÃˆ Ã†Ã·Ã€ÃÃ†Â® Â¸Â¸Ã…Â­ Â·Ã§Ã‡ÃÂ¸Â¦ ÂµÂ¹Â¸Ã§ SSNÃ€ÃŒ Â°Â¡Ã€Ã¥ Â³Â·Ã€Âº Â½ÂºÃ…Â³Ã€Â» Â³Â»Â¸Â°Â´Ã™.	
		while (iRemainPoint > 0) {
			
			sDownSkillIndex = -1; // v1.4
			if (m_pClientList[iClientH]->m_iDownSkillIndex != -1) { 
				// ÃÃ¶ÃÂ¤ÂµÃˆ Â½ÂºÃ…Â³Ã€ÃŒ Ã€Ã–Â´Ã™. 
				switch (m_pClientList[iClientH]->m_iDownSkillIndex) {
				case 3: // Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã—

				/* Ã€ÃŒ Â½ÂºÃ…Â³ÂµÂµ 0Ã€Â¸Â·Ã ÂµÃˆÂ´Ã™.
				case 4:
				case 5:
				case 7:
					// 20Ã€ÃŒÃ‡ÃÂ·ÃÂ´Ã‚ Â¶Â³Â¾Ã®ÃÃº Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â±Ã¢ÂºÂ»Â½ÂºÃ…Â³
					if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 20) {
						sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
					}
					else {
						// Â´Ã™Â¸Â¥ Â½ÂºÃ…Â³Ã€Â» Â°Ã‹Â»Ã¶Ã‡Ã‘Â´Ã™.
						iDownSkillSSN = 99999999;
						for (i = 0; i < DEF_MAXSKILLTYPE; i++)
						if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 21) && (i != iSkill) && 
							(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
							// V1.22 Â´Ã™Â¿Ã® Â½ÃƒÃ…Â³ Â½ÂºÃ…Â³Ã€Âº ÃƒÃ–Â¼Ã’ 20 Ã€ÃŒÃ‡ÃÂ·ÃÂ´Ã‚ Â¶Â³Â¾Ã®ÃÃº Â¼Ã¶ Â¾Ã¸Â´Ã™. 
							iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
							sDownSkillIndex = i;
						}
					}
					break;
				*/

				default:
					// Â½ÂºÃ…Â³Ã€ÃŒ 20 Ã€ÃŒÃ‡ÃÃ€Ã‡ Â»Ã³Ã…Ã‚Â¶Ã³Â¸Ã© Â±Ã—Â´Ã«Â·Ã 0Ã€Â¸Â·Ã Â¶Â³Â¾Ã® Â¶ÃŸÂ¸Â°Â´Ã™.
					if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 0) {
						sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
					}
					else {
						// Â´Ã™Â¸Â¥ Â½ÂºÃ…Â³Ã€Â» Â°Ã‹Â»Ã¶Ã‡Ã‘Â´Ã™.
						// Â´Ã™Â¸Â¥ Â½ÂºÃ…Â³Ã€Â» Â°Ã‹Â»Ã¶Ã‡Ã‘Â´Ã™.
						iDownSkillSSN = 99999999;
						for (i = 0; i < DEF_MAXSKILLTYPE; i++)
						if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 21) && (i != iSkill) && 
							(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
							// V1.22 Â´Ã™Â¿Ã® Â½ÃƒÃ…Â³ Â½ÂºÃ…Â³Ã€Âº ÃƒÃ–Â¼Ã’ 20 Ã€ÃŒÃ‡ÃÂ·ÃÂ´Ã‚ Â¶Â³Â¾Ã®ÃÃº Â¼Ã¶ Â¾Ã¸Â´Ã™. 
							iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
							sDownSkillIndex = i;
						}
					}
					break;
				}
			}
			// Ã‡Ã¶Ã€Ã§ 1ÂºÂ¸Â´Ã™ Ã…Â« Â½ÂºÃ…Â³ ÃÃŸÂ¿Â¡Â¼Â­ Â°Â¡Ã€Ã¥ Ã€Ã›Ã€Âº SSNÃ€Â» Â°Â®Â´Ã‚ Â½ÂºÃ…Â³Ã€Âº sDownSkillIndex 
			
			if (sDownSkillIndex != -1) {
				
				if (m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] <= 20) // v1.4
				 	 iDownPoint = m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex];
				else iDownPoint = 1;

				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= iDownPoint; // v1.4
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex]+1] - 1;
				iRemainPoint -= iDownPoint; // v1.4
				
				// Â¸Â¸Â¾Ã  Â³Â·Â¾Ã†ÃÃ¸ Â½ÂºÃ…Â³Ã€ÃŒ Ã‡Ã¶Ã€Ã§ Â»Ã§Â¿Ã«ÃÃŸÃ€Ã Â¹Â«Â±Ã¢Â¿Ã Â°Ã¼Â·ÃƒÃ€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» Â³Â·ÃƒÃŸÂ¾Ã®Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
					// Â¾Ã§Â¼Ã•Â¹Â«Â±Ã¢Â°Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã™. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// ÃˆÂ°Â·Ã¹Ã€Ã‡ Â»Ã§Â¿Ã«Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Â½ÂºÃ…Â³Ã€Ã‡ Ã‡ÃÂ¶Ã´Ã€ÃŒÂ¾ÃºÂ´Ã™. Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» Â³Â·ÃƒÃ¡Â´Ã™. 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			}
			else {
				return FALSE;
			}
		}
		return TRUE;
	}

	return FALSE;
}

/* Â¹Â®ÃÂ¦Ã€Ã‡ Â¹Â«Ã‡Ã‘Â·Ã§Ã‡Ã 
  
BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 register int i;
 int iRemainPoint, iTotalPoints, iWeaponIndex, iDownSkillSSN, iDownPoint;
 short sDownSkillIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - DEF_MAXSKILLPOINTS;

	if (iRemainPoint > 0) {
		// Â½ÂºÃ…Â³Ã€Ã‡ Ã†Ã·Ã€ÃÃ†Â®Â°Â¡ ÃƒÃŠÂ°ÃºÂµÃ‡Â¾ÃºÂ´Ã™. ÃƒÃŠÂ°ÃºÂµÃˆ Ã†Ã·Ã€ÃÃ†Â® Â¸Â¸Ã…Â­ Â·Ã§Ã‡ÃÂ¸Â¦ ÂµÂ¹Â¸Ã§ SSNÃ€ÃŒ Â°Â¡Ã€Ã¥ Â³Â·Ã€Âº Â½ÂºÃ…Â³Ã€Â» Â³Â»Â¸Â°Â´Ã™.	
		while (iRemainPoint > 0) {
			sDownSkillIndex = -1; // v1.4
			if (m_pClientList[iClientH]->m_iDownSkillIndex != -1) { 
				// ÃÃ¶ÃÂ¤ÂµÃˆ Â½ÂºÃ…Â³Ã€ÃŒ Ã€Ã–Â´Ã™. 
				// Â½ÂºÃ…Â³Ã€ÃŒ 20 Ã€ÃŒÃ‡ÃÃ€Ã‡ Â»Ã³Ã…Ã‚Â¶Ã³Â¸Ã© Â±Ã—Â´Ã«Â·Ã 0Ã€Â¸Â·Ã Â¶Â³Â¾Ã® Â¶ÃŸÂ¸Â°Â´Ã™.
				if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 0) {
					sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
				}
				else {
					// ÃÃ¶ÃÂ¤ÂµÃˆ Â½ÂºÃ…Â³Ã€ÃŒ 0Ã€ÃŒÂ´Ã™. Â´Ã™Â¸Â¥ Â½ÂºÃ…Â³Ã€Â» Â°Ã‹Â»Ã¶Ã‡Ã‘Â´Ã™.
					iDownSkillSSN = 99999999;
					for (i = 0; i < DEF_MAXSKILLTYPE; i++)
					if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 0) && (i != iSkill) && 
						(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
						
						iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
						sDownSkillIndex = i;
					}
				}
			} 
			else {
				// ÃÃ¶ÃÂ¤ÂµÃˆ Â½ÂºÃ…Â³Ã€ÃŒ Â¾Ã¸Â´Ã™. Â³Â»Â¸Â± Â½ÂºÃ…Â³Ã€Â» Â°Ã‹Â»Ã¶Ã‡Ã‘Â´Ã™.
				iDownSkillSSN = 99999999;
				for (i = 0; i < DEF_MAXSKILLTYPE; i++)
				if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 0) && (i != iSkill) && 
					(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
					
					iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
					sDownSkillIndex = i;
				}
			}
			
			// Ã‡Ã¶Ã€Ã§ 1ÂºÂ¸Â´Ã™ Ã…Â« Â½ÂºÃ…Â³ ÃÃŸÂ¿Â¡Â¼Â­ Â°Â¡Ã€Ã¥ Ã€Ã›Ã€Âº SSNÃ€Â» Â°Â®Â´Ã‚ Â½ÂºÃ…Â³Ã€Âº sDownSkillIndex 
			if (sDownSkillIndex != -1) {
				
				if (m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] <= 20) // v1.4
				 	 iDownPoint = m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex];
				else iDownPoint = 1;

				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= iDownPoint; // v1.4
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex]+1] - 1;
				iRemainPoint -= iDownPoint; // v1.4
				
				// Â¸Â¸Â¾Ã  Â³Â·Â¾Ã†ÃÃ¸ Â½ÂºÃ…Â³Ã€ÃŒ Ã‡Ã¶Ã€Ã§ Â»Ã§Â¿Ã«ÃÃŸÃ€Ã Â¹Â«Â±Ã¢Â¿Ã Â°Ã¼Â·ÃƒÃ€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» Â³Â·ÃƒÃŸÂ¾Ã®Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
					// Â¾Ã§Â¼Ã•Â¹Â«Â±Ã¢Â°Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã™. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// ÃˆÂ°Â·Ã¹Ã€Ã‡ Â»Ã§Â¿Ã«Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Â½ÂºÃ…Â³Ã€Ã‡ Ã‡ÃÂ¶Ã´Ã€ÃŒÂ¾ÃºÂ´Ã™. Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» Â³Â·ÃƒÃ¡Â´Ã™. 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
					// Â¹Â«Â±Ã¢Â°Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã™. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// Â°Ã‹Ã€ÃŒÂ³Âª MaceÂ·Ã¹Ã€Ã‡ Â»Ã§Â¿Ã«Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Â½ÂºÃ…Â³Ã€Ã‡ Ã‡ÃÂ¶Ã´Ã€ÃŒÂ¾ÃºÂ´Ã™. Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» Â³Â·ÃƒÃ¡Â´Ã™. 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				// Â½ÂºÃ…Â³Ã€ÃŒ Â³Â·Â¾Ã†ÃÂ³Ã€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			}
			else {
				// Â³Â·ÃƒÃŸÂ¾Ã®Â¾ÃŸ Ã‡Ã’ Â½ÂºÃ…Â³Ã€Â» ÃƒÂ£ÃÃ¶ Â¸Ã¸Ã‡ÃŸÂ´Ã™. Ã€ÃŒÂ·Â³ Â¾ÃˆÂµÃ‡Â´Ã‚ÂµÂ¥ 
				return FALSE;
			}
		}
		return TRUE;
	}

	return FALSE;
}

*/

/*
BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 register int i, j;
 int iRemainPoint, iTotalPoints, iWeaponIndex;
 short sDownSkillIndex, sDownSkillLevel;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - DEF_MAXSKILLPOINTS;

	if (iRemainPoint > 0) {
		// Â½ÂºÃ…Â³Ã€Ã‡ Ã†Ã·Ã€ÃÃ†Â®Â°Â¡ ÃƒÃŠÂ°ÃºÂµÃ‡Â¾ÃºÂ´Ã™. ÃƒÃŠÂ°ÃºÂµÃˆ Ã†Ã·Ã€ÃÃ†Â® Â¸Â¸Ã…Â­ Â·Ã§Ã‡ÃÂ¸Â¦ ÂµÂ¹Â¸Ã§ SSNÃ€ÃŒ Â°Â¡Ã€Ã¥ Â³Â·Ã€Âº Â½ÂºÃ…Â³Ã€Â» Â³Â»Â¸Â°Â´Ã™.	
		while (iRemainPoint != 0) {
			
			sDownSkillIndex = -1;
			sDownSkillLevel = 100;
			for (i = 0; i < DEF_MAXSKILLTYPE; i++)
			if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 1) && (i != iSkill) && 
				(m_pClientList[iClientH]->m_cSkillMastery[i] < sDownSkillLevel)) {
			
				sDownSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[i];
				sDownSkillIndex = i;
			}
			// Ã‡Ã¶Ã€Ã§ Â½ÂºÃ…Â³ Â¼Ã¶ÃÃ˜Â¿Â¡Â¼Â­ 0ÂºÂ¸Â´Ã™ Ã…Â©Â°Ã­ Â°Â¡Ã€Ã¥ Ã€Ã›Ã€Âº Â½ÂºÃ…Â³Ã€Âº sDownSkillIndex 
			
			if (sDownSkillIndex != -1) {
				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = 0;
				iRemainPoint--;
				
				// Â¸Â¸Â¾Ã  Â³Â·Â¾Ã†ÃÃ¸ Â½ÂºÃ…Â³Ã€ÃŒ Ã‡Ã¶Ã€Ã§ Â»Ã§Â¿Ã«ÃÃŸÃ€Ã Â¹Â«Â±Ã¢Â¿Ã Â°Ã¼Â·ÃƒÃ€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» Â³Â·ÃƒÃŸÂ¾Ã®Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
					// Â¾Ã§Â¼Ã•Â¹Â«Â±Ã¢Â°Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã™. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// ÃˆÂ°Â·Ã¹Ã€Ã‡ Â»Ã§Â¿Ã«Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Â½ÂºÃ…Â³Ã€Ã‡ Ã‡ÃÂ¶Ã´Ã€ÃŒÂ¾ÃºÂ´Ã™. Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» Â³Â·ÃƒÃ¡Â´Ã™. 
						m_pClientList[iClientH]->m_iHitRatio--;
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
					// Â¹Â«Â±Ã¢Â°Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã™. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// Â°Ã‹Ã€ÃŒÂ³Âª MaceÂ·Ã¹Ã€Ã‡ Â»Ã§Â¿Ã«Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Â½ÂºÃ…Â³Ã€Ã‡ Ã‡ÃÂ¶Ã´Ã€ÃŒÂ¾ÃºÂ´Ã™. Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» Â³Â·ÃƒÃ¡Â´Ã™. 
						m_pClientList[iClientH]->m_iHitRatio--;
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				// Â½ÂºÃ…Â³Ã€ÃŒ Â³Â·Â¾Ã†ÃÂ³Ã€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			}
			else {
				// Â³Â·ÃƒÃŸÂ¾Ã®Â¾ÃŸ Ã‡Ã’ Â½ÂºÃ…Â³Ã€Â» ÃƒÂ£ÃÃ¶ Â¸Ã¸Ã‡ÃŸÂ´Ã™.
				return FALSE;
			}
		}
		return TRUE;
	}

	return FALSE;
}
*/

/*
BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 register int i, j;
 int iTotalPoints, iWeaponIndex;
 short sDownSkillIndex, sComSSN;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	if (iTotalPoints > DEF_MAXSKILLPOINTS) {
		// Â´Ã™Â¸Â¥ Â½ÂºÃ…Â³Ã€Ã‡ Ã†Ã·Ã€ÃÃ†Â®Â¸Â¦ DEF_MAXSKILLPOINTSÂ¼Ã¶ÃÃ˜Ã€Â¸Â·Ã Â³Â»Â·ÃÂ¾ÃŸ Ã‡Ã‘Â´Ã™. SkillÃ€ÃŒ 1 Ã€ÃŒÂ»Ã³Ã€ÃŒÂ°Ã­ SSNÃ€ÃŒ Â°Â¡Ã€Ã¥ Ã€Ã›Ã€Âº SkillÃ€Â» 1Â³Â»Â¸Â°Â´Ã™.
		
		sDownSkillIndex = -1;
		sComSSN = 10000;
		for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 1) && (i != iSkill) && (m_pClientList[iClientH]->m_iSkillSSN[i] < sComSSN)) {
			sComSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
			sDownSkillIndex = i;
		}
		
		if (sDownSkillIndex != -1) {
			m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= (iTotalPoints - DEF_MAXSKILLPOINTS);
			m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = 0;

			// Â¸Â¸Â¾Ã  Â³Â·Â¾Ã†ÃÃ¸ Â½ÂºÃ…Â³Ã€ÃŒ Ã‡Ã¶Ã€Ã§ Â»Ã§Â¿Ã«ÃÃŸÃ€Ã Â¹Â«Â±Ã¢Â¿Ã Â°Ã¼Â·ÃƒÃ€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» Â³Â·ÃƒÃŸÂ¾Ã®Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// Â¾Ã§Â¼Ã•Â¹Â«Â±Ã¢Â°Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã™. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
					// ÃˆÂ°Â·Ã¹Ã€Ã‡ Â»Ã§Â¿Ã«Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Â½ÂºÃ…Â³Ã€Ã‡ Ã‡ÃÂ¶Ã´Ã€ÃŒÂ¾ÃºÂ´Ã™. Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» Â³Â·ÃƒÃ¡Â´Ã™. 
					m_pClientList[iClientH]->m_iHitRatio -= (iTotalPoints - DEF_MAXSKILLPOINTS);
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// Â¹Â«Â±Ã¢Â°Â¡ Ã€Ã¥Ã‚Ã¸ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã™. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
					// Â°Ã‹Ã€ÃŒÂ³Âª MaceÂ·Ã¹Ã€Ã‡ Â»Ã§Â¿Ã«Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Â½ÂºÃ…Â³Ã€Ã‡ Ã‡ÃÂ¶Ã´Ã€ÃŒÂ¾ÃºÂ´Ã™. Â¸Ã­ÃÃŸÂ·Ã¼Ã€Â» Â³Â·ÃƒÃ¡Â´Ã™. 
					m_pClientList[iClientH]->m_iHitRatio -= (iTotalPoints - DEF_MAXSKILLPOINTS);
				}
			}
	
			// Â½ÂºÃ…Â³Ã€ÃŒ Â³Â·Â¾Ã†ÃÂ³Ã€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			return TRUE;
		}
		
	}

	return FALSE;
}
*/


void CGame::OnKeyDown(WPARAM wParam, LPARAM lParam)
{
	switch (wParam) {
	case VK_F1:
		m_bF1pressed = TRUE;
		break;
	case VK_F4:
		m_bF4pressed = TRUE;
		break;
	case VK_F5:
		m_bF5pressed = TRUE;
		break;
	case VK_F12:
		m_bF12pressed = TRUE;
		break;
	}
}

void CGame::OnKeyUp(WPARAM wParam, LPARAM lParam)
{
 int i;
 
	switch (wParam) {
	case VK_F2:
				
		/*
		char cTxt[120];
		for (i = 1; i <= 200; i++){
			wsprintf(cTxt, "Level %d:  Exp %d", i, iGetLevelExp(i));
			PutLogFileList(cTxt);
		}
		
		// Ã…Ã—Â½ÂºÃ†Â® 
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 3;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// Â°Ã”Ã€Ã“ Â¼Â­Â¹Ã¶ Â¼Ã‹Â´Ã™Â¿Ã®Ã€ÃŒ Â½ÃƒÃ€Ã›ÂµÃ‡Â¸Ã© Â´ÃµÃ€ÃŒÂ»Ã³Ã€Ã‡ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® ÃÂ¢Â¼Ã“Ã€ÃŒ Â°Ã…ÂºÃÂµÃˆÂ´Ã™. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost Emulation)!!!");
		}
		*/
		break;
	
	case VK_F1:
		m_bF1pressed = FALSE;
		break;
	case VK_F4:
		m_bF4pressed = FALSE;
		break;
	case VK_F5:
		m_bF5pressed = FALSE;
		break;
	case VK_F12:
		m_bF12pressed = FALSE;
		break;
	
	case VK_F6:
		if (m_bF1pressed == TRUE) {
			PutLogList("(!) Send server shutdown announcement1...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
			}
		}
		break;

	case VK_F7:
		if (m_bF1pressed == TRUE) {
			PutLogList("(!) Send server shutdown announcement2...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
			}
		}
		break;

	case VK_F9:
		if ((m_bF1pressed == TRUE)) {
			PutLogList("(!!!) Resume Crusade Mode...");
			LocalStartCrusadeMode(NULL);
		}
		break;

	case VK_F11:
		if ((m_bF1pressed == TRUE)) {
			PutLogList("(!!!) ManualEndCrusadeMode: side 0");
			ManualEndCrusadeMode(0);
		}
		break;

	#define VK_1 0x31
	case VK_1:
		if ((m_bF1pressed == TRUE)) {
			GlobalUpdateConfigs(1);
		}
		break;

	#define VK_2 0x32
	case VK_2:
		if ((m_bF1pressed == TRUE)) {
			GlobalUpdateConfigs(2);
		}
		break;

	#define VK_3 0x33
	case VK_3:
		if ((m_bF1pressed == TRUE)) {
			GlobalUpdateConfigs(3);
		}
		break;

	#define VK_4 0x34
	case VK_4:
		if ((m_bF1pressed == TRUE)) {
			GlobalUpdateConfigs(1);
		}
		break;

	/*#define VK_A 0x41 // a key 
	case VK_A:
		if ((m_bF1pressed == TRUE)) {
			GlobalStartApocalypseMode();
		}
		break;*/
		
	/*#define VK_H 0x49 // H key 
	case VK_H:
		if ((m_bF1pressed == TRUE)) {
			GlobalStartHeldenianMode();
		}
		break;*/

		//Crusade Testcode
	case VK_HOME:
		if ((m_bF1pressed == TRUE)) {
			GlobalStartCrusadeMode();
		}
		break;

	case VK_INSERT:
		_GrandMagicLaunchMsgSend(1, 1);
		MeteorStrikeMsgHandler(1);
		break;

	case VK_DELETE:
		_GrandMagicLaunchMsgSend(1, 2);
		MeteorStrikeMsgHandler(2);
		break;
	}
}

int CGame::iGetFollowerNumber(short sOwnerH, char cOwnerType)
{
 register int i, iTotal;

	iTotal = 0;

	for (i = 1; i < DEF_MAXNPCS; i++) 
	if ( (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) ) {

		if ((m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) && (m_pNpcList[i]->m_cFollowOwnerType == cOwnerType))
			iTotal++;
	}

	return iTotal;
}

/*********************************************************************************************************************
**  BOOL CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, DWORD dwLastTime, int iTargetH,				**
**									   char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3) **
**  description			:: initiates the delayed event process														**
**  last updated		:: November 20, 2004; 9:30 PM; Hypnotoad													**
**	return value		:: BOOL																						**
**********************************************************************************************************************/
BOOL CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, DWORD dwLastTime, int iTargetH, char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3)
{
 register int i;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if (m_pDelayEventList[i] == NULL) {
		m_pDelayEventList[i] = new class CDelayEvent;
		m_pDelayEventList[i]->m_iDelayType	= iDelayType;
		m_pDelayEventList[i]->m_iEffectType = iEffectType;
		m_pDelayEventList[i]->m_cMapIndex	= cMapIndex;
		m_pDelayEventList[i]->m_dX			= dX;
		m_pDelayEventList[i]->m_dY			= dY;
		m_pDelayEventList[i]->m_iTargetH    = iTargetH;
		m_pDelayEventList[i]->m_cTargetType = cTargetType;
		m_pDelayEventList[i]->m_iV1         = iV1;
		m_pDelayEventList[i]->m_iV2         = iV2;
		m_pDelayEventList[i]->m_iV3         = iV3; 
		m_pDelayEventList[i]->m_dwTriggerTime = dwLastTime;
		return TRUE;
	}
	return FALSE;
}

void CGame::DelayEventProcessor()
{
 register int i, iSkillNum, iResult;
 DWORD dwTime = timeGetTime();
 int iTemp;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if ((m_pDelayEventList[i] != NULL) && (m_pDelayEventList[i]->m_dwTriggerTime < dwTime)) {

		// Ã€ÃŒÂºÂ¥Ã†Â®Â°Â¡ ÂµÂ¿Ã€Ã›Ã‡Ã’ Â½ÃƒÂ°Â£Ã€ÃŒ ÂµÃ†Â´Ã™. ÂµÂ¿Ã€Ã›ÃˆÃ„ Â»Ã¨ÃÂ¦ÂµÃˆÂ´Ã™.
		switch (m_pDelayEventList[i]->m_iDelayType) {

		case DEF_DELAYEVENTTYPE_ANCIENT_TABLET:
			if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x400000) != 0) {
				iTemp = 1;
			}
			else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x800000) != 0) {
				iTemp = 3;
			}
			else if ((m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iStatus & 0x10000) != 0) {
				iTemp = 4;
			}

			SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SLATE_STATUS, iTemp, NULL, NULL, NULL);
			SetSlateFlag(m_pDelayEventList[i]->m_iTargetH, iTemp, FALSE);
			break;

		case DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT:
			CalcMeteorStrikeEffectHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;

		case DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE:
			DoMeteorStrikeDamageHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;
		
		case DEF_DELAYEVENTTYPE_METEORSTRIKE:
			MeteorStrikeHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;
		
		case DEF_DELAYEVENTTYPE_USEITEM_SKILL:
			// Â¾Ã†Ã€ÃŒÃ…Ã› Â»Ã§Â¿Ã«Â¿Â¡ ÂµÃ»Â¸Â¥ Â°Ã¡Â°Ãº Â°Ã¨Â»Ãª, Ã…Ã«ÂºÂ¸ 
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				iSkillNum = m_pDelayEventList[i]->m_iEffectType;
				
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH] == NULL ) break;
				// Â±Ã¢Â¼Ãº Â»Ã§Â¿Ã«Ã€ÃŒ Â¹Â«ÃˆÂ¿ÃˆÂ­ ÂµÃ‡Â¾ÃºÂ´Ã™Â¸Ã© Â¹Â«Â½Ãƒ. 
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] == FALSE ) break;
				// Â±Ã¢Â¼Ãº Â»Ã§Â¿Ã« Â½ÃƒÂ°Â£ IDÂ°Â¡ Â´ÃÂ¶Ã³ÂµÂµ Â¹Â«Â½Ãƒ v1.12
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] != m_pDelayEventList[i]->m_iV2) break;
				
				// Â±Ã¢Â¼Ãº Â»Ã§Â¿Ã« Â»Ã³Ã…Ã‚ Ã‡Ã˜ÃÂ¦ 
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] = FALSE;
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] = NULL;
				
				// Ã€ÃŒÃÂ¦ SkillÃ€Ã‡ ÃˆÂ¿Â°ÃºÂ¿Â¡ ÂµÃ»Â¸Â¥ Â°Ã¨Â»ÃªÃ€Â» Ã‡Ã‘Â´Ã™. 
				iResult = iCalculateUseSkillItemEffect(m_pDelayEventList[i]->m_iTargetH, m_pDelayEventList[i]->m_cTargetType,
				 	                                   m_pDelayEventList[i]->m_iV1, iSkillNum, m_pDelayEventList[i]->m_cMapIndex, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY);

				// Â±Ã¢Â¼Ãº Â»Ã§Â¿Ã«Ã€ÃŒ ÃÃŸÃÃ¶ ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SKILLUSINGEND, iResult, NULL, NULL, NULL);
				break;
			}
			break;
		
		case DEF_DELAYEVENTTYPE_DAMAGEOBJECT:
			break;

		case DEF_DELAYEVENTTYPE_MAGICRELEASE: 
			// Removes the aura after time
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[ m_pDelayEventList[i]->m_iTargetH ] == NULL) break;
				
				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_MAGICEFFECTOFF, 
					          m_pDelayEventList[i]->m_iEffectType, m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ], NULL, NULL);
				
				m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = NULL;
				
				// Inbitition casting 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INHIBITION)
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bInhibition = FALSE;

				// Invisibility È¿°ú ÇØÁ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
					SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);

				// Berserk È¿°ú ÇØÁ¦
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
					SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);

				// Confusion
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_CONFUSE)
					switch(m_pDelayEventList[i]->m_iV1){
						case 3: SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;
						case 4: SetIllusionMovementFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE); break;
					}	

				// Protection Magic
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_PROTECT) {
					switch(m_pDelayEventList[i]->m_iV1){
						case 1:
							SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
							break;
						case 2:
						case 5:
							SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
							break;
						case 3:
						case 4:
							SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
							break;
					}
				}

				
				// polymorph È¿°ú ÇØÁ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
					SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}

				// Ice È¿°ú ÇØÁ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
					SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
				break;
			
			/*case DEF_DELAYEVENTTYPE_MAGICRELEASE: 
			// Removes the aura after time
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[ m_pDelayEventList[i]->m_iTargetH ] == NULL) break;
				
				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_MAGICEFFECTOFF, 
					          m_pDelayEventList[i]->m_iEffectType, m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ], NULL, NULL);
				
				m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = NULL;
				
				// Inhibition Casting
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INHIBITION)
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bInhibition = FALSE;

				// Invisibility ÃˆÂ¿Â°Ãº Ã‡Ã˜ÃÂ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
					SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);

				// Berserk ÃˆÂ¿Â°Ãº Ã‡Ã˜ÃÂ¦
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
					SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);

				// Illusion
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_CONFUSE)
					SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);

				// Protection Magic
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_PROTECT) {
					switch(m_pDelayEventList[i]->m_iV1){
						case 1:
							SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
							break;
						case 2:
						case 5:
							SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
							break;
						case 3:
						case 4:
							SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
							break;
					}
				}

				// polymorph ÃˆÂ¿Â°Ãº Ã‡Ã˜ÃÂ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
					SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}

				// Ice ÃˆÂ¿Â°Ãº Ã‡Ã˜ÃÂ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
					SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
				break;*/
			
			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ] == NULL) break;
				
				m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = NULL;
				
				// Invisibility ÃˆÂ¿Â°Ãº Ã‡Ã˜ÃÂ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
					SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

				// Berserk ÃˆÂ¿Â°Ãº Ã‡Ã˜ÃÂ¦
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
					SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

				// polymorph ÃˆÂ¿Â°Ãº Ã‡Ã˜ÃÂ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
					m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
					SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}

				// Ice ÃˆÂ¿Â°Ãº Ã‡Ã˜ÃÂ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
					SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
				
				// Illusion
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_CONFUSE)
					SetIllusionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

				// Protection Magic
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_PROTECT) {
					switch(m_pDelayEventList[i]->m_iV1){
						case 1:
							SetProtectionFromArrowFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
							break;
						case 2:
						case 5:
							SetMagicProtectionFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
							break;
						case 3:
						case 4:
							SetDefenseShieldFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
							break;
					}
				}
				//	if (m_pDelayEventList[i]->m_iEffectType == /*notcoded*/)

				break;
			}
			break;
		}
		
		delete m_pDelayEventList[i];
		m_pDelayEventList[i] = NULL;
	}
}
BOOL CGame::bRemoveFromDelayEventList(int iH, char cType, int iEffectType)
{
 register int i;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if (m_pDelayEventList[i] != NULL) {
		
		if (iEffectType == NULL) {
			// Effect ÃÂ¾Â·Ã¹Â¿Â¡ Â»Ã³Â°Ã¼Â¾Ã¸Ã€ÃŒ Â¸Ã°ÂµÃ Â»Ã¨ÃÂ¦ 	
			if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) ) {
				delete m_pDelayEventList[i];
				m_pDelayEventList[i] = NULL;
			}
		}
		else {
			// Ã‡Ã˜Â´Ã§ EffectÂ¸Â¸ Â»Ã¨ÃÂ¦.
			if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) &&
				 (m_pDelayEventList[i]->m_iEffectType == iEffectType) ) {
				delete m_pDelayEventList[i];
				m_pDelayEventList[i] = NULL;
			}
		}
	}
	
	return TRUE;
}

void CGame::SendObjectMotionRejectMsg(int iClientH)
{
 char  * cp, cData[30];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;

	m_pClientList[iClientH]->m_bIsMoveBlocked = TRUE; // v2.171
	
	// Ã€ÃŒÂµÂ¿Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
 	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_REJECT;
	
	cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX; 
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY; 
	cp += 2;
	
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	return;
}

int CGame::_iGetTotalClients()
{
 register int i, iTotal;

	iTotal = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) iTotal++;

	return iTotal;
}

void CGame::DynamicObjectEffectProcessor()
{
 register int i, ix, iy, iIndex;
 short sOwnerH, iDamage, sType;
 char  cOwnerType;
 DWORD dwTime = timeGetTime(), dwRegisterTime;
	
	// 
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != NULL) {
		switch (m_pDynamicObjectList[i]->m_sType) {

		case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:
			// Ã†Ã·Ã€ÃŒÃÃ° Ã…Â¬Â¶Ã³Â¿Ã¬ÂµÃ¥
			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Poison DamageÂ¸Â¦ Ã€Ã”Â´Ã‚Â´Ã™.
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v1.41 ÃÃŸÂ¸Â³Ã€ÃŒÂ°Ã­ Ã€Ã¼Ã…ÃµÂ¸Ã°ÂµÃ¥Â°Â¡ Â¾Ã†Â´ÃÂ¸Ã© Ã‡Ã‡Ã‡Ã˜Â¸Â¦ Ã€Ã”ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						// Ã€ÃŒÂ·Â± Â½Ã„Ã€Â¸Â·Ã Â´Ã«Â¹ÃŒÃÃ¶Ã€Ã‡ Ã…Â©Â±Ã¢Â¸Â¦ Â°Ã¡ÃÂ¤
						if (m_pDynamicObjectList[i]->m_iV1 < 20)
							 iDamage = iDice(1,6);
						else iDamage = iDice(1,8);

						// New 17/05/2004 Changed
						if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â»Ã§Â¸ÃÃ‡ÃŸÂ´Ã™.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// Â¹ÃÃ€Âº Â´Ã«Â¹ÃŒÃÃ¶Â¸Â¦ Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™. <- HPÂ¸Â¦ Â±Ã—Â´Ã«Â·Ã Â¾Ã‹Â¸Â°Â´Ã™.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
									// Â¸Â¶ÂºÃ± Â»Ã³Ã…Ã‚Â°Â¡ Ã‡Â®Â¸Â°Â´Ã™.	
									// 1: Hold-Person 
									// 2: Paralize
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}

							// v1.42 Poison ÃˆÂ¿Â°Ãº
							if ( (bCheckResistingMagicSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, 100) == FALSE) &&
								 (m_pClientList[sOwnerH]->m_bIsPoisoned == FALSE) ) {
								
								m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
								m_pClientList[sOwnerH]->m_iPoisonLevel = m_pDynamicObjectList[i]->m_iV1;
								m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
								// ÃÃŸÂµÂ¶ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
								SetPoisonFlag(sOwnerH, cOwnerType, TRUE);// poison aura appears from dynamic objects
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sOwnerH]->m_iPoisonLevel, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						// Â¸Ã³Â½ÂºÃ…ÃÃ€Ã‡ ÃÃŸÂµÂ¶ÃˆÂ¿Â°ÃºÂ´Ã‚ Â¾Ã†ÃÃ· Â±Â¸Ã‡Ã¶ Â¾ÃˆÂµÃŠ
						if (m_pNpcList[sOwnerH] == NULL) break;

						// Ã€ÃŒÂ·Â± Â½Ã„Ã€Â¸Â·Ã Â´Ã«Â¹ÃŒÃÃ¶Ã€Ã‡ Ã…Â©Â±Ã¢Â¸Â¦ Â°Ã¡ÃÂ¤
						if (m_pDynamicObjectList[i]->m_iV1 < 20)
							 iDamage = iDice(1,6);
						else iDamage = iDice(1,8);

						// Ã€Ã¼Ã€Ã¯Â¿Ã« Â±Â¸ÃÂ¶Â¹Â°ÃÃŸ Â±Ã—Â·Â£ÂµÃ¥ Â¸Ã…ÃÃ· ÃÂ¦Â³Ã—Â·Â¹Ã€ÃŒÃ…Ã, Â¿Â¡Â³ÃŠÃÃ¶ Â½Ã‡ÂµÃ¥ ÃÂ¦Â³Ã—Â·Â¹Ã€ÃŒÃ…ÃÂ´Ã‚ Ã‡ÃŠÂµÃ¥Â·Ã¹ Â¸Â¶Â¹Ã½Â¿Â¡ Â´Ã«Â¹ÃŒÃÃ¶Â¸Â¦ Ã€Ã”ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40: // ESG
						case 41: // GMG
						case 67: // McGaffin
						case 68: // Perry
						case 69: // Devlin
							iDamage = 0;
							break;
						}
						
						// HPÂ¿Â¡Â¼Â­ Â»Â«Â´Ã™. Action LimitÂ¿Â¡ ÂµÃ»Â¶Ã³ ÃƒÂ³Â¸Â®Ã‡Ã‘Â´Ã™.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // Ã€ÃÂ¹Ã
						case 3: // Â´ÃµÂ¹ÃŒÂ·Ã¹
						case 5: // Â°Ã‡ÃƒÃ Â¹Â° 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPCÂ°Â¡ Â»Ã§Â¸ÃÃ‡ÃŸÂ´Ã™.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 ÃÃŸÂµÂ¶Â±Â¸Â¸Â§Â¿Â¡ ÃÃ—Ã€Â¸Â¸Ã© Â¸Â¶ÃÃ¶Â¸Â· Â´Ã«Â¹ÃŒÃÃ¶Â°Â¡ 0. Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â½Â±Â°Ã” Â±Â¸Ã‡ÃÃÃ¶ Â¸Ã¸Ã‡ÃÂ°Ã” Ã‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã”.
						}
						else {
							// DamageÂ¸Â¦ Ã€Ã”Ã€Âº ÃƒÃ¦Â°ÃÃ€Â¸Â·Ã Ã€ÃÃ‡Ã‘ ÃÃ¶Â¿Â¬ÃˆÂ¿Â°Ãº.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã¸ Â»Ã³Ã…Ã‚Â¶Ã³Â¸Ã© Ã‡Â®Â¸Â°Â´Ã™. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPCÂ¸Â¦ ÂµÂµÂ¸ÃÂ°Â¡Â´Ã‚ Â¸Ã°ÂµÃ¥Â·Ã Ã€Ã¼ÃˆÂ¯Â½ÃƒÃ…Â²Â´Ã™.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
						}
						break;
					}
				}
			}
			break;
						
		case DEF_DYNAMICOBJECT_ICESTORM:
			for (ix = m_pDynamicObjectList[i]->m_sX -2; ix <= m_pDynamicObjectList[i]->m_sX+2; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -2; iy <= m_pDynamicObjectList[i]->m_sY+2; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;

						iDamage = iDice(3,3) + 5;

						if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
						m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â»Ã§Â¸ÃÃ‡ÃŸÂ´Ã™.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {

									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {

									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}

							if ( (bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, m_pDynamicObjectList[i]->m_iV1) == FALSE) &&
								 (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) {
								
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
									                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						
						iDamage = iDice(3,3) + 5;

						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40: // ESG
						case 41: // GMG
						case 67: // McGaffin
						case 68: // Perry
						case 69: // Devlin
							iDamage = 0;
							break;
						}
						
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0:
						case 3:
						case 5:
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPCÂ°Â¡ Â»Ã§Â¸ÃÃ‡ÃŸÂ´Ã™.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 Ã…Â¸Â¼Â­ ÃÃ—Ã€Â¸Â¸Ã© Â¸Â¶ÃÃ¶Â¸Â· Â´Ã«Â¹ÃŒÃÃ¶Â°Â¡ 0. Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â½Â±Â°Ã” Â±Â¸Ã‡ÃÃÃ¶ Â¸Ã¸Ã‡ÃÂ°Ã” Ã‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã”.
						}
						else {
							// DamageÂ¸Â¦ Ã€Ã”Ã€Âº ÃƒÃ¦Â°ÃÃ€Â¸Â·Ã Ã€ÃÃ‡Ã‘ ÃÃ¶Â¿Â¬ÃˆÂ¿Â°Ãº.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã¸ Â»Ã³Ã…Ã‚Â¶Ã³Â¸Ã© Ã‡Â®Â¸Â°Â´Ã™. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPCÂ¸Â¦ ÂµÂµÂ¸ÃÂ°Â¡Â´Ã‚ Â¸Ã°ÂµÃ¥Â·Ã Ã€Ã¼ÃˆÂ¯Â½ÃƒÃ…Â²Â´Ã™.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);

							// v1.42 Ice ÃˆÂ¿Â°Ãº
							if ( (bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_NPC, m_pDynamicObjectList[i]->m_iV1) == FALSE) &&
								 (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) {
																
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// ÃˆÂ¿Â°ÃºÂ°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‰ Â¶Â§ Â¹ÃŸÂ»Ã½Ã‡Ã’ ÂµÃ´Â·Â¹Ã€ÃŒ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
								                    sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
					   	break;
					}
				}

				// ÃÃ—Ã€ÂºÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã„Â³Â¸Â¯Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã©
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					iDamage = iDice(3,2);
					m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) {
						// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â»Ã§Â¸ÃÃ‡ÃŸÂ´Ã™.
						ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  				}
					else {
						if (iDamage > 0) {
							// Â¹ÃÃ€Âº Â´Ã«Â¹ÃŒÃÃ¶Â¸Â¦ Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™. <- HPÂ¸Â¦ Â±Ã—Â´Ã«Â·Ã Â¾Ã‹Â¸Â°Â´Ã™.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						}
					}
				}

				// Â±Ã™ÃƒÂ³Â¿Â¡ Fire ObjectÂ°Â¡ Ã€Ã–Â´Ã™Â¸Ã© Â¼Ã¶Â¸Ã­Ã€Â» ÃÃ™Ã€ÃÂ´Ã™.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if (((sType == DEF_DYNAMICOBJECT_FIRE) || (sType == DEF_DYNAMICOBJECT_FIRE3)) && (m_pDynamicObjectList[iIndex] != NULL)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		
		case DEF_DYNAMICOBJECT_FIRE3:
		case DEF_DYNAMICOBJECT_FIRE:
			// Fire-WallÂ·Ã¹Ã€Ã‡ Ã…Â¸Â´Ã‚ ÂºÃ’Â²Ã‰
			if (m_pDynamicObjectList[i]->m_iCount == 1) {
				// Â±Ã™ÃƒÂ³Â¿Â¡ Ã…Â¸Â´Ã‚ Â¹Â°Â°Ã‡Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© Â¹Ã¸ÃÃ¸Â´Ã™. 
				CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);
			}
			m_pDynamicObjectList[i]->m_iCount++;
			if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10; 


			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Fire DamageÂ¸Â¦ Ã€Ã”Â´Ã‚Â´Ã™.
					switch (cOwnerType) {
					
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v1.41 ÃÃŸÂ¸Â³Ã€ÃŒÂ°Ã­ Ã€Ã¼Ã…ÃµÂ¸Ã°ÂµÃ¥Â°Â¡ Â¾Ã†Â´ÃÂ¸Ã© Ã‡Ã‡Ã‡Ã˜Â¸Â¦ Ã€Ã”ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						iDamage = iDice(1,6);
						// New 17/05/2004
						if (m_pClientList[sOwnerH]->m_iAdminUserLevel == 0)
							m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â»Ã§Â¸ÃÃ‡ÃŸÂ´Ã™.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// Â¹ÃÃ€Âº Â´Ã«Â¹ÃŒÃÃ¶Â¸Â¦ Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™. <- HPÂ¸Â¦ Â±Ã—Â´Ã«Â·Ã Â¾Ã‹Â¸Â°Â´Ã™.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
									// Hold-Person ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã¸ Â»Ã³Ã…Ã‚Â¶Ã³Â¸Ã© Ã‡Â®Â¸Â°Â´Ã™. Fire FieldÂ·ÃÂ´Ã‚ Ã†ÃÂ·Â²Â¶Ã³Ã€ÃŒÃÃ® ÂµÃˆÂ°ÃÂµÂµ Ã‡Â®Â¸Â°Â´Ã™. 	
									// 1: Hold-Person 
									// 2: Paralize	
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						
						iDamage = iDice(1,6);

						// Ã€Ã¼Ã€Ã¯Â¿Ã« Â±Â¸ÃÂ¶Â¹Â°ÃÃŸ Â±Ã—Â·Â£ÂµÃ¥ Â¸Ã…ÃÃ· ÃÂ¦Â³Ã—Â·Â¹Ã€ÃŒÃ…Ã, Â¿Â¡Â³ÃŠÃÃ¶ Â½Ã‡ÂµÃ¥ ÃÂ¦Â³Ã—Â·Â¹Ã€ÃŒÃ…ÃÂ´Ã‚ Ã‡ÃŠÂµÃ¥Â·Ã¹ Â¸Â¶Â¹Ã½Â¿Â¡ Â´Ã«Â¹ÃŒÃÃ¶Â¸Â¦ Ã€Ã”ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40: // ESG
						case 41: // GMG
						case 67: // McGaffin
						case 68: // Perry
						case 69: // Devlin
							iDamage = 0;
							break;
						}
												
						// HPÂ¿Â¡Â¼Â­ Â»Â«Â´Ã™. Action LimitÂ¿Â¡ ÂµÃ»Â¶Ã³ ÃƒÂ³Â¸Â®Ã‡Ã‘Â´Ã™.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // Ã€ÃÂ¹Ã
						case 3: // Â´ÃµÂ¹ÃŒÂ·Ã¹
						case 5: // Â°Ã‡ÃƒÃ Â¹Â° 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPCÂ°Â¡ Â»Ã§Â¸ÃÃ‡ÃŸÂ´Ã™.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 Ã…Â¸Â¼Â­ ÃÃ—Ã€Â¸Â¸Ã© Â¸Â¶ÃÃ¶Â¸Â· Â´Ã«Â¹ÃŒÃÃ¶Â°Â¡ 0. Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â½Â±Â°Ã” Â±Â¸Ã‡ÃÃÃ¶ Â¸Ã¸Ã‡ÃÂ°Ã” Ã‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã”.
						}
						else {
							// DamageÂ¸Â¦ Ã€Ã”Ã€Âº ÃƒÃ¦Â°ÃÃ€Â¸Â·Ã Ã€ÃÃ‡Ã‘ ÃÃ¶Â¿Â¬ÃˆÂ¿Â°Ãº.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã¸ Â»Ã³Ã…Ã‚Â¶Ã³Â¸Ã© Ã‡Â®Â¸Â°Â´Ã™. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPCÂ¸Â¦ ÂµÂµÂ¸ÃÂ°Â¡Â´Ã‚ Â¸Ã°ÂµÃ¥Â·Ã Ã€Ã¼ÃˆÂ¯Â½ÃƒÃ…Â²Â´Ã™.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
						}
					   	break;
					}
				}

				// ÃÃ—Ã€ÂºÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã„Â³Â¸Â¯Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã©
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					iDamage = iDice(1,6);
					m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) {
						// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â»Ã§Â¸ÃÃ‡ÃŸÂ´Ã™.
						ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  				}
					else {
						if (iDamage > 0) {
							// Â¹ÃÃ€Âº Â´Ã«Â¹ÃŒÃÃ¶Â¸Â¦ Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™. <- HPÂ¸Â¦ Â±Ã—Â´Ã«Â·Ã Â¾Ã‹Â¸Â°Â´Ã™.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						}
					}
				}

				// Â±Ã™ÃƒÂ³Â¿Â¡ Ice ObjectÂ°Â¡ Ã€Ã–Â´Ã™Â¸Ã© Â¼Ã¶Â¸Ã­Ã€Â» ÃÃ™Ã€ÃÂ´Ã™.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if ((sType == DEF_DYNAMICOBJECT_ICESTORM) && (m_pDynamicObjectList[iIndex] != NULL)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		}
	}
}

char _tmp_cCorpseX[] = {  0,  1, 1, 1, 0, -1, -1, -1, 0, 0, 0, 0};
char _tmp_cCorpseY[] = { -1, -1, 0, 1, 1,  1,  0, -1, 0, 0, 0};

void CGame::ClearSkillUsingStatus(int iClientH)
{
 register int i;
 short tX, fX, tY, fY;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) {
		tX = m_pClientList[iClientH]->m_sX;
		tY = m_pClientList[iClientH]->m_sY;
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(tX, tY, NULL) == FALSE) {
			fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
			fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX, fY, NULL) == FALSE) {
				m_pClientList[iClientH]->m_cDir = iDice(1,8);
				fX = m_pClientList[iClientH]->m_sX + _tmp_cCorpseX[m_pClientList[iClientH]->m_cDir];
				fY = m_pClientList[iClientH]->m_sY + _tmp_cCorpseY[m_pClientList[iClientH]->m_cDir];
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(fX , fY, NULL) == FALSE) {
					return;
				}
			}
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DAMAGEMOVE, m_pClientList[iClientH]->m_cDir, NULL, NULL, NULL);
		}
	}
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		m_pClientList[iClientH]->m_bSkillUsingStatus[i] = FALSE;
		m_pClientList[iClientH]->m_iSkillUsingTimeID[i] = NULL;
	}
	
	if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) {
		if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHCANCELED, NULL, NULL, NULL, NULL);
	}

}

int CGame::iCalculateUseSkillItemEffect(int iOwnerH, char cOwnerType, char cOwnerSkill, int iSkillNum, char cMapIndex, int dX, int dY)
{
 class CItem * pItem;
 char  cItemName[21];
 short lX, lY;
 int   iResult, iFish;

	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iOwnerH] == NULL) return 0;
		if (m_pClientList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pClientList[iOwnerH]->m_sX;
		lY = m_pClientList[iOwnerH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iOwnerH] == NULL) return 0;
		if (m_pNpcList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pNpcList[iOwnerH]->m_sX;
		lY = m_pNpcList[iOwnerH]->m_sY;
		break;
	}

	// Â½ÂºÃ…Â³ Â»Ã§Â¿Ã« Â¿Â©ÂºÃ ÃÃ–Â»Ã§Ã€Â§Â¸Â¦ Â±Â¼Â¸Â°Â´Ã™. 
	if (cOwnerSkill == 0) return 0;
	
	// Â½ÂºÃ…Â³Ã€ÃŒ 100Ã€ÃŒÂ¶Ã³Â°Ã­ Ã‡Ã˜ÂµÂµ Â°Â¡Â²Ã» Â³Â¬Â½ÃƒÂ¸Â¦ Â½Ã‡Ã†ÃÃ‡ÃÂ°Ã” Ã‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã˜Â¼Â­ 1D105 
	iResult = iDice(1, 105);
	if (cOwnerSkill <= iResult)	return 0;  // Â½Ã‡Ã†ÃÂ´Ã™.

	// Â¶Â¥Â¿Â¡Â¼Â­Â´Ã‚ Â³Â¬Â½ÃƒÂ°Â¡ ÂºÃ’Â°Â¡Â´Ã‰ 
	if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0;

	// Â¼ÂºÂ°Ã¸Ã‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â½ÂºÃ…Â³ Ã„Â«Â¿Ã®Ã†Â®Â¸Â¦ Â¿ÃƒÂ¸Â°Â´Ã™.
	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(iOwnerH, iSkillNum, 1);

	switch (m_pSkillConfigList[iSkillNum]->m_sType) {
	case DEF_SKILLEFFECTTYPE_TAMING:
		// Â±Ã¦ÂµÃ©Ã€ÃŒÂ±Ã¢ Â±Ã¢Â¼Ãº: dX, dY ÂºÃÂ±Ã™Ã€Ã‡ Â¸Ã³Â½ÂºÃ…ÃÂ¸Â¦ Â±Ã¦ÂµÃ©Ã€ÃÂ´Ã™.
		_TamingHandler(iOwnerH, iSkillNum, cMapIndex, dX, dY);
		break;
	
	case DEF_SKILLEFFECTTYPE_GET: 
		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¾Ã²Â´Ã‚ Â±Ã¢Â¼ÃºÃ€ÃŒÂ¾ÃºÂ´Ã™. 
		ZeroMemory(cItemName, sizeof(cItemName));
		switch (m_pSkillConfigList[iSkillNum]->m_sValue1) {
		case 1:
			// Â±Â¤Â¹Â° 
			wsprintf(cItemName, "Meat");
			break;

		case 2:
			// Â¹Â°Â°Ã­Â±Ã¢ 
			// Â³Â¬Â½ÃƒÃ€Ã‡ Â°Ã¦Â¿Ã¬ Ã€Â§Ã„Â¡Â¿Ã Â½ÃƒÂ°Â£Â´Ã«Ã€Ã‡ Â¿ÂµÃ‡Ã¢Â¿Â¡ ÂµÃ»Â¶Ã³ Â¶Ã‡ Â¼ÂºÂ°Ã¸Â·Ã¼Ã€ÃŒ Â´ÃÂ¶Ã³ÃÃ¸Â´Ã™. 
			//if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0; 
			
			// Â±Ã™ÃƒÂ³Â¿Â¡ Â´Ã™Ã€ÃŒÂ³ÂªÂ¹Ã Â¿Ã€ÂºÃªÃÂ§Ã†Â® Â¹Â°Â°Ã­Â±Ã¢Â°Â¡ ÃÂ¸Ã€Ã§Ã‡Ã‘Â´Ã™Â¸Ã© ÂºÂ»Â°ÃÂ³Â¬Â½Ãƒ Â¸Ã°ÂµÃ¥Â·Ã ÂµÃ©Â¾Ã®Â°Â£Â´Ã™.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				iFish = iCheckFish(iOwnerH, cMapIndex, dX, dY);
		   		if (iFish == NULL) wsprintf(cItemName, "Fish");
			}
			else wsprintf(cItemName, "Fish");
			break;
		}

		if (strlen(cItemName) != 0) {
			
			// Â³Â¬Â½ÃƒÂ¿Â¡ Â¼ÂºÂ°Ã¸Ã‡ÃŸÂ´Ã™Â¸Ã© Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Ã€Ã¼Â¼Ã›.
			if (memcmp(cItemName, "Fish", 6) == 0) {
				SendNotifyMsg(NULL, iOwnerH, DEF_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
				// v1.41 Â¾Ã Â°Â£Ã€Ã‡ Â°Ã¦Ã‡Ã¨Ã„Â¡ Â»Ã³Â½Ã‚ 
				m_pClientList[iOwnerH]->m_iExpStock += iDice(1,2);
			}
			
			pItem = new class CItem;
			if (pItem == NULL) return 0;
			if (_bInitItemAttr(pItem, cItemName) == TRUE) {
				// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â³ÃµÂ´Ã‚Â´Ã™. 
				m_pMapList[cMapIndex]->bSetItem(lX, lY, pItem);
		
				// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, cMapIndex,
					lX, lY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4
			}
		}
		break;
	}

	return 1;
}



void CGame::UseSkillHandler(int iClientH, int iV1, int iV2, int iV3)
{
 char  cOwnerType;
 short sAttackerWeapon, sOwnerH;
 int   iResult, iPlayerSkillLevel;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((iV1 < 0) || (iV1 >= DEF_MAXSKILLTYPE)) return;
	if (m_pSkillConfigList[iV1]	== NULL) return;
	// Ã€ÃŒÂ¹ÃŒ Â±Ã¢Â¼ÃºÃ€Â» Â»Ã§Â¿Ã«ÃÃŸÃ€ÃŒÂ¶Ã³ÂµÂµ Â¸Â®Ã…Ã.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] == TRUE) return;

	// v1.3 !!1Ã‡Ã˜Ã…Â· Â°Ã‰Â·Â¯Â³Â»Â±Ã¢Â¿Ã«! 
	/*
	if (iV1 != 19) {
		m_pClientList[iClientH]->m_iAbuseCount++;
		if ((m_pClientList[iClientH]->m_iAbuseCount % 30) == 0) {
			wsprintf(G_cTxt, "(!) Ã‡Ã˜Ã…Â· Â¿Ã«Ã€Ã‡Ã€Ãš(%s) Skill(%d) Tries(%d)",m_pClientList[iClientH]->m_cCharName, 
				                                                       iV1, m_pClientList[iClientH]->m_iAbuseCount);
			PutLogFileList(G_cTxt);
		}
	}
	*/

	// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Â±Ã¢Â¼ÃºÂ¼Ã¶ÃÃ˜Â¿Â¡ ÂµÃ»Â¶Ã³ Â¼ÂºÂ°Ã¸Â¿Â©ÂºÃÂ¸Â¦ Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™. 
	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[iV1];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		// Â½Ã‡Ã†ÃÂ´Ã™. 
		// Â±Ã¢Â¼Ãº Â»Ã§Â¿Ã«Ã€ÃŒ ÃÃŸÃÃ¶ ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
		return;
	}

	// iV1Ã€ÃŒ Â±Ã¢Â¼Ãº Â¹Ã¸ÃˆÂ£ 
	switch (m_pSkillConfigList[iV1]->m_sType) {
	case DEF_SKILLEFFECTTYPE_PRETEND:
		switch (m_pSkillConfigList[iV1]->m_sValue1) {
		case 1:
			// ÃÃ—Ã€ÂºÃƒÂ´Ã‡ÃÂ±Ã¢ Â±Ã¢Â¼ÃºÃ€ÃŒÂ´Ã™.	
			
			// v1.44 Â»Ã§Ã…ÃµÃ€Ã¥Ã€ÃŒÂ¸Ã© ÃÃ—Ã€ÂºÃƒÂ´Ã‡ÃÂ±Ã¢ Â¸Ã¸Ã‡Ã‘Â´Ã™.
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}
			
			//Â¸Â¸Â¾Ã  Â¹Ã™Â´ÃšÂ¿Â¡ Â½ÃƒÃƒÂ¼Â°Â¡ Ã€Ã–Â´Ã™Â¸Ã© ÃÃ—Ã€ÂºÃƒÂ´ Ã‡ÃÂ±Ã¢Â¸Â¦ Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			if (sOwnerH != NULL) {
				// ÃÃ—Ã€ÂºÃƒÂ´ Ã‡ÃÂ±Ã¢Â¸Â¦ Ã‡Ã’ Ã€ÃšÂ¸Â®Â¿Â¡ Â½ÃƒÃƒÂ¼Â°Â¡ Ã€Ã–Â¾Ã® Â±Ã¢Â¼Ãº Â»Ã§Â¿Ã«Ã€ÃŒ ÃÃŸÃÃ¶ ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}
			
			// ÃÃ—Ã€ÂºÃƒÂ´ Ã‡ÃÂ°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ ÃÃ–ÂºÂ¯Â¿Â¡ Â¹Â°ÃƒÂ¼Â°Â¡ Ã€Ã–Â¾Ã®ÂµÂµ Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
			iResult = 0;
			if (m_pClientList[iClientH]->m_iAdminUserLevel <= 0) {
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;

				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
			}

			if (iResult != 0) {
				// ÃÃ—Ã€ÂºÃƒÂ´ Ã‡ÃÂ±Ã¢Â¸Â¦ Ã‡Ã’ Ã€ÃšÂ¸Â®Â¿Â¡ Â½ÃƒÃƒÂ¼Â°Â¡ Ã€Ã–Â¾Ã® Â±Ã¢Â¼Ãº Â»Ã§Â¿Ã«Ã€ÃŒ ÃÃŸÃÃ¶ ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}

			// Â½ÂºÃ…Â³ Ã„Â«Â¿Ã®Ã†Â® Â¿ÃƒÂ¸Â°Â´Ã™. <-- Â³Â»ÂºÃÂ¿Â¡Â¼Â­ Ã„Â«Â¿Ã®Ã†ÃƒÃ€Â» Ã‡Ã˜Â¾ÃŸ Â¾Ã»Â¶Ã—Ã‡Ã‘ Â½ÂºÃ…Â³Ã€ÃŒ Â¿Ã€Â¸Â£Â´Ã‚ Â°Ã¦Â¿Ã¬Â°Â¡ Â¾Ã¸Â´Ã™. 
			CalculateSSN_SkillIndex(iClientH, iV1, 1);
			
			// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” ÃÃ—Â´Ã‚ ÂµÂ¿Ã€Ã› Ã€Ã¼Â¼Ã›.
			sAttackerWeapon = 1;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 0, sAttackerWeapon, NULL);
			// ÃÂ¤Â»Ã³ Ã€Â§Ã„Â¡Â¿Â¡Â¼Â­ ÃÃ¶Â¿Ã®Â´Ã™.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(14, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			// ÃÃ—Ã€Âº Ã€Â§Ã„Â¡ Ã‡Â¥Â½ÃƒÂ¸Â¦ Ã‡Ã‘Â´Ã™.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			break;
		}
		break;

	}

	m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = TRUE;
}

void CGame::ReqSellItemHandler(int iClientH, char cItemID, char cSellToWhom, int iNum, char * pItemName)
{
 char cItemCategory,cItemName[21];
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 BOOL   bNeutral;
 DWORD  dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2, dwMul1, dwMul2;
 CItem * m_pGold;

	// Â»Ã§Â¿Ã«Ã€ÃšÃ€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã› Ã†ÃˆÂ±Ã¢ Â¿Ã¤Â±Â¸.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;

	iCalcTotalWeight(iClientH);

	m_pGold = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(m_pGold, cItemName);

	// v1.42
	bNeutral = FALSE;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = TRUE;
	// v2.13 Â¼ÂºÃˆÃ„Â´Ã Â¼Ã¶ÃÂ¤ Â¹Â°Â°Ã‡Ã€Â» Â¾Ã®ÂµÃ°Â¼Â­Â³Âª Ã†ÃˆÂ°Ã” Â¼Ã¶ÃÂ¤Ã‡ÃÂ¿Â©Â¼Â­ Ã†ÃˆÂ¶Â§Â´Ã‚ NPC Â±Â¸ÂºÃÃ€ÃŒ Ã‡ÃŠÂ¿Ã¤Â¾Ã¸Â´Ã™. 
	// Â´Ãœ Ã„Â«Ã…Ã—Â°Ã­Â¸Â®Â¸Â¦ Â±Ã¢ÃÃ˜Ã€Â¸Â·Ã Â¾Ã†Ã€ÃŒÃ…Ã› Â°Â¡Â°ÃÃ€Â» Â°Ã¡ÃÂ¤Ã‡Ã‘Â´Ã™.
	switch (cSellToWhom) {
	case 15: 		// Â»Ã³ÃÂ¡ Â¾Ã†ÃÃœÂ¸Â¶ 
	case 24:        // Â´Ã«Ã€Ã¥Â°Â£ ÃÃ–Ã€Ã 
		cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
		// 12-22 Â¼ÂºÃˆÃ„Â´Ã Â¼Ã¶ÃÂ¤ Â¾Ã®ÂµÃ°Â¼Â­ÂµÃ§ Ã†ÃˆÂ¼Ã¶ Ã€Ã–Â°Ã” Â¼Ã¶ÃÂ¤ 
		// Â»Ã³ÃÂ¡Â¾Ã†Ã€ÃŒÃ…Ã› 
		if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {

			// Ã€Ã»Ã‡Ã•Ã‡ÃÂ´Ã™. Â¹Â«ÃÂ¶Â°Ã‡ Â¹ÃÂ°Âª 
			iPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2)*iNum;
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;


			//v1.42 ÃÃŸÂ¸Â³Ã€Ã Â°Ã¦Â¿Ã¬ Â¹ÃÃ€Ã‡ Â¹ÃÂ°Âª.
			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0)    iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000;

			if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > (DWORD)_iCalcMaxLoad(iClientH)) {
				// v2.12 Ã†Ãˆ Â°Ã¦Â¿Ã¬ Â¹Â«Â°Ã”Â°Â¡ ÃƒÃŠÂ°ÃºÂµÃ‡Â¾Ã®Â¼Â­ Ã†Ãˆ Â¼Ã¶ Â¾Ã¸Â´Ã™.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
		}
		// Â´Ã«Ã€Ã¥Â°Â£ Â¾Ã†Ã€ÃŒÃ…Ã›
		else if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
			// Â¿Ã¸Â·Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Ã­Â°Ãº ÂºÃ±Â±Â³Ã‡Ã˜Â¼Â­ Â°Â¨Â°Â¡ Â»Ã³Â°Â¢Ã€Â» Â°Ã¨Â»Ãª, Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â°Â¡Â°ÃÃ€Â» Â¸Ã…Â±Ã¤Â´Ã™.
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

			if (sRemainLife == 0) {
				// Â°Ã­Ã€Ã¥Â³Â­ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Âº Ã†Ãˆ Â¼Ã¶ Â¾Ã¸Â´Ã™
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else {
				d1 = (double)sRemainLife;
				if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
					d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // Â¿Ã¸Â·Â¡ Â°Â¡Â°Ã 
				d3 = d3 * d2; // ÃƒÃŸÂ»ÃªÂµÃˆ Â°Â¡Â°Ã 

				iPrice = (int)d3;
				iPrice = iPrice*iNum;

				dwAddPrice1 = 0;
				dwAddPrice2 = 0;
				// Â¾Ã†Ã€ÃŒÃ…Ã› Ã†Â¯Â¼ÂºÃ„Â¡Â¿Â¡ ÂµÃ»Â¸Â¥ Â°Â¡Â°Ã Â»Ã³Â½Ã‚ 
	if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) {
		dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
		dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;

	switch (dwSWEType) {
		case 6: dwMul1 = 2; break;  // Â°Â¡ÂºÂ­Â¿Ã® 
		case 8: dwMul1 = 2; break;  // Â°Â­ÃˆÂ­ÂµÃˆ
		case 5: dwMul1 = 3; break;  // Â¹ÃÃƒÂ¸Ã€Ã‡
		case 1: dwMul1 = 4; break;  // Ã‡ÃŠÂ»Ã¬Ã€Ã‡ 
		case 7: dwMul1 = 5; break;  // Â¿Â¹Â¸Â®Ã‡Ã‘
		case 2: dwMul1 = 6; break;  // ÃÃŸÂµÂ¶Ã€Ã‡
		case 3: dwMul1 = 15; break; // ÃÂ¤Ã€Ã‡Ã€Ã‡ 
		case 9: dwMul1 = 20; break; // Â°Ã­Â´Ã«Â¹Â®Â¸Ã­ 
		default: dwMul1 = 1; break;
	}

	d1 = (double)iPrice*dwMul1;
	switch (dwSWEValue) {
		case 1: d2 = 10.0f; break;
		case 2: d2 = 20.0f; break;
		case 3: d2 = 30.0f; break;
		case 4: d2 = 35.0f; break;
		case 5: d2 = 40.0f; break;
		case 6: d2 = 50.0f; break;
		case 7: d2 = 100.0f; break;
		case 8: d2 = 200.0f; break;
		case 9: d2 = 300.0f; break;
		case 10: d2 = 400.0f; break;
		case 11: d2 = 500.0f; break;
		case 12: d2 = 700.0f; break;
		case 13: d2 = 900.0f; break;
		default: d2 = 0.0f; break;
	}
	d3 = d1*(d2/100.0f);

	dwAddPrice1 = (int)(d1 + d3);
	}

				// v1.42 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¶Ã³Â¸Ã© Sub ÃˆÂ¿Â°ÃºÂ¸Â¦ Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™. Â°Ã¸Â°ÃÂ¹Â«Â±Ã¢Â´Ã‚ 1Â°Â³Â¸Â¸ Ã€Ã¥Ã‚Ã¸ÂµÃˆÂ´Ã™Â°Ã­ Ã‡ÃŸÃ€Â»Â¶Â§Â¸Â¸ Ã€Â¯ÃˆÂ¿Ã‡Ã”.
	if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) {
		dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
		dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;

	switch (dwSWEType) {
		case 1: 
		case 12: dwMul2 = 2; break;

		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 7: dwMul2 = 4; break;

		case 8:
		case 9:
		case 10:
		case 11: dwMul2 = 6; break;
	}

	d1 = (double)iPrice*dwMul2;
	switch (dwSWEValue) {
		case 1: d2 = 10.0f; break;
		case 2: d2 = 20.0f; break;
		case 3: d2 = 30.0f; break;
		case 4: d2 = 35.0f; break;
		case 5: d2 = 40.0f; break;
		case 6: d2 = 50.0f; break;
		case 7: d2 = 100.0f; break;
		case 8: d2 = 200.0f; break;
		case 9: d2 = 300.0f; break;
		case 10: d2 = 400.0f; break;
		case 11: d2 = 500.0f; break;
		case 12: d2 = 700.0f; break;
		case 13: d2 = 900.0f; break;
		default: d2 = 0.0f; break;
	}
	d3 = d1*(d2/100.0f);

	dwAddPrice2 = (int)(d1 + d3);
}

				// v2.03 925 Ã†Â¯Â¼Ã¶ Â¾Ã†Ã€ÃŒÃ…Ã› Â°Â¡Â°Ã Â°Â¡ÃÃŸÃ„Â¡Â¸Â¦ 77%Â¼Ã¶ÃÃ˜Ã€Â¸Â·Ã Â´Ã™Â¿Ã® 
				iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

				//v1.42 ÃÃŸÂ¸Â³Ã€Ã Â°Ã¦Â¿Ã¬ Â¹ÃÃ€Ã‡ Â¹ÃÂ°Âª.
				if (bNeutral == TRUE) iPrice = iPrice/2;
				if (iPrice <= 0)    iPrice = 1;
				if (iPrice > 1000000) iPrice = 1000000;

				if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(m_pGold, iPrice) > (DWORD)_iCalcMaxLoad(iClientH)) {
					// v2.12 Ã†Ãˆ Â°Ã¦Â¿Ã¬ Â¹Â«Â°Ã”Â°Â¡ ÃƒÃŠÂ°ÃºÂµÃ‡Â¾Ã®Â¼Â­ Ã†Ãˆ Â¼Ã¶ Â¾Ã¸Â´Ã™.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 4, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
				}
				else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
			}
		}
		else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		break;


	default:
		break;
	}
	if (m_pGold != NULL) delete m_pGold;
}

void CGame::ReqSellItemConfirmHandler(int iClientH, char cItemID, int iNum, char * pString)
{
 class CItem * pItemGold;
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 char   * cp, cItemName[21], cData[120], cItemCategory;
 DWORD  * dwp, dwMul1, dwMul2, dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2;
 WORD   * wp;
 int    iEraseReq, iRet;
 short * sp;
 BOOL   bNeutral;


	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã†ÃˆÂ°ÃšÂ´Ã™Â´Ã‚ Â°ÃÃ€ÃŒ Â°Ã¡ÃÂ¤ÂµÃ‡Â¾ÃºÂ´Ã™.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;

	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) return;

	iCalcTotalWeight(iClientH);
	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// v1.42
	bNeutral = FALSE;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = TRUE;

	iPrice = 0;
	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ ÃÂ¾Â·Ã¹Â¿Â¡ ÂµÃ»Â¶Ã³ Â°Â¡Â°Ã Â°Ã¨Â»Ãª.
  	if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
		// Â¹Â«Â±Ã¢Â·Ã¹Â´Ã™
  		// Â¿Ã¸Â·Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Ã­Â°Ãº ÂºÃ±Â±Â³Ã‡Ã˜Â¼Â­ Â°Â¨Â°Â¡ Â»Ã³Â°Â¢Ã€Â» Â°Ã¨Â»Ãª, Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â°Â¡Â°ÃÃ€Â» Â¸Ã…Â±Ã¤Â´Ã™.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		
		if (sRemainLife <= 0) {
			// Â¸ÃÂ°Â¡ÃÃ¸ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Âº Ã†ÃˆÃÃ¶ Â¸Ã¸Ã‡Ã‘Â´Ã™.	
			return;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // Â¿Ã¸Â·Â¡ Â°Â¡Â°Ã 
			d3 = d3 * d2; // ÃƒÃŸÂ»ÃªÂµÃˆ Â°Â¡Â°Ã 
			
			iPrice = (short)d3;
			iPrice = iPrice*iNum;

			dwAddPrice1 = 0;
			dwAddPrice2 = 0;
			// Â¾Ã†Ã€ÃŒÃ…Ã› Ã†Â¯Â¼ÂºÃ„Â¡Â¿Â¡ ÂµÃ»Â¸Â¥ Â°Â¡Â°Ã Â»Ã³Â½Ã‚ 
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;
				
				// ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã› ÃˆÂ¿Â°Ãº ÃÂ¾Â·Ã¹: 
				// 0-None 1-Ã‡ÃŠÂ»Ã¬Â±Ã¢Â´Ã«Â¹ÃŒÃÃ¶ÃƒÃŸÂ°Â¡ 2-ÃÃŸÂµÂ¶ÃˆÂ¿Â°Ãº 3-ÃÂ¤Ã€Ã‡Ã€Ã‡ 4-Ã€ÃºÃÃ–Ã€Ã‡ 
				// 5-Â¹ÃÃƒÂ¸Ã€Ã‡ 6-Â°Â¡ÂºÂ­Â¿Ã® 7-Â¿Â¹Â¸Â®Ã‡Ã‘ 8-Â°Â­ÃˆÂ­ÂµÃˆ 9-Â°Ã­Â´Ã«Â¹Â®Â¸Ã­Ã€Ã‡
				switch (dwSWEType) {
				case 6: dwMul1 = 2; break;  // Â°Â¡ÂºÂ­Â¿Ã® 
				case 8: dwMul1 = 2; break;  // Â°Â­ÃˆÂ­ÂµÃˆ
				case 5: dwMul1 = 3; break;  // Â¹ÃÃƒÂ¸Ã€Ã‡
				case 1: dwMul1 = 4; break;  // Ã‡ÃŠÂ»Ã¬Ã€Ã‡ 
				case 7: dwMul1 = 5; break;  // Â¿Â¹Â¸Â®Ã‡Ã‘
				case 2: dwMul1 = 6; break;  // ÃÃŸÂµÂ¶Ã€Ã‡
				case 3: dwMul1 = 15; break; // ÃÂ¤Ã€Ã‡Ã€Ã‡ 
				case 9: dwMul1 = 20; break; // Â°Ã­Â´Ã«Â¹Â®Â¸Ã­ 
				default: dwMul1 = 1; break;
				}

				d1 = (double)iPrice*dwMul1;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice1 = (int)(d1 + d3);
			}

			// v1.42 ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¶Ã³Â¸Ã© Sub ÃˆÂ¿Â°ÃºÂ¸Â¦ Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™. Â°Ã¸Â°ÃÂ¹Â«Â±Ã¢Â´Ã‚ 1Â°Â³Â¸Â¸ Ã€Ã¥Ã‚Ã¸ÂµÃˆÂ´Ã™Â°Ã­ Ã‡ÃŸÃ€Â»Â¶Â§Â¸Â¸ Ã€Â¯ÃˆÂ¿Ã‡Ã”.
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;
				
				// ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã› ÃˆÂ¿Â°Ãº ÃÂ¾Â·Ã¹: 
				//ÃƒÃŸÂ°Â¡ ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—(1), ÃƒÃŸÂ°Â¡ Â¸Ã­ÃÃŸÂ°Âª(2), ÃƒÃŸÂ°Â¡ Â¹Ã¦Â¾Ã®Â°Âª(3), HP ÃˆÂ¸ÂºÂ¹Â·Â® ÃƒÃŸÂ°Â¡(4), SP ÃˆÂ¸ÂºÂ¹Â·Â® ÃƒÃŸÂ°Â¡(5)
				//MP ÃˆÂ¸ÂºÂ¹Â·Â® ÃƒÃŸÂ°Â¡(6), ÃƒÃŸÂ°Â¡ Â¸Â¶Â¹Ã½Ã€ÃºÃ‡Ã—(7), Â¹Â°Â¸Â® Â´Ã«Â¹ÃŒÃÃ¶ ÃˆÃ­Â¼Ã¶(8), Â¸Â¶Â¹Ã½ Â´Ã«Â¹ÃŒÃÃ¶ ÃˆÃ­Â¼Ã¶(9)
				//Â¿Â¬Ã…Â¸ Â´Ã«Â¹ÃŒÃÃ¶ ÃƒÃŸÂ°Â¡(10), Â´Ãµ Â¸Â¹Ã€Âº Â°Ã¦Ã‡Ã¨Ã„Â¡(11), Â´ÃµÂ¸Â¹Ã€Âº Gold(12)
				switch (dwSWEType) {
				case 1: 
				case 12: dwMul2 = 2; break;
					
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7: dwMul2 = 4; break;
					
				case 8:
				case 9:
				case 10:
				case 11: dwMul2 = 6; break;
				}
					
				d1 = (double)iPrice*dwMul2;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice2 = (int)(d1 + d3);
			}

			iPrice = iPrice + (dwAddPrice1 - (dwAddPrice1/3)) + (dwAddPrice2 - (dwAddPrice2/3));

			//v1.42 ÃÃŸÂ¸Â³Ã€Ã Â°Ã¦Â¿Ã¬ Â¹ÃÃ€Ã‡ Â¹ÃÂ°Âª.
			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 1000000) iPrice = 1000000; // New 06/05/2004

			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã†ÃˆÂ¾Ã’Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã› (Â´Ã™Ã€ÃŒÂ¾Ã³Â·ÃÂ±Ã— Â¹ÃšÂ½Âº ÂºÃ±ÃˆÂ°Â¼ÂºÃˆÂ­Â¿Ã«)
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

			_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[cItemID]) ;

			// Ã†Ãˆ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â»Ã¨ÃÂ¦ 
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
				// Â¼Ã¶Â·Â® Â°Â³Â³Ã¤Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© Â°Â¹Â¼Ã¶Â¸Â¦ ÃÃ™Ã€ÃÂ´Ã™.
				// v1.41 !!!
				SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
			}
			else ItemDepleteHandler(iClientH, cItemID, FALSE);
		}
	}
	else 
	if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {
		// Â½Ã„Ã‡Â°, Ã€Ã¢ÃˆÂ­ÂµÃ®Ã€Ã‡ Â¹ÃÂ°ÂªÂ¹Â°Â°Ã‡ÂµÃ© 
		iPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice/2; 
		iPrice = iPrice*iNum;

		//v1.42 ÃÃŸÂ¸Â³Ã€Ã Â°Ã¦Â¿Ã¬ Â¹ÃÃ€Ã‡ Â¹ÃÂ°Âª.
		if (bNeutral == TRUE) iPrice = iPrice/2;
		if (iPrice <= 0) iPrice = 1;
		if (iPrice > 1000000) iPrice = 1000000; // New 06/05/2004

		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã†ÃˆÂ¾Ã’Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã› (Â´Ã™Ã€ÃŒÂ¾Ã³Â·ÃÂ±Ã— Â¹ÃšÂ½Âº ÂºÃ±ÃˆÂ°Â¼ÂºÃˆÂ­Â¿Ã«)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

		_bItemLog(DEF_ITEMLOG_SELL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[cItemID]) ;

		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ ÃÂ¾Â·Ã¹Â¿Â¡ ÂµÃ»Â¶Ã³ Ã€Ã»Ã€Ã½Ã‡Ã‘ ÃƒÂ³Â¸Â®Â¸Â¦ Ã‡Ã‘Â´Ã™.
		if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			// Â¼Ã¶Â·Â® Â°Â³Â³Ã¤Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© Â°Â¹Â¼Ã¶Â¸Â¦ ÃÃ™Ã€ÃÂ´Ã™.
			// v1.41 !!!
			SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
		}
		else ItemDepleteHandler(iClientH, cItemID, FALSE);
	}

	// GoldÂ¸Â¦ ÃÃµÂ°Â¡Â½ÃƒÃ…Â²Â´Ã™. Â¸Â¸Â¾Ã  Ã†Ã‡ Â°Â¡Â°ÃÃ€ÃŒ 0 ÃˆÂ¤Ã€Âº Â¸Â¶Ã€ÃŒÂ³ÃŠÂ½ÂºÃ€ÃŒÂ¸Ã© Â±ÃÃ€Â» ÃÃ–ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
	if (iPrice <= 0) return;

	pItemGold = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItemGold, cItemName);
	
	pItemGold->m_dwCount = iPrice;
	
	if (_bAddClientItemList(iClientH, pItemGold, &iEraseReq) == TRUE) {
		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™.
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1Â°Â³ ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™. <- Â¿Â©Â±Ã¢Â¼Â­ 1Â°Â³Â¶Ãµ Ã„Â«Â¿Ã®Ã†Â®Â¸Â¦ Â¸Â»Ã‡ÃÂ´Ã‚ Â°ÃÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™
		*cp = 1;
		cp++;
		
		memcpy(cp, pItemGold->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItemGold->m_dwCount;
		cp += 4;
		
		*cp = pItemGold->m_cItemType;
		cp++;
		
		*cp = pItemGold->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // Â¾Ã²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sLevelLimit;
		cp += 2;
		
		*cp = pItemGold->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSpriteFrame;
		cp += 2;

		*cp = pItemGold->m_cItemColor;
		cp++;

		*cp = (char)pItemGold->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItemGold->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItemGold->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃ 
		cp++;
		*/
		
		if (iEraseReq == 1)
			delete pItemGold;
		
		// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		
		// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
		iCalcTotalWeight(iClientH);

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
			DeleteClient(iClientH, TRUE, TRUE);
			break;
		}
	}
	else {
		// ÃÃŸÂ·Â® ÃƒÃŠÂ°ÃºÂµÃ®Ã€Ã‡ Â¹Â®ÃÂ¦Â·Ã ÃƒÃŸÂ°Â¡ Â½Ã‡Ã†Ã.
		// Â¹ÃÃÃ¶ Â¸Ã¸Ã‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â¹Ã™Â´ÃšÂ¿Â¡ Â¶Â³Â¾Ã®ÃÃ¸Â´Ã™. 
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY, pItemGold);
		
		// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			pItemGold->m_sSprite, pItemGold->m_sSpriteFrame, pItemGold->m_cItemColor); // v1.4 color

		// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
		iCalcTotalWeight(iClientH);
		
		// Â´ÃµÃ€ÃŒÂ»Ã³ Â°Â¡ÃÃºÂ¼Ã¶ Â¾Ã¸Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
}

void CGame::ReqRepairItemHandler(int iClientH, char cItemID, char cRepairWhom, char * pString)
{
 char cItemCategory;
 short sRemainLife, sPrice;
 double d1, d2, d3;

	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â°Ã­Ã„Â¡Â°ÃšÂ´Ã™Â´Ã‚ Â¿Ã¤Â±Â¸.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ ÃÂ¾Â·Ã¹Â¿Â¡ ÂµÃ»Â¶Ã³ Â°Â¡Â°Ã Â°Ã¨Â»Ãª.
  	if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
		// Â¹Â«Â±Ã¢Â·Ã¹Â´Ã™
  		
		// Â¸Â¸Â¾Ã  Â¹Â«Â±Ã¢Â¸Â¦ Â´Ã«Ã€Ã¥Â°Â£ ÃÃ–Ã€ÃÃ€ÃŒ Â¾Ã†Â´Ã‘ Ã€ÃŒÂ¿Â¡Â°Ã” Â°Ã­ÃƒÃ„Â´ÃÂ¶Ã³Â°Ã­ Ã‡Ã‘Â´Ã™Â¸Ã© Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
		if (cRepairWhom != 24) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
		
		// Â¿Ã¸Â·Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Ã­Â°Ãº ÂºÃ±Â±Â³Ã‡Ã˜Â¼Â­ Â°Â¨Â°Â¡ Â»Ã³Â°Â¢Ã€Â» Â°Ã¨Â»Ãª, Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Â® ÂºÃ±Â¿Ã«Ã€Â» Â¸Ã…Â±Ã¤Â´Ã™.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// Â¿ÃÃ€Ã¼ÃˆÃ· Â¸ÃÂ°Â¡ÃÃ¸ Â°ÃÃ€ÃŒÂ¶Ã³Â¸Ã© Â¿Ã¸Â·Â¡Â°Â¡Â°ÃÃ€Ã‡ Ã€Ã½Â¹ÃÃ€ÃŒ ÂµÃ§Â´Ã™. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // Â¿Ã¸Â·Â¡ Â°Â¡Â°Ã 
			d3 = d3 * d2; // ÃƒÃŸÂ»ÃªÂµÃˆ Â°Â¡Â°Ã 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else if ( ((cItemCategory >= 43) && (cItemCategory <= 50)) || ((cItemCategory >= 11) && (cItemCategory <= 12))) {
		// Â³Â¬Â½ÃƒÂ´Ã«, Â°Ã®Â±ÂªÃ€ÃŒ ÂµÃ®Â°Ãº Â°Â°Ã€Âº ÂºÃ±Â¹Â«Â±Ã¢Â·Ã¹ Â¼Ã¶Â¸Â®Â°Â¡Â´Ã‰ Â¾Ã†Ã€ÃŒÃ…Ã›. Â¿ÃŠ, ÂºÃÃƒÃ·Â·Ã¹
		
		// Â¸Â¸Â¾Ã  Â»Ã³ÃÂ¡ ÃÃ–Ã€ÃÃ€ÃŒ Â¾Ã†Â´Ã‘ Ã€ÃŒÂ¿Â¡Â°Ã” Â°Ã­ÃƒÃ„Â´ÃÂ¶Ã³Â°Ã­ Ã‡Ã‘Â´Ã™Â¸Ã© Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
		if (cRepairWhom != 15) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
		
		// Â¿Ã¸Â·Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Ã­Â°Ãº ÂºÃ±Â±Â³Ã‡Ã˜Â¼Â­ Â°Â¨Â°Â¡ Â»Ã³Â°Â¢Ã€Â» Â°Ã¨Â»Ãª, Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Â® ÂºÃ±Â¿Ã«Ã€Â» Â¸Ã…Â±Ã¤Â´Ã™.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// Â¿ÃÃ€Ã¼ÃˆÃ· Â¸ÃÂ°Â¡ÃÃ¸ Â°ÃÃ€ÃŒÂ¶Ã³Â¸Ã© Â¿Ã¸Â·Â¡Â°Â¡Â°ÃÃ€Ã‡ Ã€Ã½Â¹ÃÃ€ÃŒ ÂµÃ§Â´Ã™. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // Â¿Ã¸Â·Â¡ Â°Â¡Â°Ã 
			d3 = d3 * d2; // ÃƒÃŸÂ»ÃªÂµÃˆ Â°Â¡Â°Ã 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else {
		// Â°Ã­Ã„Â¥Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
}

void CGame::ReqRepairItemCofirmHandler(int iClientH, char cItemID, char * pString)
{
 short    sRemainLife, sPrice;
 char   * cp, cItemCategory, cData[120];
 double   d1, d2, d3;
 DWORD  * dwp, dwGoldCount;
 WORD   * wp;
 int      iRet, iGoldWeight;

	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Ã¶Â¸Â®Ã‡ÃÂ°ÃšÂ´Ã™Â´Ã‚ Â°ÃÃ€ÃŒ Â°Ã¡ÃÂ¤ÂµÃ‡Â¾ÃºÂ´Ã™.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;

	// New 18/05/2004
	if (m_pClientList[iClientH]->m_pIsProcessingAllowed == FALSE) return;

	//testcode
	//PutLogList("Repair!");

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ ÃÂ¾Â·Ã¹Â¿Â¡ ÂµÃ»Â¶Ã³ Â°Â¡Â°Ã Â°Ã¨Â»Ãª.
  	if ( ((cItemCategory >= 1) && (cItemCategory <= 10)) || ((cItemCategory >= 43) && (cItemCategory <= 50)) || 
		 ((cItemCategory >= 11) && (cItemCategory <= 12))) {
		// Â¹Â«Â±Ã¢Â·Ã¹ ÃˆÂ¤Ã€Âº Â³Â¬Â½ÃƒÂ´Ã«, Â°Ã®Â±ÂªÃ€ÃŒÂ¿Ã Â°Â°Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›, Â¿ÃŠ, Â½Ã…Â¹ÃŸ 

  		// Â¿Ã¸Â·Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Ã­Â°Ãº ÂºÃ±Â±Â³Ã‡Ã˜Â¼Â­ Â°Â¨Â°Â¡ Â»Ã³Â°Â¢Ã€Â» Â°Ã¨Â»Ãª, Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Â® ÂºÃ±Â¿Ã«Ã€Â» Â¸Ã…Â±Ã¤Â´Ã™.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// Â¿ÃÃ€Ã¼ÃˆÃ· Â¸ÃÂ°Â¡ÃÃ¸ Â°ÃÃ€ÃŒÂ¶Ã³Â¸Ã© Â¿Ã¸Â·Â¡Â°Â¡Â°ÃÃ€Ã‡ Ã€Ã½Â¹ÃÃ€ÃŒ ÂµÃ§Â´Ã™. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)abs(sRemainLife);
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)abs(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan);
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // Â¿Ã¸Â·Â¡ Â°Â¡Â°Ã 
			d3 = d3 * d2; // ÃƒÃŸÂ»ÃªÂµÃˆ Â°Â¡Â°Ã 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}
		
		// sPriceÂ¸Â¸Ã…Â­Ã€Ã‡ ÂµÂ·Ã€ÃŒ ÂµÃ‡Â¸Ã© Â°Ã­Ã„Â¥ Â¼Ã¶ Ã€Ã–Ã€Â¸Â³Âª ÂºÃÃÂ·Ã‡ÃÂ¸Ã© Â°Ã­Ã„Â¥ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
		dwGoldCount = dwGetItemCount(iClientH, "Gold");
		
		if ( dwGoldCount < (DWORD)sPrice ) {
			// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â°Â®Â°Ã­Ã€Ã–Â´Ã‚ GoldÂ°Â¡ Â¾Ã†Ã€ÃŒÃ…Ã› Â¼Ã¶Â¸Â® ÂºÃ±Â¿Ã«Â¿Â¡ ÂºÃ±Ã‡Ã˜ Ã€Ã»Â´Ã™. Â°Ã­Ã„Â¥ Â¼Ã¶ Â¾Ã¸Ã€Â½.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
			cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp  = cItemID;
			cp++;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
			return;
		}
		else {
			//ÂµÂ·Ã€ÃŒ ÃƒÃ¦ÂºÃÃ‡ÃÂ´Ã™. Â°Ã­Ã„Â¥ Â¼Ã¶ Ã€Ã–Â´Ã™. 
			
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â¸Ã­Ã€Â» Â´ÃƒÂ¸Â®Â°Ã­ Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™. !BUG POINT Ã€Â§Ã„Â¡Â°Â¡ ÃÃŸÂ¿Ã¤Ã‡ÃÂ´Ã™. Â¸Ã•Ã€Ãº Â¼Ã¶Â¸Ã­Ã€Â» Â´ÃƒÂ¸Â®Â°Ã­ ÂµÂ·Ã€Ã‡ Ã„Â«Â¿Ã®Ã†Â®Â¸Â¦ Â³Â·ÃƒÃ¡Â´Ã™.
			m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
		 	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMREPAIRED, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan, NULL, NULL);
			
			iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - sPrice );
			
			// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
			iCalcTotalWeight(iClientH);

			//v1.4 Â¸Â¶Ã€Â»Ã€Ã‡ Ã€ÃšÂ±ÃÂ¿Â¡ Â´ÃµÃ‡Ã‘Â´Ã™. 
			m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += sPrice;
		}
	}
	else {
		// Â°Ã­Ã„Â¥ Ã‡ÃŠÂ¿Ã¤Â°Â¡ Â¾Ã¸Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã› 
		// Ã‡Ã˜Ã…Â·Ã€ÃŒÂ³Âª Â¹Ã¶Â±Ã—Â¿Â¡ Ã€Ã‡Ã‡Ã‘ Â°ÃÃ€ÃÂµÃ­ 
	}
}

int CGame::iCalcTotalWeight(int iClientH)
{
 register int i, iWeight;
 short sItemIndex;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	
	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	// Ã‚Ã¸Â¿Ã«Ã‡ÃÃÃ¶ Â¾ÃŠÂ¾Ã†ÂµÂµ ÃˆÂ¿Â°ÃºÂ°Â¡ Ã€Ã–Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã› ÃˆÂ¿Â°Ãº. Â¼Ã’ÃÃ¶Ã‡ÃÂ°Ã­ Ã€Ã–Â¾Ã®ÂµÂµ ÃˆÂ¿Â°ÃºÂ°Â¡ Ã€Ã–Â±Ã¢ Â¶Â§Â¹Â®Â¿Â¡ Â¿Â©Â±Ã¢Â¼Â­ Â°Ã‹Â»Ã§.
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
				// Â¼Ã¶Â¸Ã­Ã€ÃŒ Ã€Ã–Â¾Ã®Â¾ÃŸ ÃˆÂ¿Â°ÃºÂ°Â¡ Ã€Ã–Â´Ã™.
				m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		}
	}

	iWeight = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		
		iWeight += iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], m_pClientList[iClientH]->m_pItemList[i]->m_dwCount);
	}

	m_pClientList[iClientH]->m_iCurWeightLoad = iWeight;

	return iWeight;	
}

void CGame::CheckAndNotifyPlayerConnection(int iClientH, char * pMsg, DWORD dwSize)
{
 char   seps[] = "= \t\n";
 char   * token, * cp, cName[11], cBuff[256], cPlayerLocation[120];
 class  CStrTok * pStrTok;
 register int i;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwSize <= 0) return;

	ZeroMemory(cPlayerLocation,sizeof(cPlayerLocation));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	if (strlen(token) > 10) 
		 memcpy(cName, token, 10);	
	else memcpy(cName, token, strlen(token));

	// cNameÃ€Ã‡ Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ ÃÂ¢Â¼Ã“ÃÃŸÃ€ÃÃÃ¶ ÃƒÂ£Â´Ã‚Â´Ã™. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(cName, m_pClientList[i]->m_cCharName, 10) == 0)) {
		// Â°Â°Ã€Âº Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ Ã„Â³Â¸Â¯Ã…ÃÂ¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™. 
		if(m_pClientList[iClientH]->m_iAdminUserLevel > 0){ // GM's get more info
			cp = (char *)cPlayerLocation;

			memcpy(cp,m_pClientList[i]->m_cMapName,10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = m_pClientList[i]->m_sX;
			cp += 2;

			wp = (WORD *)cp;
			*wp = m_pClientList[i]->m_sY;
			cp += 2;
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERONGAME, NULL, NULL, NULL, m_pClientList[i]->m_cCharName,NULL,NULL,NULL,NULL,NULL,NULL,cPlayerLocation);

		delete pStrTok;
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;

	wp = (WORD *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, cName, 10);
	cp += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;

	bStockMsgToGateServer(cBuff, 25);

	delete pStrTok;
}



void CGame::ToggleWhisperPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;
 char *cp;
 WORD *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwMsgSize <= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token == NULL) {
		// Â±Ã“Â¼Ã“Â¸Â» Â»Ã³Â´Ã«Â°Â¡ ÃÃ¶ÃÂ¤ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™. Â±Ã“Â¼Ã“Â¸Â» Â¸Ã°ÂµÃ¥Â¸Â¦ Ã‡Ã˜ÃÂ¦Ã‡Ã‘Â´Ã™. 
		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
		ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
		m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = FALSE;
		// Â±Ã“Â¼Ã“Â¸Â» Â»Ã³Ã…Ã‚Â°Â¡ Ã‡Ã˜ÃÂ¦ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Ã…Ã«ÂºÂ¸. 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
	}
	else {
		if (strlen(token) > 10)	
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
				// Â°Â°Ã€Âº Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™. 
				// Ã€ÃšÂ±Ã¢ Ã€ÃšÂ½Ã…Ã€ÃŒÂ¶Ã³Â¸Ã© Ã‡Ã’Â´Ã§Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
				if (i == iClientH) {
					delete pStrTok;
					return;
				}
				//Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ Ã‡Ã’Â´Ã§ 
				m_pClientList[iClientH]->m_iWhisperPlayerIndex = i;
				ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
				strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
		   		break;
			}

		if (m_pClientList[iClientH]->m_iWhisperPlayerIndex == -1) {
			ZeroMemory(cBuff, sizeof(cBuff));
			cp = (char *)cBuff;
			*cp = GSM_REQUEST_FINDCHARACTER;
			cp++;

			wp = (WORD *)cp;
			*wp = m_wServerID_GSS;
			cp += 2;

			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;

			memcpy(cp, cName, 10);
			cp += 10;

			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			bStockMsgToGateServer(cBuff, 25);

			ZeroMemory(m_pClientList[iClientH]->m_cWhisperPlayerName, sizeof(m_pClientList[iClientH]->m_cWhisperPlayerName));
			strcpy(m_pClientList[iClientH]->m_cWhisperPlayerName, cName);
			m_pClientList[iClientH]->m_bIsCheckingWhisperPlayer = TRUE;
		}
		else{
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[iClientH]->m_cWhisperPlayerName);
		}
	}
 
	delete pStrTok;
}


void CGame::SetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char cTemp[256];
 register int i;


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize - 7) <= 0) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	memcpy(cTemp, (pMsg + 7), dwMsgSize - 7);
	
	// Â°Ã¸Â¹Ã©Â¶ÃµÃ€Â» Â¾Ã°Â´ÃµÂ¹Ã™Â·Ã Â¹Ã™Â²Ã›Â´Ã™. 
	for (i = 0; i < 256; i++)
		if (cTemp[i] == ' ') cTemp[i] = '_';

	// Â¿Â¡Â·Â¯ Â¹Ã¦ÃÃ¶ Ã„ÃšÂµÃ¥ 
	cTemp[255] = NULL;

	ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
	strcpy(m_pClientList[iClientH]->m_cProfile, cTemp);
}

void CGame::GetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256], cBuff2[500];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// tokenÃ€ÃŒ Â°Ã° Ã‡ÃÂ·ÃÃ‡ÃŠÃ€Â» Â¾Ã²Â°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Â»Ã§Â¿Ã«Ã€Ãš Ã€ÃŒÂ¸Â§ 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
		
			ZeroMemory(cBuff2, sizeof(cBuff2));
			wsprintf(cBuff2, "%s Profile: %s", cName, m_pClientList[i]->m_cProfile);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERPROFILE, NULL, NULL, NULL, cBuff2);

			delete pStrTok;
			return;
		}
		// Ã‡Ã¶Ã€Ã§ ÃÂ¢Â¼Ã“ÃÃŸÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}

	delete pStrTok;
	return;
}

void CGame::___RestorePlayerCharacteristics(int iClientH)
{
	int iStr, iDex, iInt, iVit, iMag, iCharisma;
	int iOriginalPoint, iCurPoint, iVerifyPoint, iToBeRestoredPoint;
	int iMax, iA, iB;
	BOOL bFlag;
	char cTxt[120];
	return;
		if (m_pClientList[iClientH] == NULL) return;

	// Â¸Ã•Ã€Ãº Â°ÂªÃ€Â» Â¹Ã©Â¾Ã·Ã‡Ã‘Â´Ã™. 
	iStr = m_pClientList[iClientH]->m_iStr;
	iDex = m_pClientList[iClientH]->m_iDex;
	iInt = m_pClientList[iClientH]->m_iInt;
	iVit = m_pClientList[iClientH]->m_iVit;
	iMag = m_pClientList[iClientH]->m_iMag;
	iCharisma = m_pClientList[iClientH]->m_iCharisma;


	iCurPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
		m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
		m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	iOriginalPoint = (m_pClientList[iClientH]->m_iLevel - 1)*3 + 70;

	iToBeRestoredPoint = iOriginalPoint - iCurPoint;

	// ÂºÂ¹Â±Â¸Ã‡Ã’ Ã‡ÃŠÂ¿Ã¤Â°Â¡ Â¾Ã¸Â´Ã™Â¸Ã© Â±ÃÃˆÂ¯.
	if (iToBeRestoredPoint == 0) return;

	if (iToBeRestoredPoint > 0) {
		// Ã€ÃŒÃÂ¦ iToBeRestoredPoint Â¸Â¸Ã…Â­Ã€Ã‡ Ã†Ã·Ã€ÃÃ†Â®Â¸Â¦ ÂºÂ¹Â±Â¸Ã‡Ã‘Â´Ã™. 
		// Â¸Ã•Ã€Ãº 10 Ã€ÃŒÃ‡ÃÃ€Ã‡ Ã†Ã·Ã€ÃÃ†Â®Â°Â¡ Ã€Ã–Â´Ã™Â¸Ã© Â¿Ã¬Â¼Â±Ã€Ã»Ã€Â¸Â·Ã ÃƒÂ¤Â¿Ã®Â´Ã™. 
		while (1) {
			bFlag = FALSE;

			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < 10)) {
				m_pClientList[iClientH]->m_iStr++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < 10)) {
				m_pClientList[iClientH]->m_iMag++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < 10)) {
				m_pClientList[iClientH]->m_iInt++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < 10)) {
				m_pClientList[iClientH]->m_iDex++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iVit < 10)) {
				m_pClientList[iClientH]->m_iVit++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iCharisma < 10)) {
				m_pClientList[iClientH]->m_iCharisma++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}

			if (bFlag == FALSE)          break;
			if (iToBeRestoredPoint <= 0) break; 
		}

		// Â¸Ã‡Â¼Ã• Â°ÃÃ…Ãµ Â½ÂºÃ…Â³Ã€Ã‡ ÃƒÃ–Â´Ã«Ã„Â¡Â´Ã‚ iMax, StrÃ€ÃŒ iMax/2ÂºÂ¸Â´Ã™ Â³Â·Â´Ã™Â¸Ã© Â±Ã—Â¸Â¸Ã…Â­ Â¿ÃƒÂ¸Â°Â´Ã™. 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[5];

		if (m_pClientList[iClientH]->m_iStr < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iStr == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		// Â¹Â«Â±Ã¢ Â»Ã§Â¿Ã« Â½ÂºÃ…Â³Ã€Ã‡ ÃƒÃ–Â´Ã«Ã„Â¡Â´Ã‚ iMax, DexÂ°Â¡ iMax/2ÂºÂ¸Â´Ã™ Â³Â·Â´Ã™Â¸Ã© Â±Ã—Â¸Â¸Ã…Â­ Â¿ÃƒÂ¸Â°Â´Ã™. 
		iA = m_pClientList[iClientH]->m_cSkillMastery[7];
		iB = m_pClientList[iClientH]->m_cSkillMastery[8];
		if (iA > iB) 
			iMax = iA;
		else iMax = iB;
		iA = m_pClientList[iClientH]->m_cSkillMastery[9];
		if (iA > iMax) iMax = iA;
		iA = m_pClientList[iClientH]->m_cSkillMastery[6];
		if (iA > iMax) iMax = iA;


		if (m_pClientList[iClientH]->m_iDex < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iDex == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		// ÃÃ—Ã€ÂºÃƒÂ´Ã‡ÃÂ±Ã¢ Â½ÂºÃ…Â³Ã€Ã‡ ÃƒÃ–Â´Ã«Ã„Â¡Â´Ã‚ iMax, IntÃ€ÃŒ iMax/2ÂºÂ¸Â´Ã™ Â³Â·Â´Ã™Â¸Ã© Â±Ã—Â¸Â¸Ã…Â­ Â¿ÃƒÂ¸Â°Â´Ã™. 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[19];

		if (m_pClientList[iClientH]->m_iInt < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iInt == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		// Â¸Â¶Â¹Ã½ Â½ÂºÃ…Â³Ã€Ã‡ ÃƒÃ–Â´Ã«Ã„Â¡Â´Ã‚ iMax, MagÃ€ÃŒ iMax/2ÂºÂ¸Â´Ã™ Â³Â·Â´Ã™Â¸Ã© Â±Ã—Â¸Â¸Ã…Â­ Â¿ÃƒÂ¸Â°Â´Ã™. 
		iA = m_pClientList[iClientH]->m_cSkillMastery[3];
		iB = m_pClientList[iClientH]->m_cSkillMastery[4];
		if (iA > iB) 
			iMax = iA;
		else iMax = iB;

		if (m_pClientList[iClientH]->m_iMag < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iMag == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		// Â³Â²Ã€Âº Ã†Ã·Ã€ÃÃ†Â®Â¸Â¦ Â·Â£Â´Ã½Ã‡ÃÂ°Ã” Â¿ÃƒÂ¸Â°Â´Ã™.
		while (iToBeRestoredPoint != 0) {
			switch (iDice(1,6)) {
			case 1:
				if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}
				break;
			case 2:
				if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iVit++;
					iToBeRestoredPoint--;
				}
				break;
			case 3:
				if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}
				break;
			case 4:
				if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}
				break;
			case 5:
				if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}
				break;
			case 6:
				if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iCharisma++;
					iToBeRestoredPoint--;
				}
				break;
			}
		}

		// ÂºÂ¹Â±Â¸Â°Â¡ Â¼ÂºÂ°Ã¸Ã€Ã»Ã€Â¸Â·Ã ÂµÃ‡Â¾ÃºÂ´Ã‚ÃÃ¶ ÃˆÂ®Ã€ÃÃ‡Ã‘Â´Ã™. 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

		if (iVerifyPoint != iOriginalPoint)	{
			wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Minor) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);

			// Â¿Â¡Â·Â¯Â´Ã™. Ã€ÃŒÃ€Ã¼ Â°ÂªÃ€Â¸Â·Ã ÂºÂ¹Â±Â¸.
			m_pClientList[iClientH]->m_iStr = iStr;
			m_pClientList[iClientH]->m_iDex = iDex;
			m_pClientList[iClientH]->m_iInt = iInt;
			m_pClientList[iClientH]->m_iVit = iVit;
			m_pClientList[iClientH]->m_iMag = iMag;
			m_pClientList[iClientH]->m_iCharisma = iCharisma;
		}
		else {
			wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Minor) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
	else {
		// Ã‡Ã˜Ã…Â·Ã€ÃŒÂ³Âª Â¿Â¡Â·Â¯Â¿Â¡ Ã€Ã‡Ã‡Ã˜Â¼Â­ Ã†Â¯Â¼ÂºÃ„Â¡Â°Â¡ Â¿Ã€Â¹Ã¶ÂµÃˆ Â°Ã¦Â¿Ã¬Ã€ÃŒÂ´Ã™. Â¿Ã€Â¹Ã¶ÂµÃˆ Ã†Ã·Ã€ÃÃ†Â®Â¸Â¸Ã…Â­ Â»Â«Â´Ã™. iToBeRestoredPointÂ°Â¡ Â¸Â¶Ã€ÃŒÂ³ÃŠÂ½ÂºÂ»Ã³Ã…Ã‚! 

		// Â¸Ã•Ã€Ãº Ã†Â¯Â¼ÂºÃ„Â¡ ÃÂ¦Ã‡Ã‘Ã„Â¡Â¸Â¦ Â¿Ã€Â¹Ã¶Ã‡Ã‘ Â°ÂªÃ€Â» Â»Â«Â´Ã™.
		while (1) {
			bFlag = FALSE;
			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iStr--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iDex--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iVit--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iInt--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iMag--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iCharisma--;
				iToBeRestoredPoint++;
			}

			if (bFlag == FALSE)	break;
			if (iToBeRestoredPoint >= 0) break;
		}

		if (iToBeRestoredPoint < 0) {
			// Â³Â²Ã€Âº Ã†Ã·Ã€ÃÃ†Â® Â¸Â¸Ã…Â­ Â·Â£Â´Ã½Ã‡ÃÂ°Ã” Â¼Â±Ã…ÃƒÂµÃˆ Ã†Â¯Â¼ÂºÃ„Â¡Ã€Ã‡ Â°ÂªÃ€Â» Â³Â»Â¸Â°Â´Ã™.
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1,6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr > 10) {
						m_pClientList[iClientH]->m_iStr--;
						iToBeRestoredPoint++;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit > 10) {
						m_pClientList[iClientH]->m_iVit--;
						iToBeRestoredPoint++;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex > 10) {
						m_pClientList[iClientH]->m_iDex--;
						iToBeRestoredPoint++;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag > 10) {
						m_pClientList[iClientH]->m_iMag--;
						iToBeRestoredPoint++;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt > 10) {
						m_pClientList[iClientH]->m_iInt--;
						iToBeRestoredPoint++;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma > 10) {
						m_pClientList[iClientH]->m_iCharisma--;
						iToBeRestoredPoint++;
					}
					break;
				}
			}
		}
		else {
			// Â°Ã¨Â»ÃªÃ€Â» Ã‡ÃŸÂ´ÃµÂ´Ã Â´Ã™Â½Ãƒ Â°ÂªÃ€ÃŒ Â¿Ã€Â¹Ã¶ÂµÃ‡Â¾ÃºÂ´Ã™. Ã€ÃŒÂ·Â²Â¼Ã¶Â°Â¡ Ã€Ã–Ã€Â»Â±Ã®?
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1,6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iStr++;
						iToBeRestoredPoint--;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iVit++;
						iToBeRestoredPoint--;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iDex++;
						iToBeRestoredPoint--;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iMag++;
						iToBeRestoredPoint--;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iInt++;
						iToBeRestoredPoint--;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iCharisma++;
						iToBeRestoredPoint--;
					}
					break;
				}
			}
		}

		// ÂºÂ¹Â±Â¸Â°Â¡ Â¼ÂºÂ°Ã¸Ã€Ã»Ã€Â¸Â·Ã ÂµÃ‡Â¾ÃºÂ´Ã‚ÃÃ¶ ÃˆÂ®Ã€ÃÃ‡Ã‘Â´Ã™. 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

		if (iVerifyPoint != iOriginalPoint)	{
			wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Over) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);

			// Â¿Â¡Â·Â¯Â´Ã™. Â±Ã—Â·Â¯Â³Âª Ã€ÃŒÃ€Ã¼ Â°ÂªÃ€Â¸Â·Ã ÂºÂ¹Â±Â¸Ã‡Ã’ Â¼Ã¶Â´Ã‚ Â¾Ã¸Â´Ã™. ÃƒÃŠÂ°ÃºÃ‡ÃÂ¹Ã‡Â·Ã
			/*
			m_pClientList[iClientH]->m_iStr = iStr;
			m_pClientList[iClientH]->m_iDex = iDex;
			m_pClientList[iClientH]->m_iInt = iInt;
			m_pClientList[iClientH]->m_iVit = iVit;
			m_pClientList[iClientH]->m_iMag = iMag;
			m_pClientList[iClientH]->m_iCharisma = iCharisma;
			*/
		}
		else {
			wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Over) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
}

void CGame::CalcTotalItemEffect(int iClientH, int iEquipItemID, BOOL bNotify)
{
 register short sItemIndex;
 int  i, iArrowIndex, iPrevSAType, iTemp;
 char cEquipPos;
 double dV1, dV2, dV3;
 DWORD  dwSWEType, dwSWEValue;
 short  sTemp;

   	if (m_pClientList[iClientH] == NULL) return;

	if ( (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]   != -1) &&
		 (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) ) {
		
		// Àß¸øµÈ ¹«±â ÀåÂø Á¶ÇÕÀÌ´Ù. µÑ Áß ÇÏ³ª¸¦ ³»·Á ³õ´Â´Ù. 
		if (m_pClientList[iClientH]->m_pItemList[ m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] ] != NULL) {
			// ÇÑ¼Õ °ËÀÇ ÀåÂø »óÅÂ¸¦ ÇØÁ¦ÇÑ´Ù. 
			m_pClientList[iClientH]->m_bIsItemEquipped[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]] = FALSE;
			m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] = -1;
		}
	}

	m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
	m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;  

	m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
	m_pClientList[iClientH]->m_cAttackBonus_L      = 0;

	m_pClientList[iClientH]->m_iHitRatio = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = m_pClientList[iClientH]->m_iDex * 2;
	m_pClientList[iClientH]->m_iDamageAbsorption_Shield = 0;
	
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
	m_pClientList[iClientH]->m_iDamageAbsorption_Armor[i]  = 0;

	m_pClientList[iClientH]->m_iManaSaveRatio  = 0;
	m_pClientList[iClientH]->m_iAddResistMagic = 0;

	m_pClientList[iClientH]->m_iAddPhysicalDamage = 0;
	m_pClientList[iClientH]->m_iAddMagicalDamage  = 0;

	m_pClientList[iClientH]->m_bIsLuckyEffect  = FALSE;
	m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = -1;
	m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = 0;

	m_pClientList[iClientH]->m_iAddAbsAir   = 0;	// ¼Ó¼ºº° ´ë¹ÌÁö Èí¼ö
	m_pClientList[iClientH]->m_iAddAbsEarth = 0;
	m_pClientList[iClientH]->m_iAddAbsFire  = 0;
	m_pClientList[iClientH]->m_iAddAbsWater = 0;

	m_pClientList[iClientH]->m_iCustomItemValue_Attack  = 0;
	m_pClientList[iClientH]->m_iCustomItemValue_Defense = 0;

	m_pClientList[iClientH]->m_iMinAP_SM = 0;
	m_pClientList[iClientH]->m_iMinAP_L  = 0;

	m_pClientList[iClientH]->m_iMaxAP_SM = 0;
	m_pClientList[iClientH]->m_iMaxAP_L  = 0;

	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = 0;	// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 4-ÀúÁÖÀÇ
	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = 0;	// Èñ±Í ¾ÆÀÌÅÛ È¿°ú °ª

	m_pClientList[iClientH]->m_iAddHP = m_pClientList[iClientH]->m_iAddSP = m_pClientList[iClientH]->m_iAddMP = 0; 
	m_pClientList[iClientH]->m_iAddAR = m_pClientList[iClientH]->m_iAddPR = m_pClientList[iClientH]->m_iAddDR = 0;
	m_pClientList[iClientH]->m_iAddMR = m_pClientList[iClientH]->m_iAddAbsPD = m_pClientList[iClientH]->m_iAddAbsMD = 0;
	m_pClientList[iClientH]->m_iAddCD = m_pClientList[iClientH]->m_iAddExp = m_pClientList[iClientH]->m_iAddGold = 0;	
	
	iPrevSAType = m_pClientList[iClientH]->m_iSpecialAbilityType;

	m_pClientList[iClientH]->m_iSpecialAbilityType     = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityLastSec  = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = 0;

	m_pClientList[iClientH]->m_iAddTransMana = 0;
	m_pClientList[iClientH]->m_iAddChargeCritical = 0;
	
	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	// Âø¿ëÇÏÁö ¾Ê¾Æµµ È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ.
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
				// ¼ö¸íÀÌ ÀÖ¾î¾ß È¿°ú°¡ ÀÖ´Ù.
				m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		}
	}
	
	// Âø¿ëÀ» ÇØ¾ß È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ 
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  ((m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) && 
		 (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)) {

		cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		
		case DEF_ITEMEFFECTTYPE_MAGICDAMAGESAVE:
			// ¸¶¹ı µ¥¹ÌÁö Àı°¨ ¾ÆÀÌÅÛ. ÀÎµ¦½º¸¦ ÀúÀåÇÑ´Ù.
			m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = sItemIndex;
			break;
		
		case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
		case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
		case DEF_ITEMEFFECTTYPE_ATTACK:
			// ¹«±â ÀåÂø È¿°ú
			m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
			m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
			m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
			m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;

			// v2.05 ¹«±âÀÇ Æ¯¼ºÄ¡ Ãß°¡ 
			iTemp = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
			//testcode
			//wsprintf(G_cTxt, "Add Damage: %d", iTemp);
			//PutLogList(G_cTxt);

			// °íÁ¤ ´ë¹ÌÁö Ãß°¡
			m_pClientList[iClientH]->m_iAddPhysicalDamage += iTemp;
			m_pClientList[iClientH]->m_iAddMagicalDamage  += iTemp;
						
			// °ø°İ¹«±âÀÇ ÇØ´ç ½ºÅ³¸¸Å­ÀÇ ¸íÁß·üÀ» ´õÇÑ´Ù. 
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			
			// v1.432 »ç¿ëÇÏÁö ¾Ê´Â´Ù. ¹«±âÀÇ °ø°İ´ë»óº° ¸íÁß·ü °¡°¨Ä¡¸¦ ´õÇÑ´Ù.
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
			// ÇÃ·¹ÀÌ¾î°¡ »ç¿ëÇÏ´Â ¹«±âÀÇ ½ºÅ³À» ÀúÀåÇÑ´Ù. 
			m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill;
			
			// v1.41 Custom-Made ¾ÆÀÌÅÛÀÌ¶ó¸é È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°İ¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
				m_pClientList[iClientH]->m_iCustomItemValue_Attack += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				// ¿¡·¯ º¸Á¤¿ë 
				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = 100;

				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < -100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = -100;

				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 0) {
					// ¾ç¼ö¸é ¹«±âÀÇ Å¸°İÄ¡ ÃÖ¼Ò°ªÀÌ ÃÖ´ë 5±îÁö ¿Ã¶ó°£´Ù.
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMinAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM + 
														   m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;
					
					m_pClientList[iClientH]->m_iMinAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L + 
														   m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;

					// ¼öÄ¡ Á¶Á¤ 
					if (m_pClientList[iClientH]->m_iMinAP_SM < 1) m_pClientList[iClientH]->m_iMinAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMinAP_L < 1)  m_pClientList[iClientH]->m_iMinAP_L = 1;

					// ÃÖ¼Ò°ªÀÌ ÃÖ´ë°ªº¸´Ù Å©¸é ÃÖ´ë°ª¸¸Å­ 
					if (m_pClientList[iClientH]->m_iMinAP_SM > (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMinAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					
					if (m_pClientList[iClientH]->m_iMinAP_L > (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMinAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
					
					//testcode
					//wsprintf(G_cTxt, "MinAP: %d %d +(%d)", m_pClientList[iClientH]->m_iMinAP_SM, m_pClientList[iClientH]->m_iMinAP_L, (int)dV1);
					//PutLogList(G_cTxt);
				}
				else if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < 0) {
					// À½¼ö¸é ¹«±âÀÇ Å¸°İÄ¡ ÃÖ´ë°ªÀÌ ÃÖ´ë 5±îÁö ³»·Á°£´Ù.
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMaxAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM 
														   + m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;
					
					m_pClientList[iClientH]->m_iMaxAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L 
														   + m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;
					
					// ¼öÄ¡ Á¶Á¤ 
					if (m_pClientList[iClientH]->m_iMaxAP_SM < 1) m_pClientList[iClientH]->m_iMaxAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMaxAP_L < 1)  m_pClientList[iClientH]->m_iMaxAP_L = 1;

					// ÃÖ´ë°ªÀÌ ÃÖ¼Ò°ªº¸´Ù ÀÛÀ¸¸é ÃÖ¼Ò°ª¸¸Å­ 
					if (m_pClientList[iClientH]->m_iMaxAP_SM < (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMaxAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					
					if (m_pClientList[iClientH]->m_iMaxAP_L < (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMaxAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
					
					//testcode
					//wsprintf(G_cTxt, "MaxAP: %d %d +(%d)", m_pClientList[iClientH]->m_iMaxAP_SM, m_pClientList[iClientH]->m_iMaxAP_L, (int)dV1);
					//PutLogList(G_cTxt);
				}
			}

			// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Main È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°İ¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				
				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				// 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 4-ÀúÁÖÀÇ 
				// 5-¹ÎÃ¸ÀÇ 6-°¡º­¿î 7-¿¹¸®ÇÑ 8-°­È­µÈ 9-°í´ë¹®¸íÀÇ 10-¸¶¹ı ¼º°øÀÇ
				m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = (int)dwSWEType;	
				m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = (int)dwSWEValue;

				switch (dwSWEType) {
				case 7: // ¿¹¸®ÇÑ 
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;

				case 9: // °í´ë¹®¸íÀÇ
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;
				}
			}

			// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Sub È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°İ¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
				
				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				//Ãß°¡ µ¶¼ºÀúÇ×(1), Ãß°¡ ¸íÁß°ª(2), Ãß°¡ ¹æ¾î°ª(3), HP È¸º¹·® Ãß°¡(4), SP È¸º¹·® Ãß°¡(5)
				//MP È¸º¹·® Ãß°¡(6), Ãß°¡ ¸¶¹ıÀúÇ×(7), ¹°¸® ´ë¹ÌÁö Èí¼ö(8), ¸¶¹ı ´ë¹ÌÁö Èí¼ö(9)
				//¿¬Å¸ ´ë¹ÌÁö Ãß°¡(10), ´õ ¸¹Àº °æÇèÄ¡(11), ´õ¸¹Àº Gold(12)
				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break;
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break;
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break;
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break;
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (int)dwSWEValue*3; break;
				case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; break;
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;
				}

				// v2.04 Æ¯¼ºÄ¡ Á¦ÇÑÀ» ºÙÀÓ.
				switch (dwSWEType) {
				case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break;
				}
			}

			// ÀÏ¹İ °ø°İ ÀÌ¿ÜÀÇ È¿°ú¸¦ ¼³Á¤.
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
				// ÃÖ´ë HP °¨¼Ò È¿°ú
				m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
				// ¸¶³ª Àı¾à È¿°ú: ¸¶³ª Àı°¨·üÀº ÃÖ´ë 80%
				m_pClientList[iClientH]->m_iManaSaveRatio    += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
				// Ãß°¡ ¹°¸® ¹æ¾î ´É·Â È¿°ú 
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
				// Æ¯¼ö ´É·Â Á¾·ù
				m_pClientList[iClientH]->m_iSpecialAbilityType    = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				// Æ¯¼ö ´É·Â Áö¼Ó ½Ã°£
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				// ÀåÂø À§Ä¡ ±â¾ïÇØ ³õ´Â´Ù.
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
								
				// Æ¯¼ö ´É·Â ¼³Á¤µÊÀ» ¾Ë·ÁÁØ´Ù.
				if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_ADDEFFECT:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// Ãß°¡ ¸¶¹ı ÀúÇ× Áõ°¡ 
				m_pClientList[iClientH]->m_iAddResistMagic += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 2:
				// ¸¶³ª Àı¾à È¿°ú 
				m_pClientList[iClientH]->m_iManaSaveRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				// ¸¶³ª Àı°¨·üÀº ÃÖ´ë 80%
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				break;

			case 3:
				// °íÁ¤ ¹°¸® ´ë¹ÌÁö È¿°ú. ¸ğµç ¹°¸® °ø°İ¿¡ ´ëÇØ¼­ °íÁ¤ ´ë¹ÌÁö°¡ ºÙ´Â´Ù. 
				m_pClientList[iClientH]->m_iAddPhysicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 4:
				// Ãß°¡ ¹°¸® ¹æ¾î·Â 
				m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 5:
				// Çà¿î È¿°ú?
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 != 0)
					 m_pClientList[iClientH]->m_bIsLuckyEffect = TRUE;
				else m_pClientList[iClientH]->m_bIsLuckyEffect = FALSE;
				break;

			case 6:
				// °íÁ¤ ¸¶¹ı ´ë¹ÌÁö È¿°ú. ¸ğµç ¸¶¹ı °ø°İ¿¡ ´ëÇØ¼­ °íÁ¤ ´ë¹ÌÁö°¡ ºÙ´Â´Ù. 
				m_pClientList[iClientH]->m_iAddMagicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 7:
				m_pClientList[iClientH]->m_iAddAbsAir += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 8:
				m_pClientList[iClientH]->m_iAddAbsEarth += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 9:
				m_pClientList[iClientH]->m_iAddAbsFire += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 10:
				// ¹°°è¿­ °ø°İ ´ë¹ÌÁö °¨¼Ò´Â ¾ó¾îºÙÀ» È®·üÀÇ °¨¼ÒÈ¿°ú°¡ ÀÖ´Ù. (2¹è·Î È®·ü °è»êµÊ)
				m_pClientList[iClientH]->m_iAddAbsWater += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 11:
				// µ¶¼º ÀúÇ×.
				m_pClientList[iClientH]->m_iAddPR += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 12:
				m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;
			}
			break;
			
		case DEF_ITEMEFFECTTYPE_ATTACK_ARROW:
			// È­»ìÀ» ÇÊ¿ä·Î ÇÏ´Â ¹«±â(È°·ù)
			// ¹«±âÀÇ °ø°İÈ¿°ú´Â ¾î¶² È­»ìÀÌ ¼±ÅÃµÇ´À³Ä¿¡ µû¶ó ´Ş¶óÁø´Ù. ¾ÆÀÌÅÛÁß È­»ìÀ» Ã£¾Æ ÇÒ´çÇÑ´Ù.
			if ( (m_pClientList[iClientH]->m_cArrowIndex != -1) && 
				 (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cArrowIndex] == NULL) ) {
				// ArrowIndex¿¡ È­»ìÀÌ ¾ø´Ù. (ºñ¾îÀÖ´Â ¾ÆÀÌÅÛ) 
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
			}
			else if (m_pClientList[iClientH]->m_cArrowIndex == -1) 
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
			
			if (m_pClientList[iClientH]->m_cArrowIndex == -1) {
				// È­»ìÀÌ ¾ø´Ù.
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
				m_pClientList[iClientH]->m_cAttackBonus_L      = 0;
			}
			else {
				iArrowIndex = m_pClientList[iClientH]->m_cArrowIndex;
				/*
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue1;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue3;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue4;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue5;
				m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue6;
				*/
				// v2.12 È°ÀÇ Å¸°İÄ¡´Â È­»ìÀÌ ¾Æ´Ï¶ó È° ÀÚÃ¼·Î ¹Ù²ï´Ù.
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
				m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
			}
			
			// °ø°İ¹«±âÀÇ ÇØ´ç ½ºÅ³¸¸Å­ÀÇ ¸íÁß·üÀ» ´õÇÑ´Ù. 
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			// v1.432 »ç¿ëÇÏÁö ¾Ê´Â´Ù. ¹«±âÀÇ °ø°İ´ë»óº° ¸íÁß·ü °¡°¨Ä¡¸¦ ´õÇÑ´Ù.
			// m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
			// m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
			break;
			
		case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
		case DEF_ITEMEFFECTTYPE_DEFENSE:
			// ¹æ¾î±¸ ÀåÂø È¿°ú.
			// ¹æ¾î±¸°¡ ÀåÂøµÇ¾ú´Ù.	ÇöÀç Defense Ratio¿¡¼­ ¹æ¾î±¸ÀÇ ´É·ÂÄ¡¸¸Å­ÀÇ ¼ö¸¦ ´õÇÑ´Ù.
			m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
			
			// v1.432 »ç¿ëÇÏÁö ¾Ê´Â´Ù.
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
			
			// v1.41 Custom-Made ¾ÆÀÌÅÛÀÌ¶ó¸é È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. 
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
				m_pClientList[iClientH]->m_iCustomItemValue_Defense += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				
				// º¸³Ê½º ¹æ¾î·Â °è»ê 
				dV2 = (double)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				dV3 = (double)m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
				dV1 = (double)(dV2 / 100.0f)*dV3;
					
				dV1 = dV1 / 2.0f;
				// ÀÌ °ªÀ» ´õÇÑ´Ù. 
				m_pClientList[iClientH]->m_iDefenseRatio += (int)dV1;
				if (m_pClientList[iClientH]->m_iDefenseRatio <= 0) m_pClientList[iClientH]->m_iDefenseRatio = 1;

				//testcode
				//wsprintf(G_cTxt, "Custom-Defense: %d", (int)dV1);
				//PutLogList(G_cTxt);
			}

			// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Main È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°İ¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				
				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				// 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 4-ÀúÁÖÀÇ 
				// 5-¹ÎÃ¸ÀÇ 6-°¡º­¿î 7-¿¹¸®ÇÑ 8-°­È­µÈ 9-°í´ë¹®¸íÀÇ 10-¸¶¹ı¼º°øÀÇ 11-¸¶³ªº¯È¯ÀÇ 12-ÇÊ»ìÃæÀüÀÇ
			
				switch (dwSWEType) {
				case 7: // ¿¹¸®ÇÑ 
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;

				case 9: // °í´ë¹®¸íÀÇ
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;

				// v2.04 
				case 11: // ¸¶³ª º¯È¯ÀÇ 
					m_pClientList[iClientH]->m_iAddTransMana += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddTransMana > 13) m_pClientList[iClientH]->m_iAddTransMana = 13;
					break;

				case 12: // ÇÊ»ì ÃæÀüÀÇ 
					m_pClientList[iClientH]->m_iAddChargeCritical += dwSWEValue;
					if (m_pClientList[iClientH]->m_iAddChargeCritical > 20) m_pClientList[iClientH]->m_iAddChargeCritical = 20;
					break;
				}
			}

			// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Sub È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°İ¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
				
				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				//Ãß°¡ µ¶¼ºÀúÇ×(1), Ãß°¡ ¸íÁß°ª(2), Ãß°¡ ¹æ¾î°ª(3), HP È¸º¹·® Ãß°¡(4), SP È¸º¹·® Ãß°¡(5)
				//MP È¸º¹·® Ãß°¡(6), Ãß°¡ ¸¶¹ıÀúÇ×(7), ¹°¸® ´ë¹ÌÁö Èí¼ö(8), ¸¶¹ı ´ë¹ÌÁö Èí¼ö(9)
				//¿¬Å¸ ´ë¹ÌÁö Ãß°¡(10), ´õ ¸¹Àº °æÇèÄ¡(11), ´õ¸¹Àº Gold(12)
				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break;
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break;
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break;
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break;
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (int)dwSWEValue*3; break;
				case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; break;
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;
				}

				// v2.04 Æ¯¼ºÄ¡ Á¦ÇÑÀ» ºÙÀÓ.
				switch (dwSWEType) {
				case 9: if (m_pClientList[iClientH]->m_iAddAbsMD > 80) m_pClientList[iClientH]->m_iAddAbsMD = 80; break; // ¸¶¹ı ´ë¹ÌÁö Èí¼ö ÃÖ´ë 80%
				}
			}

			switch ( cEquipPos ) {
			case DEF_EQUIPPOS_LHAND:
				// ¹æ¾î±¸ Áß ¹æÆĞ°¡ ÀåÂø µÇ¾ú´Ù. 
				// ¹æÆĞ¿¡ ÀÇÇÑ Ãæ°İ Èí¼ö È¿°ú ÇÒ´çÇÑ´Ù. ¹æ¾î°ªÀÇ 70% ¼öÁØ 
				m_pClientList[iClientH]->m_iDamageAbsorption_Shield	= (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) - (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1)/3;
				break;
			default:
				// °©¿Ê¿¡ ÀÇÇÑ Ãæ°İ Èí¼ö È¿°ú¸¦ ´õÇÑ´Ù. ¹æ¾î°ªÀÇ 70% ¼öÁØ <- v1.43 100%·Î º¯°æµÇ¾ú´Ù. V2!
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				break;
			}

			// ÀÏ¹İ °ø°İ ÀÌ¿ÜÀÇ È¿°ú¸¦ ¼³Á¤.
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
				// Æ¯¼ö ´É·Â Á¾·ù
				m_pClientList[iClientH]->m_iSpecialAbilityType = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				// Æ¯¼ö ´É·Â Áö¼Ó ½Ã°£
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				// ÀåÂø À§Ä¡ ±â¾ïÇØ ³õ´Â´Ù.
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
				
				// Æ¯¼ö ´É·Â ¼³Á¤µÊÀ» ¾Ë·ÁÁØ´Ù.
				if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
				break;
			}
			break;
		}
	}

	//v1.432
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) && (bNotify == TRUE)) {
		// Æ¯¼ö ´É·ÂÀÌ ÇØÁ¦µÇ¾ú´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 4, NULL, NULL, NULL);
		// ¸¸¾à Æ¯¼ö ´É·Â »ç¿ë ÁßÀÌ¾ú´Ù¸é ¿Ü¸ğµµ º¯È­ÇÏ¸ç »ç¿ëµµ Á¾·á.
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) {
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
			// ´ÙÀ½ »ç¿ë °¡´É ½Ã°£À» ÀÔ·ÂÇÑ´Ù.
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			// È¿°ú ºñÆ® Å¬¸®¾î
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			// ¿ÜÇüÀÌ º¯ÇßÀ½À» ¾Ë¸°´Ù.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		}
	}
	
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType != 0) && 
		(iPrevSAType != m_pClientList[iClientH]->m_iSpecialAbilityType) && (bNotify == TRUE)) {
		// Æ¯¼ö ´É·Â »ç¿ë µµÁß¿¡ Æ¯¼ö ´É·ÂÀ» ¹Ù²Ù¸é ´É·Â »ç¿ëÀÌ ¸ØÃá´Ù.
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) {
			// »ç¿ë½Ã°£ÀÌ ´Ù µÇ¾ú´Ù.
			SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
			// ´ÙÀ½ »ç¿ë °¡´É ½Ã°£À» ÀÔ·ÂÇÑ´Ù.
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			// È¿°ú ºñÆ® Å¬¸®¾î
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			// ¿ÜÇüÀÌ º¯ÇßÀ½À» ¾Ë¸°´Ù.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		}
	}
}

int CGame::_iGetPlayerNumberOnSpot(short dX, short dY, char cMapIndex, char cRange)
{
 register int ix, iy, iSum = 0;
 short sOwnerH;
 char  cOwnerType;

	for (ix = dX - cRange; ix <= dX + cRange; ix++)
	for (iy = dY - cRange; iy <= dY + cRange; iy++) {
		m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER))
			iSum++;
	}

	return iSum;
}

void CGame::RequestAdminUserMode(int iClientH, char * pData)
{
	// Â¿Ã®Â¿ÂµÃ€Ãš Â¸Ã°ÂµÃ¥Â¸Â¦ ÃˆÂ®Ã€ÃÃ‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã˜Â¼Â­Â´Ã‚ Ã€ÃÂ´Ãœ Ã€ÃŒ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Ã€Ã¼Â¼Ã›Ã‡ÃÂ´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¸Â¦ Â°Â®Â°Ã­ Ã€Ã–Â¾Ã®Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
	// Â¶Ã‡Ã‡Ã‘ Â³Â¯Ã‚Â¥Â¸Â¦ ÃÂ¶Ã‡Ã•Ã‡Ã˜Â¼Â­ Â»Ã½Â¼ÂºÂµÃ‡Â´Ã‚ ÃˆÂ®Ã€Ã Ã„ÃšÂµÃ¥Â°Â¡ Ã€ÃÃ„Â¡Ã‡Ã˜Â¾ÃŸ Ã‡Ã‘Â´Ã™. 

}

BOOL CGame::bAnalyzeCriminalAction(int iClientH, short dX, short dY, BOOL bIsCheck)
{
 int   iNamingValue, tX, tY;
 short sOwnerH;
 char  cOwnerType, cName[11], cNpcName[21];
 char  cNpcWaypoint[11];

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return FALSE;
	if (m_bIsCrusadeMode == TRUE) return FALSE;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

	if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL)) {
		if (_bGetIsPlayerHostile(iClientH, sOwnerH) != TRUE) {
			if (bIsCheck == TRUE) return TRUE;

			ZeroMemory(cNpcName, sizeof(cNpcName));
			if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
			else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else  if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0) 
				strcpy(cNpcName, "Guard-Neutral");

			iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {

			}
			else {
				ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
				ZeroMemory(cName, sizeof(cName));
			   	wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
				
				tX = (int)m_pClientList[iClientH]->m_sX;
				tY = (int)m_pClientList[iClientH]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					bSetNpcAttackMode(cName, iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
				}
			}
		}
	}
	return FALSE;
}

BOOL CGame::_bGetIsPlayerHostile(int iClientH, int sOwnerH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[sOwnerH]  == NULL) return FALSE;

	// Ã€ÃšÂ±Ã¢ Ã€ÃšÂ½Ã…Â¿Â¡ Â´Ã«Ã‡Ã‘ Â°Ã¸Â°ÃÃ€Âº Â¹Ã¼ÃÃ‹Â¶Ã³ ÂºÂ¼ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
	if (iClientH == sOwnerH) return TRUE;

	if (m_pClientList[iClientH]->m_cSide == 0) {
		// Â°Ã¸Â°ÃÃ€ÃšÂ´Ã‚ Â¿Â©Ã‡Ã Ã€ÃšÃ€ÃŒÂ´Ã™.
		// Â»Ã³Â´Ã«Â¹Ã¦Ã€ÃŒ Â¹Ã¼ÃÃ‹Ã€ÃšÃ€ÃŒÂ¸Ã© Ã€Ã»Â¼ÂºÃ€ÃŒÂ¸Ã§ Â±Ã— Ã€ÃŒÂ¿ÃœÂ¿Â¡Â´Ã‚ Â¾Ã†Â´ÃÂ´Ã™. 
		if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 return TRUE;
		else return FALSE;
	}
	else {
		// Â°Ã¸Â°ÃÃ€ÃšÂ´Ã‚ Â¼Ã’Â¼Ã“ Â¸Â¶Ã€Â»Ã€Â» Â°Â®Â°Ã­ Ã€Ã–Â´Ã™. 
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) {
			// Â¼Â­Â·Ã Â»Ã§Ã€ÃŒÂµÃ¥Â°Â¡ Â´Ã™Â¸Â£Â´Ã™. 
			if (m_pClientList[sOwnerH]->m_cSide == 0) {
				if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
				 	 return TRUE;
				else return FALSE;
			}
			else return TRUE;
		}
		else {
			if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 	 return TRUE;
			else return FALSE;
		}
	}

	return FALSE;
}

void CGame::bSetNpcAttackMode(char * cName, int iTargetH, char cTargetType, BOOL bIsPermAttack)
{
 register int i, iIndex;
	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, cName, 5) == 0) ) {
		iIndex = i;
		goto NEXT_STEP_SNAM1;

		//testcode
		//PutLogList("bSetNpcAttackMode - Npc found");
	}
	// Â°Â°Ã€Âº Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ NPCÂ°Â¡ Â¾Ã¸Â´Ã™.
	return;

NEXT_STEP_SNAM1:;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == NULL) return;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iTargetH] == NULL) return;
		break;
	}

	// Â¸Ã±Ã‡Â¥Â¹Â°Ã€Â» Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™. 
	m_pNpcList[iIndex]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
	m_pNpcList[iIndex]->m_sBehaviorTurnCount = 0;		
	m_pNpcList[iIndex]->m_iTargetIndex = iTargetH;
	m_pNpcList[iIndex]->m_cTargetType  = cTargetType;

	// Â¿ÂµÂ±Â¸ Â°Ã¸Â°Ã Â¸Ã°ÂµÃ¥ Â¿Â©ÂºÃ Â¼Â³ÃÂ¤ 
	m_pNpcList[iIndex]->m_bIsPermAttackMode = bIsPermAttack;

	//testcode
	//PutLogList("bSetNpcAttackMode - complete");
}


void CGame::PoisonEffect(int iClientH, int iV1)
{
 int iPoisonLevel, iDamage, iPrevHP, iProb;

	// ÃÃŸÂµÂ¶Ã€Â¸Â·Ã ÃÃ—ÃÃ¶Â´Ã‚ Â¾ÃŠÂ´Ã‚Â´Ã™. Â´Ã™Â¸Â¸ ÃƒÂ¼Â·Ã‚Ã€ÃŒ Â°Ã¨Â¼Ã“ Â±Ã¯Ã€ÃŒÂ°Ã­ ÃƒÃ–Â¼Ã’ 1Â¸Â¸ Â³Â²Â´Ã‚Â´Ã™. 
	if (m_pClientList[iClientH] == NULL)     return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	iPoisonLevel = m_pClientList[iClientH]->m_iPoisonLevel;

	iDamage = iDice(1, iPoisonLevel);
	
	iPrevHP = m_pClientList[iClientH]->m_iHP;
	m_pClientList[iClientH]->m_iHP -= iDamage;
	if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 1;

	if (iPrevHP != m_pClientList[iClientH]->m_iHP)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
		

	// ÂµÂ¶Â¼Âº Ã€ÃºÃ‡Ã— ÃˆÂ®Â·Ã¼Â·Ã ÃÃŸÂµÂ¶Ã€ÃŒ Ã‡Â®Â¸Â± Â¼Ã¶ Ã€Ã–Â´Ã™.
	iProb = m_pClientList[iClientH]->m_cSkillMastery[23] -10 +m_pClientList[iClientH]->m_iAddPR;
	if (iProb <= 10) iProb = 10;
	if (iDice(1,100) <= iProb) {
		m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
		// ÃÃŸÂµÂ¶Ã€ÃŒ Ã‡Â®Â·ÃˆÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
		SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE); // remove poison aura after effect complete
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
	}
}
BOOL CGame::bCheckResistingPoisonSuccess(short sOwnerH, char cOwnerType)
{
 int iResist, iResult;
	
	// ÂµÂ¶Â¼Âº Ã€ÃºÃ‡Ã—Ã€ÃŒ Â¼ÂºÂ°Ã¸Ã‡ÃŸÂ´Ã‚ÃÃ¶Â¸Â¦ Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™. 
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return FALSE;
		iResist = m_pClientList[sOwnerH]->m_cSkillMastery[23] +m_pClientList[sOwnerH]->m_iAddPR;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return FALSE;
		iResist = 0;
		break;
	}

	iResult = iDice(1, 100);
  	if (iResult >= iResist) // ÂµÂ¶Â¼Âº Ã€ÃºÃ‡Ã— Â½Ã‡Ã†Ã. ÃÃŸÂµÂ¶ÂµÃˆÂ´Ã™.
		return FALSE;

	// ÂµÂ¶Â¼Âº Ã€ÃºÃ‡Ã— Â¼ÂºÂ°Ã¸. Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¶Ã³Â¸Ã© Â½ÂºÃ…Â³Ã€Â» Â¿ÃƒÂ¸Â°Â´Ã™. 
	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sOwnerH, 23, 1);

	return TRUE;
}

BOOL CGame::bCheckBadWord(char * pString)
{
 char * cp;

	// Â½ÂºÃ†Â®Â¸ÂµÃ€Â» Â°Ã‹Â»Ã¶Ã‡ÃÂ¸Ã§ Â¿Ã¥Â¼Â³Ã€ÃŒ Ã€Ã–Â´Ã‚ÃÃ¶Â¸Â¦ ÃƒÂ£Â´Ã‚Â´Ã™. 
	cp = pString;
	while (*cp != NULL) {
		
		cp++;
	}

	return FALSE;
}

void CGame::CheckDayOrNightMode()
{
 SYSTEMTIME SysTime;	
 char cPrevMode;
 int  i;

	if (m_bManualTime = TRUE) return;

	// Ã‡Ã¶Ã€Ã§ Â½ÃƒÂ°Â£Â¿Â¡ ÂµÃ»Â¶Ã³ Â³Â· ÃˆÂ¤Ã€Âº Â¹Ã£Ã€Â» Â°Ã¡ÃÂ¤Ã‡Ã‘Â´Ã™. 
	// ÃÃ–, Â¾ÃŸÂ°Â£ Â¸Ã°ÂµÃ¥ Â¼Â³ÃÂ¤ 
	cPrevMode = m_cDayOrNight;
 
	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= DEF_NIGHTTIME) 
		 m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	if (cPrevMode != m_cDayOrNight) {
		// ÃÃ–, Â¾ÃŸÂ°Â£ Â¸Ã°ÂµÃ¥Â°Â¡ ÂºÂ¯Â°Ã¦ÂµÃ‡Â¾ÃºÂ´Ã™. ÃÃ–, Â¾ÃŸÂ°Â£ Â¸Ã°ÂµÃ¥Ã€Ã‡ Â¿ÂµÃ‡Ã¢Ã€Â» Â¹ÃÂ´Ã‚ Â¸ÃŠÂ¿Â¡ ÃÂ¸Ã€Ã§Ã‡ÃÂ´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®ÂµÃ©Â¿Â¡Â°Ã” Â¾Ã‹Â¸Â°Â´Ã™. 
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			if ((m_pClientList[i]->m_cMapIndex >= 0) && 
				(m_pMapList[m_pClientList[i]->m_cMapIndex] != NULL) &&
				(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == FALSE))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_TIMECHANGE, m_cDayOrNight, NULL, NULL, NULL);	
		}
	}
}


void CGame::ShutUpPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i, iTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelShutup) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// tokenÃ€ÃŒ Â°Ã° ÃƒÂ¤Ã†ÃƒÃ€Â» ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ°Ã” Â¸Â¸ÂµÃ© Â»Ã§Â¿Ã«Ã€Ãš Ã€ÃŒÂ¸Â§ 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		// Â´Ã™Ã€Â½ Ã…Ã¤Ã…Â«Ã€Âº ÃÂ¤ÃÃ¶ Â½ÃƒÃ…Â³ Â½ÃƒÂ°Â£. 
		token = pStrTok->pGet();
		if (token == NULL) 
			 iTime = 0;
		else iTime = atoi(token);
	
		if (iTime < 0) iTime = 0;
	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			
			m_pClientList[i]->m_iTimeLeft_ShutUp = iTime * 20; // 1Ã€ÃŒ 3ÃƒÃŠÂ´Ã™. 20Ã€ÃŒÂ¸Ã© 1ÂºÃ 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, iTime, NULL, NULL, cName);

			// Admin Log
			wsprintf(G_cTxt, "GM Order(%s): Shutup PC(%s) (%d)Min", m_pClientList[iClientH]->m_cCharName, 
				     m_pClientList[i]->m_cCharName, iTime);
			PutAdminLogFileList(G_cTxt);

			delete pStrTok;
			return;
		}
		// Ã‡Ã¶Ã€Ã§ ÃÂ¢Â¼Ã“ÃÃŸÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™.
		ZeroMemory(cBuff, sizeof(cBuff));

		char *cp;
		WORD *wp;

		cp = (char *)cBuff;

		*cp = GSM_REQUEST_SHUTUPPLAYER;
		cp++;

		wp = (WORD *)cp;
		*wp = m_wServerID_GSS;
		cp += 2;

		wp = (WORD *)cp;
		*wp = (WORD)iClientH;
		cp += 2;

		memcpy(cp, cName, 10);
		cp += 10;

		wp = (WORD *)cp;
		*wp = iTime;
		cp += 2;

		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;

		bStockMsgToGateServer(cBuff, 27);
	}

	delete pStrTok;
	return;
}


void CGame::SetPlayerReputation(int iClientH, char * pMsg, char cValue, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iLevel < 40) return;

	if ((m_pClientList[iClientH]->m_iTimeLeft_Rating != 0) || (m_pClientList[iClientH]->m_iPKCount != 0)) {
		// Æò°¡¸¦ ³»¸± ½Ã°£ÀÌ µÇÁö ¾Ê¾Ò°Å³ª ¹üÁËÀÚ´Â Æò°¡¸¦ ³»¸± ¼ö ¾ø´Ù. ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, m_pClientList[iClientH]->m_iTimeLeft_Rating, NULL, NULL, NULL);
		return;
	}
	else if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
		// ¼Ò¼Ó ¸¶À»ÀÌ ¾ø´Â »ç¶÷Àº ÆòÆÇÀ» ³»¸± ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, 0, NULL, NULL, NULL);
		return;	
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// tokenÀÌ °ğ ÆòÆÇÀ» Æò°¡ÇÒ »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			
			if (i != iClientH) {
				// ÀÚ±â ÀÚ½ÅÀ» Æò°¡ÇÒ ¼ö´Â ¾ø´Ù.
				if (cValue == 0) 
					m_pClientList[i]->m_iRating--;
				else if (cValue == 1)
					m_pClientList[i]->m_iRating++;
				
				if (m_pClientList[i]->m_iRating > 10000)  m_pClientList[i]->m_iRating = 10000;
				if (m_pClientList[i]->m_iRating < -10000) m_pClientList[i]->m_iRating = -10000;
				// Æò°¡¸¦ ³»·ÈÀ¸¹Ç·Î ½Ã°£ °£°İÀ» Àç ÇÒ´ç. 
				m_pClientList[iClientH]->m_iTimeLeft_Rating = 20*60;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
				
				delete pStrTok;
				return;
			}
		}
		// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}
	
	delete pStrTok;
	return;
}

BOOL CGame::bReadNotifyMsgListFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "=\t\n;";
 class CStrTok * pStrTok;
 int   i;

	cReadMode = 0;
	m_iTotalNoticeMsg = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		PutLogList("(!) Notify Message list file not found!...");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Notify Message list file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					for (i = 0; i < DEF_MAXNOTIFYMSGS; i++) 
					if (m_pNoticeMsgList[i] == NULL) {
						m_pNoticeMsgList[i] = new class CMsg;	
						m_pNoticeMsgList[i]->bPut(NULL, token, strlen(token), NULL, NULL);
						m_iTotalNoticeMsg++;
						goto LNML_NEXTSTEP1;
					}
LNML_NEXTSTEP1:;					
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "notify_msg", 10) == 0) cReadMode = 1;
			}
			
			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}
void CGame::NoticeHandler()
{
 char  cTemp, cBuffer[1000], cKey;
 DWORD dwSize, dwTime = timeGetTime();
 register int i, iMsgIndex, iTemp;

	// Â°Ã¸ÃÃ¶Â»Ã§Ã‡Ã—Ã€ÃŒ 1Â°Â³ Ã€ÃŒÃ‡ÃÂ¶Ã³Â¸Ã© ÂºÂ¸Â³Â¾ Ã‡ÃŠÂ¿Ã¤Â°Â¡ Â¾Ã¸Â´Ã™.
	if (m_iTotalNoticeMsg <= 1) return;

	if ((dwTime - m_dwNoticeTime) > DEF_NOTICETIME) {
		// Â°Ã¸ÃÃ¶Â»Ã§Ã‡Ã—Ã€Â» Ã€Ã¼Â¼Ã›Ã‡Ã’ Â½ÃƒÂ°Â£Ã€ÃŒ ÂµÃ‡Â¾ÃºÂ´Ã™. 
		m_dwNoticeTime = dwTime;	
		do {
			iMsgIndex = iDice(1, m_iTotalNoticeMsg) - 1;
		} while (iMsgIndex == m_iPrevSendNoticeMsg);

		m_iPrevSendNoticeMsg = iMsgIndex;
		
		ZeroMemory(cBuffer, sizeof(cBuffer));
		if (m_pNoticeMsgList[iMsgIndex] != NULL) {
			m_pNoticeMsgList[iMsgIndex]->Get(&cTemp, cBuffer, &dwSize, &iTemp, &cKey);
		}
		
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, cBuffer);
		}
	}
}


void CGame::ResponseSavePlayerDataReplyHandler(char * pData, DWORD dwMsgSize)
{
 char * cp, cCharName[11];
 register int i;

	ZeroMemory(cCharName, sizeof(cCharName));
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);

	// Ã€ÃŒÃÂ¦ Ã€ÃŒ Ã€ÃŒÂ¸Â§Ã€Â» Â°Â®Â´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¸Â¦ ÃƒÂ£Â¾Ã† ÃÂ¢Â¼Ã“Ã€Â» Â²Ã·Â¾Ã®ÂµÂµ ÃÃÂ´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™. 
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
			// Â°Â°Ã€Âº Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ Ã„Â³Â¸Â¯Ã…ÃÂ¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™. ÃÂ¢Â¼Ã“Ã€Â» ÃÂ¾Â·Ã¡Ã‡ÃÂ¶Ã³Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
			SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERCHANGE, NULL, NULL, NULL, NULL);
		}
	}
}

void CGame::CalcExpStock(int iClientH)
{
	BOOL bIsLevelUp;
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iExpStock <= 0) return;
	// !!!!
	// v2.12 2002-2-6 ÃÃ¶ÃÂ¸ÂµÂµ Ã‡Ã¶Ã€Ã§ Â°Ã¦Ã‡Ã¨Ã„Â¡Â°Â¡ ÃƒÃ–Â´Ã« Â·Â¹ÂºÂ§ Â°Ã¦Ã‡Ã¨Ã„Â¡ÂºÂ¸Â´Ã™ Ã€Ã»Ã€Â¸Â¸Ã© Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â¾Ã²Ã€Â»Â¼Ã¶ Ã€Ã–Â°Ã” ÂºÂ¯Â°Ã¦ .. v2.15 Â»Ã¨ÃÂ¦. ÃÃ¶ÃÂ¸ÂµÂµ Â°Ã¦Ã‡Ã¨Ã„Â¡ Â¾Ã²Â´Ã‚Â´Ã™.
	//if ((m_pClientList[iClientH]->m_iLevel >= m_iPlayerMaxLevel) && (m_pClientList[iClientH]->m_iExp >= m_iLevelExpTable[m_iPlayerMaxLevel])) return;

	// Ã†Ã·Â»Ã³Â°Ãº Ã†Ã¤Â³ÃÃ†Â¼Â°Â¡ Â¾Ã¸Â´Ã‚ Â¸ÃŠ Ã€Â§Â¿Â¡ Â¼Â­ Ã€Ã–Â´Ã™Â¸Ã© Â°Ã¦Ã‡Ã¨Ã„Â¡Â´Ã‚ Â¿ÃƒÂ¶Ã³Â°Â¡ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) {
		m_pClientList[iClientH]->m_iExpStock = 0;
		return;
	}

	// Â±Ã—ÂµÂ¿Â¾Ãˆ ÃƒÃ Ã€Ã» ÂµÃ‡Â¾ÃºÂ´Ã¸ Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™. 
	m_pClientList[iClientH]->m_iExp += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iAutoExpAmount += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iExpStock = 0;

	if (bCheckLimitedUser(iClientH) == FALSE) {
		// ÃƒÂ¼Ã‡Ã¨Ã†Ã‡ Â»Ã§Â¿Ã«Ã€Ãš ÃÂ¦Ã‡Ã‘Â¿Â¡ Ã‡Ã˜Â´Ã§ÂµÃ‡ÃÃ¶ Â¾ÃŠÃ€Â¸Â¸Ã© Â°Ã¦Ã‡Ã¨Ã„Â¡Â°Â¡ Â¿ÃƒÂ¶ÃºÂ´Ã™Â´Ã‚ Ã…Ã«ÂºÂ¸Â¸Â¦ Ã‡Ã‘Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}
	// Â·Â¹ÂºÂ§Ã€ÃŒ Â¿ÃƒÂ¶ÃºÂ´Ã‚ÃÃ¶Â¸Â¦ Â°Ã‹Â»Ã§Ã‡Ã‘Â´Ã™.
	bIsLevelUp = bCheckLevelUp(iClientH);

	// v2.03 ÂºÂ¯Â°Ã¦ 9/1
	if ((bIsLevelUp == TRUE) && (m_pClientList[iClientH]->m_iLevel <= 5)) {
		// ÃƒÃŠÂºÂ¸Â¿Ã« Gold ÃÃ¶Â±Ã. Â·Â¹ÂºÂ§ 1~5Â±Ã®ÃÃ¶ 100 Gold ÃÃ¶Â±Ã.
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, "Gold") == FALSE) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (DWORD)100;
		bAddItem(iClientH, pItem, NULL);
	}

	// v2.03 ÂºÂ¯Â°Ã¦ 9/1
	if ((bIsLevelUp == TRUE) && (m_pClientList[iClientH]->m_iLevel > 5 ) &&  (m_pClientList[iClientH]->m_iLevel <= 20) ) {
		// ÃƒÃŠÂºÂ¸Â¿Ã« Gold ÃÃ¶Â±Ã. Â·Â¹ÂºÂ§ 5~20Â±Ã®ÃÃ¶ 300 Gold ÃÃ¶Â±Ã.
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, "Gold") == FALSE) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (DWORD)300;
		bAddItem(iClientH, pItem, NULL);
	}
}

void CGame::___RestorePlayerRating(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iRating < -10000) m_pClientList[iClientH]->m_iRating = 0;
	if (m_pClientList[iClientH]->m_iRating >  10000) m_pClientList[iClientH]->m_iRating = 0;
}

int CGame::iGetExpLevel(int iExp)
{
 register int i;

	// Â°Ã¦Ã‡Ã¨Ã„Â¡Â°Â¡ Â¾Ã®Â´Ã€ Â·Â¹ÂºÂ§ Â¼Ã¶ÃÃ˜Â¿Â¡ Â¼Ã“Ã‡ÃÂ´Ã‚ÃÃ¶ Ã†Ã‡Â´ÃœÃ‡Ã‘Â´Ã™.
	for (i = 1; i < 1001; i++) 
	if ((m_iLevelExpTable[i] <= iExp) && (m_iLevelExpTable[i+1] > iExp)) return i;

	return 0;
}

void CGame::AdminOrder_CallGuard(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
 class  CStrTok * pStrTok;
 register int i, iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCallGaurd) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// tokenÃ€ÃŒ Â°Ã° ÃƒÂ¤Ã†ÃƒÃ€Â» ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ°Ã” Â¸Â¸ÂµÃ© Â»Ã§Â¿Ã«Ã€Ãš Ã€ÃŒÂ¸Â§ 
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			// Â¸Ã±Ã‡Â¥ Ã„Â³Â¸Â¯Ã…ÃÂ¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™. 	
			
			if (memcmp(m_pClientList[i]->m_cMapName, "aresden", 7) == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
			else if (memcmp(m_pClientList[i]->m_cMapName, "elvine", 6) == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else strcpy(cNpcName, "Guard-Neutral");  // <- Ã€ÃŒÂ°ÃÃ€Âº Â¸Â¶Ã€Â»Ã€ÃŒ Â¾Ã†Â´ÃÂ¹Ã‡Â·Ã ÃÃŸÂ¸Â³ Â°Â¡ÂµÃ¥Â¸Â¦ Â»Ã½Â¼ÂºÂ½ÃƒÃ…Â²Â´Ã™.
			
			iNamingValue = m_pMapList[ m_pClientList[i]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// Â´ÃµÃ€ÃŒÂ»Ã³ Ã€ÃŒ Â¸ÃŠÂ¿Â¡ NPCÂ¸Â¦ Â¸Â¸ÂµÃ©Â¼Ã¶ Â¾Ã¸Â´Ã™. Ã€ÃŒÂ¸Â§Ã€Â» Ã‡Ã’Â´Ã§Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â±Ã¢ Â¶Â§Â¹Â®.
			}
			else {
				// NPCÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[i]->m_cMapIndex+65;
				
				tX = (int)m_pClientList[i]->m_sX;
				tY = (int)m_pClientList[i]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[i]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
					// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â¿Â¹Â¾Ã ÂµÃˆ NameValueÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
					m_pMapList[ m_pClientList[i]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					// Â°Â¡ÂµÃ¥Â¸Â¦ Â»Ã½Â¼ÂºÂ½ÃƒÃ„Ã—Â´Ã™. Â°Ã¸Â°Ã Â¸Ã±Ã‡Â¥Â¸Â¦ Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™.
					bSetNpcAttackMode(cName, i, DEF_OWNERTYPE_PLAYER, TRUE);
				}
			}

			delete pStrTok;
			return;
		}

		// Ã‡Ã¶Ã€Ã§ ÃÂ¢Â¼Ã“ÃÃŸÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}
void CGame::AdminOrder_Kill(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
	class  CStrTok * pStrTok;
	register int i;
	int sAttackerWeapon, sDamage, iExH;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGMKill) {
	// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);
	//
	token = pStrTok->pGet();
	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);
	//
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		sDamage = atoi(token);
	} else {
		sDamage = 1;
	}

	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);
	//

	if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		token = cName;
		// tokenÃ€ÃŒ Â°Ã° ÃƒÂ¤Ã†ÃƒÃ€Â» ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ°Ã” Â¸Â¸ÂµÃ© Â»Ã§Â¿Ã«Ã€Ãš Ã€ÃŒÂ¸Â§ 
		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				// Â¸Ã±Ã‡Â¥ Ã„Â³Â¸Â¯Ã…ÃÂ¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™. 	

				m_pClientList[i]->m_iHP = 0;
				//if (iGetMaxHP(i) < m_pClientList[i]->m_iHP) m_pClientList[i]->m_iHP = iGetMaxHP(i);
				m_pClientList[i]->m_bIsKilled = TRUE;

				if (m_pClientList[i]->m_bIsExchangeMode == TRUE) {
					iExH = m_pClientList[i]->m_iExchangeH;
					_ClearExchangeStatus(iExH);
					_ClearExchangeStatus(i);
				}

				RemoveFromTarget(i, DEF_OWNERTYPE_PLAYER);

				SendNotifyMsg(NULL, i, DEF_NOTIFY_KILLED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
				sAttackerWeapon = 1;
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
				// ÃÂ¤Â»Ã³ Ã€Â§Ã„Â¡Â¿Â¡Â¼Â­ ÃÃ¶Â¿Ã®Â´Ã™.
				m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(12, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				// ÃÃ—Ã€Âº Ã€Â§Ã„Â¡ Ã‡Â¥Â½ÃƒÂ¸Â¦ Ã‡Ã‘Â´Ã™.
				m_pMapList[m_pClientList[i]->m_cMapIndex]->SetDeadOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);

				delete pStrTok;
				return;
			}

			// Ã‡Ã¶Ã€Ã§ ÃÂ¢Â¼Ã“ÃÃŸÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
} 

void CGame::AdminOrder_Revive(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
	class  CStrTok * pStrTok;
	register int i;
	int sAttackerWeapon, sDamage, sHP;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGMRevive) {
	// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);


	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}

	token = pStrTok->pGet();

	if (token != NULL) {
		sDamage = atoi(token);
	} else {
		sDamage = 1;
	}
	token = pStrTok->pGet();
	if (token != NULL) {
		sHP = atoi(token);
	} else {
		sHP = 1;
	}

	token = cName;
	//if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		// tokenÃ€ÃŒ Â°Ã° ÃƒÂ¤Ã†ÃƒÃ€Â» ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ°Ã” Â¸Â¸ÂµÃ© Â»Ã§Â¿Ã«Ã€Ãš Ã€ÃŒÂ¸Â§ 
		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				// Â¸Ã±Ã‡Â¥ Ã„Â³Â¸Â¯Ã…ÃÂ¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™. 	

				m_pClientList[i]->m_iHP = sHP;
				if (iGetMaxHP(i) < m_pClientList[i]->m_iHP) m_pClientList[i]->m_iHP = iGetMaxHP(i);
				m_pClientList[i]->m_bIsKilled = FALSE;
				m_pClientList[i]->m_iLastDamage = sDamage;
				//			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, m_pClientList[i]->m_iLastDamage, NULL, NULL);
				SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				sAttackerWeapon = 1;
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, sDamage, sAttackerWeapon, NULL);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(14, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->SetDeadOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);

				delete pStrTok;
				return;
			}

			// Ã‡Ã¶Ã€Ã§ ÃÂ¢Â¼Ã“ÃÃŸÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
} 
void CGame::AdminOrder_SummonDemon(int iClientH)
{
 char cName[21], cNpcName[21], cNpcWaypoint[11];	
 register int iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonDemon) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// Â´ÃµÃ€ÃŒÂ»Ã³ Ã€ÃŒ Â¸ÃŠÂ¿Â¡ NPCÂ¸Â¦ Â¸Â¸ÂµÃ©Â¼Ã¶ Â¾Ã¸Â´Ã™. Ã€ÃŒÂ¸Â§Ã€Â» Ã‡Ã’Â´Ã§Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â±Ã¢ Â¶Â§Â¹Â®.
	}
	else {
		// NPCÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Demon");	
		
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)m_pClientList[iClientH]->m_sX;
		tY = (int)m_pClientList[iClientH]->m_sY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
			// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â¿Â¹Â¾Ã ÂµÃˆ NameValueÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
			// Admin Log
			wsprintf(G_cTxt, "Admin Order(%s): Summon Demon", m_pClientList[iClientH]->m_cCharName);
			PutAdminLogFileList(G_cTxt);
		}
	}

}
void CGame::AdminOrder_SummonDeath(int iClientH)
{
	char cName[21], cNpcName[21], cNpcWaypoint[11];	
	register int iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonDeath) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// Â´ÃµÃ€ÃŒÂ»Ã³ Ã€ÃŒ Â¸ÃŠÂ¿Â¡ NPCÂ¸Â¦ Â¸Â¸ÂµÃ©Â¼Ã¶ Â¾Ã¸Â´Ã™. Ã€ÃŒÂ¸Â§Ã€Â» Ã‡Ã’Â´Ã§Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â±Ã¢ Â¶Â§Â¹Â®.
	}
	else {
		// NPCÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Wyvern");	

		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;

		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)m_pClientList[iClientH]->m_sX;
		tY = (int)m_pClientList[iClientH]->m_sY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
				// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â¿Â¹Â¾Ã ÂµÃˆ NameValueÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
			} 
		else {
			// Admin Log
			wsprintf(G_cTxt, "Admin Order(%s): Summon Death", m_pClientList[iClientH]->m_cCharName);
			PutAdminLogFileList(G_cTxt);
		}
	}

}
// v1.4311-3 ÃƒÃŸÂ°Â¡ Â¿Ã®Â¿ÂµÃ€ÃšÂ°Â¡ Â»Ã§Ã…ÃµÃ€Ã¥Ã€Â» Â¿Â¹Â¾Ã Ã‡Ã‘Â´Ã™.
void CGame::AdminOrder_ReserveFightzone(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256];
 class  CStrTok * pStrTok;
 int iNum ;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;


	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelReserveFightzone) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if( m_iFightzoneNoForceRecall == 0 ) {
		m_iFightzoneNoForceRecall = 1 ; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -5, NULL, NULL, NULL);
	} else {
		m_iFightzoneNoForceRecall = 0 ; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -4, NULL, NULL, NULL);
	}

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	iNum = atoi(token) - 1;
			
	if ( m_iFightZoneReserve[iNum] != -1) {
		// Admin Log
		wsprintf(G_cTxt, "Admin Order(%s):  %d FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		PutAdminLogFileList(G_cTxt);
		
		m_iFightZoneReserve[iNum] = - 1 ;        // Â¿Ã®Â¿ÂµÃ€ÃšÂ°Â¡ Â¿Â¹Â¾Ã Ã‡Ã‘ Â»Ã§Ã…ÃµÃ€Ã¥Ã€Âº -1 Â°ÂªÃ€ÃŒ ÂµÃ©Â¾Ã®Â°Â£Â´Ã™.
												 // Ã€ÃŒÃÂ¦ÂºÃÃ…Ã Â°Ã¨Â¼Ã“ Â´Ã™Â¸Â¥ Ã€Â¯Ã€ÃºÂ´Ã‚ Â¿Â¹Â¾Ã Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™.
		// Â¿Ã®Â¿ÂµÃ€ÃšÂ°Â¡ Â»Ã§Ã…ÃµÃ€Ã¥ Â¿Â¹Â¾Ã Â¿Â¡ Â¼ÂºÂ°Ã¸Ã‡ÃÂ´Ã‚ Â°Ã¦Â¿Ã¬ 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, iNum+1, NULL, NULL, NULL);
		
	}  else {	// Â¿Ã®Â¿ÂµÃ€ÃšÂ°Â¡ Â¿Â¹Â¾Ã Ã‡Ã‘ Â»Ã§Ã…ÃµÃ€Ã¥Ã€Â» Â´Ã™Â½Ãƒ Â¿Â¹Â¾Ã Ã‡ÃÂ¸Ã© Â¿Â¹Â¾Ã Ã€ÃŒ ÃƒÃ«Â¼Ã’ÂµÃˆÂ´Ã™.
		wsprintf(G_cTxt, "Admin Order(%s):  %d Cancel FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		PutAdminLogFileList(G_cTxt);

		m_iFightZoneReserve[iNum] = 0 ;       
		// Â¿Ã®Â¿ÂµÃ€ÃšÂ°Â¡ Â»Ã§Ã…ÃµÃ€Ã¥ Â¿Â¹Â¾Ã Ã€Â» ÃƒÃ«Â¼Ã’Ã‡ÃÂ´Ã‚ Â°Ã¦Â¿Ã¬       -3 Â°ÂªÃ€Â» Â³Ã‘Â°ÃœÃÃ˜Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -3, NULL, NULL, NULL);

	}
		
	return;
}


void CGame::AdminOrder_CloseConn(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	/*
	//v1.42 Â±Ã¦ÂµÃ¥Ã€Ã¼Â¿Ã« Ã€Ã“Â½Ãƒ Ã„ÃšÂµÃ¥ 
	if ((memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) && (m_pClientList[iClientH]->m_iSkillSSN[59] == 1)) {
		goto AOCC_PASS;
	}
	*/

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGMCloseconn) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) {
		// tokenÃ€ÃŒ Â°Ã° ÃƒÂ¤Ã†ÃƒÃ€Â» ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ°Ã” Â¸Â¸ÂµÃ© Â»Ã§Â¿Ã«Ã€Ãš Ã€ÃŒÂ¸Â§ 
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			// Â¸Ã±Ã‡Â¥ Ã„Â³Â¸Â¯Ã…ÃÂ¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™. Â°Â­ÃÂ¦Â·Ã ÃÂ¢Â¼Ã“Ã€Â» Â²Ã·Â´Ã‚Â´Ã™.	
			if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
				// v1.22 Â°Â­ÃÂ¦ ÃÂ¢Â¼Ã“ ÃÂ¾Â·Ã¡ÂµÃˆ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â´Ã‚ ÂºÃ­Â¸Â®ÂµÃ¹ Â¾Ã†Ã€ÃÂ·Â£ÂµÃ¥Â·Ã Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â®ÂµÃˆÂ´Ã™.
				DeleteClient(i, TRUE, TRUE, TRUE, TRUE);
			}

			// Admin Log
			wsprintf(G_cTxt, "Admin Order(%s): Close Conn", m_pClientList[iClientH]->m_cCharName);
			PutAdminLogFileList(G_cTxt);

			delete pStrTok;
			return;
		}
		// Ã‡Ã¶Ã€Ã§ ÃÂ¢Â¼Ã“ÃÃŸÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}



// v1.4311-3 ÃƒÃŸÂ°Â¡Â¹Ã— ÂºÂ¯Â°Ã¦ Ã‡Ã”Â¼Ã¶  Â±Ã¦ÂµÃ¥Â¿Ã¸ Â°Â­Ã…Ã° Â¸Ã­Â·Ã‰ void CGame::UserCommand_BanGuildsman
void CGame::UserCommand_BanGuildsman(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iGuildRank != 0 ) {
		// Â±Ã¦ÂµÃ¥ Â¸Â¶Â½ÂºÃ…ÃÂ°Â¡ Â¾Ã†Â´ÃÂ¾Ã®Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOGUILDMASTERLEVEL, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// tokenÃ€ÃŒ Â±Ã¦ÂµÃ¥Â¸Â¦ Ã…Â»Ã…Ã°Â½ÃƒÃ…Â³ Â»Ã§Â¶Ã· 
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) ) {
			// Â¸Ã±Ã‡Â¥ Ã„Â³Â¸Â¯Ã…ÃÂ¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™. Â°Â­ÃÂ¦Â·Ã Â±Ã¦ÂµÃ¥Â¸Â¦ Â°Â­Ã…Ã° Â½ÃƒÃ…Â²Â´Ã™. 

			if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0)  {
				// Ã€ÃšÂ½Ã…Ã€Ã‡ Â±Ã¦ÂµÃ¥Â¿Ã¸Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³ Ã‡Ã£Â¶Ã´Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™.
				
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTBANGUILDMAN, NULL, NULL, NULL, NULL);
				delete pStrTok;
				return;
			}
			// Â±Ã¦ÂµÃ¥ ÃÂ¤ÂºÂ¸ ÃˆÂ­Ã€ÃÂ¿Â¡Â¼Â­ Ã…Â»Ã…Ã°Ã‡Ã‘ Â±Ã¦ÂµÃ¥Â¿Ã¸Ã€Ã‡ Ã€ÃŒÂ¸Â§Ã€Â» Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
			bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);
		
			// Â´Ã™Â¸Â¥ Â±Ã¦ÂµÃ¥Â¿Ã¸ÂµÃ©Â¿Â¡Â°Ã” Â±Ã¦ÂµÃ¥Â¿Ã¸Ã€Ã‡ Ã…Â»Ã…Ã°Â¸Â¦ Â¾Ã‹Â¸Â°Â´Ã™.
			SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);
	
			// Â±Ã¦ÂµÃ¥Ã€Ã‡ Ã€ÃŒÂ¸Â§Ã€Â» ÃƒÃŠÂ±Ã¢ÃˆÂ­Ã‡Ã˜ ÃÃ˜Â´Ã™.
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1; 
			m_pClientList[i]->m_iGuildGUID = -1;

			// Â±Ã¦ÂµÃ¥ Â¸Â¶Â½ÂºÃ…ÃÂ¿Â¡Â°Ã” Â°Â­ÃÂ¦ Ã…Â»Ã…Ã°Â¿Â¡ Â¼ÂºÂ°Ã¸Ã‡ÃŸÃ€Â½Ã€Â» Â¾Ã‹Â¸Â®Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â»ÃÃ˜Â´Ã™.
		    SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SUCCESSBANGUILDMAN, NULL, NULL, NULL, NULL);
			
			// Â°Â­ÃÂ¦ Ã…Â»Ã…Ã°ÂµÃˆ Â±Ã¦ÂµÃ¥Â¿Ã¸Â¿Â¡Â°Ã” Â°Â­ÃÂ¦ Ã…Â»Ã…Ã° ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_BANGUILD, NULL, NULL, NULL, NULL);
		
			// Ã†Â¯Â¼ÂºÃ€ÃŒ Â¹Ã™Â²Ã®Â¹Ã‡Â·Ã Â¿ÃœÂ¾Ã§Ã€Â» Â»ÃµÂ·Ã ÂºÂ¸Â³Â½Â´Ã™. 
			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		
			delete pStrTok;
			return;
		}
		// Ã‡Ã¶Ã€Ã§ ÃÂ¢Â¼Ã“ÃÃŸÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}



void CGame::UserCommand_DissmissGuild(int iClientH, char * pData, DWORD dwMsgSize)
{

}


int CGame::iCreateFish(char cMapIndex, short sX, short sY, short sType, class CItem * pItem, int iDifficulty, DWORD dwLastTime)
{
 register int i, iDynamicHandle;

	// Â¸ÃŠÃ€Ã‡ Ã€Â§Ã„Â¡Â°Â¡ Â¹Â°Ã€ÃÃÃ¶ ÃˆÂ®Ã€ÃÃ‡Ã‘Â´Ã™. 
	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;
	if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE) return NULL;

	for (i = 1; i < DEF_MAXFISHS; i++) 
	if (m_pFish[i] == NULL) {
		// ÂºÃ³ Â°Ã¸Â°Â£Â¿Â¡ Â¹Â°Â°Ã­Â±Ã¢Â¸Â¦ Â¸Â¸ÂµÃ§Â´Ã™.
		m_pFish[i] = new class CFish(cMapIndex, sX, sY, sType, pItem, iDifficulty);
		if (m_pFish[i] == NULL) return NULL;
 		
		// Dynamic ObjectÂ¸Â¦ Â¹ÃŸÂ»Ã½Â½ÃƒÃ…Â²Â´Ã™. OwnerÂ¿Â¡ Fish Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ Â³Ã–Â´Ã‚Â´Ã™.
		switch (pItem->m_sIDnum) {
		case 101: // Â»Â¡Â°Â­Â¹Â°Â°Ã­Â±Ã¢
		case 102: // ÃƒÃŠÂ·ÃÂ¹Â°Â°Ã­Â±Ã¢
		case 103: // Â³Ã«Â¶Ã»Â¹Â°Â°Ã­Â±Ã¢
		case 570:
		case 571:
		case 572:
		case 573:
		case 574:
		case 575:
		case 576:
		case 577:	
			iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISH, cMapIndex, sX, sY, dwLastTime);
			break;
		default: 
			// Â¹Â°Â°Ã­Â±Ã¢Â°Â¡ Â¾Ã†Â´Ã‘ Â´Ã™Â¸Â¥ Â¾Ã†Ã€ÃŒÃ…Ã› 
			iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISHOBJECT, cMapIndex, sX, sY, dwLastTime);
			break;
		}
		
		if (iDynamicHandle == NULL) {
			delete m_pFish[i];
			m_pFish[i] = NULL;
			return NULL;
		}
		m_pFish[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMapList[cMapIndex]->m_iCurFish++;

		return i;
	}

	return NULL;
}


BOOL CGame::bDeleteFish(int iHandle, int iDelMode)
{
 register int i, iH;
 DWORD dwTime;
		
	if (m_pFish[iHandle] == NULL) return FALSE;
	
	dwTime = timeGetTime();

	// Â¿Â¬Â°Ã¼ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã‚ DynamicObjectÂ¸Â¦ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
	iH = m_pFish[iHandle]->m_sDynamicObjectHandle;
	
	if (m_pDynamicObjectList[iH] != NULL) {
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iH]->m_cMapIndex, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, m_pDynamicObjectList[iH]->m_sType, iH, NULL);
		// Â¸ÃŠÂ¿Â¡Â¼Â­ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, dwTime);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->m_iCurFish--;

		delete m_pDynamicObjectList[iH];
		m_pDynamicObjectList[iH] = NULL;
	}

	// Ã€ÃŒ Â¹Â°Â°Ã­Â±Ã¢Â¿Ã Â¿Â¬Â°Ã¡ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®ÂµÃ©Â¿Â¡Â°Ã” Â¹Â°Â°Ã­Â±Ã¢Â°Â¡ Â»Ã§Â¶Ã³ÃÂ® Â³Â¬Â½ÃƒÂ°Â¡ ÃƒÃ«Â¼Ã’ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) &&
			(m_pClientList[i]->m_iAllocatedFish == iHandle)) {
			// Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã› 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCANCELED, iDelMode, NULL, NULL, NULL);
			ClearSkillUsingStatus(i); // v1.4 Â³Â¬Â½Ãƒ Â½ÂºÃ…Â³Ã€Â» Ã…Â¬Â¸Â®Â¾Ã®Ã‡Ã‘Â´Ã™.
 		}
	}
	
	// Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
	delete m_pFish[iHandle];
	m_pFish[iHandle] = NULL;

	return TRUE;
}


int CGame::iCheckFish(int iClientH, char cMapIndex, short dX, short dY)
{
 register int i;
 short sDistX, sDistY;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((cMapIndex < 0)	|| (cMapIndex >= DEF_MAXMAPS)) return 0;

	// Â¸ÃŠÃ€Ã‡ Ã†Â¯ÃÂ¤ Ã€Â§Ã„Â¡ Â³Â»Â¿Â¡ Â¹Â°Â°Ã­Â±Ã¢ Â´Ã™Ã€ÃŒÂ³ÂªÂ¹Ã Â¿Ã€ÂºÃªÃÂ§Ã†Â®Â°Â¡ Ã€Ã–Â´Ã‚ÃÃ¶ Ã†Ã‡Â´ÃœÃ‡Ã‘Â´Ã™. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != NULL) {
		sDistX = abs(m_pDynamicObjectList[i]->m_sX - dX);
		sDistY = abs(m_pDynamicObjectList[i]->m_sY - dY);
		
		if ((m_pDynamicObjectList[i]->m_cMapIndex == cMapIndex) && 
			((m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISH) || (m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISHOBJECT)) &&
			(sDistX <= 2) && (sDistY <= 2)) {
			// Â¹Â°Â°Ã­Â±Ã¢ Â´Ã™Ã€ÃŒÂ³ÂªÂ¹Ã Â¿Ã€ÂºÃªÃÂ§Ã†Â®Â¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™. Ã€ÃŒÃÂ¦ Ã€ÃŒ Â´Ã™Ã€ÃŒÂ³ÂªÂ¹Ã Â¿Ã€ÂºÃªÃÂ§Ã†Â® Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ Â¼Ã’Ã€Â¯Ã‡Ã‘ FishÃ€Ã‡ Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ Â¹ÃÃˆÂ¯Ã‡Ã‘Â´Ã™. 

			if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ] == NULL) return 0;
			if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount >= DEF_MAXENGAGINGFISH) return 0;

			// Ã€ÃŒÂ¹ÃŒ Â³Â¬Â½ÃƒÂ¸Ã°ÂµÃ¥Â¿Â¡ ÂµÃ©Â¾Ã®Â°Â¡ Ã€Ã–Â´Ã‚ Ã„Â³Â¸Â¯Ã…ÃÂ´Ã‚ ÃÃŸÂºÂ¹ ÂµÂ¿Ã€Ã›Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰.
			if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) return 0;
			if (m_pClientList[iClientH]->m_cMapIndex != cMapIndex) return 0;
			// Ã€ÃŒÃÂ¦ Ã„Â³Â¸Â¯Ã…ÃÂ¿Â¡Â°Ã” Â³Â¬Â½Ãƒ Â¸Ã°ÂµÃ¥Â¸Â¦ Â½ÃƒÃ€Ã›Ã‡Ã’ Â°ÃÃ€Â» Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™.
			m_pClientList[iClientH]->m_iAllocatedFish = m_pDynamicObjectList[i]->m_sOwner;
			m_pClientList[iClientH]->m_iFishChance = 1;
			// Ã€ÃŒ Ã„Â³Â¸Â¯Ã…ÃÂ´Ã‚ Â³Â¬Â½Ãƒ Â½ÂºÃ…Â³Ã€Â» Â»Ã§Â¿Ã«ÃÃŸÃ€Ã“Ã€Â» Â¼Â³ÃÂ¤.
			m_pClientList[iClientH]->m_bSkillUsingStatus[1] = TRUE;

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EVENTFISHMODE, (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_wPrice/2), m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSprite,
				          m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSpriteFrame, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_cName);

			// Ã„Â«Â¿Ã®Ã†Â® ÃÃµÂ°Â¡ 
			m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount++;
			
			return i;
		}
	}

	return 0;
}

void CGame::FishProcessor()
{
 register int i, iSkillLevel, iResult, iChangeValue;

	// ÀÌº¥Æ® ³¬½Ã ¸ğµå°¡ ÇÒ´çµÈ ÇÃ·¹ÀÌ¾îµéÀ» Ã³¸®ÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && 
			(m_pClientList[i]->m_iAllocatedFish != NULL)) {
		
			if (m_pFish[ m_pClientList[i]->m_iAllocatedFish ] == NULL) break;	
	
			// ÀÌ ÇÃ·¹ÀÌ¾î¿¡°Ô ÇÒ´çµÈ ¹°°í±â°¡ ÀÖ´Ù. ³¬À» È®·üÀ» Àç°è»êÇÏ¿© Åëº¸ÇØ ÁØ´Ù. 
			// ³¬½Ã ±â¼úÀÇ ½ºÅ³ 
			iSkillLevel  = m_pClientList[i]->m_cSkillMastery[1];
			// ¹°°í±âÀÇ ³­ÀÌµµ¿¡ µû¶ó ½ºÅ³ ·¹º§ÀÌ ¶³¾îÁø´Ù. 
			iSkillLevel -= m_pFish[m_pClientList[i]->m_iAllocatedFish]->m_iDifficulty;
			if (iSkillLevel <= 0) iSkillLevel = 1;
			
			iChangeValue = iSkillLevel / 10;
			if (iChangeValue <= 0) iChangeValue = 1;
			iChangeValue = iDice(1, iChangeValue);

			iResult = iDice(1, 100);
			if (iSkillLevel > iResult)	{
				// ½ºÅ³ ÁÖ»çÀ§ ±¼¸² ¼º°ø. ³¬À» È®·ü Áõ°¡.
				m_pClientList[i]->m_iFishChance += iChangeValue;
				if (m_pClientList[i]->m_iFishChance > 99) m_pClientList[i]->m_iFishChance = 99;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
			}
			else if (iSkillLevel < iResult) {
				// ½ºÅ³ ÁÖ»çÀ§ ±¼¸² ½ÇÆĞ. ³¬À» È®·ü °¨¼Ò.	
				m_pClientList[i]->m_iFishChance -= iChangeValue;
				if (m_pClientList[i]->m_iFishChance < 1) m_pClientList[i]->m_iFishChance = 1;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
			}
		}
	}
}

void CGame::AdminOrder_CreateFish(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cItemName[21];
 class  CStrTok * pStrTok;
 class  CItem   * pItem;
 register int tX, tY, iType;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCreateFish) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	tX = tY = iType = 0;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		tX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		tY = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		iType = atoi(token);
	}

	if ((tX != 0) && (tY != 0) && (iType != 0)) {
		// Ã€ÃŒ ÃÃ‚Ã‡Â¥Â¿Â¡ Â¹Â°Â°Ã­Â±Ã¢Â¸Â¦ Â¸Â¸ÂµÃ§Â´Ã™.
		pItem = new class CItem;
		if (pItem == NULL) {
			delete pStrTok;
			return;
		}
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, "Â¹Â°Â°Ã­Â±Ã¢");
		if (_bInitItemAttr(pItem, cItemName) == TRUE) {
   			iCreateFish(m_pClientList[iClientH]->m_cMapIndex, tX, tY, iType, pItem, 1, 60000*20);
		}
		else delete pItem;
   	}

	delete pStrTok;
	return;
}

void CGame::AdminOrder_Teleport(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256];
 class  CStrTok * pStrTok;
 register int dX, dY;
 BOOL   bFlag;

	dX = dY = -1;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelTeleport) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dY = atoi(token);
	}

	bFlag = FALSE;
	if (strcmp("2ndmiddle", cMapName) == 0) bFlag = TRUE;
	if (strcmp("abaddon", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("arebrk11", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk12", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk21", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk22", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arefarm", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arejail", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aremidl", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aremidr", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aresden", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aresdend1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("areuni", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arewrhus", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bisle", cMapName) == 0)   bFlag = TRUE;
	if (strcmp("bsmith_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bsmith_1f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bsmith_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bsmith_2f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("BtField", cMapName) == 0) bFlag = TRUE;
	if (strcmp("cath_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("cath_2", cMapName) == 0)      bFlag = TRUE;
	if (strcmp("cityhall_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("cityhall_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("CmdHall_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("CmdHall_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("default", cMapName) == 0) bFlag = TRUE;
	if (strcmp("dglv2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("dglv3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("dglv4", cMapName) == 0) bFlag = TRUE;
	if (strcmp("druncncity", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("elvbrk11", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk12", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk21", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk22", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvfarm", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvine", cMapName) == 0)  bFlag = TRUE;
	if (strcmp("elvined1", cMapName) == 0)    bFlag = TRUE;
	if (strcmp("elvjail", cMapName) == 0)    bFlag = TRUE;
	if (strcmp("elvmidl", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvmidr", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvuni", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvwrhus", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone4", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone5", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone6", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone7", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone8", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone9", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone10", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gldhall_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gldhall_2", cMapName) == 0)   bFlag = TRUE;
	if (strcmp("GodH", cMapName) == 0)   bFlag = TRUE;
	if (strcmp("gshop_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gshop_1f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gshop_2", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("gshop_2f", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("HRampart", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("huntzone1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone4", cMapName) == 0) bFlag = TRUE;
	if (strcmp("icebound", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("inferniaA", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("inferniaB", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("maze", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("middled1n", cMapName) == 0) bFlag = TRUE;
	if (strcmp("middled1x", cMapName) == 0) bFlag = TRUE;
	if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;
	if (strcmp("penalty", cMapName) == 0) bFlag = TRUE;
	if (strcmp("procella", cMapName) == 0) bFlag = TRUE;
	if (strcmp("resurr1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("resurr2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("toh1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("toh2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("toh3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wrhus_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wrhus_1f", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wrhus_2", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("Test", cMapName) == 0) bFlag = TRUE;
	if (strcmp("GMMap", cMapName) == 0) bFlag = TRUE;
	if (strcmp("dv", cMapName) == 0) bFlag = TRUE;
	if (strcmp("HBX", cMapName) == 0) bFlag = TRUE;

	if (bFlag == TRUE)
		RequestTeleportHandler(iClientH, "2   ", cMapName, dX, dY);
   	
	delete pStrTok;
	return;
}


void CGame::ReqGetFishThisTimeHandler(int iClientH)
{
 register int iResult, iFishH;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iAllocatedFish == NULL) return;
	if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] == NULL) return;

	// ³¬½Ã ½ºÅ³ »ç¿ëÁßÀÓÀ» ÇØÁ¦½ÃÅ²´Ù.
	m_pClientList[iClientH]->m_bSkillUsingStatus[1] = FALSE;

	iResult = iDice(1, 100);
	if (m_pClientList[iClientH]->m_iFishChance >= iResult) {
		// ÀÌ ¹°°í±â¸¦ ³¬´Âµ¥ ¼º°øÇÏ¿´´Ù!
		
		// °æÇèÄ¡ Áõ°¡ 
		GetExp(iClientH, iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5)); //m_pClientList[iClientH]->m_iExpStock += iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5);
		// ½ºÅ³ Áõ°¡ 
		CalculateSSN_SkillIndex(iClientH, 1, m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty);

		// ¾ÆÀÌÅÛ Æ÷ÀÎÅÍ¸¦ ¾ò¾î¿Â´Ù.
		pItem = m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem;
		m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem = NULL;

		// ³¬Àº ¾ÆÀÌÅÛÀ» ¹Ù´Ú¿¡ ¶³¾î¶ß¸°´Ù.
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                       m_pClientList[iClientH]->m_sY, 
															       pItem);

		// ´Ù¸¥ Å¬¶óÀÌ¾ğÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

		// ³¬½Ã ¼º°ø ¸Ş½ÃÁö Àü¼Û 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
		iFishH = m_pClientList[iClientH]->m_iAllocatedFish;
		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
				
		// ¹°°í±â¸¦ Áö¿ì°í ¸®ÅÏ 
		bDeleteFish(iFishH, 1); // <- ¿©±â¼­ ´Ù¸¥ ³¬½Ã²Ûµé¿¡°Ô ¸Ş½ÃÁö°¡ Àü¼ÛµÉ °ÍÀÌ´Ù.
		return;
	}

	// ³¬´Âµ¥ ½ÇÆĞ! 
	m_pFish[ m_pClientList[iClientH]->m_iAllocatedFish ]->m_sEngagingCount--;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHFAIL, NULL, NULL, NULL, NULL);
	
	m_pClientList[iClientH]->m_iAllocatedFish = NULL;
}


void CGame::FishGenerator() 
{ 
 register int i, iP, tX, tY, iRet; 
 char  cItemName[21]; 
 short sDifficulty; 
 DWORD dwLastTime; 
 class CItem * pItem; 

	for (i = 0; i < DEF_MAXMAPS; i++) { 
		if ((iDice(1,10) == 5) && (m_pMapList[i] != NULL) && 
			(m_pMapList[i]->m_iCurFish < m_pMapList[i]->m_iMaxFish)) { 
    
			iP = iDice(1, m_pMapList[i]->m_iTotalFishPoint) - 1; 
			if ((m_pMapList[i]->m_FishPointList[iP].x == -1) || (m_pMapList[i]->m_FishPointList[iP].y == -1)) break; 

			tX = m_pMapList[i]->m_FishPointList[iP].x + (iDice(1,3) - 2); 
			tY = m_pMapList[i]->m_FishPointList[iP].y + (iDice(1,3) - 2); 

			pItem = new class CItem; 
			if (pItem == NULL) break; 
                   
			// Â¸Â¸ÂµÃ© Â¹Â°Â°Ã­Â±Ã¢ ÃÂ¾Â·Ã¹Â¿Ã Â³Â­Ã€ÃŒÂµÂµ, ÃÃ¶Â¼Ã“ Â½ÃƒÂ°Â£Ã€Â» Â°Ã¡ÃÂ¤Ã‡Ã‘Â´Ã™. 
			ZeroMemory(cItemName, sizeof(cItemName)); 
			switch (iDice(1,9)) { 
			case 1:   strcpy(cItemName, "RedCarp"); sDifficulty = iDice(1,10) + 20; break; 
			case 2:   strcpy(cItemName, "GreenCarp"); sDifficulty = iDice(1,5)  + 10; break; 
			case 3:   strcpy(cItemName, "GoldCarp"); sDifficulty = iDice(1,10) + 1;  break; 
			case 4:   strcpy(cItemName, "CrucianCarp"); sDifficulty = 1;  break;    
			case 5:   strcpy(cItemName, "BlueSeaBream"); sDifficulty = iDice(1,15) + 1;  break; 
			case 6:   strcpy(cItemName, "RedSeaBream"); sDifficulty = iDice(1,18) + 1;  break; 
			case 7:   strcpy(cItemName, "Salmon"); sDifficulty = iDice(1,12) + 1;  break; 
			case 8:   strcpy(cItemName, "GrayMullet"); sDifficulty = iDice(1,10) + 1;  break; 
			case 9: 
				// Â°Â¡Â²Ã» Â°Â¡Â´Ã™ Â³Â¬Ã€Â» Â¼Ã¶ Ã€Ã–Â´Ã‚ Ã†Â¯Â¼Ã¶ Â¾Ã†Ã€ÃŒÃ…Ã› 
				switch (iDice(1,150)) { 
				case 1: 
				case 2: 
				case 3: 
					strcpy(cItemName, "PowerGreenPotion"); 
					sDifficulty = iDice(5,4) + 30; 
					break; 

				case 10: 
				case 11: 
					strcpy(cItemName, "SuperPowerGreenPotion"); 
					sDifficulty = iDice(5,4) + 50; 
					break; 

				case 20: 
					strcpy(cItemName, "Dagger+2"); 
					sDifficulty = iDice(5,4) + 30; 
					break; 

				case 30: 
					strcpy(cItemName, "LongSword+2"); 
					sDifficulty = iDice(5,4) + 40; 
					break; 

				case 40: 
					strcpy(cItemName, "Scimitar+2"); 
					sDifficulty = iDice(5,4) + 50; 
					break; 

				case 50: 
					strcpy(cItemName, "Rapier+2"); 
					sDifficulty = iDice(5,4) + 60; 
					break; 

				case 60: 
					strcpy(cItemName, "Flameberge+2"); 
					sDifficulty = iDice(5,4) + 60; 
					break; 

				case 70: 
					strcpy(cItemName, "WarAxe+2"); 
					sDifficulty = iDice(5,4) + 50; 
					break; 

				case 90: 
					strcpy(cItemName, "Ruby"); 
					sDifficulty = iDice(5,4) + 40; 
					break; 

				case 95: 
					strcpy(cItemName, "Diamond"); 
					sDifficulty = iDice(5,4) + 40; 
					break; 
				} 
			break; 
			} 
			dwLastTime  = (60000 * 10) + (iDice(1,3) - 1)*(60000 * 10); 

			if (_bInitItemAttr(pItem, cItemName) == TRUE) { 
				iRet = iCreateFish(i, tX, tY, 1, pItem, sDifficulty, dwLastTime); 
			} 
			else { 
				delete pItem; 
				pItem = NULL; 
			} 
		} 
	}                                         
}


int CGame::_iCalcPlayerNum(char cMapIndex, short dX, short dY, char cRadius)
{
 register int ix, iy, iRet;
 class CTile * pTile;	

	// ÃƒÂ³Â¸Â® Â¼Ã“ÂµÂµÂ¸Â¦ Â³Ã´Ã€ÃŒÂ±Ã¢ Ã€Â§Ã‡Ã˜ Ã‡Ã”Â¼Ã¶Â¸Â¦ Ã„ÃÃ‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
	if ((cMapIndex < 0)	|| (cMapIndex > DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == NULL) return 0;

	iRet = 0;
	for (ix = dX - cRadius; ix <= dX + cRadius; ix++)
	for (iy = dY - cRadius; iy <= dY + cRadius; iy++) {
		if ( (ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
			 (iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY) ) {
			// ÃÃ‚Ã‡Â¥Â¸Â¦ Â¹Ã¾Â¾Ã®Â³ÂªÂ¹Ã‡Â·Ã ÃƒÂ³Â¸Â®Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.	
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			if ((pTile->m_sOwner != NULL) && (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER))
				iRet++;
		}
	}

	return iRet;
}


void CGame::WhetherProcessor()
{
char cPrevMode;
int i, j;
DWORD dwTime;

	dwTime = timeGetTime();

	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) {
			cPrevMode = m_pMapList[i]->m_cWhetherStatus;
			if (m_pMapList[i]->m_cWhetherStatus != NULL) {
				if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
					m_pMapList[i]->m_cWhetherStatus = NULL;
				}
				else {
					if (iDice(1,300) == 13) {
						m_pMapList[i]->m_cWhetherStatus = iDice(1,3); //This looks better or else we only get snow :(
						//m_pMapList[i]->m_cWhetherStatus = iDice(1,3)+3; <- This original code looks fucked
						m_pMapList[i]->m_dwWhetherStartTime = dwTime;
						m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(1,7);
					}
				}

			if (m_pMapList[i]->m_bIsSnowEnabled == TRUE) {
				m_pMapList[i]->m_cWhetherStatus = iDice(1,3)+3;
				m_pMapList[i]->m_dwWhetherStartTime = dwTime;
				m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(1,7);
			}

			if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) {
				for (j = 1; j < DEF_MAXCLIENTS; j++) 
					if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
						SendNotifyMsg(NULL, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);
			}
		} //If
	} //for Loop
}


// v1.4311-3 ÃƒÃŸÂ°Â¡ Ã‡Ã”Â¼Ã¶  Â»Ã§Ã…ÃµÃ€Ã¥ Â¿Â¹Â¾Ã  ÃƒÃŠÂ±Ã¢ÃˆÂ­Â¹Ã— Â»Ã§Â¿Ã«Ã€ÃšÂ¿Â¡Â°Ã” Â¿Â¹Â¾Ã Ã€ÃŒ ÃƒÃ«Â¼Ã’ ÂµÃ‡Â¾ÃºÃ€Â½ Â¾Ã‹Â¸Â°Â´Ã™.FightzoneReserveProcessor 
void CGame::FightzoneReserveProcessor()
{/*
 register int i;
	
	PutLogList("CAN FIGHTZONE RESERVE!!");
			
	// Â¿Â¹Â¾Ã ÂµÃˆ Â»Ã§Ã…ÃµÃ€Ã¥ÂµÃ©Ã€Â» ÃƒÃŠÂ±Ã¢ÃˆÂ­ Â½ÃƒÃ…Â²Â´Ã™.  10Â°Â³Ã€Ã‡ Â»Ã§Ã…ÃµÃ€Ã¥Ã€Ã‡ Ã€Ã”Ã€Ã¥Ã€Â» Ã‡Ã£Â¶Ã´Ã‡Ã‘Â´Ã™.
	for (i=0 ; i < DEF_MAXFIGHTZONE ; i++ ) {

		if (m_iFightZoneReserve[i] == -1 ) continue ; // Â¿Ã®Â¿ÂµÃ€ÃšÂ°Â¡ Â¿Â¹Â¾Ã Ã‡Ã‘ Â»Ã§Ã…ÃµÃ€Ã¥Ã€Âº Â¿Â¹Â¾Ã Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™.
		m_iFightZoneReserve[i] = 0 ;
	}

	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		// Â»Ã§Ã…ÃµÃ€Ã¥Ã€Â» Â¿Â¹Â¾Ã Ã‡Ã‘ Ã€Â¯Ã€ÃºÃ€ÃÃÃ¶Â¸Â¦ ÃˆÂ®Ã€ÃÃ‡Ã‘Â´Ã™. 
		// Â»Ã§Ã…ÃµÃ€Ã¥Ã€Â» Â¿Â¹Â¾Ã Ã‡Ã‘ Ã€Â¯Ã€ÃºÂ¿Â¡Â°Ã” Â»Ã§Ã…ÃµÃ€Ã¥ Â¿Â¹Â¾Ã Ã€ÃŒ ÃƒÃ«Â¼Ã’ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
		if((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iFightzoneNumber != 0))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
	}*/
}

/*********************************************************************************************************************
**  int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)										**
**  description			:: checks for a weather bonus when magic is cast											**
**  last updated		:: November 20, 2004; 10:34 PM; Hypnotoad													**
**	return value		:: int																						**
*********************************************************************************************************************/
int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)
{
 int iWheatherBonus;

	iWheatherBonus = 0;
	switch (cWheatherStatus) {
	case 0: break;
	case 1:
	case 2:
	case 3:
		switch (sType) {
		case 10:
		case 37:
		case 43:
		case 51:
			iWheatherBonus = 1;
			break;

		case 20:
		case 30:
			iWheatherBonus = -1;
			break;
		}
   		break;
	}
	return iWheatherBonus;
}


int CGame::iGetPlayerRelationship(int iClientH, int iOpponentH)
{
 int iRet;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		// ÂºÂ»Ã€ÃÃ€ÃŒ Â¹Ã¼ÃÃ‹Ã€ÃšÃ€ÃŒÃ‡ÃÂ¸Ã© Â»Ã³Â´Ã«Â¹Ã¦Ã€ÃŒ Â¸Â¶Ã€Â»Ã€ÃŒ Â°Â°Ã€Âº Â°Ã¦Â¿Ã¬ Ã€Â§Ã‡Ã¹. Â´Ã™Â¸Â£Â¸Ã© Ã€Ã» 
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) && (memcmp(m_pClientList[iOpponentH]->m_cLocation, "NONE", 4) != 0)) {
			 iRet = 7; // Ã€Â§Ã‡Ã¹ 
		}
		else iRet = 2; // Ã€Ã»   
	}
	else if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// Â»Ã³Â´Ã«Â¹Ã¦Ã€ÃŒ Â¹Ã¼ÃÃ‹Ã€ÃšÃ€ÃŒÃ‡ÃÂ¸Ã©
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0)) 
			 iRet = 6; // Â¸Â¶Ã€Â»Ã€ÃŒ Â°Â°Ã€Â¸Â¸Ã© PK
		else iRet = 2; // Â´Ã™Â¸Â£Â¸Ã© Â±Ã—Â³Ã‰ Ã€Ã» 
	}
	else {
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[iOpponentH]->m_cSide != 0)) {
				// ÂµÃ‘ Â´Ã™ 0(Traveler)Ã€ÃŒ Â¾Ã†Â´ÃÂ¸Ã© Ã€Ã»Ã€ÃŒÂ´Ã™.
				iRet = 2;
			}
			else {
				iRet = 0;
			}
		}	
		else {
			// Â¾Ã†Â±ÂºÃ€ÃŒÂ´Ã™. Â±Ã¦ÂµÃ¥Â¿Ã¸Â¿Â©ÂºÃÂ¸Â¦ Ã†Ã‡Â´Ãœ.
			if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) ) {
				// Â±Ã¦ÂµÃ¥ Ã€ÃŒÂ¸Â§Ã€ÃŒ Â°Â°Â´Ã™. 
				if (m_pClientList[iOpponentH]->m_iGuildRank == 0)
					 iRet = 5;	// Â±Ã¦ÂµÃ¥ Â·Â©Ã…Â©Â°Â¡ 0. Â±Ã¦ÂµÃ¥Â¸Â¶Â½ÂºÃ…ÃÃ€ÃŒÂ´Ã™.
				else iRet = 3;	// Â°Â°Ã€Âº Â±Ã¦ÂµÃ¥Â¿Ã¸
			}
			else 
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iOpponentH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) != 0)) {
				// Â±Ã¦ÂµÃ¥ Ã€Â§Ã„Â¡Â´Ã‚ Â°Â°Â°Ã­ Â±Ã¦ÂµÃ¥ Ã€ÃŒÂ¸Â§Ã€ÃŒ Â´Ã™Â¸Â£Â´Ã™.
				iRet = 4; // Â´Ã™Â¸Â¥ Â±Ã¦ÂµÃ¥Â¿Ã¸ 
			}
			else iRet = 1; // Â±Ã—Â³Ã‰ Â°Â°Ã€ÂºÃ†Ã­ 
		}
	}

	return iRet;
}

int CGame::iGetPlayerABSStatus(int iWhatH, int iRecvH)
{
	int iRet;

	if (m_pClientList[iWhatH] == NULL) return 0;
	if (m_pClientList[iRecvH] == NULL) return 0;

	iRet = 0;

	/*if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone == TRUE &&
		m_pClientList[iWhatH]->m_iGuildRank != -1 && m_pClientList[iRecvH]->m_iGuildRank != -1 &&
		memcmp(m_pClientList[iWhatH]->m_cGuildName,m_pClientList[iRecvH]->m_cGuildName,20) != 0) {
			iRet = 8;
		}*/

		if (m_pClientList[iWhatH]->m_iPKCount != 0) {
			iRet = 8;
		}

		if (m_pClientList[iWhatH]->m_cSide != 0) {
			iRet = iRet | 4;
		}

		if (m_pClientList[iWhatH]->m_cSide == 1) {
			iRet = iRet | 2;
		}

		if (m_pClientList[iWhatH]->m_bIsPlayerCivil == TRUE)
			iRet = iRet | 1;

		return iRet;
}

int CGame::iGetNpcRelationship(int iWhatH, int iRecvH) 
{ 
	int iRet; 

	if (m_pClientList[iRecvH] == NULL) return 0; 
	if (m_pNpcList[iWhatH] == NULL) return 0; 

	iRet = 0; 
	switch (m_pNpcList[iWhatH]->m_cSide) { 
	case 10: iRet |= 8; //Fixed, Original 15 
	case 1:  iRet = (iRet | 4) | 2; //Fixed, Original 1 
	case 2:  iRet |= 4; //Fixed, Orignal 8 
	} 

	return iRet; 
}

/*int CGame::iGetPlayerRelationship_SendEvent(int iClientH, int iOpponentH)
{
 int iRet;
	
	// Â¿Â©Â±Ã¢Â¼Â­ Â»Ã§Ã€ÃŒÂµÃ¥ Â°Ã¨Â»ÃªÃ‡ÃÂ´Ã‚ Â¹Ã¦Â¹Ã½Ã€Âº Â°Ã¼ÃÂ¡Ã€ÃŒ Â´Ã™Â¸Â£Â¹Ã‡Â·Ã ÃÃ–Ã€Ã‡Ã‡Ã‘Â´Ã™. 
    // Â³Â» ÂµÂ¥Ã€ÃŒÃ…ÃÂ¸Â¦ Ã€Ã›Â¼ÂºÃ‡ÃÂ´Ã‚ Â°ÃÃ€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³ Â´Ã™Â¸Â¥ Ã€ÃŒÂ¿Â¡Â°Ã” ÂºÂ¸Â³Â»Â´Ã‚ ÂµÂ¥Ã€ÃŒÃ…ÃÂ¸Â¦ Ã€Ã›Â¼ÂºÃ‡ÃÂ´Ã‚ Â°ÃÃ€Ã“Ã€Â» ÃÃ–Ã€Ã‡.
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		// Â³Â»Â°Â¡ Â¹Ã¼ÃÃ‹Ã€ÃšÃ€ÃŒÃ‡ÃÂ¸Ã© Â»Ã³Â´Ã«Â¹Ã¦Â¿Â¡Â°Ã”Â´Ã‚ Â¸Â¶Ã€Â»Ã€ÃŒ Â´Ã™Â¸Â¦ Â°Ã¦Â¿Ã¬ Ã€Ã», Â¾Ã†Â´ÃÂ¸Ã© PKÂ·Ã Ã€ÃÂ½Ã„ÂµÃˆÂ´Ã™.
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) != 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) && (memcmp(m_pClientList[iOpponentH]->m_cLocation, "NONE", 4) != 0)) 
			 iRet = 2; // Ã€Ã» 
		else iRet = 6; // PK 
	}
	else if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// Â³Â»Â°Â¡ Â¹Â«Â°Ã­Ã‡ÃÂ°Ã­ Â»Ã³Â´Ã«Â¹Ã¦Ã€ÃŒ Â¹Ã¼ÃÃ‹Ã€ÃšÃ€ÃŒÃ‡ÃÂ¸Ã© Â»Ã³Â´Ã«Â¹Ã¦Â¿Â¡Â°Ã” Â¸Â¶Ã€Â»Ã€ÃŒ Â´Ã™Â¸Â¦ Â°Ã¦Â¿Ã¬ Ã€Ã», Â¾Ã†Â´ÃÂ¸Ã© Ã€Â§Ã‡Ã¹Ã€Â¸Â·Ã Ã€ÃÂ½Ã„ÂµÃˆÂ´Ã™.
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) != 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) && (memcmp(m_pClientList[iOpponentH]->m_cLocation, "NONE", 4) != 0)) 
			 iRet = 2; // Ã€Ã»
		else {
			iRet = 7; // Ã€Â§Ã‡Ã¹
		}
	}
	else {
		// Â»Ã³Â´Ã«Â¹Ã¦ÂµÂµ Â³ÂªÂµÂµ Â¹Ã¼ÃÃ‹Ã€ÃšÂ°Â¡ Â¾Ã†Â´ÃÂ´Ã™. 
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			// Â³ÂªÃ€Ã‡ Ã†Ã­Â°Ãº Â»Ã³Â´Ã«Â¹Ã¦Ã€Ã‡ Ã†Ã­Ã€ÃŒ Â´Ã™Â¸Â£Â´Ã™. 
			if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[iOpponentH]->m_cSide != 0)) {
				// Â³ÂªÂµÂµ ÃÃŸÂ¸Â³Ã€ÃŒ Â¾Ã†Â´ÃÂ°Ã­ Â»Ã³Â´Ã«Â¹Ã¦ÂµÂµ ÃÃŸÂ¸Â³Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© 0(Traveler)Ã€ÃŒ Â¾Ã†Â´ÃÂ¸Ã© Ã€Ã»Ã€Â¸Â·Ã Ã€ÃÂ½Ã„ÂµÃˆÂ´Ã™.
				iRet = 2;
			}
			else {
				// Ã‡Ã‘Ã‚ÃŠÃ€ÃŒ ÃÃŸÂ¸Â³Ã€ÃŒÂ¹Ã‡Â·Ã Â»Ã³Â´Ã«Â¹Ã¦Â¿Â¡Â°Ã” ÃÃŸÂ¸Â³Ã€Â¸Â·Ã Ã€ÃÂ½Ã„ÂµÃˆÂ´Ã™.
				iRet = 0;
			}
		}	
		else {
			// Â°Â°Ã€ÂºÃ†Ã­. ÂµÃ‘Â´Ã™ ÃÃŸÂ¸Â³Ã€ÃŒÂ°Ã…Â³Âª Â°Â°Ã€Âº Â¸Â¶Ã€Â» Â¼Ã’Â¼Ã“. Â±Ã¦ÂµÃ¥Â¿Ã¸Â¿Â©ÂºÃÂ¸Â¦ Ã†Ã‡Â´Ãœ.
			if ((m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide) && 
				(m_pClientList[iClientH]->m_cSide == 0)) {
				iRet = 0; // ÂµÃ‘Â´Ã™ ÃÃŸÂ¸Â³Ã€ÃŒÂ¹Ã‡Â·Ã ÃÃŸÂ¸Â³.
			}
			else			
			if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) ) {
				// Â±Ã¦ÂµÃ¥ Ã€ÃŒÂ¸Â§Ã€ÃŒ Â°Â°Â´Ã™. 
				if (m_pClientList[iClientH]->m_iGuildRank == 0)
					 iRet = 5;	// Â³Â» Â±Ã¦ÂµÃ¥ Â·Â©Ã…Â©Â°Â¡ 0. Â±Ã¦ÂµÃ¥Â¸Â¶Â½ÂºÃ…ÃÂ·Ã Â»Ã³Â´Ã«Â¹Ã¦Â¿Â¡Â°Ã” Ã€ÃÂ½Ã„ÂµÃˆÂ´Ã™.
				else iRet = 3;	// Â°Â°Ã€Âº Â±Ã¦ÂµÃ¥Â¿Ã¸
			}
			else 
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iOpponentH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) != 0)) {
				// Â±Ã¦ÂµÃ¥ Ã€ÃŒÂ¸Â§Ã€Âº Â´Ã™Â¸Â£Â³Âª Â±Ã¦ÂµÃ¥ Ã€Â§Ã„Â¡Â´Ã‚ Â°Â°Â°Ã­ Â±Ã¦ÂµÃ¥ Ã€ÃŒÂ¸Â§Ã€ÃŒ Â´Ã™Â¸Â£Â´Ã™.
				iRet = 4; // Â´Ã™Â¸Â¥ Â±Ã¦ÂµÃ¥Â¿Ã¸ 
			}
			else {
				iRet = 1; // Â±Ã—Â³Ã‰ Â°Â°Ã€ÂºÃ†Ã­ 
			}
		}
	}

	return iRet;
}*/


int CGame::iGetNpcRelationship_SendEvent(int iNpcH, int iOpponentH)
{
 int iRet;
	
	// Â¿Â©Â±Ã¢Â¼Â­ Â»Ã§Ã€ÃŒÂµÃ¥ Â°Ã¨Â»ÃªÃ‡ÃÂ´Ã‚ Â¹Ã¦Â¹Ã½Ã€Âº Â°Ã¼ÃÂ¡Ã€ÃŒ Â´Ã™Â¸Â£Â¹Ã‡Â·Ã ÃÃ–Ã€Ã‡Ã‡Ã‘Â´Ã™. 
    // Â³Â»(NPC) ÂµÂ¥Ã€ÃŒÃ…ÃÂ¸Â¦ Ã€Ã›Â¼ÂºÃ‡ÃÂ´Ã‚ Â°ÃÃ€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³ Â´Ã™Â¸Â¥ Ã€ÃŒÂ¿Â¡Â°Ã” ÂºÂ¸Â³Â»Â´Ã‚ ÂµÂ¥Ã€ÃŒÃ…ÃÂ¸Â¦ Ã€Ã›Â¼ÂºÃ‡ÃÂ´Ã‚ Â°ÃÃ€Ã“Ã€Â» ÃÃ–Ã€Ã‡.
	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pNpcList[iNpcH] == NULL) return 0;

	iRet = 0;

	if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// Â»Ã³Â´Ã«Â¹Ã¦Ã€ÃŒ Â¹Ã¼ÃÃ‹Ã€ÃšÃ€ÃŒÃ‡ÃÂ¸Ã© Ã†Ã­Ã€ÃŒ Â°Â°Ã€Â¸Â¸Ã© Ã€Â§Ã‡Ã¹Ã€Â¸Â·Ã Â¾Ã†Â´ÃÂ¸Ã© NPC Ã€Ã»Ã€Â¸Â·Ã Ã€ÃÂ½Ã„ÂµÃˆÂ´Ã™.
		if (m_pNpcList[iNpcH]->m_cSide == m_pClientList[iOpponentH]->m_cSide)
			 iRet = 7; 
		else iRet = 2;
	}
	else {
		if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			// Â¸Ã·Ã€Ã‡ Ã†Ã­Â°Ãº Â»Ã³Â´Ã«Â¹Ã¦Ã€Ã‡ Ã†Ã­Ã€ÃŒ Â´Ã™Â¸Â£Â´Ã™.
			if (m_pNpcList[iNpcH]->m_cSide == 10) 
				iRet = 2; // Â¸Ã·Ã€ÃŒ Ã€ÃÂ¹Ã Â¸Ã·Ã€ÃŒÂ´Ã™. Â»Ã³Â´Ã«Â¹Ã¦Â¿Â¡Â°Ã”Â´Ã‚ Ã€Ã»Ã€Â¸Â·Ã Ã€ÃÂ½Ã„ÂµÃˆÂ´Ã™.
			else 
			if (m_pNpcList[iNpcH]->m_cSide == 0) iRet = 0; // Â¸Ã·Ã€ÃŒ ÃÃŸÂ¸Â³Ã€ÃŒÂ¸Ã© Â¹Â«ÃÂ¶Â°Ã‡ ÃÃŸÂ¸Â³ 	
			else 
			if (m_pClientList[iOpponentH]->m_cSide == 0) 
				 iRet = 0; // Â»Ã³Â´Ã«Â¹Ã¦Ã€ÃŒ ÃÃŸÂ¸Â³Ã€ÃŒÂ´Ã™. Â¼Ã’ÃˆÂ¯Â¸Ã·Â°Ãº ÃÃŸÂ¸Â³Â°ÃºÃ€Ã‡ Â°Ã¼Â°Ã¨Â´Ã‚ ÃÃŸÂ¸Â³. 
			else iRet = 2; // Â¼Ã’ÃˆÂ¯Â¸Ã·Â°Ãº Â½ÃƒÂ¹Ã Ã€ÃŒÂ»Ã³Ã€ÃÂµÂ¥ Ã†Ã­Ã€ÃŒ Â´Ã™Â¸Â£Â¹Ã‡Â·Ã Ã€Ã» 
			
		}
		else iRet = 1; // Â°Â°Ã€Âº Ã†Ã­ 
	}

	return iRet;
}


int CGame::iGetMapIndex(char * pMapName)
{
 register int i, iMapIndex;
 char cTmpName[256];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);

	iMapIndex = -1;
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {
		if (memcmp(m_pMapList[i]->m_cName, pMapName, 10) == 0) 
			iMapIndex = i;
	}

	return iMapIndex;
}



int CGame::_iForcePlayerDisconect(int iNum)
{
 register int i, iCnt;

	iCnt = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) {
		if (m_pClientList[i]->m_bIsInitComplete == TRUE)
			 DeleteClient(i, TRUE, TRUE);
		else DeleteClient(i, FALSE, FALSE);
		iCnt++;
		if (iCnt >= iNum) break;
	}

	return iCnt;
}

void CGame::SpecialEventHandler()
{
 DWORD dwTime;
 
	// Ã†Â¯ÂºÂ°Ã‡Ã‘ Ã€ÃŒÂºÂ¥Ã†Â®Â¸Â¦ Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™. 
	dwTime = timeGetTime();

	if ((dwTime - m_dwSpecialEventTime) < DEF_SPECIALEVENTTIME) return; // DEF_SPECIALEVENTTIME
	m_dwSpecialEventTime  = dwTime;
	m_bIsSpecialEventTime = TRUE;
	
	switch (iDice(1,180)) {
	case 98: m_cSpecialEventType = 2; break; // ÂµÂ¥Â¸Ã³ ÃˆÂ¤Ã€Âº Ã€Â¯Â´ÃÃ„ÃœÃ€ÃŒ Â³ÂªÂ¿Ãƒ Â°Â¡Â´Ã‰Â¼ÂºÃ€Âº 30ÂºÃÂ¿Â¡ 1Â¹Ã¸ 1/30
	default: m_cSpecialEventType = 1; break;
	}
}

void CGame::AdminOrder_CheckIP(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cIP[21], cInfoString[500];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCheckIP) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if (token != NULL) {
		// tokenÃ€ÃŒ IP addressÃ€ÃŒÂ´Ã™. 
		ZeroMemory(cIP, sizeof(cIP));
		strcpy(cIP, token);

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cIPaddress, cIP, strlen(cIP)) == 0)) {
			// Â¿Ã¤Â±Â¸Ã‡Ã‘ ÃÃ–Â¼Ã’Â¿Ã Ã€ÃÃ„Â¡Ã‡ÃÂ´Ã‚ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® Â¹ÃŸÂ°ÃŸ. 
			ZeroMemory(cInfoString, sizeof(cInfoString));
			wsprintf(cInfoString, "Name(%s/%s) Loc(%s: %d %d) Level(%d:%d) Init(%d) IP(%s)", 
				     m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cMapName, 
					 m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 
					 m_pClientList[i]->m_iLevel, NULL/*m_pClientList[i]->m_cAccountStatus*/,
					 m_pClientList[i]->m_bIsInitComplete, m_pClientList[i]->m_cIPaddress);

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		}
	}

	
	delete pStrTok;
}

void CGame::ToggleSafeAttackModeHandler(int iClientH) //v1.1
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	// Â¾ÃˆÃ€Ã¼ Â°Ã¸Â°Ã Â¸Ã°ÂµÃ¥Â¸Â¦ Ã…Ã¤Â±Ã›Ã‡Ã‘Â´Ã™. 
	if (m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) 
		 m_pClientList[iClientH]->m_bIsSafeAttackMode = FALSE;
	else m_pClientList[iClientH]->m_bIsSafeAttackMode = TRUE;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
}

void CGame::NpcRequestAssistance(int iNpcH)
{
 register int ix, iy, sX, sY;
 short sOwnerH;
 char  cOwnerType;
	
	// iNpc Â±Ã™Â¹Ã¦Â¿Â¡ Ã€Ã–Â´Ã‚ Ã€Ã¼Ã…ÃµÃÃŸÃ€ÃŒ Â¾Ã†Â´Ã‘ NPCÂ¿Â¡Â°Ã” ÂµÂµÂ¿Ã²Ã€Â» Â¿Ã¤ÃƒÂ»Ã‡Ã‘Â´Ã™. 
	if (m_pNpcList[iNpcH] == NULL) return;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	for (ix = sX - 8; ix <= sX + 8; ix++)
	for (iy = sY - 8; iy <= sY + 8; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != NULL) && (m_pNpcList[sOwnerH] != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && 
			(iNpcH != sOwnerH) && (m_pNpcList[sOwnerH]->m_cSide == m_pNpcList[iNpcH]->m_cSide) &&
			(m_pNpcList[sOwnerH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[sOwnerH]->m_cBehavior == DEF_BEHAVIOR_MOVE)) {
			
			// ÃÂ¶Â°Ã‡Â¿Â¡ ÂºÃÃ‡Ã•Ã‡ÃÂ´Ã‚ NPCÂ¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™. 
			m_pNpcList[sOwnerH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[sOwnerH]->m_sBehaviorTurnCount = 0;		
			m_pNpcList[sOwnerH]->m_iTargetIndex = m_pNpcList[iNpcH]->m_iTargetIndex;
			m_pNpcList[sOwnerH]->m_cTargetType  = m_pNpcList[iNpcH]->m_cTargetType;

			return;
		}
	}
}

void CGame::ForceDisconnectAccount(char *pAccountName, WORD wCount)
{
 register int i;

	// ÃÃŸÂºÂ¹ÂµÃˆ Â°Ã¨ÃÂ¤Ã€Â» Â°Â®Â°Ã­Ã€Ã–Â´Ã‚ Ã„Â³Â¸Â¯Ã…ÃÂ¸Â¦ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cAccountName, pAccountName, 10) == 0)) {
		wsprintf(G_cTxt, "<%d> Force disconnect account: CharName(%s) AccntName(%s) Count(%d)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, wCount);
		PutLogList(G_cTxt);
		
		// v1.42 Ã„Â«Â¿Ã®Ã†Ãƒ Ã‡ÃƒÂ·Â¡Â±Ã—Â¸Â¦ ÃˆÂ°Â¼ÂºÃˆÂ­ Ã‡Ã˜Â¾ÃŸ Ã‡Ã‘Â´Ã™. 
		//DeleteClient(i, TRUE, TRUE);

		//v1.4312
		SendNotifyMsg(NULL, i, DEF_NOTIFY_FORCEDISCONN, wCount, NULL, NULL, NULL);
	}
}

void CGame::AdminOrder_Polymorph(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelPolymorph) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		if (memcmp(token, "off", 3) == 0)
			m_pClientList[iClientH]->m_sType = m_pClientList[iClientH]->m_sOriginalType;

		else if (memcmp(token, "Slime", 5) == 0)
			m_pClientList[iClientH]->m_sType = 10;

		else if (memcmp(token, "Skeleton", 8) == 0)
			m_pClientList[iClientH]->m_sType = 11;

		else if (memcmp(token, "Stone-Golem", 11) == 0)
			m_pClientList[iClientH]->m_sType = 12;

		else if (memcmp(token, "Cyclops", 7) == 0)
			m_pClientList[iClientH]->m_sType = 13;

		else if (memcmp(token, "Orc", 3) == 0)
			m_pClientList[iClientH]->m_sType = 14;

		else if (memcmp(token, "ShopKeeper", 10) == 0)
			m_pClientList[iClientH]->m_sType = 15;

		else if (memcmp(token, "Giant-Ant", 9) == 0)
			m_pClientList[iClientH]->m_sType = 16;

		else if (memcmp(token, "Scorpion", 8) == 0)
			m_pClientList[iClientH]->m_sType = 17;

		else if (memcmp(token, "Zombie", 6) == 0)
			m_pClientList[iClientH]->m_sType = 18;

		else if (memcmp(token, "Gandlf", 6) == 0)
			m_pClientList[iClientH]->m_sType = 19;

		else if (memcmp(token, "Howard", 6) == 0)
			m_pClientList[iClientH]->m_sType = 20;

		else if (memcmp(token, "Gaurd", 5) == 0)
			m_pClientList[iClientH]->m_sType = 21;

		else if (memcmp(token, "Amphis", 6) == 0)
			m_pClientList[iClientH]->m_sType = 22;

		else if (memcmp(token, "Clay-Golem", 10) == 0)
			m_pClientList[iClientH]->m_sType = 23;

		else if (memcmp(token, "Tom", 3) == 0)
			m_pClientList[iClientH]->m_sType = 24;

		else if (memcmp(token, "William", 7) == 0)
			m_pClientList[iClientH]->m_sType = 25;

		else if (memcmp(token, "Kennedy", 7) == 0)
			m_pClientList[iClientH]->m_sType = 26;

		else if (memcmp(token, "Hellbound", 9) == 0)
			m_pClientList[iClientH]->m_sType = 27;

		else if (memcmp(token, "Troll", 5) == 0)
			m_pClientList[iClientH]->m_sType = 28;

		else if (memcmp(token, "Orge", 4) == 0)
			m_pClientList[iClientH]->m_sType = 29;

		else if (memcmp(token, "Liche", 5) == 0)
			m_pClientList[iClientH]->m_sType = 30;

		else if (memcmp(token, "Demon", 5) == 0)
			m_pClientList[iClientH]->m_sType = 31;

		else if (memcmp(token, "Unicorn", 7) == 0)
			m_pClientList[iClientH]->m_sType = 32;

		else if (memcmp(token, "WereWolf", 8) == 0)
			m_pClientList[iClientH]->m_sType = 33;

		else if (memcmp(token, "Dummy", 5) == 0)
			m_pClientList[iClientH]->m_sType = 34;

		else if (memcmp(token, "Energy-Sphere", 13) == 0)
			m_pClientList[iClientH]->m_sType = 35;

		else if (memcmp(token, "AGT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 36;

		else if (memcmp(token, "CGT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 37;

		else if (memcmp(token, "MS", 2) == 0)
			m_pClientList[iClientH]->m_sType = 38;

		else if (memcmp(token, "DT", 2) == 0)
			m_pClientList[iClientH]->m_sType = 39;

		else if (memcmp(token, "ESG", 3) == 0)
			m_pClientList[iClientH]->m_sType = 40;

		else if (memcmp(token, "GMG", 3) == 0)
			m_pClientList[iClientH]->m_sType = 41;

		else if (memcmp(token, "ManaStone", 9) == 0)
			m_pClientList[iClientH]->m_sType = 42;

		else if (memcmp(token, "LWB", 3) == 0)
			m_pClientList[iClientH]->m_sType = 43;

		else if (memcmp(token, "GHK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 44;

		else if (memcmp(token, "GHC", 6) == 0)
			m_pClientList[iClientH]->m_sType = 45;

		else if (memcmp(token, "TK", 2) == 0)
			m_pClientList[iClientH]->m_sType = 46;

		else if (memcmp(token, "BG", 2) == 0)
			m_pClientList[iClientH]->m_sType = 47;

		else if (memcmp(token, "Stalker", 7) == 0)
			m_pClientList[iClientH]->m_sType = 48;

		else if (memcmp(token, "Hellclaw", 8) == 0)
			m_pClientList[iClientH]->m_sType = 49;

		else if (memcmp(token, "Tigerworm", 8) == 0)
			m_pClientList[iClientH]->m_sType = 50;

		else if (memcmp(token, "CP", 2) == 0)
			m_pClientList[iClientH]->m_sType = 51;

		else if (memcmp(token, "Gagoyle", 7) == 0)
			m_pClientList[iClientH]->m_sType = 52;

		else if (memcmp(token, "Beholder", 8) == 0)
			m_pClientList[iClientH]->m_sType = 53;

		else if (memcmp(token, "Dark-Elf", 8) == 0)
			m_pClientList[iClientH]->m_sType = 54;

		else if (memcmp(token, "Rabbit", 6) == 0)
			m_pClientList[iClientH]->m_sType = 55;

		else if (memcmp(token, "Cat", 3) == 0)
			m_pClientList[iClientH]->m_sType = 56;

		else if (memcmp(token, "Giant-Frog", 10) == 0)
			m_pClientList[iClientH]->m_sType = 57;

		else if (memcmp(token, "Mountain-Giant", 14) == 0)
			m_pClientList[iClientH]->m_sType = 58;

		else if (memcmp(token, "Ettin", 5) == 0)
			m_pClientList[iClientH]->m_sType = 59;

		else if (memcmp(token, "Cannibal-Plant", 13) == 0)
			m_pClientList[iClientH]->m_sType = 60;

		else if (memcmp(token, "Rudolph", 7) == 0)
			m_pClientList[iClientH]->m_sType = 61;

		else if (memcmp(token, "DireBoar", 8) == 0)
			m_pClientList[iClientH]->m_sType = 62;

		else if (memcmp(token, "Frost", 5) == 0)
			m_pClientList[iClientH]->m_sType = 63;

		else if (memcmp(token, "Crops", 5) == 0)
			m_pClientList[iClientH]->m_sType = 64;

		else if (memcmp(token, "Ice-Golem", 9) == 0)
			m_pClientList[iClientH]->m_sType = 65;

		//else if (memcmp(token, "Wyvern", 6) == 0)
		//	m_pClientList[iClientH]->m_sType = 66;

		else if (memcmp(token, "McGaffin", 8) == 0)
			m_pClientList[iClientH]->m_sType = 67;

		else if (memcmp(token, "Perry", 5) == 0)
			m_pClientList[iClientH]->m_sType = 68;

		else if (memcmp(token, "Devlin", 6) == 0)
			m_pClientList[iClientH]->m_sType = 69;

		else if (memcmp(token, "Barlog", 6) == 0)
			m_pClientList[iClientH]->m_sType = 70;

		else if (memcmp(token, "Centaurus", 9) == 0)
			m_pClientList[iClientH]->m_sType = 71;

		else if (memcmp(token, "Claw-Turtle", 11) == 0)
			m_pClientList[iClientH]->m_sType = 72;

		//else if (memcmp(token, "Fire-Wyvern", 11) == 0)
		//	m_pClientList[iClientH]->m_sType = 73;

		else if (memcmp(token, "Giant-Crayfish", 14) == 0)
			m_pClientList[iClientH]->m_sType = 74;

		else if (memcmp(token, "Giant-Lizard", 12) == 0)
			m_pClientList[iClientH]->m_sType = 75;

		else if (memcmp(token, "Giant-Plant", 11) == 0)
			m_pClientList[iClientH]->m_sType = 76;

		else if (memcmp(token, "MasterMage-Orc", 14) == 0)
			m_pClientList[iClientH]->m_sType = 77;

		else if (memcmp(token, "Minotaurs", 9) == 0)
			m_pClientList[iClientH]->m_sType = 78;

		else if (memcmp(token, "Nizie", 5) == 0)
			m_pClientList[iClientH]->m_sType = 79;

		else if (memcmp(token, "Tentocle", 8) == 0)
			m_pClientList[iClientH]->m_sType = 80;

		//else if (memcmp(token, "Abaddon", 7) == 0)
		//	m_pClientList[iClientH]->m_sType = 81;

		else if (memcmp(token, "Sor", 3) == 0)
			m_pClientList[iClientH]->m_sType = 82;

		else if (memcmp(token, "ATK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 83;

		else if (memcmp(token, "Elf", 3) == 0)
			m_pClientList[iClientH]->m_sType = 84;

		else if (memcmp(token, "DSK", 3) == 0)
			m_pClientList[iClientH]->m_sType = 85;

		else if (memcmp(token, "HBT", 3) == 0)
			m_pClientList[iClientH]->m_sType = 86;

		else if (memcmp(token, "CT", 2) == 0)
			m_pClientList[iClientH]->m_sType = 87;

		else if (memcmp(token, "Bar", 3) == 0)
			m_pClientList[iClientH]->m_sType = 88;

		else if (memcmp(token, "AGC", 3) == 0)
			m_pClientList[iClientH]->m_sType = 89;

		else if (memcmp(token, "Gail", 4) == 0)
			m_pClientList[iClientH]->m_sType = 90;

		else if (memcmp(token, "gate", 4) == 0)
			m_pClientList[iClientH]->m_sType = 91;
	}
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	delete pStrTok;
}

void CGame::AdminOrder_SetInvi(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetInvis) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		// Ã€ÃŒ Â°ÂªÃ€ÃŒ Â¹Â®Ã€Ãš '1'Ã€ÃŒÂ¸Ã© Ã…ÃµÂ¸Ã­Ã€Â¸Â·Ã Â¼Â¼Ã†Â®. '0'Ã€ÃŒÂ¸Ã© Ã‡Ã˜ÃÂ¦ 
		if (token[0] == '1') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		else
		if (token[0] == '0') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	}

	delete pStrTok;
}

BOOL CGame::bOnClose()
{
	if (m_bIsServerShutdowned == FALSE) 
		if (MessageBox(NULL, "Player data not saved! Shutdown server now?", m_cServerName, MB_ICONEXCLAMATION | MB_YESNO) == IDYES) return TRUE;
		else return FALSE;
	else return TRUE;
		
	return FALSE;
}

void CGame::AdminOrder_SetZerk(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetZerk) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		// Ã€ÃŒ Â°ÂªÃ€ÃŒ Â¹Â®Ã€Ãš '1'Ã€ÃŒÂ¸Ã© Ã…ÃµÂ¸Ã­Ã€Â¸Â·Ã Â¼Â¼Ã†Â®. '0'Ã€ÃŒÂ¸Ã© Ã‡Ã˜ÃÂ¦ 


		if (token[0] == '1')
		{
			SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[32]->m_sValue4;
		}
		else
			if (token[0] == '0') SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	}

	delete pStrTok;
}

void CGame::AdminOrder_SetFreeze(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetIce) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		// Ã€ÃŒ Â°ÂªÃ€ÃŒ Â¹Â®Ã€Ãš '1'Ã€ÃŒÂ¸Ã© Ã…ÃµÂ¸Ã­Ã€Â¸Â·Ã Â¼Â¼Ã†Â®. '0'Ã€ÃŒÂ¸Ã© Ã‡Ã˜ÃÂ¦ 
		if (token[0] == '1') SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		else
			if (token[0] == '0') SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	}

	delete pStrTok;
}

// 05/24/2004 - Hypnotoad - Hammer and Wand train to 100% fixed
void CGame::_CheckAttackType(int iClientH, short *spType)
{
	WORD wType;

	if (m_pClientList[iClientH] == NULL) return;
	wType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	switch (*spType) {
	case 2:	
		// ÃƒË†Ã‚Â­Ã‚Â»ÃƒÂ¬Ãƒâ‚¬ÃƒÅ’ Ã‚Â¾ÃƒÂ¸Ã‚Â´Ãƒâ„¢Ã‚Â¸ÃƒÂ© ÃƒË†Ã‚Â­Ã‚Â»ÃƒÂ¬ EffectÃ‚Â´Ãƒâ€š Ã‚Â³Ãƒâ€“ÃƒÂÃƒÂ¶ Ã‚Â¾ÃƒÅ Ã‚Â´Ãƒâ€šÃ‚Â´Ãƒâ„¢. 
		if (m_pClientList[iClientH]->m_cArrowIndex == -1) *spType = 0;
		// ÃƒË†Ã‚Â° Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂÃƒâ‚¬ÃƒÅ½Ã‚ÂµÃ‚Â¥ Ãƒâ‚¬ÃƒÂ¥Ãƒâ€šÃƒÂ¸Ãƒâ€¡Ãƒâ€˜ Ã‚Â¹Ã‚Â«Ã‚Â±ÃƒÂ¢Ã‚Â°Ã‚Â¡ ÃƒË†Ã‚Â°Ãƒâ‚¬ÃƒÅ’ Ã‚Â¾Ãƒâ€ Ã‚Â´ÃƒÂÃ‚Â´Ãƒâ„¢. Ãƒâ‚¬ÃƒÂÃ‚Â¹ÃƒÂ Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂÃƒâ‚¬Ã‚Â¸Ã‚Â·ÃƒÅ½ Ãƒâ‚¬ÃƒÂ¼ÃƒË†Ã‚Â¯.
		if (wType < 40) *spType = 1;
		break;

	case 20:
		// Ã‚Â¸Ãƒâ€¡Ã‚Â¼Ãƒâ€¢ Ãƒâ€¡ÃƒÅ Ã‚Â»ÃƒÂ¬Ã‚Â±ÃƒÂ¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[5] < 100) *spType = 1;
		break;

	case 21: 
		// Ã‚Â´ÃƒÅ“Ã‚Â°Ãƒâ€¹ Ãƒâ€¡ÃƒÅ Ã‚Â»ÃƒÂ¬Ã‚Â±ÃƒÂ¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[7] < 100) *spType = 1;
		break;

	case 22: 
		// Ãƒâ€ ÃƒÂ¦Ã‚Â½ÃƒÅ’ Ãƒâ€¡ÃƒÅ Ã‚Â»ÃƒÂ¬Ã‚Â±ÃƒÂ¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[9] < 100) *spType = 1;
		break;

	case 23: 
		// Ãƒâ‚¬ÃƒÂ¥Ã‚Â°Ãƒâ€¹ Ãƒâ€¡ÃƒÅ Ã‚Â»ÃƒÂ¬Ã‚Â±ÃƒÂ¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[8] < 100) *spType = 1;
		break;

	case 24: 
		// Ã‚ÂµÃ‚ÂµÃ‚Â³Ã‚Â¢ Ãƒâ€¡ÃƒÅ Ã‚Â»ÃƒÂ¬Ã‚Â±ÃƒÂ¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[10] < 100) *spType = 1;
		break;

	case 25: 
		// ÃƒË†Ã‚Â° Ãƒâ€¡ÃƒÅ Ã‚Â»ÃƒÂ¬Ã‚Â±ÃƒÂ¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[6] < 100) *spType = 2;
		if (m_pClientList[iClientH]->m_cArrowIndex == -1)      *spType = 0;
		// ÃƒË†Ã‚Â° Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂÃƒâ‚¬ÃƒÅ½Ã‚ÂµÃ‚Â¥ Ãƒâ‚¬ÃƒÂ¥Ãƒâ€šÃƒÂ¸Ãƒâ€¡Ãƒâ€˜ Ã‚Â¹Ã‚Â«Ã‚Â±ÃƒÂ¢Ã‚Â°Ã‚Â¡ ÃƒË†Ã‚Â°Ãƒâ‚¬ÃƒÅ’ Ã‚Â¾Ãƒâ€ Ã‚Â´ÃƒÂÃ‚Â´Ãƒâ„¢. Ãƒâ‚¬ÃƒÂÃ‚Â¹ÃƒÂ Ã‚Â°ÃƒÂ¸Ã‚Â°ÃƒÂÃƒâ‚¬Ã‚Â¸Ã‚Â·ÃƒÅ½ Ãƒâ‚¬ÃƒÂ¼ÃƒË†Ã‚Â¯.
		if (wType < 40) *spType = 1;
		break;

	case 26: 
		// v2.16 2002-5-27 Ã‡Ã˜Â¸Ã“ Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[14] < 100) *spType = 1;
		break;

	case 27: 
		// v2.16 2002-5-27 ÃÃ¶Ã†ÃÃ€ÃŒ Ã‡ÃŠÂ»Ã¬Â±Ã¢ 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[21] < 100) *spType = 1;
		break;
	}
}

void CGame::ReqCreatePortionHandler(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cI[6], cPortionName[21], cData[120];
 int    iRet, i, j, iEraseReq, iSkillLimit, iSkillLevel, iResult, iDifficulty;
 short * sp, sItemIndex[6], sTemp;
 short  sItemNumber[6], sItemArray[12];
 BOOL   bDup, bFlag;
 class  CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++) {
		cI[i] = -1;
		sItemIndex[i]  = -1;
		sItemNumber[i] = 0;
	}

	cp = (char *)(pData + 11);
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;
	// Ã†Ã·Â¼Ã‡Ã€Ã‡ Ã€Ã§Â·Ã¡ Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ Â¹ÃÂ¾Ã’Â´Ã™. Ã€ÃŒ Ã€Ã§Â·Ã¡Â°Â¡ Ã†Ã·Â¼Ã‡Ã€Â» Â¸Â¸ÂµÃ© Â¼Ã¶ Ã€Ã–Â´Ã‚ ÃÂ¶Ã‡Ã•Ã€ÃÃÃ¶ ÃˆÂ®Ã€ÃÃ‡Ã‘Â´Ã™. 

	// ÂµÂ¥Ã€ÃŒÃ…ÃÂ°Â¡ Ã€Â¯ÃˆÂ¿Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã› Ã€ÃÂµÂ¦Â½ÂºÃ€ÃÃÃ¶ ÃƒÂ¼Ã…Â©Ã‡Ã‘Â´Ã™.
	for (i = 0; i < 6; i++) {
		if (cI[i] >= DEF_MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
	}

	for (i = 0; i < 6; i++)
	if (cI[i] >= 0) {
		// Â¸Ã•Ã€Ãº Ã€ÃŒÂ¹ÃŒ Ã€Ã–Â´Ã‚ Â¸Â®Â½ÂºÃ†Â®Ã€ÃÃÃ¶ Â°Ã‹Â»Ã¶ 
		bDup = FALSE;
		for (j = 0; j < 6; j++) 
		if (sItemIndex[j] == cI[i]) {
			// Ã€Ã–Â´Ã™. Ã„Â«Â¿Ã®Ã†Â® ÃÃµÂ°Â¡ 
			sItemNumber[j]++;
			bDup = TRUE;
		}
		if (bDup == FALSE) {
			// Â¾Ã¸Â´Ã™. Â»ÃµÂ·Ã ÃƒÃŸÂ°Â¡Ã‡Ã‘Â´Ã™.
			for (j = 0; j < 6; j++) 
			if (sItemIndex[j] == -1) {
				sItemIndex[j] = cI[i];
				sItemNumber[j]++;
				goto RCPH_LOOPBREAK;
			}
RCPH_LOOPBREAK:;
		}
	}
	
	// Â¾Ã†Ã€ÃŒÃ…Ã› Â¸Â®Â½ÂºÃ†Â®Â°Â¡ Â¸Â¸ÂµÃ©Â¾Ã® ÃÂ³Â´Ã™. Â¼Ã’ÂºÃ±ÂµÃ‡Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¶Ã³Â¸Ã© Â°Â¹Â¼Ã¶Â¸Â¦ ÃˆÂ®Ã€ÃÃ‡Ã‘Â´Ã™. 
	for (i = 0; i < 6; i++) 
	if (sItemIndex[i] != -1) {
		if (sItemIndex[i] < 0) return;
		if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;
		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â°Â¹Â¼Ã¶Â°Â¡ Â¿Ã€Â¹Ã¶Ã‡Ã˜ÂµÂµ Â¸Â®Ã…Ã.
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;
	}

	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã†Ã€ÃŒÂµÃ° Â¹Ã¸ÃˆÂ£Â°Â¡ Ã…Â« Â¼Ã¸Â¼Â­ÂºÃÃ…Ã ÃÂ¤Â·Ã„Ã‡Ã‘Â´Ã™. Bubble Sort
	bFlag = TRUE;
	while (bFlag == TRUE) {
		bFlag = FALSE;
		for (i = 0; i < 5; i++) 
		if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1)) {
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) <
				(m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum)) {
				// Â¹Ã™Â²Ã›Â´Ã™.
				sTemp = sItemIndex[i+1];
				sItemIndex[i+1] = sItemIndex[i];
				sItemIndex[i] = sTemp;
				sTemp = sItemNumber[i+1];
				sItemNumber[i+1] = sItemNumber[i];
				sItemNumber[i] = sTemp;
				bFlag = TRUE;
			}
		}
	}

	//testcode
	/*
	char cTemp[120];
	char cTxt1[120];
	char cTxt2[120];
	ZeroMemory(cTxt1, sizeof(cTxt1));
	ZeroMemory(cTxt2, sizeof(cTxt2));
	for (i = 0; i < 6; i++) {
		ZeroMemory(cTemp, sizeof(cTemp));
		if (sItemIndex[i] != -1)
			 wsprintf(cTemp, "(%d) ", m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum);
		else strcpy(cTemp, "(*)");
		strcat(cTxt1, cTemp);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "(%d) ", sItemNumber[i]);
		strcat(cTxt2, cTemp);
	}
	PutLogList(cTxt1);
	PutLogList(cTxt2);
	*/

	// ÂµÂ¥Ã€ÃŒÃ…ÃÂ¿Â¡ Ã€ÃŒÂ»Ã³Ã€ÃŒ Â¾Ã¸Ã€Â½Ã€ÃŒ ÃˆÂ®Ã€ÃÂµÃ‡Â¾ÃºÂ´Ã™. Ã†Ã·Â¼Ã‡ ÃÂ¦Ã€Ã› Â¹Ã¨Â¿Â­Ã€Â» Ã€Ã›Â¼ÂºÃ‡Ã‘Â´Ã™. 
	j = 0;
	for (i = 0; i < 6; i++) {
		if (sItemIndex[i] != -1)
			 sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = sItemNumber[i];
		j += 2;
	}

	//testcode
	/*
	char cTemp[120], cTxt1[120];
	ZeroMemory(cTxt1, sizeof(cTxt1));
	for (i = 0; i < 12; i++) {
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d", sItemArray[i]);
		strcat(cTxt1, cTemp);
	}
	PutLogList(cTxt1);
	*/

	// sItemArrayÃ€Ã‡ 12Â°Â¡ÃÃ¶ Â¹Ã¨Â¿Â­Â°Ãº Ã€ÃÃ„Â¡Ã‡ÃÂ´Ã‚ Ã†Ã·Â¼Ã‡Ã€Â» Â¸Â®Â½ÂºÃ†Â®Â¿Â¡Â¼Â­ Â°Ã‹Â»Ã¶Ã‡Ã‘Â´Ã™. 
	ZeroMemory(cPortionName, sizeof(cPortionName));

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) 
	if (m_pPortionConfigList[i] != NULL) {
		bFlag = FALSE;
		for (j = 0; j < 12; j++) 
		if (m_pPortionConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = TRUE;
		
		if (bFlag == FALSE) {
			// Ã†Ã·Â¼Ã‡ ÃÂ¶Ã‡Ã•Ã€ÃŒ Ã€ÃÃ„Â¡Ã‡ÃÂ´Ã‚ Â¸Â®Â½ÂºÃ†Â®Â¸Â¦ Â¹ÃŸÂ°ÃŸÃ‡ÃŸÂ´Ã™. 
			ZeroMemory(cPortionName, sizeof(cPortionName));
			memcpy(cPortionName, m_pPortionConfigList[i]->m_cName, 20);
			iSkillLimit = m_pPortionConfigList[i]->m_iSkillLimit;
			iDifficulty = m_pPortionConfigList[i]->m_iDifficulty;
		}
	}

	// ÃÂ¶Ã‡Ã•Ã€ÃŒ Ã€ÃÃ„Â¡Ã‡ÃÂ´Ã‚ Ã†Ã·Â¼Ã‡Ã€ÃŒ Â¾Ã¸Ã€Â¸Â¹Ã‡Â·Ã Â¹Â«Â½Ãƒ
	if (strlen(cPortionName) == 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMATCHINGPORTION, NULL, NULL, NULL, NULL);
		return;
	}

	// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Â¿Â¬Â±ÃÂ¼Ãº Â½ÂºÃ…Â³ Â¼Ã¶ÃÃ˜
	iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[12];
	if (iSkillLimit > iSkillLevel) {
		// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Â½ÂºÃ…Â³Ã€ÃŒ Â³Â·Â¾Ã† Â¸Â¸ÂµÃ© Â¼Ã¶ Â¾Ã¸Â´Ã‚ Ã†Ã·Â¼Ã‡Ã€ÃŒÂ´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOWPORTIONSKILL, NULL, NULL, NULL, cPortionName);
		return;
	}

	// Ã†Ã·Â¼Ã‡Ã€Ã‡ ÃÂ¦Ã€Ã› Â³Â­Ã€ÃŒÂµÂµÂ¿Â¡ ÂµÃ»Â¶Ã³ Â¼ÂºÂ°Ã¸Â·Ã¼Ã€Â» ÃÂ¶ÃÂ¤Ã‡Ã‘Â´Ã™.
	iSkillLevel -= iDifficulty;
	if (iSkillLevel <= 0) iSkillLevel = 1;

	iResult = iDice(1,100);
	if (iResult > iSkillLevel) {
		// Â½ÂºÃ…Â³ Â½Ã‡Ã†Ã 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PORTIONFAIL, NULL, NULL, NULL, cPortionName);
		return;
	}

	// Â¸Ã°ÂµÃ§ ÃÂ¶Â°Ã‡Ã€ÃŒ Â¸Â¸ÃÂ·ÂµÃ‡Â¾Ã® Ã†Ã·Â¼Ã‡Ã€Â» Â¸Â¸ÂµÃ© Â¼Ã¶ Ã€Ã–Â´Ã™. Â½ÂºÃ…Â³Ã„Â«Â¿Ã®Ã†Â®ÂµÂµ ÃÃµÂ°Â¡ 
	CalculateSSN_SkillIndex(iClientH, 12, 1);
	
	// Â¸Â¸ÃÂ·Ã‡ÃÂ´Ã‚ Ã†Ã·Â¼Ã‡ ÃÂ¶Ã‡Ã•Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© strlen(cPortionName)Ã€ÃŒ 0Ã€ÃŒ Â¾Ã†Â´ÃÂ´Ã™. Ã€ÃŒÂ¹ÃŒ Â°Ã‹Â»Ã§Ã‡ÃŸÃÃ¶Â¸Â¸ 
	if (strlen(cPortionName) != 0) {
		pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;

		// Ã†Ã·Â¼Ã‡Ã€Â» ÃÂ¦Ã€Ã›Ã‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Ã€Ã§Â·Ã¡Â¸Â¦ Â¾Ã¸Â¾Ã˜Â´Ã™.
		for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				// v1.41 !!!
				SetItemCount(iClientH, sItemIndex[i], //     m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cName,
				             m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
			else ItemDepleteHandler(iClientH, sItemIndex[i], FALSE);
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PORTIONSUCCESS, NULL, NULL, NULL, cPortionName);
		// v1.41 Â¼Ã’Â·Â®Ã€Ã‡ Â°Ã¦Ã‡Ã¨Ã„Â¡ ÃÃµÂ°Â¡ 
		m_pClientList[iClientH]->m_iExpStock += iDice(1, (iDifficulty/3));

		if ((_bInitItemAttr(pItem, cPortionName) == TRUE)) {
			// Ã†Ã·Â¼Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¸Â¸ÂµÃ©Â¾Ã®ÃÂ³Â´Ã™. Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã› Â¸Â®Â½ÂºÃ†Â®Â¿Â¡ ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™. Â¸Â¸Â¾Ã  Â°Ã¸Â°Â£Ã€ÃŒ Â¾Ã¸Â°Ã…Â³Âª 
			// Â¹Â«Â°Ã”Â°Â¡ Â¸Ã°Ã€ÃšÂ¶Ã³Â¸Ã© Â¹ÃŸ Â¹Ã˜Â¿Â¡ Â¶Â³Â¾Ã®ÃÂ®Â¾ÃŸ Ã‡Ã‘Â´Ã™.
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				ZeroMemory(cData, sizeof(cData));
				// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				
				// 1Â°Â³ ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™. AmountÂ°Â¡ Â¾Ã†Â´ÃÂ´Ã™!
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;	// Â¼Ã¶Â·Â®Ã€Â» Ã€Ã”Â·Ã‚ 
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // Â¾Ã²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				/*
				*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃ 
				cp++;
				*/
				
				if (iEraseReq == 1) delete pItem;
				
				// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
				
				// ÂºÃ±Â½Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¹ÃÂ¾Ã’Â´Ã™Â¸Ã© ÂµÂ¥Ã€ÃŒÃ…ÃÂ¸Â¦ Ã€ÃºÃ€Ã¥Ã‡Ã‘Â´Ã™. 
				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}
			else {
				// Â´ÃµÃ€ÃŒÂ»Ã³ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÂºÂ¸Â°Ã¼Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â»Ã³Ã…Ã‚Ã€ÃŒÂ´Ã™.
				// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â¸Â°Â´Ã™. 
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					                                                         m_pClientList[iClientH]->m_sY, pItem);
				
				// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4
				
				// Â´ÃµÃ€ÃŒÂ»Ã³ Â°Â¡ÃÃºÂ¼Ã¶ Â¾Ã¸Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
			}
		}
		else {
			delete pItem;
			pItem = NULL;
		}
	}
}

BOOL CGame::_bDecodePortionConfigFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iPortionConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Æ÷¼Ç ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Wrong Data format(1).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pPortionConfigList[atoi(token)] != NULL) {
						// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! POTION configuration file error - Duplicate portion number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[atoi(token)] = new class CPortion;
					iPortionConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// Æ÷¼Ç ÀÌ¸§ 
					ZeroMemory(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, sizeof(m_pPortionConfigList[iPortionConfigListIndex]->m_cName));
					memcpy(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				default:
					// ¸¶¹ı Á¾·ù m_sArray[0~10]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;

				case 14:
					// ¸¶Áö¸· m_sArray[11]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[11] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// ½ºÅ³ Á¦ÇÑÄ¡ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 16;
					break;
	
				case 16:
					// ³­ÀÌµµ
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_iDifficulty = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "potion", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! POTION configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) POTION(Total:%d) configuration - success!", iPortionConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

void CGame::LocalSavePlayerData(int iClientH)
{
 char * pData, * cp, cFn[256], cDir[256], cTxt[256], cCharDir[256];
 int    iSize;
 FILE * pFile;
 SYSTEMTIME SysTime;

	// Â·ÃÂ±Ã— Â¼Â­Â¹Ã¶Â·ÃÃ€Ã‡ Â¿Â¬Â°Ã¡Ã€ÃŒ ÃÂ¾Â·Ã¡ÂµÃ‡Â¾Ã® Ã€Ã“Â½ÃƒÂ·Ã Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶ Â³Â»Ã€Ã‡ Ã†ÃºÂ´ÃµÂ¿Â¡ Ã€ÃºÃ€Ã¥Ã‡Ã‘Â´Ã™. 
	if (m_pClientList[iClientH] == NULL) return;
 
	pData = new char[30000];
	if (pData == NULL) return;
	ZeroMemory(pData, 30000);

	cp = (char *)(pData);
	iSize = _iComposePlayerDataFileContents(iClientH, cp);

	GetLocalTime(&SysTime);
	ZeroMemory(cCharDir, sizeof(cDir));
	wsprintf(cCharDir, "Character_%d_%d_%d_%d", SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);

	ZeroMemory(cDir, sizeof(cDir));
	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn,cCharDir);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	wsprintf(cTxt, "AscII%d", (unsigned char)m_pClientList[iClientH]->m_cCharName[0]);
	strcat(cFn, cTxt);
	strcpy(cDir, cFn);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn, m_pClientList[iClientH]->m_cCharName);
	strcat(cFn, ".txt");

	// ÂµÃ°Â·ÂºÃ…Ã¤Â¸Â®Â¸Â¦ Â¸Â¸ÂµÃ§Â´Ã™.
	_mkdir(cCharDir);
	_mkdir(cDir);

	// (char*)cp ÂºÃÃ…Ã (dwMsgSize - 36)Ã…Â©Â±Ã¢Â±Ã®ÃÃ¶Â°Â¡ Ã†Ã„Ã€ÃÂ¿Â¡ Ã€ÃºÃ€Ã¥ÂµÃ‰ ÂµÂ¥Ã€ÃŒÃ…ÃÃ€ÃŒÂ´Ã™.
	if (iSize == 0) {
		PutLogList("(!) Character data body empty: Cannot create & save temporal player data file.");
		delete pData;
		return;
	}

	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		wsprintf(cTxt, "(!) Cannot create temporal player data file : Name(%s)", cFn);
		PutLogList(cTxt);
	}
	else {
		wsprintf(cTxt, "(!) temporal player data file saved : Name(%s)", cFn);
		PutLogList(cTxt);
		fwrite(cp, iSize, 1, pFile);
	}
	
	if (pFile != NULL) fclose(pFile);
	delete pData;
}

void CGame::MineralGenerator()
{
 register int i, iP, tX, tY, iRet;
 
	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((iDice(1,4) == 1) && (m_pMapList[i] != NULL) && 
			(m_pMapList[i]->m_bMineralGenerator == TRUE) && 
			(m_pMapList[i]->m_iCurMineral < m_pMapList[i]->m_iMaxMineral)) {
	
			iP = iDice(1, m_pMapList[i]->m_iTotalMineralPoint) - 1;
			if ((m_pMapList[i]->m_MineralPointList[iP].x == -1) || (m_pMapList[i]->m_MineralPointList[iP].y == -1)) break;

			tX = m_pMapList[i]->m_MineralPointList[iP].x;
			tY = m_pMapList[i]->m_MineralPointList[iP].y;

		   	iRet = iCreateMineral(i, tX, tY, m_pMapList[i]->m_cMineralGeneratorLevel);
		}
	}		
}

int CGame::iCreateMineral(char cMapIndex, int tX, int tY, char cLevel)
{
 register int i, iDynamicHandle, iMineralType;

	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;
	
	for (i = 1; i < DEF_MAXMINERALS; i++) 
	if (m_pMineral[i] == NULL) {
		// ÂºÃ³ Â°Ã¸Â°Â£Â¿Â¡ Â±Â¤Â¹Â°ÂµÂ¢Ã€ÃŒÂ¸Â¦ Â¸Â¸ÂµÃ§Â´Ã™.
		iMineralType = iDice(1, cLevel);
		m_pMineral[i] = new class CMineral(iMineralType, cMapIndex, tX, tY, 1);
		if (m_pMineral[i] == NULL) return NULL;
 		
		iDynamicHandle = NULL;
		switch (iMineralType) {
		case 1: // Â±Â¤Â¹Â°Â·Ã¹
		case 2:
		case 3:
		case 4:
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
			break;
				
		case 5: // ÂºÂ¸Â¼Â®Â·Ã¹ 
		case 6:
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL2, cMapIndex, tX, tY, NULL, i);
			break;
		
		default:
			// Â¿Â¡Â·Â¯ Â¹Ã¦ÃÃ¶Â¿Ã« Ã„ÃšÂµÃ¥ 
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
			break;
		}
		
		if (iDynamicHandle == NULL) {
			delete m_pMineral[i];
			m_pMineral[i] = NULL;
			return NULL;
		}
		m_pMineral[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMineral[i]->m_cMapIndex = cMapIndex;
		
		// Â³Â­Ã€ÃŒÂµÂµÂ¿Ã Â¼Ã¶Â·Â®Ã€Â» Ã€Ã”Â·Ã‚Ã‡Ã‘Â´Ã™.
		switch (iMineralType) {
		case 1: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		case 2: m_pMineral[i]->m_iDifficulty = 15; m_pMineral[i]->m_iRemain = 15; break;
		case 3: m_pMineral[i]->m_iDifficulty = 20; m_pMineral[i]->m_iRemain = 10; break;
		case 4: m_pMineral[i]->m_iDifficulty = 50; m_pMineral[i]->m_iRemain = 8; break;
		case 5: m_pMineral[i]->m_iDifficulty = 70; m_pMineral[i]->m_iRemain = 6; break;
		case 6: m_pMineral[i]->m_iDifficulty = 90; m_pMineral[i]->m_iRemain = 4; break;
		default: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		}

		// Â¸ÃŠÃ€Ã‡ Â¹ÃŒÂ³Ã—Â¶Ã¶ Â¼Ã¶ ÃÃµÂ°Â¡
		m_pMapList[cMapIndex]->m_iCurMineral++;
	
		return i;
	}

	return NULL;
}


void CGame::_CheckMiningAction(int iClientH, int dX, int dY)
{
	short sType;
	DWORD dwRegisterTime;
	int   iDynamicIndex, iSkillLevel, iResult, iItemID;
	class CItem * pItem;
	WORD  wWeaponType;

	if (m_pClientList[iClientH] == NULL)  return;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetDynamicObject(dX, dY, &sType, &dwRegisterTime, &iDynamicIndex);

	switch (sType) {
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		// Â±Â¤Â¹Â°ÃƒÂ¤ÃƒÃ«Â¸Â¦ Â½ÃƒÂµÂµÃ‡Ã‘ Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ ÃÂ¶Â°Ã‡Ã€Â» Â»Ã¬Ã‡Ã‰Â´Ã™. Â°Ã®Â±ÂªÃ€ÃŒÂ¸Â¦ ÂµÃ©Â°Ã­ Ã€Ã–Â´Ã‚Â°Â¡? Â±Â¤Â¹Â° ÃƒÂ¤ÃƒÃ« Â½ÂºÃ…Â³Ã€Âº? 
		// Â°Ã®Â±ÂªÃ€ÃŒÂ¿Â¡ Ã‡Ã˜Â´Ã§Ã‡ÃÂ´Ã‚ Â¿ÃœÃ‡Ã¼Ã€ÃŒÂ¸Ã© Ã…Ã«Â°Ãº 
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 25) {
			// Ã‡ÃˆÂ¾Ã—Â½ÂºÂ¸Â¦ ÂµÃ©Â°Ã­ Ã€Ã–Â´Ã™. Â±Â¤Â¹Â° ÃƒÂ¤ÃƒÃ« Â°Â¡Â´Ã‰ 
		}
		else return;

		// Ã€Ã¼Ã…Ãµ Â¸Ã°Â¼Ã‡Ã€ÃŒ Â¾Ã†Â´ÃÂ´ÃµÂ¶Ã³ÂµÂµ Â¸Â®Ã…Ã 
		if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0) return;

		iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[0];
		if (iSkillLevel == 0) break;

		if (m_pDynamicObjectList[iDynamicIndex] == NULL) break;
		// Ã„Â³Â´Ã‚ Â±Â¤Â¹Â°Ã€Ã‡ Â³Â­Ã€ÃŒÂµÂµÂ¸Â¸Ã…Â­ Â½ÂºÃ…Â³Ã€Â» Â³Â·ÃƒÃ¡Â´Ã™.
		iSkillLevel -= m_pMineral[ m_pDynamicObjectList[iDynamicIndex]->m_iV1 ]->m_iDifficulty;
		if (iSkillLevel <= 0) iSkillLevel = 1;

		iResult = iDice(1, 100);
		if (iResult <= iSkillLevel) {
			// ÃˆÂ®Â·Ã¼Ã€Âº Â¼ÂºÂ°Ã¸Ã‡ÃŸÂ´Ã™. Â±Â¤Â¹Â°ÃƒÂ¤ÃƒÃ« Â±Ã¢Â¼Ãº ÃÃµÂ°Â¡ 
			CalculateSSN_SkillIndex(iClientH, 0, 1);

			// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Â¹ÃŸ Â¹Ã˜Â¿Â¡ Â±Â¤Â¹Â°Ã€Â» Â¶Â³Â¾Ã®Â¶ÃŸÂ¸Â°Â´Ã™. 
			switch (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_cType) { 
				case 1: 
					switch (iDice(1,5)) { 
						case 1: 
						case 2: 
						case 3:    
							iItemID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 4:    
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 5:
							iItemID = 507; // BlondeStone
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3);
							break;
					} 
					break; 

				case 2: 
					switch (iDice(1,5)) { 
						case 1: 
						case 2: 
							iItemID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 3:    
						case 4:    
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 5:
							if (iDice(1,3) == 2) { 
								iItemID = 356; // SilverNugget
								m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
							} 
							else { 
								iItemID = 507; // BlondeStone
								m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							} 
							break; 
					} 
					break; 

				case 3: 
					switch (iDice(1,6)) { 
						case 1: 
							iItemID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 2: 
						case 3:    
						case 4:    
						case 5: 
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 6: 
							if (iDice(1,8) == 3) { 
								if (iDice(1,2) == 1) { 
									iItemID = 356; // SilverNugget
									m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
								} 
								else { 
									iItemID = 357; // IronOre
									m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
								}
								break;
							} 
							else { 
								iItemID = 357; // IronOre
								m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							} 
							break; 
					} 
					break; 

				case 4: 
					switch (iDice(1,6)) { 
						case 1: 
							iItemID = 355; // Coal
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 2: 
							if (iDice(1,3) == 2) {
								iItemID =  356; // SilverNugget
								m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
							}
							break;
						case 3:    
						case 4:    
						case 5: 
							iItemID = 357; // IronOre
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
							break; 
						case 6: 
							if (iDice(1,8) == 3) { 
								if (iDice(1,4) == 3) { 
									if (iDice(1,4) < 3) { 
										iItemID = 508; // Mithral
										m_pClientList[iClientH]->m_iExpStock += iDice(1,15); 
									} 
									else { 
										iItemID =  354; // GoldNugget
										m_pClientList[iClientH]->m_iExpStock += iDice(1,5); 
									}
									break;
								} 
								else { 
									iItemID =  356; // SilverNugget
									m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
								}
								break;
							} 
							else { 
								if (iDice(1,2) == 1) { 
									iItemID = 354; // GoldNugget
									m_pClientList[iClientH]->m_iExpStock += iDice(1,5);
								}
								else {
									iItemID = 357;  // IronOre
									m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
								}
								break;
							} 
							break; 
					}
					break;

				case 5: 
					switch (iDice(1,19)) { 
						case 3: 
							iItemID = 352; // Sapphire
							m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							break; 
						default: 
							iItemID = 358; // Crystal
							m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							break; 
					} 
					break; 

				case 6: 
					switch (iDice(1,5)) { 
						case 1: 
							if (iDice(1,6) == 3) { 
								iItemID =  353; // Emerald 
								m_pClientList[iClientH]->m_iExpStock += iDice(2,4); 
							} 
							else { 
								iItemID =  358; // Crystal
								m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							} 
							break; 
						case 2: 
							if (iDice(1,6) == 3) { 
								iItemID =  352; // Saphire
								m_pClientList[iClientH]->m_iExpStock += iDice(2,4); 
							} 
							else { 
								iItemID =  358; // Crystal
								m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							} 
							break; 
						case 3: 
							if (iDice(1,6) == 3) { 
								iItemID =  351; // Ruby
								m_pClientList[iClientH]->m_iExpStock += iDice(2,4); 
							} 
							else { 
								iItemID =  358; // Crystal 
								m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							} 
							break; 
						case 4: 
							iItemID =  358; // Crystal 
							m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							break; 
						case 5: 
							if (iDice(1,12) == 3) { 
								iItemID =  350; // Diamond
								m_pClientList[iClientH]->m_iExpStock += iDice(2,5); 
							} 
							else { 
								iItemID =  358; // Crystal
								m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
							} 
							break;
					} 
					break;

			} 

			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iItemID) == FALSE) {
				delete pItem;
			}
			else {
				// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â¸Â°Â´Ã™. 
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					m_pClientList[iClientH]->m_sY, pItem);
				// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4
				    // testcode
					// wsprintf(G_cTxt, "Mining Success: %d", iItemID); 
					// PutLogList(G_cTxt);
			}

			// Â±Â¤Â¹Â°Ã€Ã‡ Â³Â²Ã€Âº Â·Â®Ã€Â» ÃÃ™Ã€ÃŒÂ°Ã­ 0Ã€ÃÂ°Ã¦Â¿Ã¬ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
			m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain--;
			if (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain <= 0) {
				// Â±Â¤Â¹Â°Ã€ÃŒ Â¸Ã°ÂµÃ Â¼Ã’Â¸Ã°ÂµÃ‡Â¾ÃºÂ´Ã™. Delete Mineral 
				bDeleteMineral(m_pDynamicObjectList[iDynamicIndex]->m_iV1);

				// ÂµÂ¿Ã€Ã» Â°Â´ÃƒÂ¼ Â»Ã¨ÃÂ¦
				delete m_pDynamicObjectList[iDynamicIndex];
				m_pDynamicObjectList[iDynamicIndex] = NULL;
			}
		}
		break;

	default: 
		break;
	}
}

BOOL CGame::bDeleteMineral(int iIndex)
{
 int iDynamicIndex;
 DWORD dwTime;

	dwTime = timeGetTime();
	
	if (m_pMineral[iIndex] == NULL) return FALSE;
	iDynamicIndex = m_pMineral[iIndex]->m_sDynamicObjectHandle;
	if (m_pDynamicObjectList[iDynamicIndex] == NULL) return FALSE;

	SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex, 
		                        m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, 
								m_pDynamicObjectList[iDynamicIndex]->m_sType, iDynamicIndex, NULL);
	// Â¸ÃŠÂ¿Â¡Â¼Â­ Â±Â¤Â¹Â° ÂµÂ¿Ã€Ã» Â°Â´ÃƒÂ¼Â¸Â¦ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
	m_pMapList[m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, dwTime);
	// Â±Â¤Â¹Â°Ã€ÃŒ Â»Ã§Â¶Ã³ÃÂ³Ã€Â¸Â¹Ã‡Â·Ã Ã€ÃŒÂµÂ¿Ã€ÃŒ Â°Â¡Â´Ã‰Ã‡ÃÂ°Ã” Ã‡Ã‘Â´Ã™. 
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->SetTempMoveAllowedFlag(m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, TRUE);
			
	// Â±Â¤Â¹Â° Â°Â³ÃƒÂ¼ Â¼Ã¶ Â°Â¨Â¼Ã’ 
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->m_iCurMineral--;

	// Â±Â¤Â¹Â° Â°Â´ÃƒÂ¼ Â»Ã¨ÃÂ¦ 
	delete m_pMineral[iIndex];
	m_pMineral[iIndex] = NULL;

	return TRUE;
}

void CGame::NpcTalkHandler(int iClientH, int iWho)
{
 char cRewardName[21], cTargetName[21];
 int iResMode, iQuestNum, iQuestType, iRewardType, iRewardAmount, iContribution, iX, iY, iRange, iTargetType, iTargetCount;

	iQuestNum = 0;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	if (m_pClientList[iClientH] == NULL) return;
	switch (iWho) {
	case 1: break;
	case 2:	break;
	case 3:	break;
	case 4:
		iQuestNum = _iTalkToNpcResult_Cityhall(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		break;
	case 5: break;
	case 6:	break;
	case 32: break;
	case 21: 
		iQuestNum = _iTalkToNpcResult_Guard(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		if (iQuestNum >= 1000) return;
		break;
	}

	ZeroMemory(cRewardName, sizeof(cRewardName));
	if (iQuestNum > 0) {
		if (iRewardType > 1) {
			strcpy(cRewardName, m_pItemConfigList[iRewardType]->m_cName);
		}
		else {
			switch (iRewardType) {
			case -10: strcpy(cRewardName, "¦µ¦F-í""); break;
			}
		}

		m_pClientList[iClientH]->m_iAskedQuest        = iQuestNum;
		m_pClientList[iClientH]->m_iQuestRewardType   = iRewardType;
		m_pClientList[iClientH]->m_iQuestRewardAmount = iRewardAmount;
	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
			          iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
	}
	else {
		switch (iQuestNum) {
		case  0: SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (iWho+130), NULL, NULL, NULL, NULL); break;
		case -1:
		case -2:
		case -3:
		case -4: SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, abs(iQuestNum)+100, NULL, NULL, NULL, NULL); break;
		case -5: break;
		}
	}
}

void CGame::CheckFireBluring(char cMapIndex, int sX, int sY)
{
 register int ix, iy, iItemNum;
 register short sSpr, sSprFrame;
 char  cItemColor;
 class CItem * pItem;

	for (ix = sX -1; ix <= sX +1; ix++)
	for (iy = sY -1; iy <= sY +1; iy++) {
		// Â¸Â¸Â¾Ã  Ã€ÃŒ Ã€Â§Ã„Â¡Â¿Â¡ Â¹ÃŸÃˆÂ­Â¼Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Ã€Ã–Â´Ã™Â¸Ã© ÃÃ¶Â¿Ã¬Â°Ã­ ÂºÃ’ Â¿Ã€ÂºÃªÃÂ§Ã†Â®Â¸Â¦ Â³ÃµÂ´Ã‚Â´Ã™.	
		iItemNum = m_pMapList[cMapIndex]->iCheckItem(ix, iy);
				
		switch (iItemNum) {
		case 355: 
			// Â¼Â®Ã…ÂºÃ€ÃŒÂ´Ã™. Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃ¶Â¿Ã¬Â°Ã­ ÂºÃ’Ã€Â» Â¸Â¸ÂµÃ§Â´Ã™.
			pItem = m_pMapList[cMapIndex]->pGetItem(ix, iy, &sSpr, &sSprFrame, &cItemColor);
			if (pItem != NULL) delete pItem;
			iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_FIRE, cMapIndex, ix, iy, 6000);	

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, cMapIndex,
				                        ix, iy, sSpr, sSprFrame, cItemColor);
			break;
		}
	}
}



void CGame::AdminOrder_GetNpcStatus(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cNpcName[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGetNpcStatus) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, token);
	}

	for (i = 0; i < DEF_MAXNPCS; i++) 
	if (m_pNpcList[i] != NULL) {
		if (memcmp(m_pNpcList[i]->m_cName, cNpcName, 5) == 0) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINIFO, 1, i, NULL, NULL);	
		}
	}

	delete pStrTok;
	return;
}


int CGame::_iGetWeaponSkillType(int iClientH)
{
 WORD wWeaponType;

	if (m_pClientList[iClientH] == NULL) return 0;

	wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	if (wWeaponType == 0) {
		return 5;
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2)) {
		return 7;
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20)) {
		if (wWeaponType == 7) 
			 return 9;
		else return 8;
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 30)) {
		return 10;
	}
	else if ((wWeaponType >= 30) && (wWeaponType < 35)) {
		return 14;
	}
	else if ((wWeaponType >= 35) && (wWeaponType < 40)) {
		return 21	;
	}
	else if (wWeaponType >= 40) {
		return 6;
	}
	
	return 1;
}

static int ___iCAB5[]  = {0,0, 0,1,2};
static int ___iCAB6[]  = {0,0, 0,0,0};
static int ___iCAB7[]  = {0,0, 1,2,3};
static int ___iCAB8[]  = {0,0, 1,3,5};
static int ___iCAB9[]  = {0,0, 2,4,8};
static int ___iCAB10[] = {0,0, 1,2,3};

int CGame::iGetComboAttackBonus(int iSkill, int iComboCount)
{
	if (iComboCount <= 1) return 0;
	if (iComboCount > 6) return 0;
	switch (iSkill) {
	case 5:
		return ___iCAB5[iComboCount];
		break;
	case 6:
		return ___iCAB6[iComboCount];
		break;
	case 7:
		return ___iCAB7[iComboCount];
		break;
	case 8:
		return ___iCAB8[iComboCount];
		break;
	case 9:
		return ___iCAB9[iComboCount];
		break;
	case 10:
		return ___iCAB10[iComboCount];
		break;
	case 14:
		return ___iCAB6[iComboCount];
		break;
	case 21:
		return ___iCAB10[iComboCount];
		break;
	}

	return 0;
}

void CGame::SetDownSkillIndexHandler(int iClientH, int iSkillIndex)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((iSkillIndex < 0) || (iSkillIndex >= DEF_MAXSKILLTYPE)) return;

	if (m_pClientList[iClientH]->m_cSkillMastery[iSkillIndex] > 0)
		m_pClientList[iClientH]->m_iDownSkillIndex = iSkillIndex;

	// Â´Ã™Â¿Ã® Â½ÂºÃ…Â³Ã€Â» Â¼Â³ÃÂ¤Ã‡ÃŸÃ€Â¸Â´Ã Ã€Ã€Â´Ã¤Ã€Â» ÂºÂ¸Â³Â½Â´Ã™. 
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
}


BOOL CGame::_bDepleteDestTypeItemUseEffect(int iClientH, int dX, int dY, short sItemIndex, short sDestItemID)
{
 BOOL bRet;

	// Ã€Â§Ã„Â¡Â¸Â¦ ÃÃ¶ÃÂ¤Ã‡ÃÂ°Ã­ Â»Ã§Â¿Ã« ÃˆÃ„ Â»Ã§Â¶Ã³ÃÃ¶Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã› ÃˆÂ¿Â°Ãº ÃƒÂ³Â¸Â® ÂºÃÂºÃ 
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;

	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
	case DEF_ITEMEFFECTTYPE_OCCUPYFLAG:
		bRet =  __bSetOccupyFlag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			                     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
				 				 NULL, iClientH, NULL);
		if (bRet == TRUE) {
			GetExp(iClientH, (iDice(m_pClientList[iClientH]->m_iLevel, 10)));
		}
		else {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTFLAGSPOT, NULL, NULL, NULL, NULL);
		}
		return bRet;

	// crusade
	case DEF_ITEMEFFECTTYPE_CONSTRUCTIONKIT:
		// Â°Ã‡Â¼Â³ Ã…Â°Ã†Â®Ã€ÃŒÂ´Ã™. Â¹ÃŒÂµÃ©Â·Â£ÂµÃ¥Â¿Â¡Â¼Â­Â¸Â¸ Â»Ã§Â¿Ã« Â°Â¡Â´Ã‰Ã‡Ã”. m_sItemEffectValue1: Â°Ã‡ÃƒÃ Â¹Â° ÃÂ¾Â·Ã¹, m_sItemEffectValue2: Â°Ã‡ÃƒÃ  Â½ÃƒÂ°Â£ 
		bRet = __bSetConstructionKit(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
			                         m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,        //
				 				     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,        //
								     iClientH); // Â¼Â³Ã„Â¡Ã€Ãš 
		if (bRet == TRUE) {
			// Â°Ã‡Â¼Â³ Â½ÃƒÃ€Ã› 
		}
		else {
			// Â°Ã‡Â¼Â³ Â½Ã‡Ã†Ã			
		}
		return bRet;
	
	case DEF_ITEMEFFECTTYPE_DYE:
		// Â¾Ã†Ã€ÃŒÃ…Ã› Â¿Â°Â»Ã¶: Â¾Ã†Ã€ÃŒÃ…Ã› Â°ÂªÃ€ÃŒ Ã€Â¯ÃˆÂ¿Ã‡Ã‘Â°Â¡ ÃƒÂ¼Ã…Â©.
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) {
				if ( (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 11) ||
					 (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 12) ) {
					// Â¿Â°Â»Ã¶Ã€ÃŒ Â°Â¡Â´Ã‰Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ´Ã™.
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					// Â»Ã¶ Â¼Ã“Â¼ÂºÃ€ÃŒ Â¹Ã™Â²Ã®Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™. 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
					return TRUE;
				}
				else {
					// Â¿Â°Â»Ã¶Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ´Ã™. 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
					return FALSE;
				}
			}
		}	
		break;

	case DEF_ITEMEFFECTTYPE_ARMORDYE:
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) {
				if (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 6) {
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
					return TRUE;
				}
				else {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
					return FALSE;
				}
			}
		}	
		break;

	case DEF_ITEMEFFECTTYPE_FARMING:
		bRet = bPlantSeedBag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,
			                         m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,
				 				     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,
								     iClientH);
		return bRet;

	default:
		break;
	}

	return TRUE;
}


BOOL CGame::__bSetOccupyFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH, BOOL bAdminFlag)
{
 register int ix,iy;
 int   iDynamicObjectIndex, iIndex;
 class CTile * pTile;
 DWORD dwTime;

	dwTime = timeGetTime();
	
	if (m_pMapList[cMapIndex] == NULL) return FALSE;
	if (((m_bIsHeldenianMode == FALSE) || (m_bIsHeldenianMode != m_cHeldenianType)) && (m_bHeldenianInitiated == 1)) return FALSE;
	if ((m_cHeldenianType == 1) && (m_iBTFieldMapIndex == -1)) return FALSE;	
	if ((m_cHeldenianType == 2) && (m_iGodHMapIndex == -1)) return FALSE;	
	if ((m_pClientList[iClientH]->m_iGuildRank == 0)) return FALSE;

	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iAttribute != NULL) return FALSE;
	iSide = m_sLastHeldenianWinner;
	if ((dX < 25) || (dX >= m_pMapList[cMapIndex]->m_sSizeX - 25) || 
		(dY < 25) || (dY >= m_pMapList[cMapIndex]->m_sSizeY - 25)) return FALSE;

	if ((iClientH > 0) && (m_pClientList[iClientH] != NULL)) {
		if ((bAdminFlag == FALSE) && (m_pClientList[iClientH]->m_cSide != iSide)) return FALSE;
	}

	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iOccupyFlagIndex != NULL) return FALSE;
	if (pTile->m_bIsMoveAllowed == FALSE)  return FALSE;

	for (ix = dX-3; ix <= dX+3; ix++) 
	for (iy = dY-3; iy <= dY+3; iy++) {
		if ((ix == dX) && (iy == dY)) {

		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);			
			if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
				(pTile->m_iOccupyFlagIndex < DEF_MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL)) {
				if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide == iSide) return FALSE;
			}
		}
	}

	if (m_pMapList[cMapIndex]->m_iTotalOccupyFlags >= DEF_MAXOCCUPYFLAG) {
		return FALSE;
	}

	switch (iSide) {
	case 1:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, NULL, NULL);	break;
	case 2:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, NULL, NULL);	break;
	default: iDynamicObjectIndex = 0;
	}
	
	iEKNum = 1;
	iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
	if (iIndex < 0) {
		if (iDynamicObjectIndex > DEF_MAXGUILDS)
			return TRUE; 
	}
	
	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	pTile->m_iOccupyFlagIndex = iIndex;
		
	m_pMapList[cMapIndex]->m_iTotalOccupyFlags++;

	if (m_cHeldenianType == 1) {
		for (ix = dX-3; ix <= dX+3; ix++) 
		for (iy = dY-3; iy <= dY+3; iy++) {
			if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
				(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
			}
			else {
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
				switch (iSide) {
				case 1: 
					pTile->m_iOccupyStatus -= iEKNum; 
					break;
				case 2:	
					pTile->m_iOccupyStatus += iEKNum; 
					break;
				}
			}
		}
	}

	if (m_cHeldenianType == 2) {
		if (iSide == m_sLastHeldenianWinner) {
			m_cHeldenianVictoryType = iSide;
			//sub_4AB9D0
		}
	}
	return TRUE;
}

void CGame::SetSummonMobAction(int iClientH, int iMode, DWORD dwMsgSize, char *pData)
{
 register int i, iTargetIndex;
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	// v2.1 Áß¸³Àº ¸÷°ø°İ ¸í·ÉÀ» ÇÒ ¼ö ¾ø´Ù.
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	switch (iMode) {
	case 0: // Free ¸ğµå
	case 1: // Hold ¸ğµå
		//  ¸¶½ºÅÍ°¡ iClientHÀÎ ¸÷µéÀÇ Á¦¾î¸ğµå¸¦ º¯°æÇÑ´Ù.
		for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {
			if ( (m_pNpcList[i]->m_bIsSummoned == TRUE) && 
				 (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
				 (m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER) ) {

				m_pNpcList[i]->m_iSummonControlMode = iMode;
				m_pNpcList[i]->m_bIsPermAttackMode  = FALSE;
				m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_sBehaviorTurnCount = 0;
				m_pNpcList[i]->m_iTargetIndex       = NULL;
			}
		}
		break;
	
	case 2:
		// °ø°İ ¸ğµå - ¸ñÇ¥¹°À» ¾ò¾î¿Â´Ù. 
		if ((dwMsgSize)	<= 0) return;
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
   	
		iTargetIndex = 0;
		if (token != NULL) {
			// tokenÀÌ °ğ °ø°İÇÒ »ç¿ëÀÚ ÀÌ¸§ 
			if (strlen(token) > 10) 
				 memcpy(cTargetName, token, 10);
			else memcpy(cTargetName, token, strlen(token));

			// 2002.8.17 ÀåÁøÈ£ ¼öÁ¤
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			{
				// if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) { // original
				if ((m_pClientList[i] != NULL) &&
					(memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) &&
					(strcmp(m_pClientList[iClientH]->m_cMapName, m_pClientList[i]->m_cMapName) == 0 ) ) // adamas(mapÀÌ °°¾Æ¾ß ÇÑ´Ù.)
				{
					// ¸ñÇ¥ Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. ÀÎµ¦½º ÀúÀå
					iTargetIndex = i;
					goto SSMA_SKIPSEARCH;
				}
			}
		}

SSMA_SKIPSEARCH:;

		if ( (iTargetIndex != 0) && (m_pClientList[iTargetIndex]->m_cSide != 0) && 
			 (m_pClientList[iTargetIndex]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
			// ¸ñÇ¥¹°ÀÌ Á¸ÀçÇÑ´Ù¸é ÇÒ´çÇÑ´Ù. 
			for (i = 0; i < DEF_MAXNPCS; i++)
			if (m_pNpcList[i] != NULL) {
				if ( (m_pNpcList[i]->m_bIsSummoned == TRUE) && 
					 (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
					 (m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER) ) {

					m_pNpcList[i]->m_iSummonControlMode = iMode;
					m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
					m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[i]->m_iTargetIndex       = iTargetIndex;
					m_pNpcList[i]->m_cTargetType        = DEF_OWNERTYPE_PLAYER;
					m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
				}
			}
		}
		break;
	}
}

void CGame::GetOccupyFlagHandler(int iClientH)
{
 int   i, iNum, iRet, iEraseReq, iEKNum;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 3) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: strcpy(cItemName, "Â¾Ã†Â·Â¹Â½ÂºÂµÂ§Â±ÃªÂ¹ÃŸ"); break;
	case 2: strcpy(cItemName, "Â¿Â¤Â¹Ã™Ã€ÃÂ±ÃªÂ¹ÃŸ");   break;
	}

	// ReqPurchaseItemHandlerÂ¿Â¡Â¼Â­ Â°Â¡ÃÂ®Â¿Ã‚ Â·Ã§Ã†Â¾Ã€Â» Â°Ã­ÃƒÃ†Ã€Â½.
	iNum = 1;
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			// Â±Â¸Ã€Ã”Ã‡ÃÂ°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã› Â¸Â®Â½ÂºÃ†Â®Â»Ã³Â¿Â¡ Â¾Ã¸Â´Ã™. Â±Â¸Ã€Ã”Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™.
			delete pItem;
		}
		else {
											
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// Â¿Â¡Â·Â¯ Â¹Ã¦ÃÃ¶Â¿Ã« Ã„ÃšÂµÃ¥
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¹ÃÃ€Â» Â¼Ã¶ Ã€Ã–Â´Ã™Â´Ã‚ Â°ÃÃ€ÃŒ ÃˆÂ®ÃÂ¤ ÂµÃ‡Â¾ÃºÃ€Â¸Â¹Ã‡Â·Ã EK Â°ÂªÃ€Â» Â»Â©ÂµÂµ ÂµÃˆÂ´Ã™.
				if (m_pClientList[iClientH]->m_iEnemyKillCount > 12) {
					iEKNum = 12;
					m_pClientList[iClientH]->m_iEnemyKillCount -= 12;
				}
				else {
					iEKNum = m_pClientList[iClientH]->m_iEnemyKillCount;
					m_pClientList[iClientH]->m_iEnemyKillCount = 0;
				}
								
				// EKNumÃ€Â» Ã€Ã”Â·Ã‚Ã‡Ã‘Â´Ã™.
				pItem->m_sItemSpecEffectValue1 = iEKNum;

				//testcode Â·ÃÂ±Ã—Ã†Ã„Ã€ÃÂ¿Â¡ Â±Ã¢Â·ÃÃ‡Ã‘Â´Ã™.
				wsprintf(G_cTxt, "(*) Get Flag : Char(%s) Flag-EK(%d) Player-EK(%d)", m_pClientList[iClientH]->m_cCharName, iEKNum, m_pClientList[iClientH]->m_iEnemyKillCount);
				PutLogFileList(G_cTxt);

				// Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã²Â¾ÃºÂ´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Ã€Ã¼Â¼Ã›Ã‡Ã‘Â´Ã™.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				// 1Â°Â³ ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™.
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // Â¾Ã²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
					
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				/*
				*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃ 
				cp++;
				*/
											
				if (iEraseReq == 1) delete pItem;
				
				// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				
				// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
				iCalcTotalWeight(iClientH);
				
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}

				// ÂºÂ¯Â°Ã¦ÂµÃˆ Â¿Â¡Â³ÃŠÂ¹ÃŒ Ã…Â³Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
			}
			else 
			{
				// Â°Ã¸Â°Â£Ã€ÃŒ ÂºÃÃÂ·Ã‡Ã˜ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¾Ã²Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.
				delete pItem;

				// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
 	}
}



// v1.4311-3 ÃƒÃŸÂ°Â¡  Ã‡Ã”Â¼Ã¶ Ã€Ã”Ã€Ã¥Â±Ã‡Ã€Â» ÃÃ–Â´Ã‚ Ã‡Ã”Â¼Ã¶   GetFightzoneTicketHandler 
void CGame::GetFightzoneTicketHandler(int iClientH)
{
 int   iRet, iEraseReq, iMonth, iDay, iHour;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iFightZoneTicketNumber <= 0) { 
		// Ã€Ã”Ã€Ã¥Â±Ã‡Ã€Â» Â´Ã™ Â»Ã§Â¿Ã«Ã‡ÃŸÃ€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
		// Â»Ã§Ã…ÃµÃ€Ã¥ Â¹Ã¸ÃˆÂ£Â°Â¡ Ã€Â½Â¼Ã¶Â¸Ã© Â¿Â¹Â¾Ã Ã€Âº Ã‡ÃŸÂ´Ã‚ÂµÂ¥ Ã€Ã”Ã€Ã¥Â±Ã‡Ã€Â» Â´Ã™ Â¹ÃÃ€ÂºÂ°Ã¦Â¿Ã¬ ..
		m_pClientList[iClientH]->m_iFightzoneNumber  *= -1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -1, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cItemName, sizeof(cItemName));

	if (m_pClientList[iClientH]->m_iFightzoneNumber == 1) 
		strcpy(cItemName,"ArenaTicket") ;
	else  wsprintf(cItemName,"ArenaTicket(%d)",m_pClientList[iClientH]->m_iFightzoneNumber ) ;

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, cItemName) == FALSE) {
		delete pItem;
		return;	
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// Â¿Â¡Â·Â¯ Â¹Ã¦ÃÃ¶Â¿Ã« Ã„ÃšÂµÃ¥
		if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
			
		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¹ÃÃ€Â» Â¼Ã¶ Ã€Ã–Â´Ã™Â´Ã‚ Â°ÃÃ€ÃŒ ÃˆÂ®ÃÂ¤ ÂµÃ‡Â¾ÃºÃ€Â¸Â¹Ã‡Â·Ã Ã€Ã”Ã€Ã¥Â±Ã‡Â°Â³Â¼Ã¶Â¸Â¦ Â»Â©ÂµÂµ ÂµÃˆÂ´Ã™. 
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = m_pClientList[iClientH]->m_iFightZoneTicketNumber -1 ;
				
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		
		iMonth = m_pClientList[iClientH]->m_iReserveTime / 10000 ;
		iDay = (m_pClientList[iClientH]->m_iReserveTime - iMonth*10000) /100 ;
	    iHour = m_pClientList[iClientH]->m_iReserveTime - iMonth*10000 - iDay*100 ;

		pItem->m_sTouchEffectValue1 = iMonth ;
		pItem->m_sTouchEffectValue2 = iDay ;
		pItem->m_sTouchEffectValue3 = iHour ;
		
		
		wsprintf(G_cTxt, "(*) Get FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)(%d)(%d)", m_pClientList[iClientH]->m_cCharName, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3	);		
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);

		ZeroMemory(cData, sizeof(cData));

		// Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã²Â¾ÃºÂ´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Ã€Ã¼Â¼Ã›Ã‡Ã‘Â´Ã™.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		// 1Â°Â³ ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™.
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
				
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
				
		*cp = pItem->m_cItemType;
		cp++;
				
		*cp = pItem->m_cEquipPos;
		cp++;
				
		*cp = (char)0; // Â¾Ã²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
		cp++;
				
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
				
		*cp = pItem->m_cGenderLimit;
		cp++;
				
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
				
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
				
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
				
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
				
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
													
		if (iEraseReq == 1) delete pItem;
				
		// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				
		// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
		iCalcTotalWeight(iClientH);
				
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
				// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}	
	else {
		// Â°Ã¸Â°Â£Ã€ÃŒ ÂºÃÃÂ·Ã‡Ã˜ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¾Ã²Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.
		delete pItem;

		// Â¼Ã’ÃÃ¶Ã‡Â° ÃƒÃ‘ ÃÃŸÂ·Â® Ã€Ã§ Â°Ã¨Â»Ãª 
		iCalcTotalWeight(iClientH);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
			// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}		
}

int CGame::_iComposeFlagStatusContents(char * pData)
{
 SYSTEMTIME SysTime;
 char cTxt[120];
 int i;

	if (m_iMiddlelandMapIndex < 0) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");
	
	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	
	// 
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++) 
	if (m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i] != NULL) { 
		
		wsprintf(cTxt,"flag = %d %d %d %d", m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_cSide,
										    m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sX,
										    m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sY,
			                                m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_iEKCount);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}

	strcat(pData, "\n\n");

	return strlen(pData);
}


BOOL CGame::_bDecodeOccupyFlagSaveFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token;
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iFlagIndex = 0;
 int  iSide;
 class CStrTok * pStrTok;
 int dX, dY, iEKNum, iTotalFlags;

	if (m_iMiddlelandMapIndex < 0) {
		PutLogList("(!) This game server does not managing Middleland Map. OcuupyFlag data ignored.");
		return FALSE;
	}

	iTotalFlags = 0;

	pContents = new char[dwMsgSize+10];
	ZeroMemory(pContents, dwMsgSize+10);
	memcpy(pContents, pData, dwMsgSize - 9);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Side
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					iSide = atoi(token);
					cReadModeB = 2;
					break;
				
				case 2:
					// X ÃÃ‚Ã‡Â¥ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					dX = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Y ÃÃ‚Ã‡Â¥  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					dY = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// EKNum
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					iEKNum = atoi(token);
					
					// ÂµÂ¥Ã€ÃŒÃ…ÃÂ¸Â¦ Â¸Ã°ÂµÃ Â¸Â¸ÂµÃ©Â¾ÃºÃ€Â¸Â¹Ã‡Â·Ã Â±ÃªÂ¹ÃŸÃ€Â» ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™. (!!! Master FlagÂ·Ã ÃƒÂ³Â¸Â®Ã‡Ã˜Â¾ÃŸÂ¸Â¸ Â¼Â³Ã„Â¡Ã‡Ã’ Â¼Ã¶ Ã€Ã–Â´Ã™)
					if (__bSetOccupyFlag(m_iMiddlelandMapIndex, dX, dY, iSide, iEKNum, -1, TRUE) == TRUE)
						iTotalFlags++;
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				
			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "flag", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file contents error!");
		return FALSE;
	}

	wsprintf(G_cTxt, "(!) OccupyFlag save file decoding success! Total(%d)", iTotalFlags); 
	PutLogList(G_cTxt);

	return TRUE;
}
//Hero Code by Zabuza
void CGame::GetHeroMantleHandler(int iClientH,int iItemID,char * pString) 
{ 
 int   i, iNum, iRet, iEraseReq; 
 char  * cp, cData[256], cItemName[21]; 
 class CItem * pItem; 
 DWORD * dwp; 
 short * sp; 
 WORD  * wp; 

	if (m_pClientList[iClientH] == NULL) return; 
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 100) return; 
	if (m_pClientList[iClientH]->m_cSide == 0) return; 
	if (_iGetItemSpaceLeft(iClientH) == 0) {
		SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);
		return;
	}

	//Prevents a crash if item dosent exist
	if (m_pItemConfigList[iItemID] == NULL)  return;
 
	switch(iItemID) { 
	// Hero Cape
	case 400: //Aresden HeroCape
	case 401: //Elvine HeroCape
		if(m_pClientList[iClientH]->m_iEnemyKillCount<300) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 300; 
		break; 

	// Hero Helm
	case 403: //Aresden HeroHelm(M)
	case 404: //Aresden HeroHelm(W)
	case 405: //Elvine HeroHelm(M)
	case 406: //Elvine HeroHelm(W)
		if(m_pClientList[iClientH]->m_iEnemyKillCount < 150) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 150; 
		if(m_pClientList[iClientH]->m_iContribution < 20) return; 
		m_pClientList[iClientH]->m_iContribution -= 20; 
		break; 

	// Hero Cap
	case 407: //Aresden HeroCap(M)
	case 408: //Aresden HeroCap(W)
	case 409: //Elvine HeroHelm(M)
	case 410: //Elvine HeroHelm(W)
		if(m_pClientList[iClientH]->m_iEnemyKillCount < 100) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 100; 
		if(m_pClientList[iClientH]->m_iContribution < 20) return; 
		m_pClientList[iClientH]->m_iContribution -= 20; 
		break;

	// Hero Armour
	case 411: //Aresden HeroArmour(M)
	case 412: //Aresden HeroArmour(W)
	case 413: //Elvine HeroArmour(M)
	case 414: //Elvine HeroArmour(W)
		if(m_pClientList[iClientH]->m_iEnemyKillCount < 300) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 300; 
		if(m_pClientList[iClientH]->m_iContribution < 30) return; 
		m_pClientList[iClientH]->m_iContribution -= 30; 
		break; 

	// Hero Robe
	case 415: //Aresden HeroRobe(M)
	case 416: //Aresden HeroRobe(W)
	case 417: //Elvine HeroRobe(M)
	case 418: //Elvine HeroRobe(W)
		if(m_pClientList[iClientH]->m_iEnemyKillCount < 200) return; 
		m_pClientList[iClientH]->m_iEnemyKillCount -= 200; 
		if(m_pClientList[iClientH]->m_iContribution < 20) return; 
		m_pClientList[iClientH]->m_iContribution -= 20; 
		break; 

	// Hero Hauberk
	case 419: //Aresden HeroHauberk(M)
	case 420: //Aresden HeroHauberk(W)
	case 421: //Elvine HeroHauberk(M)
	case 422: //Elvine HeroHauberk(W)
     if(m_pClientList[iClientH]->m_iEnemyKillCount < 100) return; 
     m_pClientList[iClientH]->m_iEnemyKillCount -= 100; 
     if(m_pClientList[iClientH]->m_iContribution < 10) return; 
     m_pClientList[iClientH]->m_iContribution -= 10; 
     break; 

  // Hero Leggings
  case 423: //Aresden HeroLeggings(M)
  case 424: //Aresden HeroLeggings(W)
  case 425: //Elvine HeroLeggings(M)
  case 426: //Elvine HeroLeggings(W)
     if(m_pClientList[iClientH]->m_iEnemyKillCount < 150) return; 
     m_pClientList[iClientH]->m_iEnemyKillCount -= 150; 
     if(m_pClientList[iClientH]->m_iContribution < 15) return; 
     m_pClientList[iClientH]->m_iContribution -= 15; 
     break; 

  default: 
     return; 
     break; 
  } 

  ZeroMemory(cItemName, sizeof(cItemName)); 
  memcpy(cItemName,m_pItemConfigList[iItemID]->m_cName,20); 
  // ReqPurchaseItemHandler
  iNum = 1; 
  for (i = 1; i <= iNum; i++) 
  { 
     pItem = new class CItem; 
     if (_bInitItemAttr(pItem, cItemName) == FALSE) 
     { 
        delete pItem; 
     } 
     else { 
                                 
        if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) { 
           if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0; 
            
           wsprintf(G_cTxt, "(*) Get HeroItem : Char(%s) Player-EK(%d) Player-Contr(%d) Hero Obtained(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iEnemyKillCount, m_pClientList[iClientH]->m_iContribution,cItemName); 
           PutLogFileList(G_cTxt); 

           pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER; 
           pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1; 
           pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2; 
           pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3; 

           dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID); 
           *dwp = MSGID_NOTIFY; 
           wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE); 
           *wp  = DEF_NOTIFY_ITEMOBTAINED; 
           cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 

           *cp = 1; 
           cp++; 
            
           memcpy(cp, pItem->m_cName, 20); 
           cp += 20; 
            
           dwp  = (DWORD *)cp; 
           *dwp = pItem->m_dwCount; 
           cp += 4; 
            
           *cp = pItem->m_cItemType; 
           cp++; 
            
           *cp = pItem->m_cEquipPos; 
           cp++; 
            
           *cp = (char)0;
           cp++; 
            
           sp  = (short *)cp; 
           *sp = pItem->m_sLevelLimit; 
           cp += 2; 
            
           *cp = pItem->m_cGenderLimit; 
           cp++; 
            
           wp = (WORD *)cp; 
           *wp = pItem->m_wCurLifeSpan; 
           cp += 2; 
            
           wp = (WORD *)cp; 
           *wp = pItem->m_wWeight; 
           cp += 2; 
            
           sp  = (short *)cp; 
           *sp = pItem->m_sSprite; 
           cp += 2; 
            
           sp  = (short *)cp; 
           *sp = pItem->m_sSpriteFrame; 
           cp += 2; 

           *cp = pItem->m_cItemColor; 
           cp++; 

           *cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
           cp++; 
            
           dwp = (DWORD *)cp; 
           *dwp = pItem->m_dwAttribute; 
           cp += 4; 
           /* 
           *cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item??? ?? 
           cp++; 
           */ 
                                 
           if (iEraseReq == 1) delete pItem; 
            
           iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53); 
            
           iCalcTotalWeight(iClientH); 
            
           switch (iRet) { 
           case DEF_XSOCKEVENT_QUENEFULL: 
           case DEF_XSOCKEVENT_SOCKETERROR: 
           case DEF_XSOCKEVENT_CRITICALERROR: 
           case DEF_XSOCKEVENT_SOCKETCLOSED: 
              DeleteClient(iClientH, TRUE, TRUE); 
              return; 
           } 

           SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL); 
        } 
        else 
        { 
           delete pItem; 

           iCalcTotalWeight(iClientH); 

           dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID); 
           *dwp = MSGID_NOTIFY; 
           wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE); 
           *wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM; 
            
           iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6); 
           switch (iRet) { 
           case DEF_XSOCKEVENT_QUENEFULL: 
           case DEF_XSOCKEVENT_SOCKETERROR: 
           case DEF_XSOCKEVENT_CRITICALERROR: 
           case DEF_XSOCKEVENT_SOCKETCLOSED: 

              DeleteClient(iClientH, TRUE, TRUE); 
              return; 
           } 
        } 
     } 
   } 
}

void CGame::_SetItemPos(int iClientH, char *pData)
{
 char * cp, cItemIndex;
 short * sp, sX, sY;

	if (m_pClientList[iClientH] == NULL) return;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cItemIndex = *cp;
	cp++;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	// Ã€ÃŸÂ¸Ã¸ÂµÃˆ ÃÃ‚Ã‡Â¥Â°Âª ÂºÂ¸ÃÂ¤ 
	if (sY < -10) sY = -10; 

	if ((cItemIndex < 0) || (cItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemIndex] != NULL) {
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].x = sX;
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].y = sY;
	}
}

void CGame::CheckUniqueItemEquipment(int iClientH)
{
 register int i, iDamage;

	if (m_pClientList[iClientH] == NULL) return;
	// v1.3 Ã€Â¯Â´ÃÃ…Â© Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Ã€Ã¥Ã‚Ã¸ Â»Ã³Ã…Ã‚Â¸Â¦ Ã†Ã‡Â´ÃœÃ‡Ã‘Â´Ã™. Ã†Â¯ÃÂ¤Ã€ÃÂ¸Â¸Ã€ÃŒ Ã‚Ã¸Â¿Ã« Â°Â¡Â´Ã‰Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€Ã¥Ã‚Ã¸Ã‡Ã‘ Â°Ã¦Â¿Ã¬ Â¹Ã¾Â°ÃœÃÃ¸Â´Ã™.

	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) &&
			 (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) ) {
			// Touch Effect TypeÃ€ÃŒ DEF_ITET_OWNERÃ€ÃŒÂ¸Ã© Touch Effect Value 1, 2, 3Ã€ÃŒ ÃÃ–Ã€Ã Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ Â°Ã­Ã€Â¯Â°ÂªÃ€Â» Â°Â®Â´Ã‚Â´Ã™. 
						
			if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3) ) {
				// ID Â°ÂªÃ€ÃŒ Â¸Ã‚Â´Ã™.
			}
			else {
				// Ã€ÃšÂ½Ã…Ã€Ã‡ Â°ÃÃ€ÃŒ Â¾Ã†Â´ÃÂ¹Ã‡Â·Ã Ã‚Ã¸Â¿Ã«Ã€ÃŒ Ã‡Ã˜ÃÂ¦ÂµÃˆÂ´Ã™.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
				ReleaseItemHandler(iClientH, i, TRUE);
				// v1.4 Â´Ã«Â¹ÃŒÃÃ¶Â¸Â¦ Â¾Ã²Â´Ã‚Â´Ã™. 
				iDamage = iDice(10, 10);
				m_pClientList[iClientH]->m_iHP -= iDamage;
				if (m_pClientList[iClientH]->m_iHP <= 0) {
					ClientKilledHandler(iClientH, NULL, NULL, iDamage);
				}
			}
		}
	}
}

void CGame::_BWM_Init(int iClientH, char *pData)
{
	if (m_pClientList[iClientH] == NULL) return;

	m_pClientList[iClientH]->m_bIsBWMonitor = TRUE;
	wsprintf(G_cTxt, "(*) BWMonitor(%d) registered.", iClientH);
	PutLogList(G_cTxt);
}

void CGame::_BWM_Command_Shutup(char *pData)
{
 char * cp, cName[11];
 register int i;

	cp = (char *)(pData + 16);

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);

	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0) {
			m_pClientList[i]->m_iTimeLeft_ShutUp = 20*3*10; // 1Ã€ÃŒ 3ÃƒÃŠÂ´Ã™. 20Ã€ÃŒÂ¸Ã© 1ÂºÃ Â¿Ã¥Ã€Â» Ã‡ÃÂ¸Ã© Â¹Â«ÃÂ¶Â°Ã‡ Ã†Ã¤Â³ÃÃ†Â¼ 10ÂºÃ  
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, 20*3*10, NULL, NULL, cName);
			
			// Admin Log
			wsprintf(G_cTxt, "BWordMonitor shutup(%s %d)", cName, 20*3*10);
			PutAdminLogFileList(G_cTxt);

			return;
		}
	}
}

void CGame::ExchangeItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char *pItemName)
{
 short sOwnerH;
 char  cOwnerType;
 
	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount < iAmount) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) return;
	if (wObjectID >= DEF_MAXCLIENTS) return;

	// ¾ÆÀÌÅÛÀ» ´©±¸¿Í ±³È¯ÇÏ°Ú´Ù´Â ¸Ş½ÃÁö°¡ µµÂøÇß´Ù. »ó´ë¹æ¿¡°Ô ¾Ë¸®°í ¾çÂÊ ¸ğµÎ ±³È¯Ã¢À» ¿­µµ·Ï ÇÑ´Ù. 
	//ÀÌÁ¦ dX, dY¿¡ ÀÖ´Â ¿ÀºêÁ§Æ®¿¡°Ô ¼Òºñ¼º ¾ÆÀÌÅÛÀ» °Ç³×ÁØ´Ù. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	

	if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {

		if ((m_bAdminSecurity == TRUE) && (m_pClientList[sOwnerH]->m_iAdminUserLevel > 0)){
			return;
		}

		// v1.4 ÁÖ°íÀÚ ÇÑ °´Ã¼¿Í ¸Â´ÂÁö ÆÇ´ÜÇÑ´Ù.
		if (wObjectID != NULL) { 
			if (wObjectID < 10000) {
				// ÇÃ·¹ÀÌ¾î 
				if (m_pClientList[wObjectID] != NULL) {
					if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
				}
			}
			else sOwnerH = NULL;
		}
		
		if ((sOwnerH == NULL) || (m_pClientList[sOwnerH] == NULL)) {
			//Â¾Ã†Ã€ÃŒÃ…Ã› Â±Â³ÃˆÂ¯Ã€Â» Â¿Ã¤ÃƒÂ»Ã‡Ã‘ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¿Â¡Â°Ã” Ã‡Ã˜Â´Ã§ Ã€Â§Ã„Â¡Â¿Â¡ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¾Ã¸Ã€Â½Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
			_ClearExchangeStatus(iClientH); 
		}
		else {
			if ((m_pClientList[sOwnerH]->m_bIsExchangeMode == TRUE) || (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) ||
				(m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) {
				// Â»Ã³Â´Ã«Â¹Ã¦Ã€ÃŒ Ã€ÃŒÂ¹ÃŒ Â±Â³ÃˆÂ¯ ÃÃŸÃ€ÃŒÂ°Ã…Â³Âª Ã€Ã¼Ã…ÃµÂ¸Ã°ÂµÃ¥, ÃˆÂ¤Ã€Âº Â»Ã§Ã…ÃµÃ€Ã¥Ã€ÃŒÂ´Ã™. Â±Â³ÃˆÂ¯Â¸Ã°ÂµÃ¥Â·Ã ÂµÃ©Â¾Ã®Â°Â¥ Â¼Ã¶ Â¾Ã¸Â´Ã™. 
				_ClearExchangeStatus(iClientH);
			}
			else {
				// Â±Â³ÃˆÂ¯Â¸Ã°ÂµÃ¥Â°Â¡ Â½ÃƒÃ€Ã›ÂµÃ‡Â¾ÃºÂ´Ã™. Ã€ÃÂµÂ¦Â½Âº, Ã€ÃŒÂ¸Â§ Ã€ÃºÃ€Ã¥  
				m_pClientList[iClientH]->m_bIsExchangeMode = TRUE;
				m_pClientList[iClientH]->m_iExchangeH = sOwnerH;
				ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
				strcpy(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[sOwnerH]->m_cCharName);


				//Clear items in the list
				m_pClientList[iClientH]->iExchangeCount = 0;
				m_pClientList[sOwnerH]->iExchangeCount = 0;
				for(int i=0; i<4 ; i++){
					//Clear the trader
					ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName[i], sizeof(m_pClientList[iClientH]->m_cExchangeItemName[i]));
					m_pClientList[iClientH]->m_cExchangeItemIndex[i] = -1;
					m_pClientList[iClientH]->m_iExchangeItemAmount[i] = 0;
					//Clear the guy we're trading with
					ZeroMemory(m_pClientList[sOwnerH]->m_cExchangeItemName[i], sizeof(m_pClientList[sOwnerH]->m_cExchangeItemName[i]));
					m_pClientList[sOwnerH]->m_cExchangeItemIndex[i] = -1;
					m_pClientList[sOwnerH]->m_iExchangeItemAmount[i] = 0;
				}

				// Â±Â³ÃˆÂ¯Ã‡ÃÂ°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã› Ã€ÃÂµÂ¦Â½Âº, Â¼Ã¶Â·Â® Ã€ÃºÃ€Ã¥ 
				m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->iExchangeCount]  = (char)sItemIndex;
				m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->iExchangeCount] = iAmount;

				//ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
				memcpy(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->iExchangeCount], m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, 20);
				
				m_pClientList[sOwnerH]->m_bIsExchangeMode  = TRUE;
				m_pClientList[sOwnerH]->m_iExchangeH = iClientH;
				ZeroMemory(m_pClientList[sOwnerH]->m_cExchangeName, sizeof(m_pClientList[sOwnerH]->m_cExchangeName));
				strcpy(m_pClientList[sOwnerH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName);

				m_pClientList[iClientH]->iExchangeCount++;
				SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex+1000, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				              m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);

				SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_OPENEXCHANGEWINDOW, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				              m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);
			}
		}
	}
	else {
		// NPCÂ¿ÃÂ´Ã‚ Â¹Â°Â°Ã‡Ã€Â» Â±Â³ÃˆÂ¯Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		_ClearExchangeStatus(iClientH);

	}
}

void CGame::SetExchangeItem(int iClientH, int iItemIndex, int iAmount)
{
 int iExH;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
	if (m_pClientList[iClientH]->iExchangeCount > 4) return;	//only 4 items trade

	//no admin trade
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)){
		_ClearExchangeStatus(m_pClientList[iClientH]->m_iExchangeH);
		_ClearExchangeStatus(iClientH);
	}


	if ((m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) && (m_pClientList[iClientH]->m_iExchangeH != NULL)) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		if ( (m_pClientList[iExH] == NULL) || (memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ) {
			// ±³È¯ÇÒ »ó´ë¹æÀÌ ¾ø°Å³ª ±³È¯ÇÏ°íÀÚ Çß´ø ±× Ä³¸¯ÅÍ°¡ ¾Æ´Ï´Ù. 	

		}
		else {
			// ±³È¯ÇÏ°íÀÚ ÇÏ´Â »ó´ë¹æ¿¡°Ô ¾ÆÀÌÅÛÀ» ¾Ë·ÁÁØ´Ù. 
			// ÇØ´ç ¾ÆÀÌÅÛÀÌ Á¸ÀçÇÏ´ÂÁö, ¼ö·®ÀÌ ¸Â´ÂÁö Ã¼Å©ÇÑ´Ù. 
			if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount < iAmount) return;

			//No Duplicate items
			for(int i=0; i<m_pClientList[iClientH]->iExchangeCount;i++){
				if (m_pClientList[iClientH]->m_cExchangeItemIndex[i] == (char)iItemIndex) {
					_ClearExchangeStatus(iExH);
					_ClearExchangeStatus(iClientH);
					return;
				}
			}

			// ±³È¯ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛ ÀÎµ¦½º, ¼ö·® ÀúÀå 
			m_pClientList[iClientH]->m_cExchangeItemIndex[m_pClientList[iClientH]->iExchangeCount]  = (char)iItemIndex;
			m_pClientList[iClientH]->m_iExchangeItemAmount[m_pClientList[iClientH]->iExchangeCount] = iAmount;

			//ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
			memcpy(m_pClientList[iClientH]->m_cExchangeItemName[m_pClientList[iClientH]->iExchangeCount], m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);

			//m_pClientList[iClientH]->m_cExchangeItemIndex  = iItemIndex;
			//m_pClientList[iClientH]->m_iExchangeItemAmount = iAmount;
			//ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
			//memcpy(m_pClientList[iClientH]->m_cExchangeItemName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);
			
			m_pClientList[iClientH]->iExchangeCount++;
			SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_SETEXCHANGEITEM, iItemIndex+1000, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute); 

			SendNotifyMsg(iClientH, iExH, DEF_NOTIFY_SETEXCHANGEITEM, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
		}
	}
	else {
		// ±³È¯ ¸ğµå°¡ ¾Æ´Ï¹Ç·Î 
	}
}

void CGame::ConfirmExchangeItem(int iClientH)
{
 int iExH;
 int iItemWeightA, iItemWeightB, iWeightLeftA, iWeightLeftB, iAmountLeft;
 class CItem * pItemA[4], * pItemB[4], * pItemAcopy[4], * pItemBcopy[4];
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;
		

	if ((m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) && (m_pClientList[iClientH]->m_iExchangeH != NULL)) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
	
		// v1.42 ¼³¸¶ ÀÌ·± °æ¿ì°¡?
		if (iClientH == iExH) return;

		if (m_pClientList[iExH] != NULL) {
			if ( (memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ||
			     (m_pClientList[iExH]->m_bIsExchangeMode != TRUE) ||
				 (memcmp(m_pClientList[iExH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName, 10) != 0) ) {
				// ±³È¯ÇÏ°íÀÚ Çß´ø ±× Ä³¸¯ÅÍ°¡ ¾Æ´Ï´Ù. ±³È¯ »óÅÂ´Â Ãë¼Ò.
				_ClearExchangeStatus(iClientH);
				_ClearExchangeStatus(iExH);
				return;
			}
			else {
				m_pClientList[iClientH]->m_bIsExchangeConfirm = TRUE;
				if (m_pClientList[iExH]->m_bIsExchangeConfirm == TRUE) {
					// »ó´ë¹æµµ ±³È¯ÀÇ»ç¸¦ ¹àÇû´Ù. ±³È¯ÀÌ ¼º¸³ÇÒ ¼ö ÀÖ´ÂÁö °è»êÇÑ´Ù. ¾ÆÀÌÅÛ °¹¼ö, ¹«°Ô Á¦ÇÑÀ» ÆÇ´Ü.
					
					//Check all items
					for(int i=0; i<m_pClientList[iClientH]->iExchangeCount; i++){
						if ((m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] == NULL) ||
							(memcmp(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName, m_pClientList[iClientH]->m_cExchangeItemName[i], 20) != 0)) {
							_ClearExchangeStatus(iClientH);
							_ClearExchangeStatus(iExH);
							return;
						}
					}
					for(i=0; i<m_pClientList[iExH]->iExchangeCount; i++){
						if ((m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] == NULL) ||
							(memcmp(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName, m_pClientList[iExH]->m_cExchangeItemName[i], 20) != 0)) {
								_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;
							}
					}

					iWeightLeftA = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
					iWeightLeftB = _iCalcMaxLoad(iExH) - iCalcTotalWeight(iExH);

					//Calculate weight for items
					iItemWeightA = 0;
					for(i=0; i<m_pClientList[iClientH]->iExchangeCount; i++){
						iItemWeightA = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]],
							m_pClientList[iClientH]->m_iExchangeItemAmount[i]);
					}
					iItemWeightB = 0;
					for(i=0; i<m_pClientList[iExH]->iExchangeCount; i++){
						iItemWeightB = iGetItemWeight(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]],
							m_pClientList[iExH]->m_iExchangeItemAmount[i]);
					}

					//See if the other person can take the item weightload
					if ((iWeightLeftA < iItemWeightB) || (iWeightLeftB < iItemWeightA)) {
						// ±³È¯ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀ» ¹ŞÀ» ¹«°Ô°ø°£ÀÌ ¾ø´Ù. ±³È¯ ºÒ°¡´É. 
						_ClearExchangeStatus(iClientH);
						_ClearExchangeStatus(iExH);
						return;
					}

					for(i=0; i<m_pClientList[iClientH]->iExchangeCount; i++){
						// ¼ö·®´ÜÀ§°¡ ÀÖ´Â ¾ÆÀÌÅÛÀÇ °æ¿ì´Â »õ·Î »ı¼ºÀ» ½ÃÄÑ¾ß ³ª´­¼ö ÀÖ´Ù.
						if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {

								if (m_pClientList[iClientH]->m_iExchangeItemAmount[i] > m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount) {
									// ±³È¯ÇÏ°íÀÚ Çß´ø ¼ö·®º¸´Ù ¾ÆÀÌÅÛÀÌ Àû´Ù. ±×µ¿¾È ÁÙ¾îµé¾ú´Ù.
									_ClearExchangeStatus(iClientH);
									_ClearExchangeStatus(iExH);
									return;		
								}
								pItemA[i] = new class CItem;
								_bInitItemAttr(pItemA[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
								pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];

								// ·Î±×¸¦ ³²±â±â À§ÇÑ ¾ÆÀÌÅÛ º¹»ç¹° 
								pItemAcopy[i] = new class CItem;
								_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
								bCopyItemContents(pItemAcopy[i], pItemA[i]);
								pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
							}
						else {
							pItemA[i] = (class CItem *)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]];
							pItemA[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];

							// ·Î±×¸¦ ³²±â±â À§ÇÑ ¾ÆÀÌÅÛ º¹»ç¹° 
							pItemAcopy[i] = new class CItem;
							_bInitItemAttr(pItemAcopy[i], m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemAcopy[i], pItemA[i]);
							pItemAcopy[i]->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount[i];
						}
					}

					for(i=0; i<m_pClientList[iExH]->iExchangeCount; i++){
						if ( (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
							(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {

								if (m_pClientList[iExH]->m_iExchangeItemAmount[i] > m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount) {
									// ±³È¯ÇÏ°íÀÚ Çß´ø ¼ö·®º¸´Ù ¾ÆÀÌÅÛÀÌ Àû´Ù. ±×µ¿¾È ÁÙ¾îµé¾ú´Ù.
									_ClearExchangeStatus(iClientH);
									_ClearExchangeStatus(iExH);
									return;		
								}
								pItemB[i] = new class CItem;
								_bInitItemAttr(pItemB[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
								pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];

								// ·Î±×¸¦ ³²±â±â À§ÇÑ ¾ÆÀÌÅÛ º¹»ç¹° 
								pItemBcopy[i] = new class CItem;
								_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
								bCopyItemContents(pItemBcopy[i], pItemB[i]);
								pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
							}
						else {
							pItemB[i] = (class CItem *)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]];
							pItemB[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];

							// ·Î±×¸¦ ³²±â±â À§ÇÑ ¾ÆÀÌÅÛ º¹»ç¹° 
							pItemBcopy[i] = new class CItem;
							_bInitItemAttr(pItemBcopy[i], m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cName);
							bCopyItemContents(pItemBcopy[i], pItemB[i]);
							pItemBcopy[i]->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount[i];
						}
					}

					// ¸ÕÀú ¾ÆÀÌÅÛÀ» ³ÖÀº ÈÄ 
					for(i=0; i<m_pClientList[iExH]->iExchangeCount; i++){
						bAddItem(iClientH, pItemB[i], NULL);
						_bItemLog(DEF_ITEMLOG_EXCHANGE, iExH, iClientH, pItemBcopy[i]);
						delete pItemBcopy[i];
						pItemBcopy[i] = NULL;
						if ( (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
							(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
								//
								iAmountLeft = (int)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iExH]->m_iExchangeItemAmount[i];
								if (iAmountLeft < 0) iAmountLeft = 0;	  
								// v1.41 !!!
								SetItemCount(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], iAmountLeft);
								// m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
								//
							}
						else {
							// ¸¸¾à ÀåÂøµÈ ¾ÆÀÌÅÛÀÌ¶ó¸é ÇØÁ¦ÇÑ´Ù.
							ReleaseItemHandler(iExH, m_pClientList[iExH]->m_cExchangeItemIndex[i], TRUE);
							SendNotifyMsg(NULL, iExH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iExH]->m_cExchangeItemIndex[i], m_pClientList[iExH]->m_iExchangeItemAmount[i], NULL, m_pClientList[iClientH]->m_cCharName);
							m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex[i]] = NULL;
						}
					}

					for(i=0; i<m_pClientList[iClientH]->iExchangeCount; i++){
						bAddItem(iExH, pItemA[i], NULL);
						_bItemLog(DEF_ITEMLOG_EXCHANGE, iClientH, iExH, pItemAcopy[i]);
						delete pItemAcopy[i];
						pItemAcopy[i] = NULL;

						if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
							(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
								//
								iAmountLeft = (int)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]]->m_dwCount - m_pClientList[iClientH]->m_iExchangeItemAmount[i];
								if (iAmountLeft < 0) iAmountLeft = 0;	 
								// v1.41 !!!
								SetItemCount(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], iAmountLeft);
								// m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
								//
							}
						else {
							// ¸¸¾à ÀåÂøµÈ ¾ÆÀÌÅÛÀÌ¶ó¸é ÇØÁ¦ÇÑ´Ù.
							ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex[i], TRUE);
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iClientH]->m_cExchangeItemIndex[i], m_pClientList[iClientH]->m_iExchangeItemAmount[i], NULL, m_pClientList[iExH]->m_cCharName);
							m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex[i]] = NULL;
						}
					}

					m_pClientList[iClientH]->m_bIsExchangeMode = FALSE;
					m_pClientList[iClientH]->m_bIsExchangeConfirm = FALSE;
					ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
					m_pClientList[iClientH]->m_iExchangeH = NULL;
					m_pClientList[iClientH]->iExchangeCount = 0;

					m_pClientList[iExH]->m_bIsExchangeMode = FALSE;
					m_pClientList[iExH]->m_bIsExchangeConfirm = FALSE;
					ZeroMemory(m_pClientList[iExH]->m_cExchangeName, sizeof(m_pClientList[iExH]->m_cExchangeName));
					m_pClientList[iExH]->m_iExchangeH = NULL;
					m_pClientList[iExH]->iExchangeCount = 0;

					for(i=0;i<4;i++){
						m_pClientList[iClientH]->m_cExchangeItemIndex[i] = -1;
						m_pClientList[iExH]->m_cExchangeItemIndex[i] = -1;
					}

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);
					SendNotifyMsg(NULL, iExH,     DEF_NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);

					// ¹«°Ô Àç¼³Á¤
					iCalcTotalWeight(iClientH);
					iCalcTotalWeight(iExH);
					return;
				}
			}
		}
		else {
			// ±³È¯ÇÒ »ó´ë¹æÀÌ ¾ø´Ù. ±³È¯Àº Ãë¼Ò µÈ´Ù.
			_ClearExchangeStatus(iClientH);
			return;
		}
	}
}

int CGame::_iGetItemSpaceLeft(int iClientH)
{
 int i, iTotalItem;

	iTotalItem = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) iTotalItem++;

	return (DEF_MAXITEMS - iTotalItem);
}

BOOL CGame::bAddItem(int iClientH, CItem * pItem, char cMode)
{
 char * cp, cData[256];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int iRet, iEraseReq;


	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1Â°Â³ ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™. AmountÂ°Â¡ Â¾Ã†Â´ÃÂ´Ã™!
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;	// Â¼Ã¶Â·Â®Ã€Â» Ã€Ã”Â·Ã‚ 
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // Â¾Ã²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃ 
		cp++;
		*/
		
		if (iEraseReq == 1) {
			//testcode
			//wsprintf(G_cTxt, "AddItem: Delete (%s)", pItem->m_cName);
			//PutLogFileList(G_cTxt);
			delete pItem;
			pItem = NULL;
		}
		
		// Â¾Ã†Ã€ÃŒÃ…Ã› ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã› 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		
		return TRUE;
	}
	else {
		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€Ã¼Â´ÃÂ¹ÃÃ€Âº Ã„Â³Â¸Â¯Ã…ÃÂ°Â¡ Â´ÃµÃ€ÃŒÂ»Ã³ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÂºÂ¸Â°Ã¼Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â»Ã³Ã…Ã‚Ã€ÃŒÂ´Ã™.
		// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¼Â­Ã€Ã–Â´Ã‚ Ã€Â§Ã„Â¡Â¿Â¡ Â¹Ã¶Â¸Â°Â´Ã™. 
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                         m_pClientList[iClientH]->m_sY, 
			                                                         pItem);
		
		// Â´Ã™Â¸Â¥ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¶Â³Â¾Ã®ÃÃ¸ Â°ÃÃ€Â» Â¾Ã‹Â¸Â°Â´Ã™. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color
		
		// Â´ÃµÃ€ÃŒÂ»Ã³ Â°Â¡ÃÃºÂ¼Ã¶ Â¾Ã¸Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		
		return TRUE;
	}

	return FALSE;
}


int CGame::_iTalkToNpcResult_Cityhall(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
 int iQuest, iEraseReq, iExp;
 class CItem * pItem;

	// Return Code
	// -1  : Ã‡Ã¶Ã€Ã§ Ã€Ã“Â¹Â« Â¼Ã¶Ã‡Ã ÃÃŸ
	// -2  : Â¸Â¶Ã€Â»Ã€ÃŒ Â´Ã™Â¸Â£Â°Ã…Â³Âª ÃÃŸÂ¸Â³Ã€Âº Ã€Ã“Â¹Â«Â¸Â¦ Â¾Ã²Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.    
	// -3  : Â¹Ã¼ÃÃ‹Ã€ÃšÂ´Ã‚ Ã€Ã“Â¹Â«Â¸Â¦ Â¾Ã²Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.
	// -4  : Ã‡Ã¶Ã€Ã§ ÃÂ¶Â°Ã‡Â¿Â¡ Â¸Ã‚Â´Ã‚ Ã€Ã“Â¹Â«Â°Â¡ Â¾Ã¸Â´Ã™. Ã€ÃÂ»Ã³Ã€Ã»Ã€Ã Â´Ã«ÃˆÂ­Â³Âª ÃÂ¤ÂºÂ¸ ÃƒÃ¢Â·Ã‚ 

	// Â½ÃƒÃƒÂ» Ã‡Ã ÃÂ¤Â°Ã¼Â¿Â¡Â°Ã” Â¸Â»Ã€Â» Â°Ã‰Â¾ÃºÂ´Ã™. Â·Â¹ÂºÂ§Â°Ãº Ã„Ã¹Â½ÂºÃ†Â® Â»Ã³Ã…Ã‚Â¿Â¡ ÂµÃ»Â¶Ã³ Ã€Ã“Â¹Â«Â¸Â¦ Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™. 
	if (m_pClientList[iClientH] == NULL) return 0;
	/*if (((memcmp(m_pClientList[iClientH]->m_cMapName, "cityhall_1", 10) != 1) || 
		(memcmp(m_pClientList[iClientH]->m_cMapName, "cityhall_2", 10) != 1)) &&
		(memcmp(m_pClientList[i]->m_cLocation, "NONE",4) != 0)) {
			wsprintf(G_cTxt, "Traveller hack: (%s) Player: (%s) - is talking to William from a remote map.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
	}*/

	if (m_pClientList[iClientH]->m_iQuest != NULL) {
		if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest] == NULL) return -4;
		else if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iFrom == 4) {
			// Â½ÃƒÃƒÂ» Ã‡Ã ÃÂ¤Â°Ã¼Â¿Â¡Â°Ã” Â¸ÃƒÃ€Âº Ã€Ã“Â¹Â«Â´Ã™. Ã€Ã“Â¹Â«Â°Â¡ Â³Â¡Â³ÂµÂ´Ã™Â¸Ã© Â¿Â©Â±Ã¢Â¼Â­ ÃƒÂ³Â¸Â®Ã‡ÃÂ°Ã­ -5Â¸Â¦ Â¸Â®Ã…ÃÃ‡Ã‘Â´Ã™.
			if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) {
				// Ã†Ã·Â»Ã³Ã€Â» Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™Â¸Ã©(Â»Ã³Ã‡Â°Ã€Â» ÂµÃ© Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â»Ã³ÃˆÂ²Ã€ÃŒÂ¶Ã³Â´Ã¸Â°Â¡) Ã€Ã“Â¹Â« ÃÂ¾Â·Ã¡ ÃƒÂ³Â¸Â®Â¸Â¦ Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
				// Â¸Ã°ÂµÃ§ ÃÂ¶Â°Ã‡Ã€ÃŒ Â¸Â¸ÃÂ·ÂµÃ‡Â¸Ã© ÃƒÂ³Â¸Â®Ã‡ÃÂ°Ã­ -5Â¸Â¦ Â¸Â®Ã…Ã.
				if ( (m_pClientList[iClientH]->m_iQuestRewardType > 0) &&
					 (m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType] != NULL) ) {
					// Ã„Ã¹Â½ÂºÃ†Â®Ã€Ã‡ Â´Ã±Â°Â¡Â°Â¡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ´Ã™. Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¹ÃÃ€Â» Â¼Ã¶ Ã€Ã–Â´Ã‚ÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃÂ¸Â¦ Ã†Ã‡Â´ÃœÃ‡Ã‘Â´Ã™.
					pItem = new class CItem;
					_bInitItemAttr(pItem, m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName);
					pItem->m_dwCount = m_pClientList[iClientH]->m_iQuestRewardAmount;
					if (_bCheckItemReceiveCondition(iClientH, pItem) == TRUE) {
						// Ã„Ã¹Â½ÂºÃ†Â® Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¹ÃÃ€Â» Â¼Ã¶ Ã€Ã–Â´Ã‚ ÃÂ¶Â°Ã‡Ã€ÃŒÂ´Ã™. Â¼Ã¶Â¿Â©Ã‡Ã‘Â´Ã™.
						_bAddClientItemList(iClientH, pItem, &iEraseReq);
						SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, NULL);
						if (iEraseReq == 1) delete pItem;
						
						// Â°Ã¸Ã‡Ã¥ÂµÂµ Â»Ã³Â½Ã‚ 
						m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

						// Ã†Ã·Â»Ã³Ã€ÃŒ Ã€Ã¼Â´ÃÂµÃ‡Â¾ÃºÂ´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã› ÃˆÃ„ Â¸Â®Ã…Ã. Ã„Ã¹Â½ÂºÃ†Â® Â»Ã³Ã…Ã‚ Ã…Â¬Â¸Â®Â¾Ã®.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							          m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);
						
						_ClearQuestStatus(iClientH);
						return -5;
					} 
					else {
						delete pItem;
						// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¹ÃÃ€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã› ÃˆÃ„ Â¸Â®Ã…Ã
						SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);

						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 0, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							          m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);

						return -5;
					}
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -1) {
					// Ã„Ã¹Â½ÂºÃ†Â®Ã€Ã‡ Â´Ã±Â°Â¡Â°Â¡ Â°Ã¦Ã‡Ã¨Ã„Â¡Ã€ÃŒÂ´Ã™. 
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iQuestRewardAmount;
					// Â°Ã¸Ã‡Ã¥ÂµÂµ Â»Ã³Â½Ã‚ 
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							      "Â°Ã¦Ã‡Ã¨Ã„Â¡              ", m_pClientList[iClientH]->m_iContribution);
					
					// Ã„Ã¹Â½ÂºÃ†Â® Â»Ã³Ã…Ã‚Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®Ã‡Ã‘Â´Ã™.
					_ClearQuestStatus(iClientH);
					return -5;
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -2) {
					// Ã„Ã¹Â½ÂºÃ†Â®Ã€Ã‡ Â´Ã±Â°Â¡Â´Ã‚ ÂºÃ±Â·ÃŠ Â°Ã¦Ã‡Ã¨Ã„Â¡ Ã€Ã»Â¿Â¡Â°Ã” ÃÃ—Â¾ÃºÃ€Â»Â¶Â§ Â°Ã¦Ã‡Ã¨Ã„Â¡ * m_pClientList[iClientH]->m_iQuestRewardAmount Â¸Â¸Ã…Â­Ã€Ã‡ Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â¾Ã²Â´Ã‚Â´Ã™.
					//***
					iExp = iDice(1, (10*m_pClientList[iClientH]->m_iLevel));
					//***
					iExp = iExp * m_pClientList[iClientH]->m_iQuestRewardAmount;
					
					m_pClientList[iClientH]->m_iExpStock += iExp;
					// Â°Ã¸Ã‡Ã¥ÂµÂµ Â»Ã³Â½Ã‚ 
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, iExp, 
							      "Â°Ã¦Ã‡Ã¨Ã„Â¡              ", m_pClientList[iClientH]->m_iContribution);
					
					// Ã„Ã¹Â½ÂºÃ†Â® Â»Ã³Ã…Ã‚Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®Ã‡Ã‘Â´Ã™.
					_ClearQuestStatus(iClientH);
					return -5;
				}
				else {
					// Ã„Ã¹Â½ÂºÃ†Â®Ã€Ã‡ Â´Ã±Â°Â¡Â´Ã‚ Â¾Ã¸Â´Ã™. Â°Ã¸Ã‡Ã¥ÂµÂµÂ¸Â¸ Â¿Ã€Â¸Â¥Â´Ã™.
					// Â°Ã¸Ã‡Ã¥ÂµÂµ Â»Ã³Â½Ã‚ 
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, 0, 
							      "                     ", m_pClientList[iClientH]->m_iContribution);
					
					// Ã„Ã¹Â½ÂºÃ†Â® Â»Ã³Ã…Ã‚Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®Ã‡Ã‘Â´Ã™.
					_ClearQuestStatus(iClientH);
					return -5;
				}
			}
			else return -1;
		}
		
		return -4;	// Â´Ã™Â¸Â¥ NPCÂ¿Â¡Â°Ã”Â¼Â­ Â¾Ã²Ã€Âº Ã„Ã¹Â½ÂºÃ†Â®Â¸Â¦ Â¼Ã¶Ã‡Ã ÃÃŸÃ€ÃŒÂ´Ã™. ÃÃ¯ ÃÂ¶Â°Ã‡Â¿Â¡ Â¸Ã‚Â´Ã‚ Ã€Ã“Â¹Â«Â°Â¡ Â¾Ã¸Â´Ã™. Ã€ÃÂ»Ã³Ã€Ã»Ã€Ã Â´Ã«ÃˆÂ­Â¸Â¦ ÃƒÃ¢Â·Ã‚Ã‡Ã‘Â´Ã™.
	}
	
	// Â¾Ã†Â¹Â«Â·Â± Ã€Ã“Â¹Â«Â¸Â¦ Â¸Ã‚Â°Ã­ Ã€Ã–ÃÃ¶ Â¾ÃŠÂ´Ã™. Ã€Ã“Â¹Â«Â¸Â¦ Â¸ÃƒÃ€Â» Â¼Ã¶ Ã€Ã–Â´Ã‚ ÃÂ¶Â°Ã‡Ã€ÃÃÃ¶ Ã†Ã‡ÂºÂ°Ã‡Ã‘Â´Ã™. 
	if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) == 0) {
		// Â¸Â¶Ã€Â» Â¼Ã’Â¼Ã“Ã€ÃŒ Â°Â°Â´Ã™. 
		// Â¹Ã¼ÃÃ‹Ã€ÃšÂ¶Ã³Â¸Ã© Ã€Ã“Â¹Â«Â¸Â¦ Â¸ÃƒÃ€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™. 
		if (m_pClientList[iClientH]->m_iPKCount > 0) return -3;
		
		iQuest = __iSearchForQuest(iClientH, 4, pQuestType, pMode, pRewardType, pRewardAmount, pContribution, pTargetName, pTargetType, pTargetCount, pX, pY, pRange);
		if (iQuest <= 0) return -4;

		// Ã€Ã“Â¹Â« ÃƒÂ£Â¾Ã’Â´Ã™. 
		return iQuest;
	}
	else return -2; // Â¸Â¶Ã€Â»Ã€ÃŒ Â´Ã™Â¸Â£Â°Ã…Â³Âª Â¸Â¶Ã€Â» Â¼Ã’Â¼Ã“Ã€ÃŒ Â¾Ã†Â´ÃÂ´Ã™.

	return -4;
}


int CGame::_iTalkToNpcResult_Guard(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
	// Â°Ã¦ÂºÃ±ÂºÂ´Â°ÃºÃ€Ã‡ Â´Ã«ÃˆÂ­. Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Ã€Â§Ã„Â¡Â¿Â¡ Ã€Ã»Ã€Ã½Ã‡Ã‘ Â´Ã«ÃˆÂ­ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂµÃ°Â½ÂºÃ‡ÃƒÂ·Â¹Ã€ÃŒÃ‡Ã‘Â´Ã™.
	if (m_pClientList[iClientH] == NULL) return 0;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "are", 3) == 0) {
		// Â¸Â» Â°Ã‡ Â»Ã§Â¶Ã·Ã€ÃŒ Â¾Ã†Â·Â¹Â½ÂºÂµÂ§ Â¼Ã’Â¼Ã“ 
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			// Ã€ÃšÂ±Ã¢ Â¸Â¶Ã€Â» Â°Ã¦ÂºÃ±Â¿Â¡Â°Ã” Â¸Â»Ã€Â» Â°Ã‰Â¾ÃºÃ€Â½.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (200), NULL, NULL, NULL, NULL);
			return 1000;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elv", 3) == 0) {
			// Â´Ã™Â¸Â¥ Â¸Â¶Ã€Â» Â°Ã¦ÂºÃ±Â¿Â¡Â°Ã” Â¸Â»Ã€Â» Â°Ã‰Â¾ÃºÃ€Â½.	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (201), NULL, NULL, NULL, NULL);
			return 1001;
		}
	}
	else
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elv", 3) == 0) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			// Â´Ã™Â¸Â¥ Â¸Â¶Ã€Â» Â°Ã¦ÂºÃ±Â¿Â¡Â°Ã” Â¸Â»Ã€Â» Â°Ã‰Â¾ÃºÃ€Â½.	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (202), NULL, NULL, NULL, NULL);
			return 1002;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elv", 3) == 0) {
			// Ã€ÃšÂ±Ã¢ Â¸Â¶Ã€Â» Â°Ã¦ÂºÃ±Â¿Â¡Â°Ã” Â¸Â»Ã€Â» Â°Ã‰Â¾ÃºÃ€Â½.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (203), NULL, NULL, NULL, NULL);
			return 1003;
		}
	}
	else
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			// ÃÃŸÂ¸Â³Ã€ÃŒ Â¾Ã†Â·Â¹Â½ÂºÂµÂ§ Â°Ã¦ÂºÃ±Â¿Â¡Â°Ã” Â¸Â»Ã€Â» Â°Ã‰Â¾ÃºÃ€Â½
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (204), NULL, NULL, NULL, NULL);
			return 1004;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
			// ÃÃŸÂ¸Â³Ã€ÃŒ Â¿Â¤Â¹Ã™Ã€Ã Â°Ã¦ÂºÃ±Â¿Â¡Â°Ã” Â¸Â»Ã€Â» Â°Ã‰Â¾ÃºÃ€Â½.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (205), NULL, NULL, NULL, NULL);
			return 1005;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "default", 7) == 0) {
			// ÃƒÃŠÂºÂ¸ Â»Ã§Â³Ã‰Ã…Ã
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (206), NULL, NULL, NULL, NULL);
			return 1006;
		}
	}

	return 0;
}


BOOL CGame::_bDecodeQuestConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iQuestConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Ã„Ã¹Â½ÂºÃ†Â® Â¹Ã¸ÃˆÂ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pQuestConfigList[atoi(token)] != NULL) {
						// Ã€ÃŒÂ¹ÃŒ Ã‡Ã’Â´Ã§ÂµÃˆ Â¹Ã¸ÃˆÂ£Â°Â¡ Ã€Ã–Â´Ã™. Â¿Â¡Â·Â¯Ã€ÃŒÂ´Ã™.
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Duplicate quest number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[atoi(token)] = new class CQuest;
					iQuestConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// Ã„Ã¹Â½ÂºÃ†Â® Â»Ã§Ã€ÃŒÂµÃ¥  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Ã„Ã¹Â½ÂºÃ†Â® ÃÂ¾Â·Ã¹  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// TargetType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTargetType = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// MaxCount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxCount= atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iFrom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMinLevel = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxLevel = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillNum = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillLevel = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTimeLimit = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iAssignType = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[1] = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[1] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[2] = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[2] = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[3] = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[3] = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContribution = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContributionLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iResponseMode = atoi(token);
					cReadModeB = 22;
					break;

				case 22:
					ZeroMemory(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, sizeof(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName));
					strcpy(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, token);
					cReadModeB = 23;
					break;

				case 23:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sX = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sY = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRange = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iQuestID = atoi(token);
					cReadModeB = 27;
					break;

				case 27:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iReqContribution = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "quest", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) QUEST(Total:%d) configuration - success!", iQuestConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}


int CGame::__iSearchForQuest(int iClientH, int iWho, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
 int i, iQuestList[DEF_MAXQUESTTYPE], iIndex, iQuest, iReward, iQuestIndex;

	if (m_pClientList[iClientH] == NULL) return -1;
 
	// Ã€Ã»Ã‡Ã•Ã‡Ã‘ Â¹ÃŒÂ¼Ã‡ Â¹Ã¨Â¿Â­ ÃƒÃŠÂ±Ã¢ÃˆÂ­.
	iIndex = 0;
	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		iQuestList[i] = -1;

	for (i = 1; i < DEF_MAXQUESTTYPE; i++) 
	if (m_pQuestConfigList[i] != NULL) {
		
		if (m_pQuestConfigList[i]->m_iFrom != iWho) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMinLevel > m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMaxLevel < m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iReqContribution > m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

		if (m_pQuestConfigList[i]->m_iRequiredSkillNum != -1) {
			// Â°Ã­Â·ÃÃ‡Ã˜Â¾ÃŸ Ã‡Ã’ Â½ÂºÃ…Â³Ã€ÃŒ Ã€Ã–Â´Ã™. 
			if (m_pClientList[iClientH]->m_cSkillMastery[m_pQuestConfigList[i]->m_iRequiredSkillNum] < 
				m_pQuestConfigList[i]->m_iRequiredSkillLevel) goto SFQ_SKIP;
		}
		
		// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â¸Ã°ÂµÃ¥Ã€ÃÂ¶Â§Â´Ã‚ Ã‡Ã’Â´Ã§ Ã…Â¸Ã€Ã”Ã€ÃŒ 1Ã€Ã Ã„Ã¹Â½ÂºÃ†Â®Â¸Â¸ ÂºÃÂ¿Â©ÂµÃˆÂ´Ã™.
		if ((m_bIsCrusadeMode == TRUE) && (m_pQuestConfigList[i]->m_iAssignType != 1)) goto SFQ_SKIP; 
		// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â¸Ã°ÂµÃ¥Â°Â¡ Â¾Ã†Â´Ã’Â¶Â§Â´Ã‚ Ã‡Ã’Â´Ã§ Ã…Â¸Ã€Ã”Ã€ÃŒ 1Ã€Âº Â¼Â±Ã…ÃƒÂµÃ‡ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
		if ((m_bIsCrusadeMode == FALSE) && (m_pQuestConfigList[i]->m_iAssignType == 1)) goto SFQ_SKIP; 

		if (m_pQuestConfigList[i]->m_iContributionLimit < m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

		// Â¿Â©Â±Ã¢Â±Ã®ÃÃ¶ Â¿Ã€Â¸Ã© ÃÂ¶Â°Ã‡Â¿Â¡ Ã‡Ã•Â´Ã§Ã‡Ã‘ Ã„Ã¹Â½ÂºÃ†Â®Â´Ã™. ÂµÃ®Â·ÃÃ‡Ã‘Â´Ã™. 
		iQuestList[iIndex] = i;
		iIndex++;

SFQ_SKIP:;
	}

	// iIndexÂ°Â³ Â¸Â¸Ã…Â­Ã€Ã‡ ÃÂ¶Â°Ã‡Â¿Â¡ Â¸Â¸ÃÂ·Ã‡ÃÂ´Ã‚ Ã„Ã¹Â½ÂºÃ†Â®Â¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™. Â±Ã— ÃÃŸÂ¿Â¡Â¼Â­ Â·Â£Â´Ã½Ã‡ÃÂ°Ã” 1Â°Â³Â¸Â¦ Â¼Â±Ã…ÃƒÃ‡Ã‘Â´Ã™.
	if (iIndex == 0) return -1;
	iQuest		 = (iDice(1, iIndex)) - 1;
	iQuestIndex  = iQuestList[iQuest];
	// Ã„Ã¹Â½ÂºÃ†Â® Ã€ÃÂµÂ¦Â½Âº 
	iReward = iDice(1,3);
	*pMode = m_pQuestConfigList[iQuestIndex]->m_iResponseMode;					// Ã„Ã¹Â½ÂºÃ†Â® Ã€Ã€Â´Ã¤ Â¸Ã°ÂµÃ¥ 
	*pRewardType   = m_pQuestConfigList[iQuestIndex]->m_iRewardType[iReward];	// Ã„Ã¹Â½ÂºÃ†Â® Â»Ã³Ã‡Â° ÃÂ¾Â·Ã¹ 
	*pRewardAmount = m_pQuestConfigList[iQuestIndex]->m_iRewardAmount[iReward];	// Ã„Ã¹Â½ÂºÃ†Â® Â»Ã³Ã‡Â° Â°Â¹Â¼Ã¶ 
	*pContribution = m_pQuestConfigList[iQuestIndex]->m_iContribution;			// Ã„Ã¹Â½ÂºÃ†Â® Ã‡Ã˜Â°Ã¡Â½Ãƒ Â¿ÃƒÂ¶Ã³Â°Â¡Â´Ã‚ Â°Ã¸Ã‡Ã¥ÂµÂµ 
	
	strcpy(pTargetName, m_pQuestConfigList[iQuestIndex]->m_cTargetName);			// Ã„Ã¹Â½ÂºÃ†Â® Â¸ÃŠ Ã€ÃŒÂ¸Â§ Â¼Ã¶Â·Ã 
	*pX     = m_pQuestConfigList[iQuestIndex]->m_sX;
	*pY     = m_pQuestConfigList[iQuestIndex]->m_sY;
	*pRange = m_pQuestConfigList[iQuestIndex]->m_iRange;

	*pTargetType  = m_pQuestConfigList[iQuestIndex]->m_iTargetType;
	*pTargetCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
	*pQuestType   = m_pQuestConfigList[iQuestIndex]->m_iType;

	return iQuestIndex;
}

// New 14/05/2004
void CGame::QuestAcceptedHandler(int iClientH)
{
 int iIndex;

	if (m_pClientList[iClientH] == NULL) return;
	
	// Does the quest exist ??
	if(m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest] == NULL) return;

	if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iAssignType == 1) {
		// Ã€Ã¼Â¸Ã©Ã€Ã¼Â¿Ã« Ã„Ã¹Â½ÂºÃ†Â®Ã€ÃŒÂ´Ã™. 
		switch (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iType) {
		case 10: // Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â®Â¿Ã« 1ÃˆÂ¸Â¼Âº Ã„Ã¹Â½ÂºÃ†Â®. Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â®Ã‡ÃÂ°Ã­ Â³ÂªÂ¸Ã© Â³Â¡Ã€ÃŒÂ´Ã™. Â´ÃµÃ€ÃŒÂ»Ã³Ã€Ã‡ Ã„Ã¹Â½ÂºÃ†Â® Â¿Â©ÂºÃÂ°Â¡ Â¾Ã¸Ã€Â½.
			_ClearQuestStatus(iClientH);
			RequestTeleportHandler(iClientH, "2   ", m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_cTargetName,
				                   m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sX, m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sY);
			return;
		}
	}

	// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Ã„Ã¹Â½ÂºÃ†Â®Â¸Â¦ Â¼Ã¶Â¶Ã´Ã‡ÃŸÂ´Ã™. Ã„Ã¹Â½ÂºÃ†Â® Â¹Ã¸ÃˆÂ£, IDÂ°Âª Ã‡Ã’Â´Ã§.
	m_pClientList[iClientH]->m_iQuest = m_pClientList[iClientH]->m_iAskedQuest;
	iIndex = m_pClientList[iClientH]->m_iQuest;
	m_pClientList[iClientH]->m_iQuestID = m_pQuestConfigList[iIndex]->m_iQuestID;
	m_pClientList[iClientH]->m_iCurQuestCount    = 0;
	m_pClientList[iClientH]->m_bIsQuestCompleted = FALSE;
	
	_CheckQuestEnvironment(iClientH);
	_SendQuestContents(iClientH);
}


void CGame::_SendQuestContents(int iClientH)
{
 int iWho, iIndex, iQuestType, iContribution, iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted;
 char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) {
		// Ã‡Ã’Â´Ã§ÂµÃˆ QuestÂ°Â¡ Â¾Ã¸Â´Ã™. 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, NULL, NULL, NULL, NULL,  
		              NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	}
	else {
		// Ã‡Ã’Â´Ã§ÂµÃˆ Quest Â³Â»Â¿Ã«Ã€Â» ÂºÂ¸Â³Â»ÃÃ˜Â´Ã™.
		iWho          = m_pQuestConfigList[iIndex]->m_iFrom;
		iQuestType    = m_pQuestConfigList[iIndex]->m_iType;
		iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
		iTargetType   = m_pQuestConfigList[iIndex]->m_iTargetType;
		iTargetCount  = m_pQuestConfigList[iIndex]->m_iMaxCount;
		iX            = m_pQuestConfigList[iIndex]->m_sX;
		iY            = m_pQuestConfigList[iIndex]->m_sY;
		iRange        = m_pQuestConfigList[iIndex]->m_iRange;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, iWho, iQuestType, iContribution, NULL,  
			          iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);
	}
}

void CGame::_CheckQuestEnvironment(int iClientH)
{
 int iIndex;
 char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) return;
	if (m_pQuestConfigList[iIndex] == NULL) return;

	if (iIndex >= 35 && iIndex <= 40) {
		m_pClientList[iClientH]->m_iQuest = 0;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}

	if (m_pQuestConfigList[iIndex]->m_iQuestID != m_pClientList[iClientH]->m_iQuestID) {
		// Ã„Ã¹Â½ÂºÃ†Â® ID Â°ÂªÃ€ÃŒ Â´Ã™Â¸Â£Â´Ã™. Ã‡Ã’Â´Ã§Â¹ÃÂ¾Ã’Â´Ã¸ Â±Ã— Ã„Ã¹Â½ÂºÃ†Â®Â°Â¡ Â¾Ã†Â´ÃÂ´Ã™. Ã„Ã¹Â½ÂºÃ†Â®Â´Ã‚ ÃƒÃ«Â¼Ã’ÂµÃˆÂ´Ã™.
		m_pClientList[iClientH]->m_iQuest   = NULL;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}

	switch (m_pQuestConfigList[iIndex]->m_iType) {
	case DEF_QUESTTYPE_MONSTERHUNT:
	case DEF_QUESTTYPE_GOPLACE:
		// Â¸Ã³Â½ÂºÃ…Ã Â»Ã§Â³Ã‰Ã€Ã‡ Â°Ã¦Â¿Ã¬ Â¸Ã…Â¹Ã¸ Â¸Ã³Â½ÂºÃ…Ã Â»Ã§Â³Ã‰Â½Ãƒ Â¸ÃŠ Ã€ÃŒÂ¸Â§Ã€Â» ÂºÃ±Â±Â³Ã‡ÃÂ´Ã‚ Â°ÃÃ€Âº ÂºÃ±ÃˆÂ¿Ã€Â²Ã€Ã»Ã€ÃŒÂ¹Ã‡Â·Ã Â¹ÃŒÂ¸Â® Â¸ÃŠ Ã€ÃŒÂ¸Â§Ã€Â» ÂºÃ±Â±Â³, Ã‡ÃƒÂ·Â¡Â±Ã—Â¸Â¦ Â¼Â³ÃÂ¤Ã‡Ã˜ Â³ÃµÂ´Ã‚Â´Ã™. 
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cTargetName, 10) == 0)
			 m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = TRUE;
		else m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = FALSE;
		break;
	}

}

BOOL CGame::_bCheckIsQuestCompleted(int iClientH)
{
 int iQuestIndex;

	// Ã„Ã¹Â½ÂºÃ†Â®Â°Â¡ ÃÂ¾Â·Ã¡ÂµÃ‡Â¾ÃºÂ´Ã‚ÃÃ¶ Ã†Ã‡Â´ÃœÃ‡Ã‘ ÃˆÃ„ Â¸ÃÂ½ÃƒÃÃ¶ ÃƒÂ³Â¸Â®.
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) return FALSE;
	iQuestIndex = m_pClientList[iClientH]->m_iQuest;
	if (iQuestIndex == NULL) return FALSE;
		
	if (m_pQuestConfigList[iQuestIndex] != NULL) {
		switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
		case DEF_QUESTTYPE_MONSTERHUNT:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) && 
				 (m_pClientList[iClientH]->m_iCurQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount) ) {
				// Â¸Ã³Â½ÂºÃ…Ã Â»Ã§Â³Ã‰ Ã„Ã¹Â½ÂºÃ†Â®Â°Â¡ Â¿ÃÂ·Ã¡ÂµÃ‡Â¾ÃºÂ´Ã™. Â¿ÃÂ·Ã¡ÂµÃ‡Â¾ÃºÃ€Â¸Â¸Ã© Ã€Ã‡Â·ÃšÃ€ÃÂ¿Â¡Â°Ã” ÂµÂ¹Â¾Ã†Â°Â¡ Â´Ã«ÃˆÂ­Â¸Â¦ Ã‡ÃÂ¸Ã© Ã†Ã·Â»Ã³Â¹ÃÂ´Ã‚Â´Ã™. 
				m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;					
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
				return TRUE;
			}
			break;

		case DEF_QUESTTYPE_GOPLACE:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) && // Â¸ÃŠÃ€Âº Â¸Ã‚Â°Ã­
				 (m_pClientList[iClientH]->m_sX >= m_pQuestConfigList[iQuestIndex]->m_sX - m_pQuestConfigList[iQuestIndex]->m_iRange) && // ÃÃ‚Ã‡Â¥ÂµÂµ Ã€ÃŒÂ³Â»Ã€ÃŒÂ¸Ã© 
				 (m_pClientList[iClientH]->m_sX <= m_pQuestConfigList[iQuestIndex]->m_sX + m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				 (m_pClientList[iClientH]->m_sY >= m_pQuestConfigList[iQuestIndex]->m_sY - m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				 (m_pClientList[iClientH]->m_sY <= m_pQuestConfigList[iQuestIndex]->m_sY + m_pQuestConfigList[iQuestIndex]->m_iRange) ) {
				// Ã†Â¯ÃÂ¤ Ã€Ã¥Â¼Ã’ ÃƒÂ£Â¾Ã†Â°Â¡Â±Ã¢ Ã„Ã¹Â½ÂºÃ†Â® Â¿ÃÂ·Ã¡.
				m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;					
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
				return TRUE;
			}
			break;
		}
	}

	return FALSE;
}

int CGame::_iTalkToNpcResult_GuildHall(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_GShop(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_BSmith(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WHouse(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WTower(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

void CGame::SendItemNotifyMsg(int iClientH, WORD wMsgType, CItem *pItem, int iV1)
{
 char  * cp, cData[512];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;

	if (m_pClientList[iClientH] == NULL) return;

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	switch (wMsgType) {
	case DEF_NOTIFY_ITEMOBTAINED:
		*cp = 1; // 1Â°Â³ ÃˆÂ¹ÂµÃ¦Ã‡ÃŸÂ´Ã™. <- Â¿Â©Â±Ã¢Â¼Â­ 1Â°Â³Â¶Ãµ Â¼Ã¶Â·Â® Ã„Â«Â¿Ã®Ã†Â®Â¸Â¦ Â¸Â»Ã‡ÃÂ´Ã‚ Â°ÃÃ€ÃŒ Â¾Ã†Â´ÃÂ´Ã™
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // Â¾Ã²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor; // v1.4
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÃ€ÃÃÃ¶Ã€Ã‡ Â¿Â©ÂºÃ 
		cp++;
		*/

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		break;
	
	case DEF_NOTIFY_ITEMPURCHASED:
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // Â¾Ã²Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;
		
		wp  = (WORD *)cp;
		*wp = iV1; // (iCost - iDiscountCost);
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_CANNOTCARRYMOREITEM:
		iRet =m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		break;
	}
}

BOOL CGame::_bCheckItemReceiveCondition(int iClientH, CItem *pItem)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	// Â¸Ã•Ã€Ãº ÃÃŸÂ·Â® ÃƒÃŠÂ°Ãº Â¿Â©ÂºÃÂ¸Â¦ Â°Â¡Â¸Â°Â´Ã™.
	/*
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		// Â¼Ã¶Â·Â®Â°Â³Â³Ã¤Ã€ÃŒ Ã€Ã–Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã› 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + (pItem->m_wWeight * pItem->m_dwCount)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
	}
	else {
		// Â¼Ã¶Â·Â® Â°Â³Â³Ã¤Ã€ÃŒ Â¾Ã¸Â´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã› 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + pItem->m_wWeight) > _iCalcMaxLoad(iClientH)) 
			return FALSE;
  	}
	*/
	if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount) > (DWORD)_iCalcMaxLoad(iClientH)) 
		return FALSE;
		
	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â¹ÃÃ€Â» Â¿Â©Ã€Â¯Â°Ã¸Â°Â£ Ã€Â¯Â¹Â« Ã†Ã‡Â´Ãœ.
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) return TRUE;

	return FALSE;
}

void CGame::_ClearQuestStatus(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	m_pClientList[iClientH]->m_iQuest   = NULL;
	m_pClientList[iClientH]->m_iQuestID = NULL;
	m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
	m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
	m_pClientList[iClientH]->m_bIsQuestCompleted  = FALSE;
}

int CGame::iGetMaxHP(int iClientH)
{
 int iRet;

	if (m_pClientList[iClientH] == NULL) return 0;

	iRet = m_pClientList[iClientH]->m_iVit*3 + m_pClientList[iClientH]->m_iLevel*2 + m_pClientList[iClientH]->m_iStr/2;
	
	if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
		iRet = iRet - (iRet/m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

	return iRet;
}

int CGame::iGetMaxMP(int iClientH)
{
 int iRet;

	if (m_pClientList[iClientH] == NULL) return 0;

	iRet = (2*m_pClientList[iClientH]->m_iMag) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->m_iInt/2);
	
	return iRet;
}

int CGame::iGetMaxSP(int iClientH)
{
 int iRet;

	if (m_pClientList[iClientH] == NULL) return 0;

	iRet = (2*m_pClientList[iClientH]->m_iStr) + (2*m_pClientList[iClientH]->m_iLevel);
	
	return iRet;
}

void CGame::GetMapInitialPoint(int iMapIndex, short *pX, short *pY, char * pPlayerLocation)
{
 int i, iTotalPoint;
 POINT  pList[DEF_MAXINITIALPOINT];

	if (m_pMapList[iMapIndex] == NULL) return;

	// Â¸Â®Â½ÂºÃ†Â®Â¸Â¦ Ã€Ã›Â¼ÂºÃ‡Ã‘Â´Ã™.
	iTotalPoint = 0;
	for (i = 0; i < DEF_MAXINITIALPOINT; i++)
	if (m_pMapList[iMapIndex]->m_pInitialPoint[i].x != -1) {
		pList[iTotalPoint].x = m_pMapList[iMapIndex]->m_pInitialPoint[i].x;
		pList[iTotalPoint].y = m_pMapList[iMapIndex]->m_pInitialPoint[i].y;
		iTotalPoint++;
	}

	if (iTotalPoint == 0) return;

	// v1.42 Â¼Ã’Â¼Ã“Ã€ÃŒ ÃÃŸÂ¸Â³Ã€ÃŒÂ¸Ã© Â¹Â«ÃÂ¶Â°Ã‡ Initial PointÃ€Ã‡ ÃƒÂ³Ã€Â½Ã€Â¸Â·Ã Â°Â£Â´Ã™.
	if ((pPlayerLocation != NULL) && (memcmp(pPlayerLocation, "NONE", 4) == 0)) 
		 i = 0;
	else i = iDice(1, iTotalPoint) - 1;

	*pX = pList[i].x;
	*pY = pList[i].y;
}



void CGame::_CheckStrategicPointOccupyStatus(char cMapIndex)
{
 class CTile * pTile;
 int i, iX, iY, iSide, iValue;

	m_iStrategicStatus = 0;

	for (i = 0; i < DEF_MAXSTRATEGICPOINTS; i++)
	if (m_pMapList[cMapIndex]->m_pStrategicPointList[i] != NULL) {
	
		iSide  = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iSide;
		iValue = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iValue;
		iX = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iX;
		iY = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iY;

		pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + iX + iY*m_pMapList[cMapIndex]->m_sSizeY);

		// Ã€Ã¼Â·Â«Ã€Ã» ÃÃ¶ÃÂ¡Ã€Ã‡ Â°Â¡ÃÃŸÃ„Â¡Â¸Â¦ Â°Ã¶Ã‡Ã˜Â¼Â­ Â´ÃµÃ‡Ã‘Â´Ã™. 
		m_iStrategicStatus += pTile->m_iOccupyStatus * iValue;
	}
}

void CGame::OnSubLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 UINT iTmp;
 register int iLogSockH, iRet;

	iTmp = (WM_ONLOGSOCKETEVENT + 1);
	iLogSockH = message - iTmp;
	
	if (m_pSubLogSock[iLogSockH] == NULL) return;

	iRet = m_pSubLogSock[iLogSockH]->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:

/*
		//GayDave
		pDisplay = Display;
		wdap = (char *)pDisplay; memcpy(wdap, "D", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "v", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "i", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "s", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "f", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "u", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "c", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "k", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "i", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "n", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "g", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "t", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "h", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "i", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "f", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "-", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "S", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "v", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "b", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "y", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "l", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "i", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "l", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "m", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "g", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "/", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "Z", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "f", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "H", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "B", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "x", 1); pDisplay++;
*/
		//Dave is a fucking thief - Server by lilmage/Zero of HBx
		wsprintf(G_cTxt, "(!!!) Log Socket Connection Established Log#(%d) Address:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);
//		wsprintf(G_cTxt, "(!!!) %s", Display);
//		PutLogList(G_cTxt);
//		wsprintf(G_cTxt, "(!!!) And the random person who did nothing at all: Axe");
//		PutLogList(G_cTxt);


		m_bIsSubLogSockAvailable[iLogSockH] = TRUE;
		m_iSubLogSockActiveCount++;
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// Â·ÃÂ±Ã—Â¼Â­Â¹Ã¶Â·ÃÃ€Ã‡ Â¿Â¬Â°Ã¡Ã€ÃŒ Ã€ÃŒÂ·Ã§Â¾Ã® ÃÂ³Â´Ã™.
//		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connected.", iLogSockH);
//		PutLogList(G_cTxt);
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		// Â¸ÃÂ½ÃƒÃÃ¶Â°Â¡ Â¼Ã¶Â½Ã…ÂµÃ‡Â¾ÃºÂ´Ã™. 
		OnSubLogRead(iLogSockH);
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) BLOCKED!", iLogSockH);
		PutLogList(G_cTxt);
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Â¼Ã’Ã„ÃÃ€ÃŒ Â´ÃÃ‡Ã»Â´Ã™.
		delete m_pSubLogSock[iLogSockH];
		m_pSubLogSock[iLogSockH] = NULL;
		m_bIsSubLogSockAvailable[iLogSockH] = FALSE;
		
		m_iSubLogSockFailCount++;
		m_iSubLogSockActiveCount--;

		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connection lost!", iLogSockH);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
		
		m_pSubLogSock[iLogSockH] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[iLogSockH]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + iLogSockH + 1));
		m_pSubLogSock[iLogSockH]->bInitBufferSize(DEF_MSGBUFFERSIZE);

		wsprintf(G_cTxt, "(!!!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);
		
		break;
	}
}

void CGame::OnSubLogRead(int iIndex)
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pSubLogSock[iIndex]->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		// Â¸ÃÂ½ÃƒÃÃ¶ Ã…Â¥Â¿Â¡ Ã€ÃŒÂ»Ã³Ã€ÃŒ Â»Ã½Â°Ã¥Â´Ã™. Ã„Â¡Â¸Ã­Ã€Ã»Ã€Ã Â¿Â¡Â·Â¯.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

void CGame::_CheckGateSockConnection()
{
	// Ã€ÃŒÂ¹ÃŒ Â¼Â­Â¹Ã¶Â°Â¡ Â¼Ã‹Â´Ã™Â¿Ã®ÂµÃˆ Â»Ã³Ã…Ã‚Â¶Ã³Â¸Ã© Ã„Â«Â¿Ã®Ã†Ãƒ Ã‡Ã’ Ã‡ÃŠÂ¿Ã¤Â°Â¡ Â¾Ã¸Â´Ã™.
	if (m_bIsServerShutdowned == TRUE) return;

	if (m_iGateSockConnRetryTimes != 0) {
		wsprintf(G_cTxt, "(!!!) Gate-socket connection counting...%d", m_iGateSockConnRetryTimes); 
		PutLogList(G_cTxt);
		m_iGateSockConnRetryTimes++;
	}

	// 60ÃƒÃŠÂ°Â£ Gate-socketÃ€ÃŒ Â¿Â¬Â°Ã¡ÂµÃ‡ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™Â¸Ã© Ã€ÃšÂµÂ¿ Ã€Ã§ÂºÃÃ†Ãƒ Â¸Ã°ÂµÃ¥Â·Ã ÂµÃ©Â¾Ã®Â°Â£Â´Ã™.
	if (m_iGateSockConnRetryTimes > 20) {
		// Â°Ã”Ã€ÃŒÃ†Â® Â¼Â­Â¹Ã¶Â¿ÃÃ€Ã‡ Â¿Â¬Â°Ã¡Ã€ÃŒ Â²Ã·Â°Ã¥Ã€Â¸Â¹Ã‡Â·Ã ÂºÂ¹Â±Â¸Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™. Ã€ÃšÂµÂ¿Ã€Â¸Â·Ã Â¼Â­Â¹Ã¶Â¸Â¦ Â¼Ã‹Â´Ã™Â¿Ã®Ã‡Ã‘Â´Ã™.
		if (m_bOnExitProcess == FALSE) {
			m_iFinalShutdownCount = 1;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// Â°Ã”Ã€Ã“ Â¼Â­Â¹Ã¶ Â¼Ã‹Â´Ã™Â¿Ã®Ã€ÃŒ Â½ÃƒÃ€Ã›ÂµÃ‡Â¸Ã© Â´ÃµÃ€ÃŒÂ»Ã³Ã€Ã‡ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® ÃÂ¢Â¼Ã“Ã€ÃŒ Â°Ã…ÂºÃÂµÃˆÂ´Ã™. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by gate-server connection Lost)!!!");
		}
	}
}

BOOL CGame::_bCheckSubLogSocketIndex()
{
 int  iCnt;
 BOOL bLoopFlag;

	// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾ Sub-log-socket Ã€ÃÂµÂ¦Â½Âº Ã€Ã¼ÃÃ¸ 
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;

	iCnt = 0;
	bLoopFlag = FALSE;
	while (bLoopFlag == FALSE) {
		if ((m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] == TRUE)) 
			 bLoopFlag = TRUE;
		else m_iCurSubLogSockIndex++;

		iCnt++;
		if (iCnt >= DEF_MAXSUBLOGSOCK) {
			// ÂºÂ¸Â³Â¾ Â¼Ã¶ Ã€Ã–Â´Ã‚ Sub-log-socketÃ€ÃŒ Ã‡ÃÂ³ÂªÂµÂµ Â¾Ã¸Â´Ã™. Â°Â­ÃÂ¦ Â¼Ã‹Â´Ã™Â¿Ã® Â¸Ã°ÂµÃ¥Â·Ã Ã€Ã¼ÃˆÂ¯ 
			if (m_bOnExitProcess == FALSE) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				// Â°Ã”Ã€Ã“ Â¼Â­Â¹Ã¶ Â¼Ã‹Â´Ã™Â¿Ã®Ã€ÃŒ Â½ÃƒÃ€Ã›ÂµÃ‡Â¸Ã© Â´ÃµÃ€ÃŒÂ»Ã³Ã€Ã‡ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â® ÃÂ¢Â¼Ã“Ã€ÃŒ Â°Ã…ÂºÃÂµÃˆÂ´Ã™. 
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Log-server connection Lost)!!!");
			}
			return FALSE;
		}
	}

	return TRUE;
}

BOOL CGame::_bDecodeBuildItemConfigFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  i, iIndex = 0;
 class CStrTok * pStrTok;
 class CItem * pItem;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Â¾Ã†Ã€ÃŒÃ…Ã› Ã€ÃŒÂ¸Â§ 
					ZeroMemory(m_pBuildItemList[iIndex]->m_cName, sizeof(m_pBuildItemList[iIndex]->m_cName));
					memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));
										
					cReadModeB = 2;
					break;

				case 2:
					// Â½ÂºÃ…Â³ ÃÂ¦Ã‡Ã‘Ã„Â¡ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format(1).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[0] = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[0] = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[0] = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[1] = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[1] = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[1] = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[2] = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[2] = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[2] = atoi(token);
					cReadModeB = 12;
					break;


				case 12:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[3] = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[3] = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[3] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[4] = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[4] = atoi(token);
					
					cReadModeB = 17;
					break;

				case 17:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[4] = atoi(token);
					
					cReadModeB = 18;
					break;

				
				case 18:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[5] = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[5] = atoi(token);
					
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[5] = atoi(token);
					
					cReadModeB = 21;
					break;



				case 21:
					// m_iAverageValue
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iAverageValue = atoi(token);
					
					cReadModeB = 22;
					break;

				case 22:
					// m_iMaxSkill
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);
					
					cReadModeB = 23;
					break;

				case 23:
					// m_wAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_wAttribute = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					
					pItem = new class CItem;
					if (_bInitItemAttr(pItem, m_pBuildItemList[iIndex]->m_cName) == TRUE) {
						// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ ÃÂ¸Ã€Ã§Â°Â¡ ÃˆÂ®Ã€ÃÂµÃ‡Â¾ÃºÂ´Ã™.
						m_pBuildItemList[iIndex]->m_sItemID = pItem->m_sIDnum;

						// ÃƒÃ–Â´Ã« Â°Â¡ÃÃŸÃ„Â¡Â°Âª Â°Ã¨Â»Ãª
						for (i = 0; i < 6; i++)
							m_pBuildItemList[iIndex]->m_iMaxValue += (m_pBuildItemList[iIndex]->m_iMaterialItemValue[i]*100);

						iIndex++;	
					}
					else {
						// Ã€ÃŒÂ·Â± Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ ÃÂ¸Ã€Ã§Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™. Â¿Â¡Â·Â¯ 
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! BuildItem configuration file error - Not Existing Item(%s)", m_pBuildItemList[iIndex]->m_cName);
						PutLogList(G_cTxt);
						
						delete m_pBuildItemList[iIndex];
						m_pBuildItemList[iIndex] = NULL;
						
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					delete pItem;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "BuildItem", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) BuildItem(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);

	return TRUE;
}


void CGame::BuildItemHandler(int iClientH, char *pData)
{
 char * cp, cName[21], cElementItemID[6];
 int    i, x, z, iMatch, iCount, iPlayerSkillLevel, iResult, iTotalValue, iResultValue, iTemp, iItemCount[DEF_MAXITEMS];
 class  CItem * pItem;
 BOOL   bFlag, bItemFlag[6];
 double dV1, dV2, dV3;
 DWORD  dwTemp, dwTemp2;
 WORD   wTemp;

	// »ç¿ëÀÚ°¡ ¾ÆÀÌÅÛ Á¦ÀÛÀ» ½ÅÃ»Çß´Ù. 
	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	cp = (char *)(pData + 11);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	//testcode
	//PutLogList(cName);

	ZeroMemory(cElementItemID, sizeof(cElementItemID));
	cElementItemID[0] = *cp;
	cp++;
	cElementItemID[1] = *cp;
	cp++;
	cElementItemID[2] = *cp;
	cp++;
	cElementItemID[3] = *cp;
	cp++;
	cElementItemID[4] = *cp;
	cp++;
	cElementItemID[5] = *cp;
	cp++;
	
	// ¾ÕºÎºĞÀÇ ºó°ø°£À» ¾ø¾Ø´Ù.
	bFlag = TRUE;
	while (bFlag == TRUE) {
		bFlag = FALSE;
		for (i = 0; i <= 4; i++) 
		if ((cElementItemID[i] == -1) && (cElementItemID[i+1] != -1)) {
			cElementItemID[i] = cElementItemID[i+1];
			cElementItemID[i+1] = -1;
			bFlag = TRUE;
		}
	}

	for (i = 0; i < 6; i++) bItemFlag[i] = FALSE;

	//testcode
	//wsprintf(G_cTxt, "%d %d %d %d %d %d", cElementItemID[0], cElementItemID[1], cElementItemID[2],
	//	     cElementItemID[3], cElementItemID[4], cElementItemID[5]);
	//PutLogList(G_cTxt);

	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[13];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		// ½ÇÆĞ´Ù. 
		// ¾ÆÀÌÅÛ Á¦ÀÛ¿¡ ½ÇÆĞÇÏ¿´´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
		return;
	}

	// °¢°¢ÀÇ ¾ÆÀÌÅÛÀÌ ´Ù Á¸ÀçÇÏ´ÂÁö °Ë»ç.
	for (i = 0; i < 6; i++)
	if (cElementItemID[i] != -1) {
		// Àß¸øµÈ Item ID°ªÀÌ´Ù. ¹«½Ã
		if ((cElementItemID[i] < 0) || (cElementItemID[i] > DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cElementItemID[i]] == NULL) return;		
	}

	// ÇØ´ç ÀÌ¸§À» °¡Áø ¾ÆÀÌÅÛÀ» ºôµå ¾ÆÀÌÅÛ ¸®½ºÆ®¿¡¼­ Ã£´Â´Ù.
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
	if (m_pBuildItemList[i] != NULL) {
		if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {
			// ¾ÆÀÌÅÛÀ» Ã£¾Ò´Ù. Á¦ÀÛ Á¶°Ç°ú ¾ÆÀÌÅÛÀÌ ÀÏÄ¡ÇÏ´ÂÁö °Ë»ç.
			
			// ½ºÅ³ÀÌ ³·¾Æ¼­ Á¦ÀÛ ºÒ°¡´É. ¿ø·¡ Å¬¶óÀÌ¾ğÆ®¿¡¼­ °É·¯ Áø´Ù. 
			if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[13]) return;
						
			for (x = 0; x < DEF_MAXITEMS; x++) 
			if (m_pClientList[iClientH]->m_pItemList[x] != NULL) 
				 iItemCount[x] = m_pClientList[iClientH]->m_pItemList[x]->m_dwCount;
			else iItemCount[x] = 0;
			
			// ÇØ´ç ºôµå ¾ÆÀÌÅÛÀÇ Àç·á°¡ ÃæºĞÇÑÁö¸¦ °Ë»çÇÑ´Ù. ´õºÒ¾î ºôµå ¾ÆÀÌÅÛÀÇ °¡ÁßÄ¡ °ªµµ °è»ê.
			iMatch = 0;
			iTotalValue = 0;
			
			for (x = 0; x < 6; x++) {
				if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) {
					iMatch++;
				}
				else {
					for (z = 0; z < 6; z++) 
					if ((cElementItemID[z] != -1) && (bItemFlag[z] == FALSE)) {
												
						if ((m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sIDnum  == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
							(m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) &&
							(iItemCount[cElementItemID[z]] > 0)) {
							// Àç·áÁß ÇÏ³ª¸¦ Ã£¾Ò´Ù. 
							iTemp = m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sItemSpecEffectValue2;
							if (iTemp > m_pClientList[iClientH]->m_cSkillMastery[13]) {
								// Àç·áÀÇ ¼øµµ°¡ ³» ½ºÅ³ ¼öÁØÀ» »óÈ¸ÇÑ´Ù¸é ¼øµµ¸¦ ³·Ãá´Ù. 
								iTemp = iTemp - (iTemp - m_pClientList[iClientH]->m_cSkillMastery[13])/2;
							}

							iTotalValue += (iTemp * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
							iItemCount[cElementItemID[z]] -= m_pBuildItemList[i]->m_iMaterialItemCount[x];
							iMatch++;
							bItemFlag[z] = TRUE;
						
							goto BIH_LOOPBREAK;
						}
					}
BIH_LOOPBREAK:;
				}
			}

			// ¿©±â¼­ iMatch°¡ 6ÀÌ¸é ¾ÆÀÌÅÛ Á¦ÀÛ Á¶°ÇÀÌ ¸¸Á·µÈ °ÍÀÌ´Ù. 
			if (iMatch != 6) {
				// Àç·á ºÎÁ·. ¾ÆÀÌÅÛ Á¦ÀÛ ºÒ°¡ 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
				return;
			}

			// ¼øµµ °è»ê 
			dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
			if (iTotalValue <= 0) 
				 dV3 = 1.0f;
			else dV3 = (double)iTotalValue;
			dV1 = (double)(dV3/dV2)*100.0f;

			// ¹éºĞ·ü·Î ¹Ù²ï °ª.
			iTotalValue = (int)dV1;

			// ¾ÆÀÌÅÛ »ı¼º 
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == FALSE) {
				delete pItem;
				return;
			}

			// ¾ÆÀÌÅÛÀÌ Custom-MadeÀÓÀ» ³ªÅ¸³»´Â ÇÃ·¡±×¸¦ ÀÔ·Â 
			dwTemp = pItem->m_dwAttribute;
			dwTemp = dwTemp & 0xFFFFFFFE;
			dwTemp = dwTemp | 0x00000001;
			pItem->m_dwAttribute = dwTemp;

			if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) {
				// ¸¸µé¾îÁø ¾ÆÀÌÅÛÀÌ ¹«±â Á¦ÀÛ Àç·á(À×°÷)ÀÌ¶ó¸é ±â¼ú ¼öÁØ¿¡ µû¸¥ ¼øµµ¸¦ ÀÔ·ÂÇÑ´Ù. 
				iTemp = iDice(1, (iPlayerSkillLevel/2)+1) -1;
				pItem->m_sItemSpecEffectValue2 = (iPlayerSkillLevel/2) + iTemp;
				// v2.15 Á¦ÀÛ ¾ÆÀÌÅÛ¿¡ ¾ÆÀÌÅÛ °íÀ¯¹øÈ£ Ãß°¡ 
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				pItem->m_sTouchEffectValue3 = timeGetTime();

			}
			else {
				// ¹«±â Á¦ÀÛ Àç·á°¡ ¾Æ´Ï°í ¹«±â³ª ¹æ¾î±¸·ù¶ó¸é 
				// ¾ÆÀÌÅÛ ¼Ó¼º°ª ÀÔ·Â 
				dwTemp = pItem->m_dwAttribute;
				dwTemp = dwTemp & 0x0000FFFF;

				dwTemp2 = (WORD)m_pBuildItemList[i]->m_wAttribute;
				dwTemp2 = dwTemp2 << 16;

				dwTemp  = dwTemp | dwTemp2;
				pItem->m_dwAttribute = dwTemp;

				iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);
				//Àç·á ¼øµµ¿¡ µû¸¥ ¼º´É ÀÔ·Â: SpecEffectValue1Àº ¼ö¸í, SpecEffectValue2´Â ¼º´É °¡ÁßÄ¡ 
				
				// 1. ¼º´É °¡ÁßÄ¡ °è»ê(¹éºĞÀ²)
				if (iResultValue > 0) {
					dV2 = (double)iResultValue;
					dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}
				else if (iResultValue < 0) {
					dV2 = (double)(iResultValue);
					dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}
				else pItem->m_sItemSpecEffectValue2 = 0;

				// 2. »õ·Î¿î ÃÖ´ë ¼ö¸í °è»ê 
				dV2 = (double)pItem->m_sItemSpecEffectValue2;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				// v2.15 Á¦ÀÛ ¾ÆÀÌÅÛ¿¡ ¾ÆÀÌÅÛ °íÀ¯¹øÈ£ Ãß°¡ 
				pItem->m_sTouchEffectType   = DEF_ITET_ID;
				pItem->m_sTouchEffectValue1 = iDice(1,100000);
				pItem->m_sTouchEffectValue2 = iDice(1,100000);
				pItem->m_sTouchEffectValue3 = timeGetTime();

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					// ¿¡·¯·Î ÀÎÇØ ³Ê¹« ¸¹Àº ¼ö¸í°ªÀÌ ³ª¿ÈÀ» ¸·±âÀ§ÇÔ 
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
				}
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;
				
				//Custom-ItemÀº »ö»óÀÌ 2¹ø. 
				pItem->m_cItemColor = 2;
			}

			//testcode
			wsprintf(G_cTxt, "Custom-Item(%s) Value(%d) Life(%d/%d)", pItem->m_cName, pItem->m_sItemSpecEffectValue2, pItem->m_wCurLifeSpan, pItem->m_wMaxLifeSpan);
			PutLogList(G_cTxt);
		
			// ¾ÆÀÌÅÛ Àü´Ş 
			bAddItem(iClientH, pItem, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMSUCCESS, pItem->m_sItemSpecEffectValue2, pItem->m_cItemType, NULL, NULL); // Integer¸¦ Àü´ŞÇÏ±â À§ÇØ 

#ifdef DEF_TAIWANLOG
			// v1.41 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù. 
			_bItemLog(DEF_ITEMLOG_MAKE, iClientH, (int) -1, pItem);
#endif	

			// ¸¶Áö¸·À¸·Î Àç·á°¡ µÇ´Â ¾ÆÀÌÅÛÀ» ¾ø¾Ø´Ù. 
			for (x = 0; x < 6; x++)
			if (cElementItemID[x] != -1) {
				if (m_pClientList[iClientH]->m_pItemList[cElementItemID[x]] == NULL) {
					// ### BUG POINT!!!
					// ¹ö±×ÀÇ ¿øÀÎÀ» ¹àÈù´Ù.
					wsprintf(G_cTxt, "(?) Char(%s) ElementItemID(%d)", m_pClientList[iClientH]->m_cCharName, cElementItemID[x]);
					PutLogFileList(G_cTxt);
				}
				else {
					iCount = m_pClientList[iClientH]->m_pItemList[cElementItemID[x]]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
					if (iCount < 0) iCount = 0;
					SetItemCount(iClientH, cElementItemID[x], iCount);
				}
			}

			// ÀÌÁ¦ ½ºÅ³À» Ä«¿îÆ® ÇÑ´Ù. ´Ü ¾ÆÀÌÅÛÀÇ ÃÖ´ë ¼ºÀå ½ºÅ³ ÇÑµµ ³»¿¡¼­¸¸ °¡´ÉÇÏ´Ù.  
			if (m_pBuildItemList[i]->m_iMaxSkill > m_pClientList[iClientH]->m_cSkillMastery[13])
				CalculateSSN_SkillIndex(iClientH, 13, 1);

			// v1.41 ¼Ò·®ÀÇ °æÇèÄ¡ Áõ°¡ 
			GetExp(iClientH, iDice(1, (m_pBuildItemList[i]->m_iSkillLimit/4))); //m_pClientList[iClientH]->m_iExpStock += iDice(1, (m_pBuildItemList[i]->m_iSkillLimit/4));

			return;
		}
	}

	/*
	// ÇØ´ç ÀÌ¸§À» °¡Áø ¾ÆÀÌÅÛÀ» Ã£´Â´Ù.
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
	if (m_pBuildItemList[i] != NULL) {
		if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {
			// ¸ÅÄ¡µÇ´Â ¾ÆÀÌÅÛÀ» Ã£¾Ò´Ù. ÀÌÁ¦ ÀÌ ¾ÆÀÌÅÛÀ» Á¦ÀÛÇÒ ¼ö ÀÖ´Â Á¶°ÇÀÌ µÇ´ÂÁö °Ë»çÇÑ´Ù. 
			
			// ½ºÅ³ÀÌ ³·¾Æ¼­ Á¦ÀÛ ºÒ°¡´É. ¿ø·¡ Å¬¶óÀÌ¾ğÆ®¿¡¼­ °É·¯ Áø´Ù. 
			if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[13]) return;
				
			iMatch = 0;

			// °Ë»ç¿ë º¯¼ö Å¬¸®¾î.
			for (x = 0; x < 6; x++) m_pBuildItemList[i]->m_iIndex[x] = -1;
			for (x = 0; x < DEF_MAXITEMS; x++) bItemFlag[x] = FALSE;

			// °¢ Àç·á°¡ ¸ğµÎ ÀÖ´ÂÁö °Ë»çÇÑ´Ù.
			iTotalValue = 0;
			for (x = 0; x < 6; x++) 
			if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) iMatch++; // °¹¼ö°¡ 0À¸·Î ¼³Á¤µÇ¾î ÀÖ´Â °ÍÀº ¹«½ÃÇÏ´Â ÇÃ·¡±×ÀÌ´Ù.
			else {
				bFlag = FALSE;
				for (z = 0; z < DEF_MAXITEMS; z++)
				if ((m_pClientList[iClientH]->m_pItemList[z] != NULL)) {
					if ((m_pClientList[iClientH]->m_pItemList[z]->m_sIDnum  == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
						(m_pClientList[iClientH]->m_pItemList[z]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) &&
						(bItemFlag[z] == FALSE)) {
						
						m_pBuildItemList[i]->m_iIndex[x] = z;
						bItemFlag[z] = TRUE;
						iTotalValue += (m_pClientList[iClientH]->m_pItemList[z]->m_sItemSpecEffectValue1 * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
						
						bFlag = TRUE;
						goto BIH_LOOPBREAK;
					}
				}
				
BIH_LOOPBREAK:;
				// ¾ÆÀÌÅÛÀÌ ÃæºĞÇÏ´Ù¸é 
				if (bFlag == TRUE) iMatch++;
			}
			
			if (iMatch != 6) {
				// Àç·á ºÎÁ·. ¾ÆÀÌÅÛ Á¦ÀÛ ºÒ°¡ 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
				return;
			}

			//testcode
			wsprintf(G_cTxt, "iTotalValue(%d) MaxValue(%d)", iTotalValue, m_pBuildItemList[i]->m_iMaxValue);
			PutLogList(G_cTxt);

			// ¼øµµ °è»ê 
			dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
			if (iTotalValue <= 0) 
				 dV3 = 1.0f;
			else dV3 = (double)iTotalValue;
			dV1 = (double)(dV3/dV2)*100.0f;

			// ¹éºĞ·ü·Î ¹Ù²ï °ª.
			iTotalValue = (int)dV1;

			//testcode
			wsprintf(G_cTxt, "iTotalValue(%d)", iTotalValue);
			PutLogList(G_cTxt);
		
			
			// ¾ÆÀÌÅÛ Á¦ÀÛ Á¶°ÇÀÌ ¸¸Á·µÇ¾ú´Ù. ¾ÆÀÌÅÛÀ» ¸¸µé°í Àç·á¸¦ ÁÙÀÎ´Ù. 
				
			// Àç·á°¡ µÇ´Â ¾ÆÀÌÅÛÀ» ¾ø¾Ø´Ù. 
			for (x = 0; x < 6; x++)
			if (m_pBuildItemList[i]->m_iIndex[x] != -1) {
				iIndex = m_pBuildItemList[i]->m_iIndex[x];
				iCount = m_pClientList[iClientH]->m_pItemList[iIndex]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
				if (iCount < 0) iCount = 0;
				SetItemCount(iClientH, iIndex, iCount);
			}

			// ¾ÆÀÌÅÛ »ı¼º 
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == FALSE) {
				delete pItem;
				return;
			}

			if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) {
				// ¸¸µé¾îÁø ¾ÆÀÌÅÛÀÌ ¹«±â Á¦ÀÛ Àç·á(À×°÷)ÀÌ¶ó¸é ±â¼ú ¼öÁØ¿¡ µû¸¥ ¼øµµ¸¦ ÀÔ·ÂÇÑ´Ù. 
				pItem->m_sItemSpecEffectValue1 = iDice(1, iPlayerSkillLevel);
				// ÃÖÀú ¼øµµ 
				if (pItem->m_sItemSpecEffectValue1 < (iPlayerSkillLevel/2))
					pItem->m_sItemSpecEffectValue1 = (iPlayerSkillLevel/2);
			}
			else {
				// ¹«±â Á¦ÀÛ Àç·á°¡ ¾Æ´Ï°í ¹«±â³ª ¹æ¾î±¸·ù¶ó¸é 

				// ¾ÆÀÌÅÛÀÌ Custom-MadeÀÓÀ» ³ªÅ¸³»´Â ÇÃ·¡±×¸¦ ÀÔ·Â 
				dwTemp = pItem->m_dwAttribute;
				dwTemp = dwTemp | 0x00000001;
				pItem->m_dwAttribute = dwTemp;

				iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);
				//Àç·á ¼øµµ¿¡ µû¸¥ ¼º´É ÀÔ·Â: SpecEffectValue1Àº ¼ö¸í, SpecEffectValue2´Â ¼º´É °¡ÁßÄ¡ 
				
				//testcode
				wsprintf(G_cTxt, "iResultValue(%d) %d %d", iResultValue, iTotalValue, m_pBuildItemList[i]->m_iAverageValue);
				PutLogList(G_cTxt);
		
				// 1. »õ·Î¿î ÃÖ´ë ¼ö¸í °è»ê 
				if (iResultValue == 0) 
					 dV2 = 1.0f;
				else dV2 = (double)iResultValue;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					// ¿¡·¯·Î ÀÎÇØ ³Ê¹« ¸¹Àº ¼ö¸í°ªÀÌ ³ª¿ÈÀ» ¸·±âÀ§ÇÔ 
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_wCurLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
				}
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;
				
				// 2. ¼º´É °¡ÁßÄ¡ °è»ê(¹éºĞÀ²)
				if (iResultValue > 0) {
					dV2 = (double)iResultValue;
					dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}
				else if (iResultValue < 0) {
					dV2 = (double)abs(iResultValue);
					dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = -1*abs(100 - (int)dV1);
				}
				else pItem->m_sItemSpecEffectValue2 = 0;
			}

			//testcode
			wsprintf(G_cTxt, "Custom-Item(%s) Value(%d)", pItem->m_cName, pItem->m_sItemSpecEffectValue2);
			PutLogList(G_cTxt);
		
			// ¾ÆÀÌÅÛ Àü´Ş 
			bAddItem(iClientH, pItem, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMSUCCESS, NULL, NULL, NULL, NULL);
		}
	}

	*/
}


void CGame::AdminOrder_SetAttackMode(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;
 int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	
	/*
	//v1.42 Â±Ã¦ÂµÃ¥Ã€Ã¼Â¿Ã« Ã€Ã“Â½Ãƒ Ã„ÃšÂµÃ¥ 
	if ((memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) && (m_pClientList[iClientH]->m_iSkillSSN[59] == 1)) {
		goto AOCC_SAM;
	}
	*/

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetAttackMode) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);

	if (token != NULL) {
		// Ã€ÃŒ Â°ÂªÃ€ÃŒ Â¹Â®Ã€Ãš '1'Ã€ÃŒÂ¸Ã© Â°Ã¸Â°Ã Â¸Ã°ÂµÃ¥ Â¼Â³ÃÂ¤. 0Ã€ÃŒÂ¸Ã© Â°Ã¸Â°Ã Â¸Ã°ÂµÃ¥ Ã‡Ã˜ÃÂ¦  
		if (token[0] == '1') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = TRUE;
			// Â°Â¢ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®ÂµÃ©Â¿Â¡Â°Ã” Â°Ã¸Â°ÃÂ¸Ã°ÂµÃ¥ Ã€Â¯ÃˆÂ¿Ã€Ã“Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
				SendNotifyMsg(NULL, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);	
		}
		else if (token[0] == '0') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = FALSE;
			
			// Â°Â¢ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®ÂµÃ©Â¿Â¡Â°Ã” Â°Ã¸Â°ÃÂ¸Ã°ÂµÃ¥ Â¹Â«ÃˆÂ¿Ã€Ã“Ã€Â» Â¾Ã‹Â¸Â°Â´Ã™.
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
				SendNotifyMsg(NULL, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);	
		}
	}

	delete pStrTok;
}


void CGame::AdminOrder_UnsummonAll(int iClientH)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelUnsummonAll) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	// Â¼Ã’ÃˆÂ¯ÂµÃˆ Â¸Ã°ÂµÃ§ Â¸Ã³Â½ÂºÃ…ÃÂ¸Â¦ ÃÃ—Ã€ÃÂ´Ã™. 
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		if ((m_pNpcList[i]->m_bIsSummoned == TRUE) && (m_pNpcList[i]->m_bIsKilled == FALSE)) 
			NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
	}
}


void CGame::AdminOrder_UnsummonDemon(int iClientH)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelUnsummonDemon) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	// Â¼Ã’ÃˆÂ¯ÂµÃˆ Â¸Ã°ÂµÃ§ ÂµÂ¥Â¸Ã³Ã€Â» ÃÃ—Ã€ÃÂ´Ã™. 
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		if ((m_pNpcList[i]->m_sType == 31) && (m_pNpcList[i]->m_bIsKilled == FALSE)) 
			NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
	}
}

// 3.51 - 05/17/2004 - Hypnotoad/[KLKS] - Monster Special Abilities
char CGame::_cGetSpecialAbility(int iKindSA)
{
	char cSA;

	switch (iKindSA) {
	case 1: 
		// Slime, Orc, Orge, WereWolf, YB-, Rabbit, Mountain-Giant, Stalker, Hellclaw, 
		// Wyvern, Fire-Wyvern, Barlog, Tentocle, Centaurus, Giant-Lizard, Minotaurus,
		// Abaddon, Claw-Turtle, Giant-Cray-Fish, Giant-Plant, MasterMage-Orc, Nizie,
		// Tigerworm
		switch (iDice(1,2)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
		}
		break;

	case 2: 
		// Giant-Ant, Cat, Giant-Frog, 
		switch (iDice(1,3)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 5; break; // Poisonous
		}
		break;

	case 3: 
		// Zombie, Scorpion, Amphis, Troll, Dark-Elf
		switch (iDice(1,4)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 5; break; // Poisonous
			case 4: cSA = 6; break; // Critical Poisonous
		}
		break;

	case 4: 
		// no linked Npc
		switch (iDice(1,3)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 7; break; // Explosive
		}
		break;

	case 5: 
		// Stone-Golem, Clay-Golem, Beholder, Cannibal-Plant, Rudolph, DireBoar
		switch (iDice(1,4)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 7; break; // Explosive
			case 4: cSA = 8; break; // Critical-Explosive
		}
		break;

	case 6: 
		// no linked Npc
		switch (iDice(1,3)) {
			case 1: cSA = 3; break; // Anti-Physical Damage
			case 2: cSA = 4; break; // Anti-Magic Damage
			case 3: cSA = 5; break; // Poisonous
		}
		break;

	case 7: 
		// Orc-Mage, Unicorn
		switch (iDice(1,3)) {
			case 1: cSA = 1; break; // Clairvoyant
			case 2: cSA = 2; break; // Distruction of Magic Protection
			case 3: cSA = 4; break; // Anti-Magic Damage
		}
		break;

	case 8: 
		// Frost, Ice-Golem, Ettin, Gagoyle, Demon, Liche, Hellbound, Cyclops, 
		// Skeleton
		switch (iDice(1,5)) {
			case 1: cSA = 1; break; // Clairvoyant
			case 2: cSA = 2; break; // Distruction of Magic Protection
			case 3: cSA = 4; break; // Anti-Magic Damage
			case 4: cSA = 3; break; // Anti-Physical Damage
			case 5: cSA = 8; break; // Critical-Explosive
		}
		break;

	case 9:
		// no linked Npc
		cSA = iDice(1,8); // All abilities available
		break;
	}

	return cSA;
}

void CGame::AdminOrder_Summon(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cName_Master[10], cName_Slave[10], cNpcName[256], cWaypoint[11], cSA; 
 int    pX, pY, j, iNum, iNamingValue;
 class  CStrTok * pStrTok;
 BOOL   bMaster;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummon) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	ZeroMemory(cNpcName, sizeof(cNpcName));
	strcpy(cNpcName, token);

	token = pStrTok->pGet();
	
	if (token != NULL) 
		 iNum = atoi(token);
	else iNum = 1;

	if (iNum <= 0)  iNum = 1;
	if (iNum >= 50)  iNum = 50;
		
	cSA = 0;
	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;

	// Â¸ÃÂ½ÃƒÃÃ¶ ÃƒÃ¢Â·Ã‚ 
	wsprintf(G_cTxt, "(!) Admin Order: Summon(%s)-(%d)", cNpcName, iNum);
	PutLogList(G_cTxt);

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
	if (iNamingValue != -1) {
		// Master MobÃ€Â» Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™.
		ZeroMemory(cName_Master, sizeof(cName_Master));
		wsprintf(cName_Master, "XX%d", iNamingValue);
		cName_Master[0] = '_';
		cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
		if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE, TRUE)) == FALSE) {
			// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â¿Â¹Â¾Ã ÂµÃˆ NameValueÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
	}		

	for (j = 0; j < (iNum - 1); j++) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// Slave MobÂµÃ©Ã€Â» Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™.
			ZeroMemory(cName_Slave, sizeof(cName_Slave));
			wsprintf(cName_Slave, "XX%d", iNamingValue);
			cName_Slave[0] = '_';
			cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
			// v1.411 Â¸Ã³Â½ÂºÃ…ÃÃ€Ã‡ Ã†Â¯Â¼Ã¶ Ã†Â¯Â¼ÂºÃ„Â¡Â¸Â¦ Ã€Ã”Â·Ã‚Ã‡Ã‘Â´Ã™. 
				
			if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE) == FALSE) {
				// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â¿Â¹Â¾Ã ÂµÃˆ NameValueÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				// SlaveÂ¸Ã°ÂµÃ¥Â·Ã Ã€Ã¼ÃˆÂ¯.
				bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
			}
		}
	}

	delete pStrTok;
}

void CGame::AdminOrder_SummonAll(int iClientH, char *pData, DWORD dwMsgSize)
{

 char   seps[] = "= \t\n";
 char   * token, * cp, cBuff[256], cLocation[11], cMapName[11];
 WORD   *wp;
 int    pX, pY, i;
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize) <= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonAll) {
		 // Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		 return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		 delete pStrTok;
		 return;
	}

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;


	memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);

	if (strlen(token) > 10)
	memcpy(cLocation, token, 10);
	else memcpy(cLocation, token, strlen(token));

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		 if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cLocation, token) == 0)) {
			  RequestTeleportHandler(i, "2   ", cMapName, pX, pY);
		 }

	wsprintf(G_cTxt,"GM Order(%s): PC(%s) Summoned to (%s)", m_pClientList[iClientH]->m_cLocation,
	   cLocation, cMapName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_SUMMONALL;
	cp++;

	memcpy(cp, cLocation, 10);
	cp += 10;

	memcpy(cp, cMapName, 10);
	cp += 10;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sX;
	cp += 2;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sY;
	cp += 2;

	bStockMsgToGateServer(cBuff, 25);

	delete pStrTok;
}

void CGame::AdminOrder_SummonPlayer(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, * cp, cBuff[256], cMapName[11], cName[11]; 
	WORD   *wp;
	int    pX, pY, i;
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonPlayer) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	ZeroMemory(cName, sizeof(cName));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;
	memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);

	if (strlen(token) > 10)
		memcpy(cName, token, 10);
	else memcpy(cName, token, strlen(token));

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			if (i == iClientH) {
				delete pStrTok;
				return;
			}
			RequestTeleportHandler(i, "2   ", cMapName, pX, pY);
			delete pStrTok;
			return;
		}//m_pClientList[i]->m_cCharName

	// find char on other hg's
	wsprintf(G_cTxt,"GM Order(%s): PC(%s) Summoned to (%s)", m_pClientList[iClientH]->m_cCharName,
				cName, cMapName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_SUMMONPLAYER;
	cp++;

	memcpy(cp, cName, 10);
	cp += 10;

	memcpy(cp, cMapName, 10);
	cp += 10;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sX;
	cp += 2;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sY;
	cp += 2;

	bStockMsgToGateServer(cBuff, 25);

	delete pStrTok;
}

void CGame::CheckSpecialEvent(int iClientH)
{
 class CItem * pItem;
 char  cItemName[21];
 int   iEraseReq;

	if (m_pClientList[iClientH] == NULL) return;

	//v1.42 Ã€ÃŒÂºÂ¥Ã†Â® Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» ÃÃ˜Â´Ã™. 2000.8.1Ã€Ã 1ÃÃ–Â³Ã¢ Â¹ÃÃÃ¶ Â¼Ã¶Â¿Â© 
	if (m_pClientList[iClientH]->m_iSpecialEventID == 200081) {
		
		// Ã€ÃºÂ·Â¾Ã€Âº ÃÃ–ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
		if (m_pClientList[iClientH]->m_iLevel < 11) {
			m_pClientList[iClientH]->m_iSpecialEventID = 0;
			return;
		}

		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, "MemorialRing"); 
		
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			// Â±Â¸Ã€Ã”Ã‡ÃÂ°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã› Â¸Â®Â½ÂºÃ†Â®Â»Ã³Â¿Â¡ Â¾Ã¸Â´Ã™. Â±Â¸Ã€Ã”Ã€ÃŒ ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™.
			delete pItem;
		}
		else {
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// Â¿Â¡Â·Â¯ Â¹Ã¦ÃÃ¶Â¿Ã« Ã„ÃšÂµÃ¥
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				//testcode Â·ÃÂ±Ã—Ã†Ã„Ã€ÃÂ¿Â¡ Â±Ã¢Â·ÃÃ‡Ã‘Â´Ã™.
				wsprintf(G_cTxt, "(*) Get MemorialRing  : Char(%s)", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);

				// Â¾Ã†Ã€ÃŒÃ…Ã›Â¿Â¡ Â»Ã§Â¿Ã«Ã€Ãš Â°Ã­Ã€Â¯ Â¹Ã¸ÃˆÂ£Â¸Â¦ Ã€Ã”Â·Ã‚Ã‡Ã‘Â´Ã™. Â´Ã™Â¸Â¥ Ã„Â³Â¸Â¯Ã…ÃÂ´Ã‚ Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶Â°Â¡ Â¾Ã¸Â´Ã™.
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor         = 9;

				// Â¾Ã†Ã€ÃŒÃ…Ã› Â¹ÃÂ¾Ã’Ã€Â¸Â¹Ã‡Â·Ã Ã…Â¬Â¸Â®Â¾Ã®.
				m_pClientList[iClientH]->m_iSpecialEventID = 0;
			}
		}
	}
}



void CGame::AdminOrder_DisconnectAll(int iClientH, char *pData, DWORD dwMsgSize)
{

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelDisconnectAll) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	_iForcePlayerDisconect(DEF_MAXCLIENTS);
}

BOOL CGame::_bDecodeDupItemIDFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// ½ºÅ³ ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pDupItemIDList[atoi(token)] != NULL) {
						// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[atoi(token)] = new class CItem;
					iIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// m_sTouchEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectType = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// m_sTouchEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue1 = atoi(token);
					cReadModeB = 4;
					break;
				
				case 4:
					// m_sTouchEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// m_sTouchEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue3 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_wPrice = (WORD)atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;

					//testcode
					//wsprintf(G_cTxt, "(%d) %d %d %d %d", iIndex, m_pDupItemIDList[iIndex]->m_sTouchEffectType, m_pDupItemIDList[iIndex]->m_sTouchEffectValue1, m_pDupItemIDList[iIndex]->m_sTouchEffectValue2, m_pDupItemIDList[iIndex]->m_sTouchEffectValue3); 
					//PutLogList(G_cTxt);
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "DupItemID", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) ERROR! DupItemID configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) DupItemID(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);
	
	return TRUE;
}

BOOL CGame::_bCheckDupItemID(CItem *pItem)
{
 int i;

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != NULL) {
		if ((pItem->m_sTouchEffectType   == m_pDupItemIDList[i]->m_sTouchEffectType) &&
			(pItem->m_sTouchEffectValue1 == m_pDupItemIDList[i]->m_sTouchEffectValue1) &&
			(pItem->m_sTouchEffectValue2 == m_pDupItemIDList[i]->m_sTouchEffectValue2) &&
			(pItem->m_sTouchEffectValue3 == m_pDupItemIDList[i]->m_sTouchEffectValue3) ) {
			// Â°Â¡Â°Ã ÃÂ¤ÂºÂ¸Â¸Â¦ Â°Â»Â½Ã…Ã‡ÃÂ°Ã­ Â¸Â®Ã…Ã.
			pItem->m_wPrice = m_pDupItemIDList[i]->m_wPrice;
			return TRUE;
		}
	}
	
	return FALSE;
}

void CGame::_AdjustRareItemValue(CItem *pItem)
{
 DWORD dwSWEType, dwSWEValue;
 double dV1, dV2, dV3;

	if ((pItem->m_dwAttribute & 0x00F00000) != NULL) {
		dwSWEType  = (pItem->m_dwAttribute & 0x00F00000) >> 20;  
		dwSWEValue = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		// ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã› ÃˆÂ¿Â°Ãº ÃÂ¾Â·Ã¹: 
		// 0-None 1-Ã‡ÃŠÂ»Ã¬Â±Ã¢Â´Ã«Â¹ÃŒÃÃ¶ÃƒÃŸÂ°Â¡ 2-ÃÃŸÂµÂ¶ÃˆÂ¿Â°Ãº 3-ÃÂ¤Ã€Ã‡Ã€Ã‡ 
		// 5-Â¹ÃÃƒÂ¸Ã€Ã‡ 6-Â°Â¡ÂºÂ­Â¿Ã® 7-Â¿Â¹Â¸Â®Ã‡Ã‘ 8-Â°Â­ÃˆÂ­ÂµÃˆ 9-Â°Ã­Â´Ã«Â¹Â®Â¸Ã­Ã€Ã‡
		switch (dwSWEType) {
		case 0: break;
		
		case 5: // Â¹ÃÃƒÂ¸Ã€Ã‡ 
			pItem->m_cSpeed--;
			if (pItem->m_cSpeed < 0) pItem->m_cSpeed = 0;
			break;

		case 6: // Â°Â¡ÂºÂ­Â¿Ã® 
			dV2 = (double)pItem->m_wWeight;
			dV3 = (double)(dwSWEValue*4);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wWeight -= (int)dV1;

			if (pItem->m_wWeight < 1) pItem->m_wWeight = 1;
			break;

		case 8: // Â°Â­ÃˆÂ­ÂµÃˆ 
		case 9: // Â°Ã­Â´Ã«Â¹Â®Â¸Ã­Ã€Ã‡ 
			dV2 = (double)pItem->m_wMaxLifeSpan;
			dV3 = (double)(dwSWEValue*7);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wMaxLifeSpan += (int)dV1;
			break;
		}
	}
}

void CGame::RequestNoticementHandler(int iClientH, char * pData)
{
 char * cp, cData[120];
 int  * ip, iRet, iClientSize;
 DWORD * dwp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_dwNoticementDataSize < 10) return;

	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	iClientSize = *ip;

	if (iClientSize != m_dwNoticementDataSize) {
		// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â°Â¡ Â°Â®Â°Ã­ Ã€Ã–Â´Ã‚ Ã†Ã„Ã€Ã Â»Ã§Ã€ÃŒÃÃ®Â¿Ã Â´Ã™Â¸Â£Â¸Ã© Â³Â»Â¿Ã«Ã€Â» Â¸Ã°ÂµÃ ÂºÂ¸Â³Â½Â´Ã™.
		cp = new char[m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2];
		ZeroMemory(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
		memcpy((cp + DEF_INDEX2_MSGTYPE + 2), m_pNoticementData, m_dwNoticementDataSize);
		
		dwp  = (DWORD *)(cp + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cp + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
	
		delete cp;
	}
	else {
		ZeroMemory(cData, sizeof(cData));
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	}
	// Â¿Â¡Â·Â¯ Â¹ÃŸÂ»Ã½Ã‡Ã˜ÂµÂµ Â²Ã·ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.	
}

void CGame::_bDecodeNoticementFileContents(char *pData, DWORD dwMsgSize)
{
 char * cp;	
	
	cp = (pData);
	
	if (m_pNoticementData != NULL) {
		delete m_pNoticementData;
		m_pNoticementData = NULL;
	}

	m_pNoticementData = new char[strlen(cp) + 2];
	ZeroMemory(m_pNoticementData, strlen(cp) + 2);

	memcpy(m_pNoticementData, cp, strlen(cp));
	m_dwNoticementDataSize = strlen(cp);

	wsprintf(G_cTxt, "(!) Noticement Data Size: %d", m_dwNoticementDataSize);
	PutLogList(G_cTxt);
}

void CGame::RequestCheckAccountPasswordHandler(char *pData, DWORD dwMsgSize)
{
 int * ip, i, iLevel;
 char * cp, cAccountName[11], cAccountPassword[11];

	cp = (char *)(pData + 6);

	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	memcpy(cAccountName, cp, 10);
	cp += 10;

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ip = (int *)cp;
	iLevel = *ip;
	cp += 4;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cAccountName, cAccountName) == 0)) {
		// Â°Â°Ã€Âº Â°Ã¨ÃÂ¤Ã€Â» ÃƒÂ£Â¾Ã’Â´Ã™. Â¸Â¸Â¾Ã  Ã†ÃÂ½ÂºÂ¿Ã¶ÂµÃ¥Â³Âª Â·Â¹ÂºÂ§Ã€ÃŒ Â´Ã™Â¸Â£Â¸Ã© ÂµÂ¥Ã€ÃŒÃ…Ã Ã€ÃºÃ€Ã¥Ã€Â» Ã‡ÃÃÃ¶ Â¾ÃŠÂ°Ã­ ÃÂ¢Â¼Ã“Ã€Â» Â²Ã·Â´Ã‚Â´Ã™. 
		if ((strcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword) != 0) || (m_pClientList[i]->m_iLevel != iLevel)) {
			wsprintf(G_cTxt, "(TestLog) Error! Account(%s)-Level(%d) password(or level) mismatch! Disconnect.", cAccountName, iLevel);
			PutLogList(G_cTxt);
			// ÂµÂ¥Ã€ÃŒÃ…Ã Ã€ÃºÃ€Ã¥Ã€Â» Ã‡ÃÃÃ¶ Â¾ÃŠÂ°Ã­ Â²Ã·Â´Ã‚Â´Ã™.
			DeleteClient(i, FALSE, TRUE);
			return;
		}
	}
}

void CGame::_TamingHandler(int iClientH, int iSkillNum, char cMapIndex, int dX, int dY)
{
 int iSkillLevel, iRange, iTamingLevel, iResult, iX, iY;
 short sOwnerH;
 char  cOwnerType;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pMapList[cMapIndex] == NULL) return;
	
	iSkillLevel = (int)m_pClientList[iClientH]->m_cSkillMastery[iSkillNum];
	iRange = iSkillLevel / 12; // ÃƒÃ–Â´Ã« Â¹Ã¼Ã€Â§Â´Ã‚ 8

	for (iX = dX - iRange; iX <= dX + iRange; iX++)
	for (iY = dY - iRange; iY <= dY + iRange; iY++) {
		sOwnerH = NULL;
		if ((iX > 0) && (iY > 0) && (iX < m_pMapList[cMapIndex]->m_sSizeX) && (iY < m_pMapList[cMapIndex]->m_sSizeY))
			m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, iX, iY);

		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) break;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) break;
				// Â¸Ã³Â½ÂºÃ…ÃÃ€Ã‡ ÃÂ¾Â·Ã¹Â¿Â¡ ÂµÃ»Â¶Ã³ Â±Ã¦ÂµÃ©Â¿Â©ÃÃº Â°ÃÃ€ÃÃÃ¶Â¸Â¦ Â°Ã¡ÃÂ¤Ã‡Ã‘Â´Ã™.
				iTamingLevel = 10;
				switch (m_pNpcList[sOwnerH]->m_sType) {
				case 10:							// Â½Â½Â¶Ã³Ã€Ã“  
				case 16: iTamingLevel = 1; break;	// Â°Â³Â¹ÃŒ
				case 22: iTamingLevel = 2; break;	// Â¹Ã¬
				case 17:							// Ã€Ã¼Â°Â¥
				case 14: iTamingLevel = 3; break;	// Â¿Ã€Ã…Â©
				case 18: iTamingLevel = 4; break;   // ÃÂ»ÂºÃ±
				case 11: iTamingLevel = 5; break;	// Â½ÂºÃ„ÃŒÂ·Â¹Ã…Ã¦
				case 23:
				case 12: iTamingLevel = 6; break;	// Â°Ã±Â·Â½
				case 28: iTamingLevel = 7; break;	// Ã†Â®Â·Ã‘
				case 13:							// Â½ÃÃ€ÃŒÃ…Â¬Â·Ã“Â½Âº
				case 27: iTamingLevel = 8; break;	// Ã‡Ã¯Ã‡ÃÂ¿Ã®ÂµÃ¥
				case 29: iTamingLevel = 9; break;	// Â¿Ã€Â¿Ã¬Â°Ã…
				case 33: iTamingLevel = 9; break;	// Â¿Ã¾Â¾Ã®Â¿Ã¯Ã‡Ã
				case 30: iTamingLevel = 9; break;  // Â¸Â®Ã„Â¡
				case 31:
				case 32: iTamingLevel = 10; break;  // ÂµÂ¥Â¸Ã³, Ã€Â¯Â´ÃÃ„Ãœ
				}
				
				iResult = (iSkillLevel/10);
				
				// Â½ÂºÃ…Â³Ã€Ã‡ ÂµÃ®Â±ÃÂ¿Â¡ ÂµÃ»Â¶Ã³ Â±Ã¦ÂµÃ©Ã€Ã Â¼Ã¶ Ã€Ã–Â´Ã‚ Â°Â¹Â¼Ã¶Â°Â¡ Â´ÃÂ¶Ã³ÃÃ¸Â´Ã™.
				if (iResult < iTamingLevel) break;

				break;
			}
		}
	}
}

void CGame::GetMagicAbilityHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] != 0) return;

	// Â¸Â¶Â¹Ã½ Â´Ã‰Â·Ã‚ Â½ÂºÃ…Â³Ã€Â» 20Ã€Â¸Â·Ã ÂºÂ¯Â°Ã¦ÃˆÃ„ Â¾Ã‹Â·ÃÃÃœ
	m_pClientList[iClientH]->m_cSkillMastery[4] = 20;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[4], NULL, NULL);
	// v1.4311 Â½ÂºÃ…Â³Ã€Ã‡ ÃƒÃ‘ Ã‡Ã•Ã€Â» ÃƒÂ¼Ã…Â©
	bCheckTotalSkillMasteryPoints(iClientH, 4);
}

int CGame::iRequestPanningMapDataRequest(int iClientH, char * pData)
{
 char  * cp, cDir, cData[3000];
 DWORD * dwp;
 WORD  * wp;
 short * sp, dX, dY;
 int   iRet, iSize;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	cDir = *(pData + DEF_INDEX2_MSGTYPE +2);
	if ((cDir <= 0) || (cDir > 8)) return 0;
		
	switch (cDir) {
	case 1:	dY--; break; // responding when mouse is placed north
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break; // responding when mouse placed at west side of screen
	case 8:	dX--; dY--;	break; // responding when mouse is placed north west
/*
player is in the center, and is trying to pan,
directions not responding or causing a break will be kept as X, 
others are the cDir case... 
		8	1	X

		7	_	X

		X	X	X
*/
	}

	m_pClientList[iClientH]->m_sX   = dX;
	m_pClientList[iClientH]->m_sY   = dY;
	m_pClientList[iClientH]->m_cDir = cDir;
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_PANNING;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOVE_CONFIRM;
		
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);
		
	sp  = (short *)cp;
	*sp = (short)(dX - 10); 
	cp += 2;
		
	sp  = (short *)cp;
	*sp = (short)(dY - 7); 
	cp += 2;

	*cp = cDir;
	cp++;
		
	iSize = iComposeMoveMapData((short)(dX - 10), (short)(dY - 7), iClientH, cDir, cp);
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Â¾Â¶Â§ Â¿Â¡Â·Â¯Â°Â¡ Â¹ÃŸÂ»Ã½Ã‡ÃŸÂ´Ã™Â¸Ã© ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

void CGame::AdminOrder_SetObserverMode(int iClientH)
{

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) {
		// Â»Ãµ Ã€Â§Ã„Â¡Â¿Â¡ Ã‡Â¥Â½ÃƒÃ‡Ã‘Â´Ã™. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);		
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_OBSERVERMODE, 0, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = FALSE;
	}
	else {
		// Ã‡Ã¶Ã€Ã§ Ã€Â§Ã„Â¡Â¿Â¡Â¼Â­ ÃÃ¶Â¿Ã®Â´Ã™. Â¾Ã¸Â¾Ã®ÃÃ¸ Ã‡Ã Ã€Â§Â¸Â¦ Â¾Ã‹Â·ÃÃÃ Â¾ÃŸ Ã‡Ã‘Â´Ã™. Â¾Ã†ÃÃ· Â¹ÃŒÂ±Â¸Ã‡Ã¶
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
		//iRequestPanningMapDataRequest(iClientH, pData)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_OBSERVERMODE, 1, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = TRUE;
	}
}

void CGame::RequestRestartHandler(int iClientH)
{
 char  cTmpMap[32];

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) {
		
		strcpy(cTmpMap,m_pClientList[iClientH]->m_cMapName) ;
		ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		
		if (strcmp(m_pClientList[iClientH]->m_cLocation, "NONE") == 0) {
			// ¿©ÇàÀÚ¶ó¸é  default¸ÊÀ¸·Î °£´Ù.
			strcpy(m_pClientList[iClientH]->m_cMapName, "default");
		}
		else {
			// ¼Ò¼ÓÀÌ ÀÖ´Ù¸é ¼Ò¼Ó ¸¶À»ÀÇ ºÎÈ°Á¸À¸·Î °£´Ù.
			if (strcmp(m_pClientList[iClientH]->m_cLocation, "aresden") == 0) {
				if (m_bIsCrusadeMode == TRUE) {
					// Å©·ç¼¼ÀÌµå ¸ğµå¿¡¼­ »ç¸ÁÇÑ °æ¿ì: ¸¶À» ¸Ê¿¡¼­ ÀÏÁ¤½Ã°£ ³ª°¥ ¼ö ¾ø´Ù.
					if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
						ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04
					}
					else {
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04 10ºĞ ¾È¿¡ ¶Ç Á×À¸¸é ¸¶À»¿¡ °®Èù´Ù.
					}
				}
				// v2.16 2002-5-31
				if (strcmp(cTmpMap, "elvine") == 0){
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvjail", 7);
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvjail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ; // 3ºĞ 
				}else if (m_pClientList[iClientH]->m_iLevel > 80)
					 memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "arefarm", 7);
			}
			else {
				if (m_bIsCrusadeMode == TRUE) {
					// Å©·ç¼¼ÀÌµå ¸ğµå¿¡¼­ »ç¸ÁÇÑ °æ¿ì: ¸¶À» ¸Ê¿¡¼­ ÀÏÁ¤½Ã°£ ³ª°¥ ¼ö ¾ø´Ù.
					if (m_pClientList[iClientH]->m_iDeadPenaltyTime > 0) {
						ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04
					}
					else {
						memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
						m_pClientList[iClientH]->m_iDeadPenaltyTime = 60*10; // v2.04 10ºĞ ¾È¿¡ ¶Ç Á×À¸¸é ¸¶À»¿¡ °®Èù´Ù.
					}
				}
				if (strcmp(cTmpMap, "aresden") == 0){
					memcpy(m_pClientList[iClientH]->m_cMapName, "arejail", 7);
					strcpy(m_pClientList[iClientH]->m_cLockedMapName, "arejail");
					m_pClientList[iClientH]->m_iLockedMapTime = 60*3 ; // 3ºĞ 

				}else if (m_pClientList[iClientH]->m_iLevel > 80)
					 memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
				else memcpy(m_pClientList[iClientH]->m_cMapName, "elvfarm", 7);
			}
		}
		
		// v2.04 ´Ù½Ã »ì¸®´Â Ã³¸®¸¦ ÇÑ´Ù. HP, ¹è°íÇÄ Áö¼ö ¸¸¶¥
		m_pClientList[iClientH]->m_bIsKilled = FALSE;
		m_pClientList[iClientH]->m_iHP = (3*m_pClientList[iClientH]->m_iVit) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->m_iStr/2);
		m_pClientList[iClientH]->m_iHungerStatus = 100;

		ZeroMemory(cTmpMap, sizeof(cTmpMap));
		strcpy(cTmpMap, m_pClientList[iClientH]->m_cMapName);
		// !!! RequestTeleportHandler³»¿¡¼­ m_cMapNameÀ» ¾²±â ¶§¹®¿¡ ±×´ë·Î ÆÄ¶ó¹ÌÅÍ·Î ³Ñ°ÜÁÖ¸é ¿Àµ¿ÀÛ
		RequestTeleportHandler(iClientH, "2   ", cTmpMap, -1, -1);
	}
}


void CGame::AdminOrder_EnableAdminCommand(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   * token, cBuff[256], len;
 char   seps[] = "= \t\n";
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		len = strlen(token);
		if(len > 10) len = 10;
		if (memcmp(token, m_cSecurityNumber, len) == 0) {
			m_pClientList[iClientH]->m_bIsAdminCommandEnabled = TRUE;
		}
		else {
			wsprintf(G_cTxt, "(%s) Player(%s) attempts to access /enableadmincommand with %s", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, token);
			PutHackLogFileList(G_cTxt);
			return;
		}
	}
}

void CGame::AdminOrder_CreateItem(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * cp, * token, cBuff[256], cItemName[256], cData[256], cTemp[256], cAttribute[256], cValue[256];
 SYSTEMTIME SysTime;
 class  CStrTok * pStrTok;
 class  CItem * pItem;
 short  * sp;
 int    iRet, iTemp, iEraseReq, iValue;
 DWORD * dwp;
 WORD  * wp, wTemp;
 double dV1, dV2, dV3;
 
	// if the client doesnt exist than no effect.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	// if the command is just "/createitem " than no effect.
	if ((dwMsgSize)	<= 0) return;

	// if client's admin level is less than 4 no effect.
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCreateItem) {
		// if the admin user level is not 0 and less than 4 send message 
		if (m_pClientList[iClientH]->m_iAdminUserLevel !=  0)	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	} // close if (m_pClientList[iClientH]->m_iAdminUserLevel < 4) {

	// IP address not able to create item 
	// DISABLED: if (memcmp(m_pClientList[iClientH]->m_cIPaddress, "192.168.1.", 12) != 0) return;

	// check if the client has typed "/enableadmincreateitem"
	//if (m_pClientList[iClientH]->m_bIsAdminCreateItemEnabled == FALSE) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);
	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	// if the token is something it is an item name
	if (token != NULL) {
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, token);
	} // close if (token != NULL) {

	// if the 2nd token is true it is the item attribute
	ZeroMemory(cAttribute, sizeof(cAttribute));
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cAttribute, sizeof(cAttribute));
		strcpy(cAttribute, token);
	} // close if (token != NULL) {

	// if the 3rd token is true it is the item value
	ZeroMemory(cValue, sizeof(cValue));
	iValue = 0;
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cValue, sizeof(cValue));
		strcpy(cValue, token);
		iValue = atoi(cValue);
	} // close if (token != NULL) {

	pItem = new class CItem;
	// if the given itemname doesnt exist delete item
	if (_bInitItemAttr(pItem, cItemName) == FALSE) {
		delete pItem;
		return;	
	} //close if (_bInitItemAttr(pItem, cItemName) == FALSE) {

	if (strlen(cAttribute) != 0) {
		pItem->m_dwAttribute = atoi(cAttribute);
		if (pItem->m_dwAttribute == 1) {
			if ((iValue >= 1) && (iValue <= 200)) {
				pItem->m_cItemColor = 2;
				pItem->m_sItemSpecEffectValue2 = iValue - 100;
								
				dV2 = (double)pItem->m_sItemSpecEffectValue2;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
				} // close if (wTemp <= pItem->m_wMaxLifeSpan*2) {
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;
			} // close if ((iValue >= 1) && (iValue <= 200)) {
			else pItem->m_dwAttribute = NULL;
		} // close if (pItem->m_dwAttribute == 1) {
		else {
			if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
				switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
				case 6:	pItem->m_cItemColor = 2; break;
				case 8: pItem->m_cItemColor = 3; break;
				case 1:	pItem->m_cItemColor = 5; break;
				case 5:	pItem->m_cItemColor = 1; break;
				case 3:	pItem->m_cItemColor = 7; break;
				case 2:	pItem->m_cItemColor = 4; break;
				case 7:	pItem->m_cItemColor = 6; break;
				case 9:	pItem->m_cItemColor = 8; break;
				} // close switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
			} // close if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
			else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
				switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
				case 10: pItem->m_cItemColor = 5; break;
				} // close switch ((pItem->m_dwAttribute & 0xF00000) >> 20) {
			} // close else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
		} // close else {
	} // close if (strlen(cAttribute) != 0) {

	// if the item id is
	switch (pItem->m_sIDnum) {
	case 511: // ArenaTicket
	case 513: // ArenaTicket(2)
	case 515: // ArenaTicket(3)
	case 517: // ArenaTicket(4)
	case 530: // ArenaTicket(5)
	case 531: // ArenaTicket(6)
	case 532: // ArenaTicket(7)
	case 533: // ArenaTicket(8)
	case 534: // ArenaTicket(9)
		GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		// v1.4311-3 º¯°æ ¿î¿µÀÚ°¡ ¹ß±ŞÇÑ ÀÔÀå±ÇÀº ±×³¯Àº Ç×»ó ÀÔÀå °¡´É ..
		pItem->m_sTouchEffectValue1 = (short)SysTime.wMonth;
		pItem->m_sTouchEffectValue2 = (short)SysTime.wDay;
		pItem->m_sTouchEffectValue3 = 24 ;
		break;

	default:
		GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		// ¸¶Áö¸· ¼ıÀÚ´Â ¾ÆÀÌÅÛ »ı¼º ¿ù, ÀÏ	
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
		pItem->m_sTouchEffectValue3 = atoi(cTemp);
		break;
	}
	
	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1°³ È¹µæÇß´Ù. Amount°¡ ¾Æ´Ï´Ù!
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;	// ¼ö·®À» ÀÔ·Â 
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		// v2.15 ·Î±× °ü·Ã ¼öÁ¤
		if (iEraseReq == 1) {
			delete pItem;
			pItem = NULL ;
		}
		
		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		

		// v2.14 Admin Log
		wsprintf(G_cTxt, "(%s) GM Order(%s): Create ItemName(%s)",m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cItemName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, NULL,G_cTxt);

		return;
	}
	else {
		// ¾ÆÀÌÅÛÀ» ¼ÒÁöÇÒ ¼ö ¾ø´Â »óÈ²ÀÌ´Ù.		
		delete pItem;
		return;
	}
}

void CGame::RequestSellItemListHandler(int iClientH, char * pData)
{
 int i, * ip, iAmount;
 char * cp, cIndex;
 struct {
	char cIndex;
	int  iAmount;
 } stTemp[12];

	if (m_pClientList[iClientH] == NULL) return;

	cp = (char *)(pData + 6);
	for (i = 0; i < 12; i++) {
		stTemp[i].cIndex = *cp;
		cp++;

		ip = (int *)cp;
		stTemp[i].iAmount = *ip;
		cp += 4;
	}

	// Â³Â»Â¿Ã«Ã€Â» Â´Ã™ Ã€ÃÂ¾ÃºÂ´Ã™. Â¼Ã¸Â¼Â­Â´Ã«Â·Ã Ã†ÃˆÂ¾Ã†Ã„Â¡Â¿Ã®Â´Ã™.
	for (i = 0; i < 12; i++) {
		cIndex = stTemp[i].cIndex;
		iAmount = stTemp[i].iAmount;

		if ((cIndex == -1) || (cIndex < 0) || (cIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cIndex] == NULL) return;

		// cIndexÂ¿Â¡ Ã‡Ã˜Â´Ã§Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã†Ã‡Â´Ã™.
		ReqSellItemConfirmHandler(iClientH, cIndex, iAmount, NULL);
		// Ã€ÃŒ Â·Ã§Ã†Â¾Ã€Â» Â¼Ã¶Ã‡Ã Ã‡Ã‘ Â´Ã™Ã€Â½ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â°Â¡ Â»Ã¨ÃÂ¦ÂµÃ‡Â¾ÃºÃ€Â» Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡!
		if (m_pClientList[iClientH] == NULL) return;
	}
}

void CGame::_DeleteRandomOccupyFlag(int iMapIndex)
{
 int i, iCount, iTotalFlags, iTargetFlag, iDynamicObjectIndex;
 int tx, ty, fx, fy, iLocalSide, iLocalEKNum, iPrevStatus;
 class CTile * pTile;
 DWORD dwTime;

	if (m_pMapList[iMapIndex] == NULL) return;

	dwTime = timeGetTime();

	// ÃƒÃ‘ Â±ÃªÂ¹ÃŸ Â°Â¹Â¼Ã¶Â¸Â¦ Â±Â¸Ã‡Ã‘Â´Ã™.
	iTotalFlags = 0;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++)
	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != NULL) {
		iTotalFlags++;
	}

	// Â·Â£Â´Ã½Ã‡ÃÂ°Ã” Ã‡ÃÂ³Âª ÃÂ¤Ã‡Ã‘Â´Ã™.
	iTargetFlag = iDice(1, iTotalFlags);

	iCount = 0;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++)
	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != NULL) {
		iCount++;
		if ((iCount == iTotalFlags) && (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != NULL)) {
			// m_pMapList[iMapIndex]->m_pOccupyFlag[i] : Ã€ÃŒ Â±ÃªÂ¹ÃŸÃ€Â» Â¾Ã¸Â¾Ã˜Â´Ã™.	

			//testcode
			wsprintf(G_cTxt, "(*)Delete OccupyFlag: Side(%d) XY(%d, %d)", m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_cSide, m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX, m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY);
			PutLogList(G_cTxt);

			fx = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX;
			fy = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY;
			iLocalSide  = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_cSide;
			iLocalEKNum = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iEKCount;
			
			pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX + 
				                    m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY*m_pMapList[iMapIndex]->m_sSizeY);
			// Â±ÃªÂ¹ÃŸ Â°Â´ÃƒÂ¼ Â°Â¨Â¼Ã’ 
			m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;
						
			iDynamicObjectIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iDynamicObjectIndex;
			// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â±ÃªÂ¹ÃŸÃ€ÃŒ Â»Ã§Â¶Ã³ÃÃ¼Ã€Â» Â¾Ã‹Â¸Â®Â°Ã­ 
			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
										m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
										m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);
			// Â¸ÃŠÂ¿Â¡Â¼Â­ Â±ÃªÂ¹ÃŸ ÂµÂ¿Ã€Ã» Â°Â´ÃƒÂ¼Â¸Â¦ Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
			m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);
						
			// Â±ÃªÂ¹ÃŸ Â°Â´ÃƒÂ¼Â¸Â¦ Â»Ã¨ÃÂ¦ 
			delete m_pMapList[iMapIndex]->m_pOccupyFlag[i];
			m_pMapList[iMapIndex]->m_pOccupyFlag[i] = NULL;

			// Ã…Â¸Ã€Ã Â»Ã³Ã€Ã‡ Â±ÃªÂ¹ÃŸ Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ Â»Ã¨ÃÂ¦
			pTile->m_iOccupyFlagIndex = NULL;

			// ÂµÂ¿Ã€Ã» Â°Â´ÃƒÂ¼ Â»Ã¨ÃÂ¦ 
			delete m_pDynamicObjectList[iDynamicObjectIndex];
			m_pDynamicObjectList[iDynamicObjectIndex] = NULL;

			// Ã€ÃŒ Â±ÃªÂ¹ÃŸÃ€Â» Â»Ã¨ÃÂ¦Ã‡ÃÂ¹Ã‡Â·Ã Â¿ÂµÃ‡Ã¢Â±Ã‡ Â³Â»Ã€Ã‡ Â°ÂªÃ€Â» ÂºÂ¯Â°Ã¦Â½ÃƒÃ„Ã‘Â¾ÃŸ Ã‡Ã‘Â´Ã™. *** Â¸Ã‡ Â¸Â¶ÃÃ¶Â¸Â·Â¿Â¡ ÃƒÂ³Â¸Â®Ã‡Ã˜Â¾ÃŸ Ã‡Ã‘Â´Ã™.
			for (tx = fx - 10; tx <= fx + 10; tx++)
			for (ty = fy - 8; ty <= fy + 8; ty++) {	
				if ((tx < 0) || (tx >= m_pMapList[iMapIndex]->m_sSizeX) || 
					(ty < 0) || (ty >= m_pMapList[iMapIndex]->m_sSizeY)) {
					// Â¹Â«Â½ÃƒÃ‡Ã˜Â¾ÃŸ Ã‡ÃÂ´Ã‚ ÃÃ‚Ã‡Â¥ 
				}
				else {
					pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + tx + ty*m_pMapList[iMapIndex]->m_sSizeY);
					iPrevStatus = pTile->m_iOccupyStatus;
					// Side: Â¾Ã†Â·Â¹Â½ÂºÂµÂ§(1)  Â¿Â¤Â¹Ã™Ã€Ã(2)
					switch (iLocalSide) {
					case 1: 
						pTile->m_iOccupyStatus += iLocalEKNum;
						if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
						break;
					case 2:
						pTile->m_iOccupyStatus -= iLocalEKNum;
						if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
						break;
					}
				}
			}
			//
			return;
		}
	}
}


void CGame::CreateNewPartyHandler(int iClientH)
{
 BOOL bFlag;

	if (m_pClientList[iClientH] == NULL) return;

	bFlag = m_pClientList[iClientH]->bCreateNewParty();
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RESPONSE_CREATENEWPARTY, (int)bFlag, NULL, NULL, NULL);
}

void CGame::JoinPartyHandler(int iClientH, int iV1, char *pMemberName)
{
	char * cp, cData[120];
	short sAppr2;
	DWORD * dwp;
	WORD * wp;
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;

	switch (iV1) {
	case 0: // Ã†Ã„Ã†Â¼ Ã…Â»Ã…Ã° Â½Ã…ÃƒÂ»
		RequestDeletePartyHandler(iClientH);
		break;

	case 1: // Ã†Ã„Ã†Â¼ Â°Â¡Ã€Ã” Â½Ã…ÃƒÂ»
		//testcode
		wsprintf(G_cTxt, "Join Party Req: %s(%d) ID(%d) Stat(%d) ReqJoinH(%d) ReqJoinName(%s)", m_pClientList[iClientH]->m_cCharName, iClientH, 
			m_pClientList[iClientH]->m_iPartyID, m_pClientList[iClientH]->m_iPartyStatus, m_pClientList[iClientH]->m_iReqJoinPartyClientH,
			m_pClientList[iClientH]->m_cReqJoinPartyName);
		PutLogList(G_cTxt);

		if ((m_pClientList[iClientH]->m_iPartyID != NULL) || (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL)) {
			// Ã€ÃŒÂ¹ÃŒ Ã†Ã„Ã†Â¼Â¿Â¡ Â°Â¡Ã€Ã”Ã‡Ã˜ Ã€Ã–Â´Ã™Â¸Ã© Ã†Ã„Ã†Â¼ Â°Â¡Ã€Ã” Â½Ã…ÃƒÂ»Ã€Â» Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
			m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
			ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			//testcode
			PutLogList("Join Party Reject (1)");
			return;
		}

		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pMemberName) == 0)) {
				// Â°Â°Ã€Âº Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â¸Â¦ ÃƒÂ£Â¾Ã’Â´Ã™.
				sAppr2 = (short)((m_pClientList[i]->m_sAppr2 & 0xF000) >> 12);
				if (sAppr2 != 0) {
					// Ã€Ã¼Ã…Ãµ Â¸Ã°ÂµÃ¥ Â»Ã³Ã…Ã‚Ã€Ã‡ Â»Ã³Â´Ã«Â¿Â¡Â°Ã”Â´Ã‚ Ã†Ã„Ã†Â¼ Â°Â¡Ã€Ã” Â½Ã…ÃƒÂ»Ã€Â» Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
					//testcode
					PutLogList("Join Party Reject (2)");
				}
				else if (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) {
					// Ã†Ã­Ã€ÃŒ Â´Ã™Â¸Â£Â¸Ã© Ã†Ã„Ã†Â¼Â¿Â¡ ÂµÃ© Â¼Ã¶ Â¾Ã¸Â´Ã™.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
					//testcode
					PutLogList("Join Party Reject (3)");
				}
				else if (m_pClientList[i]->m_iPartyStatus == DEF_PARTYSTATUS_PROCESSING) {
					// Ã†Ã„Ã†Â¼ Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡Ã‘ Â´Ã«Â»Ã³Ã€ÃŒ Ã€ÃŒÂ¹ÃŒ Â´Ã™Â¸Â¥ Ã†Ã„Ã†Â¼ Â°Â¡Ã€Ã” Â°Ã¼Â·Ãƒ ÃƒÂ³Â¸Â®Â¸Â¦ Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã™. Â½Ã…ÃƒÂ» ÂºÃ’Â°Â¡.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
					//testcode
					PutLogList("Join Party Reject (4)");
					//testcode
					wsprintf(G_cTxt, "Party join reject(2) ClientH:%d ID:%d JoinName:%d", i, m_pClientList[i]->m_iPartyID, m_pClientList[i]->m_cReqJoinPartyName);
					PutLogList(G_cTxt);

					m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
					ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				}
				else {
					// Â°Â¡Ã€Ã” Â½Ã‚Ã€Ã Â¿Â©ÂºÃÂ¸Â¦ Â¹Â¯Â´Ã‚Â´Ã™.
					m_pClientList[i]->m_iReqJoinPartyClientH = iClientH;
					ZeroMemory(m_pClientList[i]->m_cReqJoinPartyName, sizeof(m_pClientList[i]->m_cReqJoinPartyName));
					strcpy(m_pClientList[i]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName);
					SendNotifyMsg(NULL, i, DEF_NOTIFY_QUERY_JOINPARTY, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);

					// Â½Ã…ÃƒÂ»Ã‡Ã‘ ÃƒÃ¸Â¿Â¡Â´Ã‚ Ã†Ã„Ã†Â¼ Â¸Â¶Â½ÂºÃ…ÃÂ°Â¡ ÂµÃ‰ Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ Â³Ã–Â¾Ã®ÃÃœ. ÃƒÃ«Â¼Ã’Ã‡Ã’Â¶Â§ ÃƒÂ³Â¸Â®Ã‡ÃÂ±Ã¢ Ã€Â§Ã‡Ã”Ã€Ã“.
					m_pClientList[iClientH]->m_iReqJoinPartyClientH = i;
					ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
					strcpy(m_pClientList[iClientH]->m_cReqJoinPartyName, m_pClientList[i]->m_cCharName);
					// Ã†Ã„Ã†Â¼ Â»Ã³Ã…Ã‚ Â¼Â¼Ã†Â®
					m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
				}
				return;
			}
			break;

	case 2: // Ã†Ã„Ã†Â¼ Â¸Ã¢Â¹Ã¶ ÃˆÂ®Ã€Ã Â¸Ã­Â·Ã‰ 
		if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) {
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 6; // Ã†Ã„Ã†Â¼ Â¸Ã¢Â¹Ã¶ Â¸Â®Â½ÂºÃ†Â® Â¿Ã¤ÃƒÂ»
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}
		break;
	}
}



BOOL CGame::bCheckEnergySphereDestination(int iNpcH, short sAttackerH, char cAttackerType)
{
 int i, sX,sY, dX, dY, iGoalMapIndex;
 char cResult;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex == -1) return FALSE;

	if (m_pNpcList[iNpcH]->m_cMapIndex != m_iMiddlelandMapIndex) {
		// Â»Ã§Ã…ÃµÃ€Ã¥Ã€Ã‡ Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®
		iGoalMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;
		
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
	
		cResult = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-2) && (sX <= dX+2) && (sY >= dY-2) && (sY <= dY+2)) {
			// Â¾Ã†Â·Â¹Â½ÂºÂµÂ§ Â¸Ã±Ã‡Â¥ÃÃ¶ÃÂ¡Â¿Â¡ ÂµÂµÃ‚Ã¸Ã‡ÃŸÂ´Ã™.
			// Ã‡Ã¶Ã€Ã§ Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã® Â°Ã± Ã€ÃÂµÂ¦Â½Âº Ã€ÃºÃ€Ã¥ 
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					// Ã€ÃšÂ½Ã…Ã€Ã‡ Â±Â¹Â°Â¡ Ã†Ã·Ã…Â»Â¿Â¡ Â°Ã±Ã€Â» Â³Ã–Ã€Âº Â°Ã¦Â¿Ã¬ Â°Ã¸Ã‡Ã¥ÂµÂµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// Â·ÃÂ±Ã— Ã€Ã›Â¼Âº
					wsprintf(G_cTxt, "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// Â´Ã™Â¸Â¥ Â±Â¹Â°Â¡Â¿Â¡ Â°Ã±Ã€Â» Â³Ã–Â¾ÃºÃ€Â» Â°Ã¦Â¿Ã¬ Â°Ã¸Ã‡Ã¥ÂµÂµÂ°Â¡ 10 Â¶Â³Â¾Ã®ÃÃ¸Â´Ã™.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®Â°Â¡ Â°Ã±Ã€Ã ÂµÃ†Ã€Â½Ã€Â» Â¸Ã°ÂµÃ§ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿ÃÃ€Ã‡ Â¸ÃÂ½ÃƒÃÃ¶ Ã‚Ã¸Â¿Ã€Â·Ã 
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}

		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-2) && (sX <= dX+2) && (sY >= dY-2) && (sY <= dY+2)) {
			// Â¿Â¤Â¹Ã™Ã€Ã Â¸Ã±Ã‡Â¥ÃÃ¶ÃÂ¡Â¿Â¡ ÂµÂµÃ‚Ã¸Ã‡ÃŸÂ´Ã™.
			// Ã‡Ã¶Ã€Ã§ Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã® Â°Ã± Ã€ÃÂµÂ¦Â½Âº Ã€ÃºÃ€Ã¥ 
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					// Ã€ÃšÂ½Ã…Ã€Ã‡ Â±Â¹Â°Â¡ Ã†Ã·Ã…Â»Â¿Â¡ Â°Ã±Ã€Â» Â³Ã–Ã€Âº Â°Ã¦Â¿Ã¬ Â°Ã¸Ã‡Ã¥ÂµÂµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// Â·ÃÂ±Ã— Ã€Ã›Â¼Âº
					wsprintf(G_cTxt, "(!) EnergySphere Hit By Elvine Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// Â´Ã™Â¸Â¥ Â±Â¹Â°Â¡Â¿Â¡ Â°Ã±Ã€Â» Â³Ã–Â¾ÃºÃ€Â» Â°Ã¦Â¿Ã¬ Â°Ã¸Ã‡Ã¥ÂµÂµÂ°Â¡ 10 Â¶Â³Â¾Ã®ÃÃ¸Â´Ã™.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®Â°Â¡ Â°Ã±Ã€Ã ÂµÃ†Ã€Â½Ã€Â» Â¸Ã°ÂµÃ§ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					//
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
		}
		return FALSE;
	}
	else {
		// Â¹ÃŒÂµÃ©Â·Â£ÂµÃ¥ Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®.

		// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®Ã€Ã‡ Ã‡Ã¶Ã€Ã§ Ã€Â§Ã„Â¡Â°Â¡ Â°Ã±Â°Ãº Â°Ã…Ã€Ã‡ Ã€Â¯Â»Ã§Ã‡ÃÂ¸Ã© 
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
	
		cResult = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-4) && (sX <= dX+4) && (sY >= dY-4) && (sY <= dY+4)) {
			// Â¾Ã†Â·Â¹Â½ÂºÂµÂ§ Â¸Ã±Ã‡Â¥ÃÃ¶ÃÂ¡Â¿Â¡ ÂµÂµÃ‚Ã¸Ã‡ÃŸÂ´Ã™.
			// Ã‡Ã¶Ã€Ã§ Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã® Â°Ã± Ã€ÃÂµÂ¦Â½Âº Ã€ÃºÃ€Ã¥ 
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					// Ã€ÃšÂ½Ã…Ã€Ã‡ Â±Â¹Â°Â¡ Ã†Ã·Ã…Â»Â¿Â¡ Â°Ã±Ã€Â» Â³Ã–Ã€Âº Â°Ã¦Â¿Ã¬ Â°Ã¸Ã‡Ã¥ÂµÂµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// Â·ÃÂ±Ã— Ã€Ã›Â¼Âº
					wsprintf(G_cTxt, "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// Â´Ã™Â¸Â¥ Â±Â¹Â°Â¡Â¿Â¡ Â°Ã±Ã€Â» Â³Ã–Â¾ÃºÃ€Â» Â°Ã¦Â¿Ã¬ Â°Ã¸Ã‡Ã¥ÂµÂµÂ°Â¡ 10 Â¶Â³Â¾Ã®ÃÃ¸Â´Ã™.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®Â°Â¡ Â°Ã±Ã€Ã ÂµÃ†Ã€Â½Ã€Â» Â¸Ã°ÂµÃ§ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿ÃÃ€Ã‡ Â¸ÃÂ½ÃƒÃÃ¶ Ã‚Ã¸Â¿Ã€Â·Ã 
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}

		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-4) && (sX <= dX+4) && (sY >= dY-4) && (sY <= dY+4)) {
			// Â¿Â¤Â¹Ã™Ã€Ã Â¸Ã±Ã‡Â¥ÃÃ¶ÃÂ¡Â¿Â¡ ÂµÂµÃ‚Ã¸Ã‡ÃŸÂ´Ã™.
			// Ã‡Ã¶Ã€Ã§ Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã® Â°Ã± Ã€ÃÂµÂ¦Â½Âº Ã€ÃºÃ€Ã¥ 
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					// Ã€ÃšÂ½Ã…Ã€Ã‡ Â±Â¹Â°Â¡ Ã†Ã·Ã…Â»Â¿Â¡ Â°Ã±Ã€Â» Â³Ã–Ã€Âº Â°Ã¦Â¿Ã¬ Â°Ã¸Ã‡Ã¥ÂµÂµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// Â·ÃÂ±Ã— Ã€Ã›Â¼Âº
					wsprintf(G_cTxt, "(!) EnergySphere Hit By Aresden Player (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// Â´Ã™Â¸Â¥ Â±Â¹Â°Â¡Â¿Â¡ Â°Ã±Ã€Â» Â³Ã–Â¾ÃºÃ€Â» Â°Ã¦Â¿Ã¬ Â°Ã¸Ã‡Ã¥ÂµÂµÂ°Â¡ 10 Â¶Â³Â¾Ã®ÃÃ¸Â´Ã™.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®Â°Â¡ Â°Ã±Ã€Ã ÂµÃ†Ã€Â½Ã€Â» Â¸Ã°ÂµÃ§ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					//
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}
		return FALSE;
	}
}

void CGame::EnergySphereProcessor(BOOL bIsAdminCreate, int iClientH)
{
 int i, iNamingValue, iCIndex, iTemp, pX, pY;
 char cSA, cName_Internal[31], cWaypoint[31];

	if (bIsAdminCreate != TRUE) {
		
		if (m_iMiddlelandMapIndex < 0) return;
		if (m_pMapList[m_iMiddlelandMapIndex] == NULL) return;
		// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®Â°Â¡ Â¸Â¸ÂµÃ©Â¾Ã®ÃÃº ÃˆÂ®Â·Ã¼Ã€Âº 3ÃƒÃŠÂ¸Â¶Â´Ã™ 2000ÂºÃÃ€Ã‡ 1
		if (iDice(1,2000) != 123) return; 
		// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®Â´Ã‚ ÃƒÃ‘ Â»Ã§Â¿Ã«Ã€Ãš 500Â¸Ã­ Ã€ÃŒÂ»Ã³Ã€ÃÂ¶Â§Â¸Â¸ Â¸Â¸ÂµÃ©Â¾Ã® ÃÃ¸Â´Ã™.
		if (m_iTotalGameServerClients < 500) return;
	
		// Â¸Â¸Â¾Ã  Ã€ÃŒÂ¹ÃŒ Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®Ã€Ã‡ Â°Ã±Ã€ÃŒ Ã‡Ã’Â´Ã§ÂµÃ‡Â¾Ã® Ã€Ã–Ã€Â¸Â¸Ã© Â¸Â¸ÂµÃ©Â¸Ã© Â¾ÃˆÂµÃˆÂ´Ã™.
		if (m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®Â¸Â¦ Â¸Â¸ÂµÃ© Ã€Â§Ã„Â¡Â¸Â¦ Â°Ã¡ÃÂ¤ 
		iCIndex = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereCreationPoint);

		// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã® Â½ÃƒÃ€Ã› Ã€Â§Ã„Â¡Â°Â¡ ÃƒÃŠÂ±Ã¢ÃˆÂ­Â°Â¡ Â¾ÃˆÂµÃˆ Â»Ã³Ã…Ã‚Â¶Ã³Â¸Ã© 
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;
		
		// Â¿Â©Â±Ã¢Â¼Â­ Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã® Â»Ã½Â¼Âº 
		cSA = 0;
 		pX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));
	
		iNamingValue = m_pMapList[m_iMiddlelandMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_iMiddlelandMapIndex + 65;
			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_iMiddlelandMapIndex]->m_cName, (rand() % 5), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
				m_pMapList[m_iMiddlelandMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}		

		// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã® Â°Ã± Â»Ã½Â¼Âº 
		iTemp  = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;
	
		// Ã‡Ã¶Ã€Ã§ Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã® Â°Ã± Ã€ÃÂµÂ¦Â½Âº Ã€ÃºÃ€Ã¥ 
		m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®Â°Â¡ Â¸Â¸ÂµÃ©Â¾Ã® ÃÂ³Ã€Â½Ã€Â» Â¸Ã°ÂµÃ§ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
		}

		//testcode
		wsprintf(G_cTxt, "(!) Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
	else {
		// Â¸Â¸Â¾Ã  Ã€ÃŒÂ¹ÃŒ Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®Ã€Ã‡ Â°Ã±Ã€ÃŒ Ã‡Ã’Â´Ã§ÂµÃ‡Â¾Ã® Ã€Ã–Ã€Â¸Â¸Ã© Â¸Â¸ÂµÃ©Â¸Ã© Â¾ÃˆÂµÃˆÂ´Ã™.
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®Â¸Â¦ Â¸Â¸ÂµÃ© Ã€Â§Ã„Â¡Â¸Â¦ Â°Ã¡ÃÂ¤ 
		iCIndex = iDice(1, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalEnergySphereCreationPoint);

		// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã® Â½ÃƒÃ€Ã› Ã€Â§Ã„Â¡Â°Â¡ ÃƒÃŠÂ±Ã¢ÃˆÂ­Â°Â¡ Â¾ÃˆÂµÃˆ Â»Ã³Ã…Ã‚Â¶Ã³Â¸Ã© 
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;
		
		// Â¿Â©Â±Ã¢Â¼Â­ Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã® Â»Ã½Â¼Âº 
		cSA = 0;
 		pX = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));
	
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 5), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
				// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â¿Â¹Â¾Ã ÂµÃˆ NameValueÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}		

		// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã® Â°Ã± Â»Ã½Â¼Âº 
		iTemp  = iDice(1, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;
	
		// Ã‡Ã¶Ã€Ã§ Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã® Â°Ã± Ã€ÃÂµÂ¦Â½Âº Ã€ÃºÃ€Ã¥ 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		// Â¿Â¡Â³ÃŠÃÃ¶ Â½ÂºÃ‡Ã‡Â¾Ã®Â°Â¡ Â¸Â¸ÂµÃ©Â¾Ã® ÃÂ³Ã€Â½Ã€Â» Â¸Ã°ÂµÃ§ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
		}

		//testcode
		wsprintf(G_cTxt, "(!) Admin Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
}


void CGame::ActivateSpecialAbilityHandler(int iClientH)
{
 DWORD dwTime = timeGetTime();
 short sTemp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) return;
	if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) return;

	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled  = TRUE;
	m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;

	m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;

	sTemp = m_pClientList[iClientH]->m_sAppr4;
	sTemp = sTemp & 0xFF0F;
	switch (m_pClientList[iClientH]->m_iSpecialAbilityType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
		sTemp = sTemp | 0x0010;
		break;
	case 50:
	case 51:
	case 52:
	case 53:
	case 54:
		sTemp = sTemp | 0x0020;
		break;
	}
	m_pClientList[iClientH]->m_sAppr4 = sTemp;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, NULL);
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::CancelQuestHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	// Ã„Ã¹Â½ÂºÃ†Â® Â»Ã³Ã…Ã‚Â¸Â¦ Ã…Â¬Â¸Â®Â¾Ã®Ã‡Ã‘Â´Ã™.
	_ClearQuestStatus(iClientH);
	// Ã„Ã¹Â½ÂºÃ†Â®Â°Â¡ ÃƒÃ«Â¼Ã’ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
}

int CGame::iGetItemWeight(CItem *pItem, int iCount)
{
 int iWeight;

	// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â¼Ã¶Â·Â®Â¿Â¡ ÂµÃ»Â¸Â¥ Â¹Â«Â°Ã”Â¸Â¦ Â°Ã¨Â»ÃªÃ‡Ã‘Â´Ã™. GoldÃ€Ã Â°Ã¦Â¿Ã¬ Â¹Â«Â°Ã”Â¸Â¦ 20ÂºÃÃ€Ã‡ 1Â·Ã ÂºÂ¯Â°Ã¦ 
	iWeight = (pItem->m_wWeight);
	if (iCount < 0) iCount = 1;
	iWeight = iWeight * iCount;
	if (pItem->m_sIDnum == 90) iWeight = iWeight / 20;
	if (iWeight <= 0) iWeight = 1;

	return iWeight;
}

void CGame::UpdateMapSectorInfo()
{
 int i, ix, iy;
 int iMaxNeutralActivity, iMaxAresdenActivity, iMaxElvineActivity, iMaxMonsterActivity, iMaxPlayerActivity;
	
	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL) {
	
		iMaxNeutralActivity = iMaxAresdenActivity = iMaxElvineActivity = iMaxMonsterActivity = iMaxPlayerActivity = 0;	
		m_pMapList[i]->m_iMaxNx = m_pMapList[i]->m_iMaxNy = m_pMapList[i]->m_iMaxAx = m_pMapList[i]->m_iMaxAy = 0;
		m_pMapList[i]->m_iMaxEx = m_pMapList[i]->m_iMaxEy = m_pMapList[i]->m_iMaxMx = m_pMapList[i]->m_iMaxMy = 0;
		m_pMapList[i]->m_iMaxPx = m_pMapList[i]->m_iMaxPy = 0;

		// Â±Ã—ÂµÂ¿Â¾Ãˆ Ã€ÃºÃ€Ã¥Ã‡ÃŸÂ´Ã¸ TempSectorInfoÂ¿Â¡Â¼Â­ ÃÂ¤ÂºÂ¸Â¸Â¦ Â¾Ã²Â¾Ã® SectorInfoÂ¿Â¡ Ã€ÃºÃ€Ã¥Ã‡Ã‘ Â´Ã™Ã€Â½ TempSectorInfoÂ´Ã‚ ÃÃ¶Â¿Ã®Â´Ã™.
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity > iMaxNeutralActivity) {
				iMaxNeutralActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity;
				m_pMapList[i]->m_iMaxNx = ix;
				m_pMapList[i]->m_iMaxNy = iy;
			}
			
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity > iMaxAresdenActivity) {
				iMaxAresdenActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity;
				m_pMapList[i]->m_iMaxAx = ix;
				m_pMapList[i]->m_iMaxAy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity > iMaxElvineActivity) {
				iMaxElvineActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity;
				m_pMapList[i]->m_iMaxEx = ix;
				m_pMapList[i]->m_iMaxEy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity > iMaxMonsterActivity) {
				iMaxMonsterActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity;
				m_pMapList[i]->m_iMaxMx = ix;
				m_pMapList[i]->m_iMaxMy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity > iMaxPlayerActivity) {
				iMaxPlayerActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity;
				m_pMapList[i]->m_iMaxPx = ix;
				m_pMapList[i]->m_iMaxPy = iy;
			}
		}
	
		// TempSectorInfo Â³Â¯Â¸Â°Â´Ã™.
		m_pMapList[i]->ClearTempSectorInfo();

		// Sector InfoÂ¿Â¡ Ã€ÃºÃ€Ã¥
		if (m_pMapList[i]->m_iMaxNx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxNx][m_pMapList[i]->m_iMaxNy].iNeutralActivity++;
		if (m_pMapList[i]->m_iMaxAx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxAx][m_pMapList[i]->m_iMaxAy].iAresdenActivity++;
		if (m_pMapList[i]->m_iMaxEx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxEx][m_pMapList[i]->m_iMaxEy].iElvineActivity++;
		if (m_pMapList[i]->m_iMaxMx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxMx][m_pMapList[i]->m_iMaxMy].iMonsterActivity++;
		if (m_pMapList[i]->m_iMaxPx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxPx][m_pMapList[i]->m_iMaxPy].iPlayerActivity++;
	}
}


void CGame::AgingMapSectorInfo()
{
 int i, ix, iy;

	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL) {
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
			m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity--;
			
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity   = 0;
		}
	}
}


BOOL CGame::__bSetConstructionKit(int iMapIndex, int dX, int dY, int iType, int iTimeCost, int iClientH)
{
 int iNamingValue, ix, iy, tX, tY;
 char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
 short sOwnerH;

	// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â¸Ã°ÂµÃ¥Â°Â¡ Â¾Ã†Â´ÃÂ°Ã…Â³Âª Â°Ã‡Â¼Â³Ã‡Ã‘ Â»Ã§Â¶Ã·Ã€ÃŒ Â°Ã¸ÂºÂ´Ã€ÃŒ Â¾Ã†Â´ÃÂ¸Ã© Â¹Â«Â½Ãƒ.
	if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[iClientH]->m_iCrusadeDuty != 2)) return FALSE;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures >= DEF_MAXCRUSADESTRUCTURES) {
		// Ã‡Ã˜Â´Ã§ Â¸ÃŠÂ¿Â¡ Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â°Ã‡Â¹Â° Â°Â³Â¼Ã¶ ÃÂ¦Ã‡Ã‘Â¿Â¡ Â°Ã‰Â¸Â®ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™Â¸Ã©
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMORECRUSADESTRUCTURE, NULL, NULL, NULL, NULL);
		return FALSE;
	}

	// Ã‡Ã˜Â´Ã§ Ã€Â§Ã„Â¡Â¿Â¡ Â°Ã‡ÃƒÃ Â¹Â° NPCÂ¸Â¦ Â»Ã½Â¼Âº.
	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// Â´ÃµÃ€ÃŒÂ»Ã³ Ã€ÃŒ Â¸ÃŠÂ¿Â¡ NPCÂ¸Â¦ Â¸Â¸ÂµÃ©Â¼Ã¶ Â¾Ã¸Â´Ã™. Ã€ÃŒÂ¸Â§Ã€Â» Ã‡Ã’Â´Ã§Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â±Ã¢ Â¶Â§Â¹Â®.
	}
	else {

		// Â¸Ã•Ã€Ãº Â¼Â³Ã„Â¡Ã‡ÃÂ°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Â±Ã™ÃƒÂ³Â¿Â¡ Â±Â¸ÃÂ¶Â¹Â°Ã€ÃŒ Â¾Ã¸Â³Âª ÃˆÂ®Ã€ÃÃ‡Ã‘Â´Ã™.
		for (ix = dX -3; ix <= dX +5; ix++)
		for (iy = dY -3; iy <= dX +5; iy++) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5)) return FALSE;
		}

		// NPCÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		if (m_pClientList[iClientH]->m_cSide == 1) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Aresden"); break;
			case 2: strcpy(cNpcName, "CGT-Aresen"); break;
			case 3: strcpy(cNpcName, "MS-Aresden"); break;
			case 4: strcpy(cNpcName, "DT-Aresden"); break;
			}
		}
		else if (m_pClientList[iClientH]->m_cSide == 2) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Elvine"); break;
			case 2: strcpy(cNpcName, "CGT-Elvine"); break;
			case 3: strcpy(cNpcName, "MS-Elvine"); break;
			case 4: strcpy(cNpcName, "DT-Elvine"); break;
			}
		}
		else return FALSE;
	
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)dX;
		tY = (int)dY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
			// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â¿Â¹Â¾Ã ÂµÃˆ NameValueÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
			// Â¼ÂºÂ°Ã¸
			wsprintf(G_cTxt, "Structure(%s) construction begin(%d,%d)!", cNpcName, tX, tY);
			PutLogList(G_cTxt);
			return TRUE;
		}
	}

	return FALSE;
}

void CGame::LocalStartCrusadeMode(DWORD dwCrusadeGUID)
{
 int i;

	if (m_bIsCrusadeMode == TRUE) return;
	m_bIsCrusadeMode = TRUE;
	m_iCrusadeWinnerSide = 0;

	if (dwCrusadeGUID != NULL) {
		// Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ GUID Ã†Ã„Ã€ÃÃ€Â» Â¸Â¸ÂµÃ§Â´Ã™.
		_CreateCrusadeGUID(dwCrusadeGUID, NULL);
		m_dwCrusadeGUID = dwCrusadeGUID;
	}

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
		// Â¸Ã°ÂµÃ§ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Ã€Ã¼Â¸Ã©Ã€Ã¼ Â¸Ã°ÂµÃ¥Â°Â¡ Â½ÃƒÃ€Ã›ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™. Â¸ÃƒÃ€Âº Ã€Ã“Â¹Â« Ã…Â¬Â¸Â®Â¾Ã® ÃˆÃ„ Ã…Ã«ÂºÂ¸Ã‡Ã”.
		m_pClientList[i]->m_iCrusadeDuty = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;
		m_pClientList[i]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		SendNotifyMsg(NULL, i, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[i]->m_iCrusadeDuty, NULL, NULL);
	}

	// Â½ÂºÃ†Â®Â¶Ã³Ã€ÃŒÃ…Â© Ã†Ã·Ã€ÃÃ†Â® HP ÃƒÃŠÂ±Ã¢ÃˆÂ­.
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) m_pMapList[i]->RestoreStrikePoints();

	// Â°Â¢Â°Â¢Ã€Ã‡ Â¸ÃŠÂ¿Â¡ ÃƒÃŠÂ±Ã¢ Â°Ã‡Â¹Â° Â¼Â³Ã„Â¡. (Â¸Â¶Â³Âª Â½ÂºÃ…Ã¦, Â¿Â¡Â³ÃŠÃÃ¶ Â½Ã‡ÂµÃ¥ ÃÂ¦Â³Ã—Â·Â¹Ã€ÃŒÃ…Ã, Â±Ã—Â·Â¹Ã€ÃŒÃ†Â® Â¸Ã…ÃÃ· ÃÂ¦Â³Ã—Â·Â¹Ã€ÃŒÃ…Ã, Â°Â¡ÂµÃ¥Ã…Â¸Â¿Ã¶ÂµÃ®ÂµÃ®)
	CreateCrusadeStructures();
	
	PutLogList("(!)Crusade Mode ON.");
	_bCrusadeLog(DEF_CRUSADELOG_STARTCRUSADE, NULL, NULL, NULL);
}

void CGame::LocalEndCrusadeMode(int iWinnerSide)
{
 int i;

	//testcode
	wsprintf(G_cTxt, "LocalEndCrusadeMode(%d)", iWinnerSide);
	PutLogList(G_cTxt);

	if (m_bIsCrusadeMode == FALSE) return;
	m_bIsCrusadeMode = FALSE;

	PutLogList("(!)Crusade Mode OFF.");

	// Â¼Â³Ã„Â¡ÂµÃ‡Â¾ÃºÂ´Ã¸ Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â°Ã‡ÃƒÃ Â¹Â° ÃÂ¦Â°Ã….
	RemoveCrusadeStructures();

	RemoveCrusadeNpcs();

	// Ã€ÃŒÂ±Ã¤Ã‚ÃŠ Â»Ã§Ã€ÃŒÂµÃ¥Â¸Â¦ Ã€Ã”Â·Ã‚.
	_CreateCrusadeGUID(m_dwCrusadeGUID, iWinnerSide);
	m_iCrusadeWinnerSide = iWinnerSide;
	m_iLastCrusadeWinner = iWinnerSide;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
		// Â¸Ã°ÂµÃ§ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â¿Â¡Â°Ã” Ã€Ã¼Â¸Ã©Ã€Ã¼ Â¸Ã°ÂµÃ¥Â°Â¡ Â³Â¡Â³ÂµÃ€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™. Â¸ÃƒÃ€Âº Ã€Ã“Â¹Â« Ã…Â¬Â¸Â®Â¾Ã® ÃˆÃ„ Ã…Ã«ÂºÂ¸Ã‡Ã”.
		m_pClientList[i]->m_iCrusadeDuty = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;
		SendNotifyMsg(NULL, i, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, NULL, NULL, m_iCrusadeWinnerSide);
	}
	RemoveCrusadeRecallTime();

	if (iWinnerSide == 2) {
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, FALSE, FALSE, "Elvine Win!");
	}
	else if (iWinnerSide == 1) {
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, FALSE, FALSE, "Aresden Win!");
	}
	else{
		_bCrusadeLog(DEF_CRUSADELOG_ENDCRUSADE, FALSE, FALSE, "Drawn!");
	}

	if (m_iMiddlelandMapIndex != -1) {
		//bSendMsgToLS(0x3D00123C, 0, TRUE, NULL);
	}
}


void CGame::SaveOccupyFlagData()
{
 char * pData;
 int iSize;
 FILE * pFile;

	PutLogList("(!) Middleland OccupyFlag data saved.");
		
	pData = new char[1000000+1];
	if (pData == NULL) return;
	ZeroMemory(pData, 1000000);
			
	iSize = _iComposeFlagStatusContents(pData);
	
	_mkdir("GameData");

	pFile = fopen("GameData\\OccupyFlag.txt", "wt");
	if (pFile == NULL) return;

	fwrite(pData, 1, iSize, pFile);

	delete pData;
	fclose(pFile);
}


void CGame::CreateCrusadeStructures()
{
 int i, z, tX, tY, iNamingValue;
 char cName[6], cNpcName[21], cNpcWayPoint[11];

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
	if (m_stCrusadeStructures[i].cType != NULL) {
		for (z = 0; z < DEF_MAXMAPS; z++)
		if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stCrusadeStructures[i].cMapName) == 0)) {
			// Ã€Â§Ã„Â¡Â°Â¡ Ã€ÃÃ„Â¡Ã‡ÃÂ´Ã‚ Â¸ÃŠÂ¿Â¡ Â°Ã‡ÃƒÃ Â¹Â°Ã€Â» Ã€Â§Ã„Â¡Â½ÃƒÃ…Â²Â´Ã™.
			iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// Â´ÃµÃ€ÃŒÂ»Ã³ Ã€ÃŒ Â¸ÃŠÂ¿Â¡ NPCÂ¸Â¦ Â¸Â¸ÂµÃ©Â¼Ã¶ Â¾Ã¸Â´Ã™. Ã€ÃŒÂ¸Â§Ã€Â» Ã‡Ã’Â´Ã§Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â±Ã¢ Â¶Â§Â¹Â®.
				// Ã€ÃŒÂ·Â± Ã€ÃÃ€ÃŒ?
			}
			else {
				// NPCÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = z+65;
				
				switch (m_stCrusadeStructures[i].cType) {
				case 36:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "AGT-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "AGT-Elvine");
					break;

				case 37: 
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "CGT-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "CGT-Elvine");
					break;

				case 40:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "ESG-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "ESG-Elvine");
					break;

				case 41:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "GMG-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "GMG-Elvine");
					break;

				case 42:
					strcpy(cNpcName, "ManaStone");
					break;

				default: 
					strcpy(cNpcName, m_pNpcConfigList[m_stCrusadeStructures[i].cType]->m_cNpcName); 
					break;
				}

				tX = (int)m_stCrusadeStructures[i].dX;
				tY = (int)m_stCrusadeStructures[i].dY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
					// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â¿Â¹Â¾Ã ÂµÃˆ NameValueÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
					m_pMapList[z]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					wsprintf(G_cTxt, "(!) Creating Crusade Structure(%s) at %s(%d, %d)", cNpcName, m_stCrusadeStructures[i].cMapName, tX, tY);
					PutLogList(G_cTxt);
				}
			}
		}
	}
}

void CGame::RequestSetGuildConstructLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
 char * cp, cData[120];
 register int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

	// Â°Ã”Ã€ÃŒÃ†Â® Â¼Â­Â¹Ã¶ Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã›Â¼Âº 
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDCONSTRUCTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;
	
	memcpy(cp, pMapName, 10);
	cp += 10;
	//

	dwTime = timeGetTime();

	//testcode
	wsprintf(G_cTxt, "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	// Â¸Ã•Ã€Ãº Â°Â°Ã€Âº GUIDÂ¸Â¦ Â°Â¡ÃÃ¸ Â±Ã¦ÂµÃ¥ Ã„ÃÂ½ÂºÃ†Â®Â·Â°Ã†Â® ÃÃ‚Ã‡Â¥Â°Â¡ Â¼Â³ÃÂ¤ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã‚ÃÃ¶ ÃƒÂ£Â´Ã‚Â´Ã™. 
	// Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® Ã€Â§Ã„Â¡Ã€Ã‡ 2Â¹Ã¸ ÂºÂ¯Â¼Ã¶ÂµÃ©Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã‘Â´Ã™.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// Ã€ÃŒÂ¹ÃŒ Â±Ã¦ÂµÃ¥Â°Â¡ Ã€Ã–Â´Ã™.
		if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
			// Â³Â»Â¿Ã«Ã€ÃŒ Ã€ÃÃ„Â¡Ã‡Ã‘Â´Ã™. Ã…Â¸Ã€Ã“ Ã€Ã”Â·Ã‚ÃˆÃ„ Â½ÂºÃ…Âµ.
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// Â³Â»Â¿Ã« Â°Â»Â½Ã…ÃˆÃ„ 
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				
			//Â°Ã”Ã€ÃŒÃ†Â® Â¼Â­Â¹Ã¶Â¸Â¦ Ã…Ã«Ã‡Ã˜ Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Â·Ã ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã›
			bStockMsgToGateServer(cData, 23);
			return;
		}
	}
	
	// Â¼Â³ÃÂ¤ÂµÃˆ Â³Â»Â¿Ã«Ã€ÃŒ Â¾Ã¸Â´Ã™. Â»ÃµÂ·Ã Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

			//Â°Ã”Ã€ÃŒÃ†Â® Â¼Â­Â¹Ã¶Â¸Â¦ Ã…Ã«Ã‡Ã˜ Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Â·Ã ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã›  
			bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			// Â°Â¡Ã€Ã¥ Â¿Ã€Â·Â§ÂµÂ¿Â¾Ãˆ Ã‚Ã¼ÃÂ¶ÂµÃ‡ÃÃ¶ Â¾ÃŠÃ€Âº Â¸Â®Â½ÂºÃ†Â®Ã€Ã‡ Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ ÃƒÂ£Â´Ã‚Â´Ã™.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	// Ã„Â³Â½Ãƒ Â°Ã¸Â°Â£Ã€ÃŒ Â´Ã™ ÃƒÂ¡Â´Ã™. Ã€ÃŒÂ·Â± Â°Ã¦Â¿Ã¬ Â¸Â®Â½ÂºÃ†Â® ÃÃŸ Â°Â¡Ã€Ã¥ Â¿Ã€Â·Â§ÂµÂ¿Â¾Ãˆ Â»Ã§Â¿Ã«Ã‡ÃÃÃ¶ Â¾ÃŠÃ€Âº Â¸Â®Â½ÂºÃ†Â®(iIndex)Â¸Â¦ Â»Ã¨ÃÂ¦Ã‡ÃÂ°Ã­ Â¾Ã·ÂµÂ¥Ã€ÃŒÃ†Â® Ã‡Ã‘Â´Ã™.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstructLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

	//Â°Ã”Ã€ÃŒÃ†Â® Â¼Â­Â¹Ã¶Â¸Â¦ Ã…Ã«Ã‡Ã˜ Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Â·Ã ÃÂ¤ÂºÂ¸ Ã€Ã¼Â¼Ã›
	bStockMsgToGateServer(cData, 23);
}

// New 14/05/2004 Changed
void CGame::RequestSummonWarUnitHandler(int iClientH, int dX, int dY, char cType, char cNum, char cMode)
{
 char cName[6], cNpcName[21], cMapName[11], cNpcWayPoint[11], cOwnerType;
 register int i, x;
 int iNamingValue, tX, tY, ix, iy;
 BOOL bRet;
 short sOwnerH;
 DWORD dwTime = timeGetTime();
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cMapName, sizeof(cMapName));
		
	// Â¿Â¡Â·Â¯ ÃƒÂ¼Ã…Â©Â¿Ã« 
	if (cType < 0) return;
	if (cType >= DEF_MAXNPCTYPES) return;
	if (cNum  >  10) return;

	// Â°Ã‡Â¼Â³Ã‡ÃÂ±Ã¢Â¿Â¡ Ã†Ã·Ã€ÃÃ†Â®Â°Â¡ Â¸Ã°Ã€ÃšÂ¶ÃµÂ´Ã™.
	if (m_pClientList[iClientH]->m_iConstructionPoint < m_iNpcConstructionPoint[cType]) return;
	// Â°Ã‡Â¹Â° Â³Â»ÂºÃÂ¸Ã© Ã€Ã¼Ã€Ã¯ Ã€Â¯Â´ÃÃ†Â® Â¼Ã’ÃˆÂ¯ ÂºÃ’Â°Â¡.
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE)) return; 

	// Ã€ÃÂ´Ãœ Â¿Â¡Â·Â¯Â¹Ã¦ÃÃ¶Â¿Ã«
	cNum = 1;

	// ConstructionPoint ÃÂ¦Ã‡Ã‘Ã€Â» Â°Ã¨Â»ÃªÃ‡ÃÂ°Ã­ Ã€Â¯Â´ÃÃ†Â® Â°Â³Â¼Ã¶Â¸Â¸Ã…Â­ ÃÃ™Ã€ÃÂ´Ã™.
	for (x = 1; x <= cNum; x++) {
		// Â°Â³Â¼Ã¶Â¸Â¸Ã…Â­  Ã€Ã¼Ã€Ã¯ Ã€Â¯Â´ÃÃ†Â® Â»Ã½Â¼Âº 
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {
			// Â´ÃµÃ€ÃŒÂ»Ã³ Ã€ÃŒ Â¸ÃŠÂ¿Â¡ NPCÂ¸Â¦ Â¸Â¸ÂµÃ©Â¼Ã¶ Â¾Ã¸Â´Ã™. Ã€ÃŒÂ¸Â§Ã€Â» Ã‡Ã’Â´Ã§Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â±Ã¢ Â¶Â§Â¹Â®.
			// Ã€ÃŒÂ·Â± Ã€ÃÃ€ÃŒ?
		}
		else {
			// NPCÂ¸Â¦ Â»Ã½Â¼ÂºÃ‡Ã‘Â´Ã™.
			ZeroMemory(cName, sizeof(cName));
			wsprintf(cName, "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
			
			// ÂµÂ¿Ã€ÃÃ‡Ã‘ Ã…Â¸Ã€Ã”Ã€Â» Â°Â®ÃÃ¶Â¸Â¸ Â´Ã™Â¸Â¥ Â»Ã§Ã€ÃŒÂµÃ¥Â¸Â¦ Â°Â®Â´Ã‚ Â°Ã¦Â¿Ã¬ 

			switch (cType) {
			case 43: // Light War Beetle
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "LWB-Aresden"); break;
				case 2: strcpy(cNpcName, "LWB-Elvine"); break;
				}
				break;

			case 36: // Arrow Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "AGT-Aresden"); break;
				case 2: strcpy(cNpcName, "AGT-Elvine"); break;
				}
				break;

			case 37: // Cannon Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CGT-Aresden"); break;
				case 2: strcpy(cNpcName, "CGT-Elvine"); break;
				}
				break;

			case 38: // Mana Collector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "MS-Aresden"); break;
				case 2: strcpy(cNpcName, "MS-Elvine"); break;
				}
				break;

			case 39: // Detector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "DT-Aresden"); break;
				case 2: strcpy(cNpcName, "DT-Elvine"); break;
				}
				break;

			case 51: // Catapult
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CP-Aresden"); break;
				case 2: strcpy(cNpcName, "CP-Elvine"); break;
				}
				break;

			case 44:
				strcpy(cNpcName, "GHK");
				break;

			case 45:
				strcpy(cNpcName, "GHKABS");
				break;

			case 46:
				strcpy(cNpcName, "TK");
				break;

			case 47:
				strcpy(cNpcName, "BG");
				break;

			case 82:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "Sor-Aresden"); break;
					case 2: strcpy(cNpcName, "Sor-Elvine"); break;
				}
				break;

			case 83:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "ATK-Aresden"); break;
					case 2: strcpy(cNpcName, "ATK-Elvine"); break;
				}
				break;

			case 84:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "Elf-Aresden"); break;
					case 2: strcpy(cNpcName, "Elf-Elvine"); break;
				}
				break;

			case 85:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "DSK-Aresden"); break;
					case 2: strcpy(cNpcName, "DSK-Elvine"); break;
				}
				break;

			case 86:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "HBT-Aresden"); break;
					case 2: strcpy(cNpcName, "HBT-Elvine"); break;
				}
				break;

			case 87:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "CT-Aresden"); break;
					case 2: strcpy(cNpcName, "CT-Elvine"); break;
				}
				break;

			case 88:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "Bar-Aresden"); break;
					case 2: strcpy(cNpcName, "Bar-Elvine"); break;
				}
				break;

			case 89:
				switch (m_pClientList[iClientH]->m_cSide) {
					case 1: strcpy(cNpcName, "AGC-Aresden"); break;
					case 2: strcpy(cNpcName, "AGC-Elvine"); break;
				}
				break;
			}

			//testcode
			wsprintf(G_cTxt, "(!) Request Summon War Unit (%d) (%s)", cType, cNpcName);
			PutLogList(G_cTxt);
			
			tX = (int)dX;
			tY = (int)dY;
						
			// Â¸Â¸Â¾Ã  Ã€Ã¼Ã€Ã¯ Â°Ã‡ÃƒÃ Â¹Â°Ã€ÃŒÂ¶Ã³Â¸Ã© Â°Ã‡ÃƒÃ  Ã€Â§Ã„Â¡Â·ÃÂºÃÃ…Ã Ã€ÃÃÂ¢Ã‡Ã˜Â¾ÃŸ Ã‡Ã‘Â´Ã™.
			bRet = FALSE;
			switch (cType) {
			case 36:
			case 37:
			case 38:
			case 39:
				// Â°Ã‡Â¼Â³ Ã€Â§Ã„Â¡Â¸Â¦ ÂºÃ±Â±Â³
				if (strcmp(m_pClientList[iClientH]->m_cConstructMapName, m_pClientList[iClientH]->m_cMapName) != 0) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sX - m_pClientList[iClientH]->m_iConstructLocX) > 10) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sY - m_pClientList[iClientH]->m_iConstructLocY) > 10) bRet = TRUE;

				if (bRet == TRUE) {
					// Â°Ã‡Â¼Â³ Ã€Â§Ã„Â¡Â¿Ã Â³ÃŠÂ¹Â« Â¸Ã–Â¸Â® Â¹Ã¾Â¾Ã®Â³Âª Ã€Ã–Ã€Â¸Â¸Ã© Â°Ã‡ÃƒÃ  ÂºÃ’Â°Â¡.
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 2, NULL, NULL, NULL);
					return;
				}

				// Â±Ã¦ÂµÃ¥Â¿Â¡Â¼Â­ Â°Ã‡Â¼Â³Ã‡Ã‘ Â°Ã‡ÃƒÃ Â¹Â°Ã€Ã‡ Â°Â¹Â¼Ã¶Â¸Â¦ Ã„Â«Â¿Ã®Ã†Â®Ã‡Ã‘Â´Ã™. Ã€ÃÃÂ¤ Â°Â¹Â¼Ã¶ Ã€ÃŒÂ»Ã³Ã€Âº ÃÃ¶Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.
				/////
				for (i = 0; i < DEF_MAXGUILDS; i++) 
				if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;
					if (m_pGuildTeleportLoc[i].m_iV2 >= DEF_MAXCONSTRUCTNUM) {
						// Â±Ã¦ÂµÃ¥ Â°Ã‡Â¼Â³ Â°Â³Â¼Ã¶ ÃƒÃŠÂ°Ãº. ÃÃ¶Ã€Â»Â¼Ã¶ Â¾Ã¸Â´Ã™.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);		
						return;
					}
					else {
						// Â°Ã‡Â¼Â³ÂµÃˆ Â°Ã‡Â¹Â° Â°Â¹Â¼Ã¶ ÃÃµÂ°Â¡.
						m_pGuildTeleportLoc[i].m_iV2++;
						goto RSWU_LOOPBREAK;
					}
				}

				// Â±Ã¦ÂµÃ¥ Â¼Â³ÃÂ¤ÂµÃ‡Â¾Ã® Ã€Ã–ÃÃ¶ Â¾ÃŠÃ€Â½. ÃÃ¶Ã€Â»Â¼Ã¶ Â¾Ã¸Â´Ã™.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
				return;
				/////
				break;
			case 43:
			case 44:
			case 45:
			case 46:
			case 47:
			case 51:
				break;

			case 40:
			case 41:
			case 42:
			case 48:
			case 49:
			case 50:
				break;
			}
			
RSWU_LOOPBREAK:;

			// Â¸Â¸Â¾Ã  Ã€Ã¼Ã€Ã¯ Â°Ã‡ÃƒÃ Â¹Â°ÃÃŸ Â°Â¡ÂµÃ¥Ã…Â¸Â¿Ã¶Â°Â°Ã€ÃŒ Â°Ã¸Â°ÃÃ‡Ã¼Ã€ÃŒÂ¶Ã³Â¸Ã© Â³ÃŠÂ¹Â« Ã€ÃÃÂ¢Ã‡Ã˜Â¼Â­ Â°Ã‡Â¼Â³Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
			bRet = FALSE;
			switch (cType) {
			case 36:
			case 37:
				for (ix = tX-2; ix <= tX+2; ix++)
				for (iy = tY-2; iy <= tY+2; iy++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC)) {
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 36:
						case 37:
							bRet = TRUE;
							break;
						}
					}
				}

				// ÃÃ¶Ã€Â» Â¼Ã¶ Â¾Ã¸Â´Ã‚ Â»Ã³Ã€Â§ÃÃ‚Ã‡Â¥
				if ((dY <= 32) || (dY >= 783)) bRet = TRUE;
				break;
			}

			if (bRet == TRUE) {
				// Â±Ã™ÃƒÂ³Â¿Â¡ Â°Â¡ÂµÃ¥Ã…Â¸Â¿Ã¶ÂµÃ©Ã€ÃŒ Ã€Ã–Â¾Ã®Â¼Â­ Â°Ã‡ÃƒÃ ÂºÃ’Â°Â¡.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 1, NULL, NULL, NULL);
				return;
			}

			// Â°Â¡ÂµÃ¥ Â¸Ã°ÂµÃ¥Ã€ÃÂ°Â¡ ÃƒÃŸÃÂ¾ Â¸Ã°ÂµÃ¥Ã€ÃÂ°Â¡ Â¼Â±Ã…Ãƒ 
			if (cMode == NULL) {
				bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_FOLLOW, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				bSetNpcFollowMode(cName, m_pClientList[iClientH]->m_cCharName, DEF_OWNERTYPE_PLAYER);
			}
			else bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_GUARD, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				
			if (bRet == FALSE) {
				// Â½Ã‡Ã†ÃÃ‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â¿Â¹Â¾Ã ÂµÃˆ NameValueÂ¸Â¦ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ…Â²Â´Ã™.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
			} 
			else {
				// Â°Ã‡Â¼Â³Â¿Â¡ Â¼ÂºÂ°Ã¸Ã‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Â°Ã‡Â¼Â³ Ã†Ã·Ã€ÃÃ†Â® Â°Â¨Â¼Ã’ Â½ÃƒÃ…Â²Â´Ã™.
				m_pClientList[iClientH]->m_iConstructionPoint -= m_iNpcConstructionPoint[cType];
				if (m_pClientList[iClientH]->m_iConstructionPoint < 0) m_pClientList[iClientH]->m_iConstructionPoint = 0;
				// ÃÃ¶ÃˆÃ–Â°Ã¼Â¿Â¡Â°Ã” Â¹Ã™Â·Ã Ã…Ã«ÂºÂ¸.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, NULL, NULL);
			}
		}
	}
}

void CGame::CheckConnectionHandler(int iClientH, char *pData)
{
 char * cp;
 DWORD * dwp, dwTimeRcv, dwTime, dwTimeGapClient, dwTimeGapServer;

	if (m_pClientList[iClientH] == NULL) return;
	//m_pClientList[iClientH]->m_cConnectionCheck = 0;

	dwTime = timeGetTime();
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	dwp = (DWORD *)cp;
	dwTimeRcv = *dwp;

	if (m_pClientList[iClientH]->m_dwInitCCTimeRcv == NULL) {
		m_pClientList[iClientH]->m_dwInitCCTimeRcv = dwTimeRcv;
		m_pClientList[iClientH]->m_dwInitCCTime = dwTime;
	}
	else {
		dwTimeGapClient = (dwTimeRcv - m_pClientList[iClientH]->m_dwInitCCTimeRcv);
		dwTimeGapServer = (dwTime - m_pClientList[iClientH]->m_dwInitCCTime);
		
		if (dwTimeGapClient < dwTimeGapServer) return;
		if ((abs(dwTimeGapClient - dwTimeGapServer)) >= (DEF_CLIENTTIMEOUT)) {
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
}

void CGame::SelectCrusadeDutyHandler(int iClientH, int iDuty)
{

	if (m_pClientList[iClientH] == NULL) return;
	if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (iDuty == 3)) return;

	if (m_iLastCrusadeWinner == m_pClientList[iClientH]->m_cSide &&
		m_pClientList[iClientH]->m_dwCrusadeGUID == 0 && iDuty == 3) {
			m_pClientList[iClientH]->m_iConstructionPoint = 3000;
	}
	m_pClientList[iClientH]->m_iCrusadeDuty = iDuty;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	if (iDuty == 1) 
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Fighter");
	else if (iDuty == 2) 
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Constructor");
	else
		_bCrusadeLog(DEF_CRUSADELOG_SELECTDUTY,iClientH,NULL,"Commander");
}

void CGame::MapStatusHandler(int iClientH, int iMode, char * pMapName)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iMode) {
	case 1:
		if (m_pClientList[iClientH]->m_iCrusadeDuty == NULL) return;

		for (i = 0; i < DEF_MAXGUILDS; i++) 
		if ((m_pGuildTeleportLoc[i].m_iV1 != NULL) && (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID)) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TCLOC, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY,
				          NULL, m_pGuildTeleportLoc[i].m_cDestMapName, m_pGuildTeleportLoc[i].m_sDestX2, m_pGuildTeleportLoc[i].m_sDestY2,
						  NULL, NULL, NULL, NULL, m_pGuildTeleportLoc[i].m_cDestMapName2);	
			// °Ç¼³ À§Ä¡¸¦ ÀúÀåÇØ ³õ´Â´Ù.
			ZeroMemory(m_pClientList[iClientH]->m_cConstructMapName, sizeof(m_pClientList[iClientH]->m_cConstructMapName));
			memcpy(m_pClientList[iClientH]->m_cConstructMapName, m_pGuildTeleportLoc[i].m_cDestMapName2, 10);
			m_pClientList[iClientH]->m_iConstructLocX = m_pGuildTeleportLoc[i].m_sDestX2;
			m_pClientList[iClientH]->m_iConstructLocY = m_pGuildTeleportLoc[i].m_sDestY2;
			return;
		}

		// ±æµå ¼Ò¼ÓÀÌ ¾Æ´Ñ ±ºÀÎÀÇ ¿äÃ»ÀÌ´Ù.
		break;

	case 3:
		//if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) return;
		// µ¥ÀÌÅÍ Ä³½Ã ±¸Á¶Ã¼ ÃÊ±âÈ­ 
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = NULL;
		}
		m_pClientList[iClientH]->m_iCSIsendPoint = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cSendingMapName, sizeof(m_pClientList[iClientH]->m_cSendingMapName));

		if (strcmp(pMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName) == 0) {
			// ÇöÀç »ç¿ëÀÚ°¡ À§Ä¡ÇÑ ¸ÊÀÇ Á¤º¸¸¦ ¿ä±¸Çß´Ù.
			// ¸Ê µ¥ÀÌÅÍ¸¦ ¿äÃ»ÇÒ ´ç½ÃÀÇ ³»¿ëÀ» ±×´ë·Î Ä«ÇÇÇÑ´Ù.
			for (i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures; i++) {
				// v2.15 »ç¿ëÀÚ°¡ Commander °¡ ¾Æ´Ï¾îµµ °Ç¹°ÀÇ À§Ä¡¸¦ º¸¿©ÁØ´Ù.
				if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
				else if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType == 42) 
				{
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
				}
			}
			memcpy(m_pClientList[iClientH]->m_cSendingMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 10);
		}
		else {
			// ´Ù¸¥ ¸ÊÀÇ »óÈ²À» ¿äÃ»Çß´Ù. ¹Ìµé·£µåÀÇ °æ¿ì´Â °¡´É 
			if (strcmp(pMapName, "middleland") == 0) {
				for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
				// v2.15 »ç¿ëÀÚ°¡ Commander °¡ ¾Æ´Ï¾îµµ °Ç¹°ÀÇ À§Ä¡¸¦ º¸¿©ÁØ´Ù.
					if ( m_pClientList[iClientH]->m_iCrusadeDuty == 3) 
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}								
					else if (m_stMiddleCrusadeStructureInfo[i].cType == 42)
					{
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
						m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
					}
				}
				strcpy(m_pClientList[iClientH]->m_cSendingMapName, "middleland");
			}
			else {
				// ¾ÆÁ÷ Áö¿øµÇÁö ¾Ê´Â ±â´ÉÀÌ´Ù.
			}
		}
	
		_SendMapStatus(iClientH);
		break;
	}
}

void CGame::_SendMapStatus(int iClientH)
{
 register int i, iDataSize;
 char *cp, cData[DEF_MAXCRUSADESTRUCTURES*6];
 short * sp;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);

	memcpy(cp, m_pClientList[iClientH]->m_cSendingMapName, 10);
	cp += 10;
	
	sp = (short *)cp;
	*sp = (short)m_pClientList[iClientH]->m_iCSIsendPoint;
	cp += 2;

	// ÃƒÃ‘ Â¸Ã®Â°Â³Ã€Ã‡ ÂµÂ¥Ã€ÃŒÃ…ÃÂ°Â¡ Ã€Ã–Â´Ã‚ÃÃ¶ Â¾Ã‹Â¸Â®Â´Ã‚ Â°Ã· Â¶Ã§Â¿Ã².
	cp++;

	if (m_pClientList[iClientH]->m_iCSIsendPoint == NULL)
		m_pClientList[iClientH]->m_bIsSendingMapStatus = TRUE;

	// 100Â°Â³Â¾Â¿ ÃÂ¤ÂºÂ¸Â¸Â¦ ÂºÂ¸Â³Â½Â´Ã™.
	iDataSize = 0;
	for (i = 0 ; i < 100; i++) {
		if (m_pClientList[iClientH]->m_iCSIsendPoint >= DEF_MAXCRUSADESTRUCTURES) goto SMS_ENDOFDATA;
		if (m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType == NULL) goto SMS_ENDOFDATA;
		
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType;
		cp++;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sX;
		cp += 2;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sY;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cSide;
		cp++;

		iDataSize += 6;
		m_pClientList[iClientH]->m_iCSIsendPoint++;
	}

	// Â¿Â©Â±Ã¢Â±Ã®ÃÃ¶ Â¿Ã”Â´Ã™Â¸Ã© Â´Ãµ ÂºÂ¸Â³Â¾ Â¸ÃÂ½ÃƒÃÃ¶Â°Â¡ Ã€Ã–Â´Ã™Â´Ã‚ Ã€Ã‡Â¹ÃŒ.
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAPSTATUSNEXT, iDataSize +13, NULL, NULL, cData);
	return;

SMS_ENDOFDATA:;

	// ÂµÂ¥Ã€ÃŒÃ…ÃÂ°Â¡ Â´Ã™ Ã€Ã¼Â¼Ã› ÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Ã€Ã‡Â¹ÃŒ.
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAPSTATUSLAST, iDataSize +13, NULL, NULL, cData);
	m_pClientList[iClientH]->m_bIsSendingMapStatus = FALSE;

	return;
}


void CGame::RemoveCrusadeStructures()
{
 register int i;

	for (i = 0 ; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		switch (m_pNpcList[i]->m_sType) {
		case 36:
		case 37:
		case 38:
		case 39:
		case 40:
		case 41:
		case 42:
			DeleteNpc(i);
			break;
		}
	}
}

void CGame::RequestHelpHandler(int iClientH)
{
 // Ã‡Ã¯Ã‡Ã Â¿Ã¤ÃƒÂ»Ã€ÃŒÂ´Ã™. Â±Ã¦ÂµÃ¥ Â¸Â¶Â½ÂºÃ…ÃÂ¿Â¡Â°Ã” ÃÃ‚Ã‡Â¥Â¸Â¦ Ã€Ã¼Â´ÃÃ‡Ã˜ ÃÃ˜Â´Ã™.
 register int i;	

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iGuildRank == -1) return;
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 1) return;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildRank == 0) && 
		(m_pClientList[i]->m_iCrusadeDuty == 3) && (m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
		// Â°Â°Ã€Âº Â±Ã¦ÂµÃ¥ Â¸Â¶Â½ÂºÃ…ÃÃ€ÃŒÂ°Ã­ ÃÃ¶ÃˆÃ–Â°Ã¼ Â¿ÂªÃˆÂ°Ã€Â» Â¸ÃƒÃ€Âº Â»Ã³Ã…Ã‚Ã€ÃŒÂ´Ã™.
		SendNotifyMsg(NULL, i, DEF_NOTIFY_HELP, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_iHP, m_pClientList[iClientH]->m_cCharName);
		return;
	}

	// Ã‡Ã¶Ã€Ã§ Â¸ÃŠÂ¿Â¡ ÃÃ¶ÃˆÃ–Â°Ã¼Ã€ÃŒ Â¾Ã¸Ã€Â½Ã€Â» Ã…Ã«ÂºÂ¸Ã‡Ã˜ ÃÃ˜Â´Ã™.
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELPFAILED, NULL, NULL, NULL, NULL);
}


BOOL CGame::bStockMsgToGateServer(char *pData, DWORD dwSize)
{
 char * cp;

	//testcode
	//wsprintf(G_cTxt, "StockMsg(%d) Size(%d)", *pData, dwSize);
	//PutLogList(G_cTxt);

	if ((m_iIndexGSS + dwSize) >= DEF_MAXGATESERVERSTOCKMSGSIZE-10) return FALSE;

	cp = (char *)(m_cGateServerStockMsg + m_iIndexGSS);	
	memcpy(cp, pData, dwSize);

	m_iIndexGSS += dwSize;

	return TRUE;
}


void CGame::SendStockMsgToGateServer()
{
 DWORD * dwp;
 WORD * wp;
 char * cp;

	// Â±Ã—ÂµÂ¿Â¾Ãˆ Â¸Ã°Â¾Ã†Â³ÃµÂ¾Ã’Â´Ã¸ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Â°Ã”Ã€ÃŒÃ†Â® Â¼Â­Â¹Ã¶Â·Ã Ã€Ã¼Â¼Ã›.
	if (m_iIndexGSS > 6) {
		//testcode
		//wsprintf(G_cTxt, "(!) Sending Gate Server Stock Msg(%d)", m_iIndexGSS);
		//PutLogList(G_cTxt);

		SendMsgToGateServer(MSGID_SERVERSTOCKMSG, NULL, m_cGateServerStockMsg);
	
		// Â¹Ã¶Ã†Ã› Ã…Â¬Â¸Â®Â¾Ã®
		ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
		// Â¸Ã‡ Â¾Ã•ÂºÃÂºÃÂ¿Â¡ Â¸ÃÂ½ÃƒÃÃ¶ Â»Ã°Ã€Ã”
		cp = (char *)m_cGateServerStockMsg;
		dwp = (DWORD *)cp;
		*dwp = MSGID_SERVERSTOCKMSG;
		cp += 4;
		wp = (WORD *)cp;
		*wp = DEF_MSGTYPE_CONFIRM;
		cp += 2;

		m_iIndexGSS = 6;
	}
}

void CGame::ServerStockMsgHandler(char *pData)
{
 char * cp, * cp2, cTemp[120], cLocation[10], cGuildName[20], cName[11], cTemp2[120], cTemp3[120], cMapName[11], cBuffer[256]; short * sp;
 WORD * wp, wServerID, wClientH, wV1, wV2, wV3, wV4, wV5;
 DWORD * dwp;
 BOOL bFlag = FALSE;
 int * ip, i, iTotal, iV1, iV2, iV3, iRet;
 short sX, sY;

	iTotal = 0;
	cp = (char *)(pData + 6);
	while (bFlag == FALSE) {
		iTotal++;
		switch (*cp) {
		
		case GSM_REQUEST_SUMMONGUILD:
			cp++;
			ZeroMemory(cGuildName, sizeof(cGuildName));
			memcpy(cGuildName, cp, 20);
			cp += 20;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			cp2 = (char *) cTemp + 10;
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp = (WORD *)cp;
			wV2 = *wp;
			cp += 2;

			for (i = 0; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cGuildName, cGuildName) == 0)) {
			RequestTeleportHandler(i, "2   ", cTemp, wV1, wV2);
			}
			break;

		// v2.14 Â¼ÂºÃˆÃ„Â´Ã ÃƒÃŸÂ°Â¡ Ã€Â¯Ã€Ãº Â¼Ã’ÃˆÂ¯ 
		case GSM_REQUEST_SUMMONPLAYER:
			cp++;
			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			cp2 = (char *) cTemp + 10 ;
			
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
					//wsprintf(G_cTxt, "%s %d %d", cTemp, wV1, wV2);
					//PutLogFileList(G_cTxt);					
					RequestTeleportHandler(i, "2   ", cTemp ,wV1, wV2);
					break;
				}
			break;
		
		case GSM_REQUEST_SUMMONALL:
			cp++;
			ZeroMemory(cLocation, sizeof(cLocation));
			memcpy(cLocation, cp, 10);
			cp += 10;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			cp2 = (char *) cTemp + 10;
			
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			
			for (i = 0; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cLocation, cLocation) == 0)) {
			RequestTeleportHandler(i, "2   ", cTemp, wV1, wV2);
		}
		break;

		case GSM_CHATMSG:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			ZeroMemory(cName, sizeof(cName));
			iV1 = *cp;
			cp++;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			memcpy(cName, cp, 10);
			cp += 10;;
			sp = (short *)cp;
			wV1 = (WORD)*sp;
			cp += 2;
			ChatMsgHandlerGSM(iV1, iV2, cName, cp, wV1);
			cp += wV1;
			break;
		
		case GSM_CONSTRUCTIONPOINT:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			GSM_ConstructionPoint(iV1, iV2);
			break;

		case GSM_SETGUILDTELEPORTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildTeleportLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_SETGUILDCONSTRUCTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildConstructLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_REQUEST_SETFORCERECALLTIME:
			cp++;
			wp = (WORD *)cp;
			m_sForceRecallTime = *wp;
			cp += 2;

			wsprintf(G_cTxt,"(!) Game Server Force Recall Time (%d)min",m_sForceRecallTime) ;
			PutLogList(G_cTxt) ;
			break;

		case GSM_MIDDLEMAPSTATUS:
			cp++;
			// Â±Â¸ÃÂ¶ÃƒÂ¼ Ã…Â¬Â¸Â®Â¾Ã®
			for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = NULL;
				m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
				m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
				m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
			}
			sp = (short *)cp;
			m_iTotalMiddleCrusadeStructures = *sp;
			cp += 2;
			// ÃÂ¤ÂºÂ¸ Ã€ÃÂ¾Ã®ÂµÃ©Ã€ÃÂ´Ã™.
			for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = *cp;
				cp++;
				m_stMiddleCrusadeStructureInfo[i].cSide = *cp;
				cp++;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sX = *sp;
				cp += 2;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sY = *sp;
				cp += 2;	
			}
			break;
		
		case GSM_BEGINCRUSADE:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartCrusadeMode(*dwp);
			break;

		case GSM_BEGINAPOCALYPSE:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartApocalypse(*dwp);
			break;

		case GSM_STARTHELDENIAN:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartHeldenianMode(wV1, wV2, *dwp);
			break;

		case GSM_ENDHELDENIAN:
			cp++;
			LocalEndHeldenianMode();
			break;
			
			/*case GSM_BEGINHELDENIEN:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartHeldenian(*dwp);
			break;
		
		case GSM_ENDHeldenian:
			cp++;
			LocalEndHeldenian(*dwp)//sub_4ABCD0(*dwp);
			break;*/

		case GSM_UPDATECONFIGS:
			cp++;
			LocalUpdateConfigs(*cp);
			cp += 16;
			break;

		case GSM_ENDAPOCALYPSE:
			cp++;
			LocalEndApocalypse();
			break;

		case GSM_ENDCRUSADE:
			cp++;
			LocalEndCrusadeMode(*cp);
			cp += 16;
			break;

		case GSM_COLLECTEDMANA:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			CollectedManaHandler(wV1, wV2);
			break;

		case GSM_GRANDMAGICLAUNCH:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;

			switch (wV1) {
			case 1: // Â¸ÃÃ…Ã—Â¿Ã€ Â½ÂºÃ†Â®Â¶Ã³Ã€ÃŒÃ…Â© 
				MeteorStrikeMsgHandler((char)wV2);
				break;
			}
			break;
		
		case  GSM_GRANDMAGICRESULT:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV3 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV4 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV5 = *wp;

			GrandMagicResultHandler(cTemp, wV1, wV2, wV3, wV4, wV5, cp);
			break;
		
			// v2.15 2002-5-21
		case GSM_REQUEST_SHUTUPPLAYER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			GSM_RequestShutupPlayer(cTemp,wServerID,wClientH, wV1, cName);
			break ;

		case GSM_RESPONSE_SHUTUPPLAYER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cName, sizeof(cName));
			memcpy(cName, cp, 10);
			cp += 10;

			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;


			if (wServerID == m_wServerID_GSS) {
				if ((m_pClientList[wClientH] != NULL)&& (strcmp(m_pClientList[wClientH]->m_cCharName, cName) == 0)&&(m_pClientList[wClientH]->m_iAdminUserLevel > 0)) {
					SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_PLAYERSHUTUP, wV1, NULL, NULL, cTemp);

				}
			}
			break;

		// New 16/05/2004
		case GSM_WHISFERMSG:
			ZeroMemory(cName, sizeof(cName));
			ZeroMemory(cBuffer, sizeof(cBuffer));
			cp++;
			memcpy(cName, cp, 10);
			cp += 10;
			wp = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			memcpy(cBuffer, cp, wV1);
			cp += wV1;

			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(cBuffer, wV1);
					if(	m_pClientList[i]->m_iAdminUserLevel > 0) {
						char cTxt[200],cTmpName[12] ;
						ZeroMemory(cTxt,sizeof(cTxt)) ;
						ZeroMemory(cTmpName,sizeof(cTmpName)) ;

						memcpy(cTmpName,cBuffer+10,10) ;
						wsprintf(cTxt,"PC Chat(%s):\"%s\"\tto GM(%s)",cTmpName,cBuffer+21,m_pClientList[i]->m_cCharName) ;
						bSendMsgToLS(MSGID_GAMEMASTERLOG, i, NULL, cTxt);
					}
					break;
				}
		break;

		// New 16/05/2004 Changed
		case GSM_REQUEST_FINDCHARACTER:
			cp++;

			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;

			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;

			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;

			GSM_RequestFindCharacter(wServerID, wClientH, cTemp, cTemp2);
			break;

		case GSM_RESPONSE_FINDCHARACTER:
			sX = -1;
			sY = -1;
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			ZeroMemory(cTemp2, sizeof(cTemp2));
			memcpy(cTemp2, cp, 10);
			cp += 10;

			ZeroMemory(cTemp3, sizeof(cTemp3));
			memcpy(cTemp3, cp, 14);

			if ((wServerID == m_wServerID_GSS) && m_pClientList[wClientH] != NULL) {
				if (m_pClientList[wClientH]->m_bIsAdminOrderGoto == TRUE) {
					m_pClientList[wClientH]->m_bIsAdminOrderGoto = FALSE;
					ZeroMemory(cMapName, sizeof(cMapName));
					memcpy(cMapName, cp, 10);
					cp += 10;

					wp = (WORD *)cp;
					sX = *wp;
					cp += 2;

					wp = (WORD *)cp;
					sY = *wp;
					cp += 2;

					if (m_pClientList[wClientH]->m_iAdminUserLevel > 0) {
						if(sX == -1 && sY == -1){
							wsprintf(G_cTxt,"GM Order(%s): GoTo MapName(%s)",m_pClientList[wClientH]->m_cCharName, cMapName);
						}
						else{
							wsprintf(G_cTxt,"GM Order(%s): GoTo MapName(%s)(%d %d)",m_pClientList[wClientH]->m_cCharName,
								cMapName, sX, sY);
						}
						bSendMsgToLS(MSGID_GAMEMASTERLOG, wClientH, FALSE, G_cTxt);
						RequestTeleportHandler(wClientH,"2   ", cMapName, sX, sY);
					}
				}
				else{
					if ((m_pClientList[wClientH]->m_bIsCheckingWhisperPlayer == TRUE) && (strcmp(m_pClientList[wClientH]->m_cWhisperPlayerName, cTemp) == 0)) {
						m_pClientList[wClientH]->m_iWhisperPlayerIndex = 10000;
						SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_WHISPERMODEON, NULL, NULL, NULL, m_pClientList[wClientH]->m_cWhisperPlayerName);
					}
					else{
						if (m_pClientList[wClientH]->m_iAdminUserLevel == 0) {
							ZeroMemory(cTemp3, sizeof(cTemp3));
						}
						if (strcmp(m_pClientList[wClientH]->m_cCharName, cTemp2) == 0) {
							SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_PLAYERONGAME, NULL, NULL, NULL, cTemp,
								NULL, NULL, NULL, NULL, NULL, NULL, cTemp3);
						}
					}
				}
			}
			break;

		default:
			bFlag = TRUE;
			break;
		}
	}

	//testcode
	//wsprintf(G_cTxt, "(!) Total %d GSM Messages.", iTotal-1);
	//PutLogList(G_cTxt);
}

void CGame::GSM_RequestFindCharacter(WORD wReqServerID, WORD wReqClientH, char *pName, char * pFinder)
{
 char * cp, cTemp[120];
 WORD * wp;
 register int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL)  && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
		// ÃƒÂ£Â¾Ã’Â´Ã™.
		ZeroMemory(cTemp, sizeof(cTemp));
		cp = (char *)(cTemp);
		*cp = GSM_RESPONSE_FINDCHARACTER;
		cp++;

		wp = (WORD *)cp;
		*wp = wReqServerID;
		cp += 2;

		wp = (WORD *)cp;
		*wp = wReqClientH;
		cp += 2;
		
		memcpy(cp, pName, 10);
		cp += 10;

		memcpy(cp, pFinder, 10);
		cp += 10;

		memcpy(cp, m_pClientList[i]->m_cMapName, 10);
		cp += 10;

		wp = (WORD *)cp;
		*wp = m_pClientList[i]->m_sX;
		cp += 2;

		wp = (WORD *)cp;
		*wp = m_pClientList[i]->m_sY;
		cp += 2;

		bStockMsgToGateServer(cTemp, 39);
		return;	
	}
}

// New 11/05/2004 Changed
void CGame::DoMeteorStrikeDamageHandler(int iMapIndex)
{
 int i, iDamage;

	// Ã‡Ã˜Â´Ã§ Â¸ÃŠÃ€Ã‡ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®ÂµÃ©Ã€Ã‡ HPÂ¸Â¦ Ã€ÃÂ°Ã½ Â»Ã¨Â°Â¨
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_cSide != 0) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
		if (m_pClientList[i]->m_iLevel < 80) 
			 iDamage = m_pClientList[i]->m_iLevel   +iDice(1,10);
		else iDamage = m_pClientList[i]->m_iLevel*2 +iDice(1,10);
		iDamage = iDice(1, m_pClientList[i]->m_iLevel) + m_pClientList[i]->m_iLevel;
		// ÃƒÃ–Â´Ã« 255Ã€ÃŒÂ»Ã³Ã€Ã‡ Â´Ã«Â¹ÃŒÃÃ¶Â´Ã‚ Â¹ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
		if (iDamage > 255) iDamage = 255;
	
		if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) { //magic cut in half
			iDamage = (iDamage/2) - 2;
		}

		if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 5) { 
			iDamage = 0;
		}
		
		if (m_pClientList[i]->m_iAdminUserLevel > 0) { // Admins get no damage
			iDamage = 0;
		}

		m_pClientList[i]->m_iHP -= iDamage;
		if (m_pClientList[i]->m_iHP <= 0) {
			// Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â»Ã§Â¸ÃÃ‡ÃŸÂ´Ã™.
			ClientKilledHandler(i, NULL, NULL, iDamage);	
			m_stMeteorStrikeResult.iCasualties++;
		}
		else {
			if (iDamage > 0) {
				// Â¹ÃÃ€Âº Â´Ã«Â¹ÃŒÃÃ¶Â¸Â¦ Ã…Ã«ÂºÂ¸Ã‡Ã‘Â´Ã™. <- HPÂ¸Â¦ Â±Ã—Â´Ã«Â·Ã Â¾Ã‹Â¸Â°Â´Ã™.
				SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				// ÃƒÃ¦Â°ÃÃ€Â» Â¹ÃÂ¾Ã’Â´Ã™Â¸Ã© ÃƒÃ¦Â°ÃÂµÂ¿Ã€Ã› Ã€Ã¼Â¼Ã› 
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

				// v1.4 ÃÃ—Ã€ÂºÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Â°Ã¦Â¿Ã¬Â´Ã‚ Owner Ã€Â§Ã„Â¡Â¸Â¦ Â¿Ã…Â±Ã¤Â´Ã™. 
				if (m_pClientList[i]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				}
			
				if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person ÂµÃ‡Â¾Ã® Ã€Ã–Â¾ÃºÂ´Ã¸ Â»Ã³Ã…Ã‚Â¶Ã³Â¸Ã© Ã‡Â®Â¸Â°Â´Ã™. Â¸Â¶Â¹Ã½Â°Ã¸Â°Ã Ã†ÃÂ·Â²Â¶Ã³Ã€ÃŒÃÃ® ÂµÃˆ Â°ÃÂµÂµ Ã‡Â®Â¸Â°Â´Ã™.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
					m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}		
	}
}

void CGame::SyncMiddlelandMapInfo()
{
 int i;
 char * cp;
 short * sp;

	// ¹Ìµé·£µåÀÇ Á¤º¸¸¦ ¸ğµç ¼­¹ö¿¡°Ô ½ÌÅ©½ÃÅ²´Ù. ¹Ìµé·£µå¸¦ ´ã´çÇÑ ¼­¹ö¶ó¸é ¹Ù·Î ±¸Á¶Ã¼¸¦ ¾÷µ¥ÀÌÆ® ÇÏ°í ³ª¸ÓÁö ¼­¹öµé¿¡°Ô Á¤º¸ Àü¼Û.
	if (m_iMiddlelandMapIndex != -1) {
		// ±¸Á¶Ã¼ Å¬¸®¾î
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = NULL;
			m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
			m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
			m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
		}
		// ±¸Á¶Ã¼ º¹»ç ¹× Àü¼Û ¸Ş½ÃÁö ÀÛ¼º 
		m_iTotalMiddleCrusadeStructures = m_pMapList[m_iMiddlelandMapIndex]->m_iTotalCrusadeStructures;
		ZeroMemory(G_cData50000, sizeof(G_cData50000));
		cp = (char *)G_cData50000;
		*cp = GSM_MIDDLEMAPSTATUS;
		cp++;

		sp = (short *)cp;
		*sp = (short)m_iTotalMiddleCrusadeStructures;
		cp += 2;
				
		for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cType;
			m_stMiddleCrusadeStructureInfo[i].cSide = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cSide;
			m_stMiddleCrusadeStructureInfo[i].sX    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sX;
			m_stMiddleCrusadeStructureInfo[i].sY    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sY;
			
			*cp = m_stMiddleCrusadeStructureInfo[i].cType;
			cp++;
			*cp = m_stMiddleCrusadeStructureInfo[i].cSide;
			cp++;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sX;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sY;
			cp += 2;
		}
		
		// ¸Ş½ÃÁö ½ºÅå.
		if (m_iTotalMiddleCrusadeStructures != 0) {
			//testcode
			//wsprintf(G_cTxt, "m_iTotalMiddleCrusadeStructures: %d", m_iTotalMiddleCrusadeStructures);
			//PutLogList(G_cTxt);
			bStockMsgToGateServer(G_cData50000, 3 + m_iTotalMiddleCrusadeStructures*6);
		}
	}
}

void CGame::GSM_SetGuildConstructLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
 int i, iIndex;
 DWORD dwTemp, dwTime;

	// Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®Â·ÃÂºÃÃ…ÃÃ€Ã‡ Â¿Ã¤ÃƒÂ»Ã€ÃŒ Â¾Ã†Â´ÃÂ¶Ã³ Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Â·ÃÂºÃÃ…ÃÃ€Ã‡ Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® ÃÃ‚Ã‡Â¥ Â¼Â³ÃÂ¤ Â¿Ã¤ÃƒÂ»Ã€Ã“. Ã€Ã€Â´Ã¤Ã‡Ã’ Ã‡ÃŠÂ¿Ã¤ Â¾Ã¸Ã€Â½.
	
	//testcode
	wsprintf(G_cTxt, "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = timeGetTime();

	// Â¸Ã•Ã€Ãº Â°Â°Ã€Âº GUIDÂ¸Â¦ Â°Â¡ÃÃ¸ Â±Ã¦ÂµÃ¥ Ã…ÃšÂ·Â¹Ã†Ã·Ã†Â® ÃÃ‚Ã‡Â¥Â°Â¡ Â¼Â³ÃÂ¤ÂµÃ‡Â¾Ã® Ã€Ã–Â´Ã‚ÃÃ¶ ÃƒÂ£Â´Ã‚Â´Ã™.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// Ã€ÃŒÂ¹ÃŒ Â±Ã¦ÂµÃ¥Â°Â¡ Ã€Ã–Â´Ã™.
		if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
			// Â³Â»Â¿Ã«Ã€ÃŒ Ã€ÃÃ„Â¡Ã‡Ã‘Â´Ã™. Ã…Â¸Ã€Ã“ Ã€Ã”Â·Ã‚ÃˆÃ„ Â½ÂºÃ…Âµ.
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// Â³Â»Â¿Ã« Â°Â»Â½Ã…
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
	}
	
	// Â¼Â³ÃÂ¤ÂµÃˆ Â³Â»Â¿Ã«Ã€ÃŒ Â¾Ã¸Â´Ã™. Â»ÃµÂ·Ã Â¼Â³ÃÂ¤Ã‡Ã‘Â´Ã™.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// Â°Â¡Ã€Ã¥ Â¿Ã€Â·Â§ÂµÂ¿Â¾Ãˆ Ã‚Ã¼ÃÂ¶ÂµÃ‡ÃÃ¶ Â¾ÃŠÃ€Âº Â¸Â®Â½ÂºÃ†Â®Ã€Ã‡ Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ ÃƒÂ£Â´Ã‚Â´Ã™.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	// Ã„Â³Â½Ãƒ Â°Ã¸Â°Â£Ã€ÃŒ Â´Ã™ ÃƒÂ¡Â´Ã™. Ã€ÃŒÂ·Â± Â°Ã¦Â¿Ã¬ Â¸Â®Â½ÂºÃ†Â® ÃÃŸ Â°Â¡Ã€Ã¥ Â¿Ã€Â·Â§ÂµÂ¿Â¾Ãˆ Â»Ã§Â¿Ã«Ã‡ÃÃÃ¶ Â¾ÃŠÃ€Âº Â¸Â®Â½ÂºÃ†Â®(iIndex)Â¸Â¦ Â»Ã¨ÃÂ¦Ã‡ÃÂ°Ã­ Â¾Ã·ÂµÂ¥Ã€ÃŒÃ†Â® Ã‡Ã‘Â´Ã™.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstLocuct Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
}

void CGame::CheckCommanderConstructionPoint(int iClientH)
{
 char * cp, cData[120];
 int  * ip, i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_bIsCrusadeMode == FALSE) return;
	if (m_pClientList[iClientH]->m_iConstructionPoint <= 0) return;

	switch (m_pClientList[iClientH]->m_iCrusadeDuty) {
	case 1: // Ã†Ã„Ã€ÃŒÃ…Ã
	case 2: // Â°Ã‡Â¼Â³Ã€Ãš: Â¸Ã°Â¾Ã† Â³ÃµÃ€Âº Ã†Ã·Ã€ÃÃ†Â®Â¸Â¦ Â±Ã¦ÂµÃ¥Â¸Â¶Â½ÂºÃ…Ã ÃÃ¶ÃˆÃ–Â°Ã¼Â¿Â¡Â°Ã” Ã€Ã¼Â´ÃÃ‡Ã‘Â´Ã™.
		for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
			(m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
			// Ã‡Ã¶Ã€Ã§ Â¼Â­Â¹Ã¶ Â³Â»Â¿Â¡ Â±Ã¦ÂµÃ¥Â¸Â¶Â½ÂºÃ…Ã ÃÃ¶ÃˆÃ–Â°Ã¼Ã€ÃŒ Ã€Ã–Â´Ã™. ÃÃ¶ÃˆÃ–Â°Ã¼Ã€Ã‡ Ã†Ã·Ã€ÃÃ†Â®Â¸Â¦ Â³Ã´Ã€Ã ÃˆÃ„ 
			m_pClientList[i]->m_iConstructionPoint += m_pClientList[iClientH]->m_iConstructionPoint;
			m_pClientList[i]->m_iWarContribution   += (m_pClientList[iClientH]->m_iConstructionPoint / 10);

			if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
				m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
		
			if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
				m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

			SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
			m_pClientList[iClientH]->m_iConstructionPoint = 0; // Â°Âª ÃƒÃŠÂ±Ã¢ÃˆÂ­ 
			return;
		}

		// Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Ã€Ã‡ ÃÃ¶ÃˆÃ–Â°Ã¼Â¿Â¡Â°Ã” Â¾Ã‹Â·ÃÂ¾ÃŸ Ã‡Ã‘Â´Ã™.
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_CONSTRUCTIONPOINT;
		cp++;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iConstructionPoint;
		cp += 4;
		bStockMsgToGateServer(cData, 9);

		m_pClientList[iClientH]->m_iConstructionPoint = 0; // Â°Âª ÃƒÃŠÂ±Ã¢ÃˆÂ­ 
		break;

	case 3: // ÃÃ¶ÃˆÃ–Â°Ã¼: ÂºÂ¸Â³Â¾ Ã‡ÃŠÂ¿Ã¤ Â¾Ã¸Ã€Â½ 
		
		break;
	}
}

void CGame::GSM_ConstructionPoint(int iGuildGUID, int iPoint)
{
 int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
		(m_pClientList[i]->m_iGuildGUID == iGuildGUID)) {
		// Ã‡Ã˜Â´Ã§ Â±Ã¦ÂµÃ¥Â¸Â¶Â½ÂºÃ…Ã ÃÃ¶ÃˆÃ–Â°Ã¼Ã€Â» ÃƒÂ£Â¾Ã’Â´Ã™.
		m_pClientList[i]->m_iConstructionPoint += iPoint;
		m_pClientList[i]->m_iWarContribution   += iPoint/10;
		
		if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
			m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
		
		if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
			m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

		SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
		//testcode
		wsprintf(G_cTxt, "GSM_ConstructionPoint: %d %d", iGuildGUID, iPoint);
		PutLogList(G_cTxt);
		return;
	}
}

BOOL CGame::bAddClientShortCut(int iClientH)
{
 int i; 

	// Â¸Ã•Ã€Ãº ÂµÂ¿Ã€ÃÃ‡Ã‘ Â¹Ã¸ÃˆÂ£Â°Â¡ ÃÂ¸Ã€Ã§Ã‡ÃÂ´Ã‚ÃÃ¶ Â°Ã‹Â»Ã¶

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == iClientH) return FALSE;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == 0) {
		m_iClientShortCut[i] = iClientH;
		return TRUE;
	}

	return FALSE;
}

void CGame::RemoveClientShortCut(int iClientH)
{
 int i;

	for (i = 0; i < DEF_MAXCLIENTS+1; i++)
	if (m_iClientShortCut[i] == iClientH) {
		m_iClientShortCut[i] = 0;
		goto RCSC_LOOPBREAK;
	}

RCSC_LOOPBREAK:;

	// ÂºÃ³ Â¿Â©Â¹Ã©Ã€Â» Â¸ÃÂ²Ã›Â´Ã™.
	//m_iClientShortCut[i] = m_iClientShortCut[m_iTotalClients+1];
	//m_iClientShortCut[m_iTotalClients+1] = 0;
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_iClientShortCut[i] == 0) && (m_iClientShortCut[i+1] != 0)) {
		m_iClientShortCut[i] = m_iClientShortCut[i+1];
		m_iClientShortCut[i+1] = 0;
	}
}

void CGame::_CreateCrusadeGUID(DWORD dwCrusadeGUID, int iWinnerSide)
{
 char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;
		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));
	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"CrusadeGUID.Txt");
		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		// Ã†Ã„Ã€ÃÃ€Â» Â¸Â¸ÂµÃ© Â¼Ã¶ Â¾Ã¸Â°Ã…Â³Âª Â»Ã§Ã€ÃŒÃÃ®Â°Â¡ ÃÃ¶Â³ÂªÃ„Â¡Â°Ã” Ã€Ã›Ã€Âº Â°Ã¦Â¿Ã¬Â´Ã‚ . 
		wsprintf(cTxt, "(!) Cannot create CrusadeGUID(%d) file", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));
		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "CrusadeGUID = %d\n", dwCrusadeGUID);
		strcat(cTemp, cTxt);

		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);
		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		
		wsprintf(cTxt, "(O) CrusadeGUID(%d) file created", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}


BOOL CGame::bReadCrusadeGUIDFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶Ã€Ã‡ ÃƒÃŠÂ±Ã¢ÃˆÂ­ Ã†Ã„Ã€ÃÃ€Â» Ã€ÃÃ€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.
		PutLogList("(!) Cannot open CrusadeGUID file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading CrusadeGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwCrusadeGUID = atoi(token);
					wsprintf(G_cTxt, "CrusadeGUID = %d", m_dwCrusadeGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;

				case 2:
					// New 13/05/2004 Changed
					m_iLastCrusadeWinner = atoi(token);
					wsprintf(G_cTxt, "CrusadeWinnerSide = %d", m_iLastCrusadeWinner);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "CrusadeGUID", 11) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}
			
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CGame::ManualEndCrusadeMode(int iWinnerSide)
{
 char * cp, cData[256];
 WORD * wp;

	// Â¸Ã…Â´ÂºÂ¾Ã³Â·Ã Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ Â¸Ã°ÂµÃ¥Â¸Â¦ ÃÂ¾Â·Ã¡Â½ÃƒÃ…Â²Â´Ã™. ÂºÃ±Â±Ã¤ Â»Ã³Ã…Ã‚Â·Ã ÃÂ¾Â·Ã¡Â½ÃƒÃ…Â²Â´Ã™.
	if (m_bIsCrusadeMode == FALSE) return;

	LocalEndCrusadeMode(iWinnerSide);

	// Â´Ã™Â¸Â¥ Â¼Â­Â¹Ã¶Â¿Â¡ Ã…Â©Â·Ã§Â¼Â¼Ã€ÃŒÂµÃ¥ ÃÂ¾Â·Ã¡Â¸Â¦ Â¾Ã‹Â¸Â².
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp =  GSM_ENDCRUSADE;
	cp++;

	*cp = (char)iWinnerSide;
	cp++;			

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;
		
	cp += 10;

	bStockMsgToGateServer(cData, 18);
}

int CGame::iGetMapLocationSide(char *pMapName)
{

	if (strcmp(pMapName, "aresden") == 0) return 3;
	if (strcmp(pMapName, "elvine") == 0) return 4;
	if (strcmp(pMapName, "arebrk11") == 0) return 3;
	if (strcmp(pMapName, "elvbrk11") == 0) return 4;

	if (strcmp(pMapName, "cityhall_1") == 0) return 1;
	if (strcmp(pMapName, "cityhall_2") == 0) return 2;
	if (strcmp(pMapName, "cath_1") == 0) return 1;
	if (strcmp(pMapName, "cath_2") == 0) return 2;
	if (strcmp(pMapName, "gshop_1") == 0) return 1;
	if (strcmp(pMapName, "gshop_2") == 0) return 2;
	if (strcmp(pMapName, "bsmith_1") == 0) return 1;
	if (strcmp(pMapName, "bsmith_2") == 0) return 2;
	if (strcmp(pMapName, "wrhus_1") == 0) return 1;
	if (strcmp(pMapName, "wrhus_2") == 0) return 2;
	if (strcmp(pMapName, "gldhall_1") == 0) return 1;
	if (strcmp(pMapName, "gldhall_2") == 0) return 2;
	if (strcmp(pMapName, "wzdtwr_1") == 0) return 1;
	if (strcmp(pMapName, "wzdtwr_2") == 0) return 2;
	if (strcmp(pMapName, "arefarm") == 0) return 1;
	if (strcmp(pMapName, "elvfarm") == 0) return 2;
	if (strcmp(pMapName, "arewrhus") == 0) return 1;
	if (strcmp(pMapName, "elvwrhus") == 0) return 2;
	if (strcmp(pMapName, "cmdhall_1") == 0) return 1;
	if (strcmp(pMapName, "Cmdhall_2") == 0) return 2;

	return 0;
}

BOOL CGame::bCopyItemContents(CItem * pCopy, CItem *pOriginal)
{
	if (pOriginal == NULL) return FALSE;
	if (pCopy == NULL) return FALSE;
	
	pCopy->m_sIDnum = pOriginal->m_sIDnum;					// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã‡ Â°Ã­Ã€Â¯ Â¹Ã¸ÃˆÂ£ 
	pCopy->m_cItemType = pOriginal->m_cItemType;
	pCopy->m_cEquipPos = pOriginal->m_cEquipPos;
	pCopy->m_sItemEffectType = pOriginal->m_sItemEffectType;     
	pCopy->m_sItemEffectValue1 = pOriginal->m_sItemEffectValue1;
	pCopy->m_sItemEffectValue2 = pOriginal->m_sItemEffectValue2;
	pCopy->m_sItemEffectValue3 = pOriginal->m_sItemEffectValue3; 
	pCopy->m_sItemEffectValue4 = pOriginal->m_sItemEffectValue4;
	pCopy->m_sItemEffectValue5 = pOriginal->m_sItemEffectValue5;
	pCopy->m_sItemEffectValue6 = pOriginal->m_sItemEffectValue6; 
	pCopy->m_wMaxLifeSpan = pOriginal->m_wMaxLifeSpan;
	pCopy->m_sSpecialEffect = pOriginal->m_sSpecialEffect;
	
	//short m_sSM_HitRatio, m_sL_HitRatio;
	//v1.432 Â¸Ã­ÃÃŸÂ·Ã¼ Â°Â¡Â°Â¨ Â»Ã§Â¿Ã« Â¾ÃˆÃ‡Ã‘Â´Ã™. Â´Ã«Â½Ã… Ã†Â¯Â¼Ã¶ Â´Ã‰Â·Ã‚ Â¼Ã¶Ã„Â¡Â°Â¡ ÂµÃ©Â¾Ã®Â°Â£Â´Ã™.
	pCopy->m_sSpecialEffectValue1 = pOriginal->m_sSpecialEffectValue1;
	pCopy->m_sSpecialEffectValue2 = pOriginal->m_sSpecialEffectValue2; 

	pCopy->m_sSprite = pOriginal->m_sSprite;
	pCopy->m_sSpriteFrame = pOriginal->m_sSpriteFrame;

	pCopy->m_cApprValue = pOriginal->m_cApprValue;
	pCopy->m_cSpeed = pOriginal->m_cSpeed;

	pCopy->m_wPrice = pOriginal->m_wPrice; 
	pCopy->m_wWeight = pOriginal->m_wWeight;
	pCopy->m_sLevelLimit = pOriginal->m_sLevelLimit;	
	pCopy->m_cGenderLimit = pOriginal->m_cGenderLimit;

	pCopy->m_sRelatedSkill = pOriginal->m_sRelatedSkill;
	
	pCopy->m_cCategory = pOriginal->m_cCategory;
	pCopy->m_bIsForSale = pOriginal->m_bIsForSale;
	// 

	pCopy->m_dwCount = pOriginal->m_dwCount;
	pCopy->m_sTouchEffectType = pOriginal->m_sTouchEffectType;
	pCopy->m_sTouchEffectValue1 =pOriginal->m_sTouchEffectValue1;
	pCopy->m_sTouchEffectValue2 = pOriginal->m_sTouchEffectValue2;
	pCopy->m_sTouchEffectValue3 = pOriginal->m_sTouchEffectValue3;
	pCopy->m_cItemColor = pOriginal->m_cItemColor;
	pCopy->m_sItemSpecEffectValue1 = pOriginal->m_sItemSpecEffectValue1;
	pCopy->m_sItemSpecEffectValue2 = pOriginal->m_sItemSpecEffectValue2;
	pCopy->m_sItemSpecEffectValue3 = pOriginal->m_sItemSpecEffectValue3;
	pCopy->m_wCurLifeSpan = pOriginal->m_wCurLifeSpan;
	pCopy->m_dwAttribute = pOriginal->m_dwAttribute;			

	return TRUE;
}


void CGame::AdminOrder_SummonStorm(int iClientH, char* pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n"; 
	char   * token, cBuff[256], cOwnerType;
	int    i; 
	class  CStrTok * pStrTok; 
	short  sOwnerH,sType,sX,sY;
	int    dX1,dY1,iWhetherBonus,iResult = 0,tX,tY,iErr,ix,iy;
	int    iStormCount,iMagicAttr;

	if (m_pClientList[iClientH] == NULL) return; 
	if ((dwMsgSize)   <= 0) return; 
	if (m_pClientList[iClientH]->m_bIsAdminCommandEnabled == FALSE) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelStorm) { 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL); 
		return; 
	} 

	ZeroMemory(cBuff, sizeof(cBuff)); 
	memcpy(cBuff, pData, dwMsgSize); 

	pStrTok = new class CStrTok(cBuff, seps); 
	token = pStrTok->pGet(); 
	token = pStrTok->pGet(); 

	//No Storm Specified
	if (token == NULL) { 
		delete pStrTok; 
		return; 
	} 
	
	sType = atoi(token);

	//Only 100 Magic Spells
	if (sType <= 0)	sType = 1;
	if (sType > 100) sType = 100;

	//No Count Specified
	token = pStrTok->pGet(); 
	if (token == NULL) { 
		delete pStrTok; 
		return; 
	} 
	iStormCount = atoi(token);

	if (iStormCount < 0)
		iStormCount = 0;
	if (iStormCount > 30)
		iStormCount = 30;//Original : 30

try{
	//Whether Bouns
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);
	
	//Magic Attribute
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

	//Calculate Area Coords
	//Gives Right
	dX1= m_pClientList[iClientH]->m_sX;
	dX1-=10;
	//Gives Top
	dY1= m_pClientList[iClientH]->m_sY;
	dY1-=7;

	while (iStormCount != 0) {
		int randX,randY;
		randX = (rand() % 20) + dX1;
		randY = (rand() % 13) + dY1;

		switch (m_pMagicConfigList[sType]->m_sType) {
			case DEF_MAGICTYPE_DAMAGE_SPOT:
				//Calculate Damage
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, randX, randY);
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, randX, randY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
					(m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
			break;

			case DEF_MAGICTYPE_DAMAGE_LINEAR:
				// Ã€ÃÃÃ·Â¼Â± Â»Ã³Â¿Â¡ Ã€Ã–Â´Ã‚ Â¸Ã±Ã‡Â¥Â¸Â¦ Â¸Ã°ÂµÃ Â°Ã¸Â°ÃÃ‡Ã‘Â´Ã™.
				sX = m_pClientList[iClientH]->m_sX;
				sY = m_pClientList[iClientH]->m_sY;

				for (i = 2; i < 10; i++) {
					iErr = 0;
					m_Misc.GetPoint2(sX, sY, randX, randY, &tX, &tY, &iErr, i);

					// tx, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {
							// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}

						// tx-1, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}

							// tx+1, ty
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								}

							// tx, ty-1
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
								if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
									(m_pClientList[sOwnerH]->m_iHP > 0) ) {
										// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									}

							// tx, ty+1
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
									if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
										(m_pClientList[sOwnerH]->m_iHP > 0) ) {
											// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										}

									if ( (abs(tX - randX) <= 1) && (abs(tY - randY) <= 1)) break;
					}

					// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
					for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								}
						}

						// dX, dY
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, randX, randY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr); // v1.41 FALSE

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, randX, randY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr); // v1.41 FALSE
					}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
			break;

			case DEF_MAGICTYPE_DAMAGE_AREA:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, randX, randY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, randX, randY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
					(m_pClientList[sOwnerH]->m_iHP > 0) ) {
						// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
					}

				// ÃÃ–ÂºÂ¯ Â°Ã¸Â°Ã ÃˆÂ¿Â°Ãº 
				for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// Ã€ÃšÂ½Ã…ÂµÂµ Ã‡Ã‡Ã†Ã¸ÂµÃ‰ Â¼Ã¶ Ã€Ã–Ã€Â¸Â´Ã ÃÃ–Ã€Ã‡.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, randX, randY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// ÃÃ—Ã€Âº ÃƒÂ´Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â´Ã™.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, randX, randY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
					}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
			break;
		default:
			goto Skip_Storm;
	}
		Sleep(rand() % 10);
		iStormCount--;
	}
}
catch(...){}
Skip_Storm:
	delete pStrTok;
}

void CGame::SendMsg(short sOwnerH, char cOwnerType, BOOL bStatus, long lPass) { 
	if (m_pClientList[sOwnerH] == NULL) return; 
	//SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);

	SendNotifyMsg(NULL, sOwnerH, lPass, NULL, NULL, NULL, NULL);

}

//ArchAngel Function
void CGame::AdminOrder_Weather(int iClientH, char * pData, DWORD dwMsgSize) 
{ 
char   seps[] = "= \t\n"; 
char   * token, cBuff[256]; 
class  CStrTok * pStrTok; 
char cPrevMode; 
int i, j, sType, sTime; 
DWORD dwTime; 

  dwTime = timeGetTime(); 

  if (m_pClientList[iClientH] == NULL) return; 
  if ((dwMsgSize)   <= 0) return; 

  if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelWeather) { 
     SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL); 
     return; 
  } 
   
  ZeroMemory(cBuff, sizeof(cBuff)); 
  memcpy(cBuff, pData, dwMsgSize); 

  pStrTok = new class CStrTok(cBuff, seps); 
  token = pStrTok->pGet(); 
  token = pStrTok->pGet(); 
   
  if (token == NULL) { 
     delete pStrTok; 
     return; 
  } 

     sType = atoi(token); 

  token = pStrTok->pGet(); 

  if (token == NULL) { 
     delete pStrTok; 
     return; 
  } 

  sTime = atoi(token); 

  delete pStrTok; 
   
  for (i = 0; i < DEF_MAXMAPS; i++) { 
     if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) { 
        cPrevMode = m_pMapList[i]->m_cWhetherStatus; 
        if (m_pMapList[i]->m_cWhetherStatus != NULL) { 
           if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
              m_pMapList[i]->m_cWhetherStatus = NULL; 
        } 
        else { 
           sTime *= 1000; 
           m_pMapList[i]->m_cWhetherStatus = sType; 
           m_pMapList[i]->m_dwWhetherStartTime = dwTime; 
           m_pMapList[i]->m_dwWhetherLastTime  = sTime; 
        } 
        if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) { 
           for (j = 1; j < DEF_MAXCLIENTS; j++) 
           if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
              SendNotifyMsg(NULL, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);    
        } 
     } 
  } 
}

void CGame::RequestChangePlayMode(int iClientH)
{

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPKCount > 0) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if (memcmp(m_pClientList[iClientH]->m_cMapName,"cityhall",8) != 0) return;

	if (m_pClientList[iClientH]->m_iLevel < 100||
		m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE) {
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden",7) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"arehunter");
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine",6) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"elvhunter");
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter",9) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"aresden");
			else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter",9) == 0 ) strcpy(m_pClientList[iClientH]->m_cLocation,"elvine");

			if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
				m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;
			else m_pClientList[iClientH]->m_bIsPlayerCivil = TRUE;

			SendNotifyMsg(NULL,iClientH,DEF_NOTIFY_CHANGEPLAYMODE,NULL,NULL,NULL,m_pClientList[iClientH]->m_cLocation);
			SendEventToNearClient_TypeA(iClientH,DEF_OWNERTYPE_PLAYER,MSGID_EVENT_MOTION,100,NULL,NULL,NULL);
		}
}

void CGame::AdminOrder_SetStatus(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, * token2, cBuff[256];
	int    iPass;
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetStatus) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token2 = pStrTok->pGet();

	iPass = (int)token;
	if (token != NULL) {
		// Ã€ÃŒ Â°ÂªÃ€ÃŒ Â¹Â®Ã€Ãš '1'Ã€ÃŒÂ¸Ã© Ã…ÃµÂ¸Ã­Ã€Â¸Â·Ã Â¼Â¼Ã†Â®. '0'Ã€ÃŒÂ¸Ã© Ã‡Ã˜ÃÂ¦ 

		if (token[0]=='0') {
			SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetInhibitionCastingFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			SetHeroFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		}
		if (token[0]=='1') {
			SetPoisonFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='2') {
			SetIllusionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='3') {
			SetDefenseShieldFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='4') {
			SetMagicProtectionFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='5') {
			SetProtectionFromArrowFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='6') {
			SetIllusionMovementFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='7') {
			SetInhibitionCastingFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
		if (token[0]=='8') {
			SetHeroFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		}
	}
	delete pStrTok;
}

/*********************************************************************************************************************
**  void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show invisibility aura								**
**  last updated		:: November 20, 2004; 9:30 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000010;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFEF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000010;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFEF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

/*********************************************************************************************************************
**  void CGame::SetInhibitionCastingFlag(short sOwnerH, char cOwnerType, BOOL bStatus)								**
**  description			:: changes the status of the player to show inhibit casting aura							**
**  last updated		:: November 20, 2004; 9:33 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetInhibitionCastingFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00100000;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFEFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00100000;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFEFFFFF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show berserk aura									**
**  last updated		:: November 20, 2004; 9:35 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000020;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFDF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000020;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFDF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetIceFlag(short sOwnerH, char cOwnerType, BOOL bStatus)										**
**  description			:: changes the status of the player to show frozen aura										**
**  last updated		:: November 20, 2004; 9:35 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIceFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000040;
		else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFFBF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000040;
		else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFFBF;
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

/*********************************************************************************************************************
**  void void CGame::SetPoisonFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show poison aura										**
**  last updated		:: November 20, 2004; 9:36 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetPoisonFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00000080;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFFFF7F;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00000080;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFFFF7F;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetIllusionFlag(short sOwnerH, char cOwnerType, BOOL bStatus)									**
**  description			:: changes the status of the player to show illusion aura									**
**  last updated		:: November 20, 2004; 9:36 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIllusionFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x01000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFEFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x01000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFEFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetHeroFlag(short sOwnerH, char cOwnerType, BOOL bStatus)										**
**  description			:: changes the status of the player to show hero item aura									**
**  last updated		:: November 20, 2004; 9:37 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetHeroFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00020000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFFDFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x00020000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFFFDFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetDefenseShieldFlag(short sOwnerH, char cOwnerType, BOOL bStatus)								**
**  description			:: changes the status of the player to show defense aura									**
**  last updated		:: November 20, 2004; 9:37 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetDefenseShieldFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x02000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFDFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x02000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFDFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetMagicProtectionFlag(short sOwnerH, char cOwnerType, BOOL bStatus)							**
**  description			:: changes the status of the player to show magic protect aura								**
**  last updated		:: November 20, 2004; 9:38 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetMagicProtectionFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x04000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFBFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x04000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xFBFFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetProtectionFromArrowFlag(short sOwnerH, char cOwnerType, BOOL bStatus)						**
**  description			:: changes the status of the player to show arrow protect aura								**
**  last updated		:: November 20, 2004; 9:39 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetProtectionFromArrowFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
 	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x08000000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xF7FFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus | 0x08000000;
			else m_pNpcList[sOwnerH]->m_iStatus = m_pNpcList[sOwnerH]->m_iStatus & 0xF7FFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

/*********************************************************************************************************************
**  void void CGame::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, BOOL bStatus)							**
**  description			:: changes the status of the player to show illusion movement aura							**
**  last updated		:: November 20, 2004; 9:39 PM; Hypnotoad													**
**	return value		:: void																						**
*********************************************************************************************************************/
void CGame::SetIllusionMovementFlag(short sOwnerH, char cOwnerType, BOOL bStatus) 
{ 
  	switch (cOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwnerH] == NULL) return;
			if (bStatus == TRUE) 
				 m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus | 0x00200000;
			else m_pClientList[sOwnerH]->m_iStatus = m_pClientList[sOwnerH]->m_iStatus & 0xFFDFFFFF;
			SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
	}    
}

// New 07/05/2004
void CGame::RequestGuildNameHandler(int iClientH, int iObjectID, int iIndex)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((iObjectID <= 0) || (iObjectID >= DEF_MAXCLIENTS)) return;

	if (m_pClientList[iObjectID] == NULL) {
		// Â¿Ã¤ÃƒÂ» Â¹ÃÃ€Âº ObjectÂ°Â¡ Â¾Ã¸Â´Ã™.

	}
	else {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REQGUILDNAMEANSWER, m_pClientList[iObjectID]->m_iGuildRank, iIndex, NULL, m_pClientList[iObjectID]->m_cGuildName);	
	}
}

// Item Logging
BOOL CGame::_bItemLog(int iAction,int iGiveH, int iRecvH, class CItem * pItem,BOOL bForceItemLog)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];
	int iItemCount ;
	if (pItem == NULL) return FALSE;

	// !!ÃÃ–Ã€Ã‡ Ã‡Ã‘Â±Â¹Â¿Â¡ Ã€Ã»Â¿Ã«Ã‡Ã’Â¶Â§  New Item Ã€ÃŒ Â»Ã½Â±Ã¦Â¶Â§Â´Ã‚  iGiveÂ°Â¡ Â³ÃÃ€ÃÂ¼Ã¶ Ã€Ã–Â´Ã™.
	if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;

	if (iAction == DEF_ITEMLOG_DUPITEMID) {
		// ÂºÂ¹Â»Ã§ÂµÃˆ Â¾Ã†Ã€ÃŒÃ…Ã› Ã€ÃºÃ€Ã¥ Â¿Ã¤ÃƒÂ»Ã€ÃŒÂ´Ã™. 
		if (m_pClientList[iGiveH] == NULL) return FALSE;
		if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
		wsprintf(G_cTxt, "(!) Delete-DupItem(%s %d %d %d %d) Owner(%s)", pItem->m_cName, pItem->m_dwCount, pItem->m_sTouchEffectValue1,
			pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3,
			m_pClientList[iGiveH]->m_cCharName);
		//	PutItemLogFileList(iGiveH,G_cTxt);
		bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,G_cTxt);
		return TRUE;
	}

	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));

	switch (iAction) {
		
		case DEF_ITEMLOG_EXCHANGE:
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "(%s) PC(%s)\tExchange\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			break;

		case DEF_ITEMLOG_GIVE:	
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "(%s) PC(%s)\tGive\t%s(%d %d %d %d %x)\t%s(%d %d)\tPC(%s)",m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY, m_pClientList[iRecvH]->m_cCharName);
			break;

		case DEF_ITEMLOG_DROP:
			wsprintf(cTxt, "(%s) PC(%s)\tDrop\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_GET:
			wsprintf(cTxt, "(%s) PC(%s)\tGet\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_MAKE:
			wsprintf(cTxt, "(%s) PC(%s)\tMake\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_DEPLETE:	
			wsprintf(cTxt, "(%s) PC(%s)\tDeplete\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_BUY:
			iItemCount = iRecvH ;
			wsprintf(cTxt, "(%s) PC(%s)\tBuy\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, iItemCount , 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_SELL:
			wsprintf(cTxt, "(%s) PC(%s)\tSell\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_RETRIEVE:
			wsprintf(cTxt, "(%s) PC(%s)\tRetrieve\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);		
			break;

		case DEF_ITEMLOG_DEPOSIT:
			wsprintf(cTxt, "(%s) PC(%s)\tDeposit\t%s(%d %d %d %d %x)\t%s(%d %d)",m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName, pItem->m_dwCount, 
				pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute, 
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_UPGRADEFAIL:
			wsprintf(cTxt, "(%s) PC(%s)\tUpgrade Fail\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;

		case DEF_ITEMLOG_UPGRADESUCCESS:
			wsprintf(cTxt, "(%s) PC(%s)\tUpgrade Success\t%s(%d %d %d %d %x)\t%s(%d %d)", m_pClientList[iGiveH]->m_cIPaddress, m_pClientList[iGiveH]->m_cCharName, pItem->m_cName,
				pItem->m_dwCount, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, pItem->m_dwAttribute,
				m_pClientList[iGiveH]->m_cMapName,m_pClientList[iGiveH]->m_sX,m_pClientList[iGiveH]->m_sY);
			break;
		default:
			return FALSE ;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iGiveH, NULL,cTxt);
	return TRUE;
}

BOOL CGame::_bItemLog(int iAction,int iClientH , char * cName, class CItem * pItem)
{
	if(pItem == NULL) return FALSE;
	if(_bCheckGoodItem( pItem ) == FALSE) return FALSE;
	if(iAction != DEF_ITEMLOG_NEWGENDROP)
	{
		if( m_pClientList[iClientH] == NULL ) return FALSE;
	}
	char  cTxt[200], cTemp1[120];
	//  Â·ÃÂ±Ã— Â³Â²Â±Ã¤Â´Ã™. 
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	if( m_pClientList[iClientH] != NULL ) m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp1);

	switch (iAction) {
		
		case DEF_ITEMLOG_NEWGENDROP:
		if (pItem == NULL) return FALSE;
		wsprintf(cTxt, "NPC(%s)\tDrop\t%s(%d %d %d %d)",cName, pItem->m_cName, pItem->m_dwCount,  
			pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3);
		break;
	case DEF_ITEMLOG_SKILLLEARN:
	case DEF_ITEMLOG_MAGICLEARN:
		if (cName == NULL) return FALSE; 
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt, "PC(%s)\tLearn\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 
	case DEF_ITEMLOG_SUMMONMONSTER:
		if (cName == NULL) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tSummon\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break ;
	case DEF_ITEMLOG_POISONED:
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tBe Poisoned\t \t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, 
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 

	case DEF_ITEMLOG_REPAIR:
		if (cName == NULL) return FALSE;
		if (m_pClientList[iClientH] == NULL) return FALSE;
		wsprintf(cTxt,"PC(%s)\tRepair\t(%s)\t%s(%d %d)\t \tIP(%s)",m_pClientList[iClientH]->m_cCharName, cName,
			m_pClientList[iClientH]->m_cMapName,m_pClientList[iClientH]->m_sX,m_pClientList[iClientH]->m_sY, cTemp1);
		break; 

	default:
		return FALSE;
	}
	bSendMsgToLS(MSGID_GAMEITEMLOG, iClientH, NULL,cTxt);
	return TRUE ;
}

BOOL CGame::_bCheckGoodItem( class CItem * pItem )
{
	if( pItem == NULL ) return FALSE;

	if( pItem->m_sIDnum == 90 )
	{
		if( pItem->m_dwCount > 10000 ) return TRUE;  //GoldÂ¿Â¡ Ã‡Ã‘Ã‡Ã˜ 10000Â¿Ã¸ Ã€ÃŒÂ»Ã³Â¸Â¸ Â·ÃÂ±Ã—Â¿Â¡ Â³Â²Â±Ã¤Â´Ã™.
		else return FALSE;
	}
	switch (pItem->m_sIDnum) {
		//	case 90: // Gold ÃƒÃŸÂ°Â¡ 
	case 259:
	case 290:
	case 291:
	case 292:
	case 300:
	case 305:
	case 308:
	case 311:
	case 334:
	case 335:
	case 336:
	case 338:
	case 380:
	case 381:
	case 382:
	case 391:
	case 400:
	case 401:
	case 490:
	case 491:
	case 492:
	case 508:
	case 581:
	case 610:
	case 611:
	case 612:
	case 613:
	case 614:
	case 616:  // ÂµÂ¥Â¸Ã³-Â½Â½Â·Â¹Ã€ÃŒÂ¾Ã®
	case 618:  // Â´Ã™Ã…Â©Â¿Â¤Ã‡Ã-ÂºÂ¸Â¿Ã¬

	case 620:
	case 621:
	case 622:
	case 623:

	case 630:
	case 631:

	case 632:
	case 633:
	case 634:
	case 635:
	case 636:
	case 637:
	case 638:
	case 639:
	case 640:
	case 641:

	case 642:
	case 643:

	case 644:
	case 645:
	case 646:
	case 647:

	case 650:
	case 654:
	case 655:
	case 656:
	case 657:

	case 700: 	// v2.03 Â»Ã³Â¾Ã® Â¾Ã†Ã€ÃŒÃ…Ã› 
	case 701:
	case 702:
	case 703:
	case 704:
	case 705:
	case 706:
	case 707:
	case 708:
	case 709:
	case 710:
	case 711:
	case 712:
	case 713:
	case 714:
	case 715:

	case 720:
	case 721:
	case 722:
	case 723:

	case 724:
	case 725:
	case 726:
	case 727:
	case 728:
	case 729:
	case 730:
	case 731:
	case 732:
	case 733:

	case 734:
	case 735:

	case 736:  // Â»ÃµÂ·ÃÂ¿Ã® Â»Ã³Â¾Ã®Ã€Ã‡ Ã€ÃšÃ€ÃŒÂ¾Ã°Ã†Â® Â¼Ã’ÂµÃ¥
	case 737:  // Â»ÃµÂ·ÃÂ¿Ã® ÃˆÃ¦Â±Ã¢Â»Ã§Ã€Ã‡ Ã€ÃšÃ€ÃŒÂ¾Ã°Ã†Â® Â¼Ã’ÂµÃ¥
	case 738:  // Â»ÃµÂ·ÃÂ¿Ã® ÃˆÃ¦Â¸Â¶Â¹Ã½Â»Ã§Ã€Ã‡Â¸Ã…ÃÃ·Â¿Ã¸ÂµÃ¥

		return TRUE;  //Ã†Â¯ÂºÂ°Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ±Ã¢ Â¶Â«Â½Ãƒ Â±Ã¢Â·Ã...
		break;
	default:
		// v2.17 2002-7-31 ÃÂ¦Ã€Ã› Â¾Ã†Ã€ÃŒÃ…Ã›ÂµÂµ Â·ÃÂ±Ã—Â¿Â¡ Â³Â²Â°Ã” Ã‡Ã‘Â´Ã™.
		if ((pItem->m_dwAttribute & 0xF0F0F001) == NULL) return FALSE;  //Ã†Â¯ÂºÂ°Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›ÂµÃ Â¾Ã†Â´ÃÂ±Â¸ Ã†Â¯Â¼ÂºÃ„Â¡ÂµÂµ Â¾Ã¸Â´Ã™Â¸Ã© ÂºÂ°Â·Ã§..
		else if( pItem->m_sIDnum > 30 ) return TRUE;  //Ã†Â¯ÂºÂ°Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Âº Â¾Ã†Â´ÃÃÃ¶Â¸Â¸ Ã†Â¯Â¼ÂºÃ„Â¡Â°Â¡ Ã€Ã–Â°Ã­ Â´ÃœÂ°Ã‹Â·Ã¹Â°Â¡ Â¾Ã†Â´ÃÂ¶Ã³Â¸Ã© ÃÃÃ€Âº Â¾Ã†Ã…Ã›..
		else return FALSE;  //Ã†Â¯ÂºÂ°Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›ÂµÃ Â¾Ã†Â´ÃÂ±Â¸ Ã†Â¯Â¼ÂºÃ„Â¡Â´Ã‚ Ã€Ã–ÃÃ¶Â¸Â¸ Â´ÃœÂ°Ã‹Â·Ã¹Â¶Ã³Â¸Ã© ÂºÂ°Â·Ã§...
	}
}

/*void CGame::GetExp(int iClientH, int iExp, BOOL bIsAttackerOwn)
{
 double dV1, dV2, dV3;
 int i, iH, iUnitValue;
 DWORD dwTime = timeGetTime();
	
	// v2.1 ÆÄÆ¼Á¦¿¡ ¸ÂÃß¾î °æÇèÄ¡¸¦ ³ª´©°í, ·¹º§ÀÌ 80 ¹Ì¸¸ÀÎ °æ¿ì °æÇèÄ¡¸¦ ´õ ¾ò´Â´Ù.
	if (m_pClientList[iClientH] == NULL) return;
	if (iExp <= 0) return;

	if (m_pClientList[iClientH]->m_iLevel <= 80) {
		dV1 = (double)(80 - m_pClientList[iClientH]->m_iLevel);
		dV2 = dV1 * 0.025f;
		dV3 = (double)iExp;
		dV1 = (dV2 + 1.025f)*dV3;
		iExp = (int)dV1;
	}
	else { //Lower exp
		if ((m_pClientList[iClientH]->m_iLevel >= 100) &&((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) 
		|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0))) {
			iExp = (iExp/10) ;
	} // v2.16 2002-5-27 ·¹º§ 80 °ú 100 »çÀÌ°í ³ó°æÁöÀÌ¸é °æÇèÄ¡ÀÇ 1/4 
	else if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) 
		|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {
			iExp = (iExp*1/4) ;
	}
		
	if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) && 
		((dwTime - m_pClientList[iClientH]->m_dwLastActionTime) < 1000*60*5)) {
		// ÆÄÆ¼°¡ ¸Î¾îÁ® ÀÖ´Ù¸é °æÇèÄ¡ ºĞ¹è ¹æ¹ıÀÌ ´Ş¶óÁø´Ù.
		if ((iExp >= m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers > 0)) {
			// ÀÏ´Ü ¾òÀº °æÇèÄ¡°¡ ÃÑ ÆÄÆ¼ ¸â¹ö ¼öº¸´Ù ÀÌ»óÀÌ¶ó¸é µ¿µîÇÏ°Ô ºĞ¹è 
			
			// ÆÄÆ¼¿øµé ¼ö¿¡ µû¶ó °æÇèÄ¡ ·® Áõ°¡
			dV1 = (double)m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers;
			dV2 = 2.5f * dV1;
			dV3 = (double)iExp;
			dV1 = ((dV2/100.0f) * dV3) +0.5f;
			iExp += (int)dV1;

			dV1 = (double)iExp;
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers <= 0)
				 dV2 = 1.0f;
			else dV2 = (double)m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers;
			dV3 = (dV1 / dV2) + 0.5f;
			iUnitValue = (int)dV3;
			
			// °æÇèÄ¡¸¦ ³ª´«´Ù.
			for (i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++) {
				iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];

			if (m_pClientList[iH]->m_iLevel >= 1 && m_pClientList[iH]->m_iLevel < 20)
				iUnitValue *= (int)3.5;
			else if (m_pClientList[iH]->m_iLevel >= 20 && m_pClientList[iH]->m_iLevel < 121)
				iUnitValue *= 3;
			else if (m_pClientList[iH]->m_iLevel >= 120 && m_pClientList[iH]->m_iLevel < 161)
				iUnitValue *= 2;
			else if (m_pClientList[iH]->m_iLevel >= 160 && m_pClientList[iH]->m_iLevel < 180)
				iUnitValue *= (int)1.5;
			if((m_pClientList[iH]->m_iStatus & 0x10000) != 0)
				iUnitValue *= 3;

			if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iHP > 0)) m_pClientList[iH]->m_iExpStock += iUnitValue;
			}

			// °ø°İÀÚ ÀÚ½ÅÀÌ¸é
				if ((bIsAttackerOwn == TRUE) && (iTotalPartyMembers > 1))
					m_pClientList[iClientH]->m_iExpStock += (iUnitValue/10);
		}
	
	} // if

	if (m_pClientList[iClientH]->m_iLevel >= 1 && m_pClientList[iClientH]->m_iLevel < 20)
		iExp *= (int)3.5;
	else if (m_pClientList[iClientH]->m_iLevel >= 20 && m_pClientList[iClientH]->m_iLevel < 121)
		iExp *= 3;
	else if (m_pClientList[iClientH]->m_iLevel > 120 && m_pClientList[iClientH]->m_iLevel < 161)
		iExp *= 2;
	else if (m_pClientList[iClientH]->m_iLevel > 160 && m_pClientList[iClientH]->m_iLevel < 180)
		iExp *= (int)1.5;

	if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0)
			iExp *= 3;
	else m_pClientList[iClientH]->m_iExpStock += iExp;

	}
}*/

void CGame::GetExp(int iClientH, int iExp, BOOL bIsAttackerOwn)
{
	double dV1, dV2, dV3;
	int i, iH, iUnitValue;
	DWORD dwTime = timeGetTime();
	int iTotalPartyMembers;

	if (m_pClientList[iClientH] == NULL) return;
	if (iExp <= 0) return;

	if (m_pClientList[iClientH]->m_iLevel <= 80) {
		dV1 = (double)(80 - m_pClientList[iClientH]->m_iLevel);
		dV2 = dV1 * 0.025f;
		dV3 = (double)iExp;
		dV1 = (dV2 + 1.025f)*dV3;
		iExp = (int)dV1;
	}
	else { //Lower exp
		if ((m_pClientList[iClientH]->m_iLevel >= 100) &&((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) 
			|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0))) {
				iExp = (iExp/10) ;
			}
		else if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) 
			|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {
				iExp = (iExp*1/4) ;
			}
	}

	//Check for party status, else give exp to player
	//if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) && 
	//	((dwTime - m_pClientList[iClientH]->m_dwLastActionTime) < 1000*60*5)) {
	if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
			//Only divide exp if > 1 person and exp > 10
			if(iExp >= 10 && m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers > 0){

				//Calc total ppl in party
				iTotalPartyMembers = 0;
				for(i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++){
					iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
					if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iHP > 0)) {
						//Newly added, Only players on same map get exp :}
						//if(m_pClientList[iH]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)
						if ((strlen(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName)) == (strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName))) {
							if(memcmp(m_pMapList[m_pClientList[iH]->m_cMapIndex]->m_cName, 
									  m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 
									  strlen(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName)) == 0){
								iTotalPartyMembers++;
							}
						}
					}
				}

				//Check for party bug
				if(iTotalPartyMembers > 8){
					wsprintf(G_cTxt, "(X) Party Bug !! partyMember %d XXXXXXXXXX", iTotalPartyMembers);
					PutLogFileList(G_cTxt);
					iTotalPartyMembers = 8;
				}

				//Figure out how much exp a player gets
				dV1 = (double)iExp;

				switch(iTotalPartyMembers){
				case 1:
					dV2 = dV1;
					break;
				case 2:
					dV2 = (dV1 + (dV1 * 2.0e-2)) / 2.0;
					break;
				case 3:
					dV2 = (dV1 + (dV1 * 5.0e-2)) / 3.0;
					break;
				case 4:
					dV2 = (dV1 + (dV1 * 7.000000000000001e-2)) / 4.0;
					break;
				case 5:
					dV2 = (dV1 + (dV1 * 1.0e-1)) / 5.0;
					break;
				case 6:
					dV2 = (dV1 + (dV1 * 1.4e-1)) / 6.0;
					break;
				case 7:
					dV2 = (dV1 + (dV1 * 1.7e-1)) / 7.0;
					break;
				case 8:
					dV2 = (dV1 + (dV1 * 2.0e-1)) / 8.0;
					break;
				}

				dV3 = dV2 + 5.0e-1;
				iUnitValue = (int)dV3;

				//Divide exp among party members
				for(i = 0; i < iTotalPartyMembers; i++){
					iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
					//Player who kills monster gets more exp
						if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_bSkillUsingStatus[19] != 1) && (m_pClientList[iH]->m_iHP > 0)) { // Is player alive ??
							//Exp gain based on lvl
							if((m_pClientList[iH]->m_iStatus & 0x10000) != 0)
								iUnitValue *= 3;
							m_pClientList[iH]->m_iExpStock += iUnitValue;
							iUnitValue = (int)dV3;
						}
					}
			}
			else{
				if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0)
					iExp *= 3;
				m_pClientList[iClientH]->m_iExpStock += iExp;
			}
		}
		else{
			if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0)
				iExp *= 3;

			//Add exp to player
			m_pClientList[iClientH]->m_iExpStock += iExp;
		}
}

/*
void CGame::GetExp(int iClientH, int iExp, BOOL bIsAttackerOwn)
{
	double dV1, dV2, dV3;
	int i, iH, iUnitValue;
	DWORD dwTime = timeGetTime();

	// v2.1 Ã†Ã„Ã†Â¼ÃÂ¦Â¿Â¡ Â¸Ã‚ÃƒÃŸÂ¾Ã® Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â³ÂªÂ´Â©Â°Ã­, Â·Â¹ÂºÂ§Ã€ÃŒ 80 Â¹ÃŒÂ¸Â¸Ã€Ã Â°Ã¦Â¿Ã¬ Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â´Ãµ Â¾Ã²Â´Ã‚Â´Ã™.
	if (m_pClientList[iClientH] == NULL) return;
	if (iExp <= 0) return;

	// Â·Â¹ÂºÂ§ 80 Ã€ÃŒÃ‡ÃÂ´Ã‚ ÂºÂ¸Â³ÃŠÂ½Âº Â°Ã¦Ã‡Ã¨Ã„Â¡Â°Â¡ Ã€Ã»Â¿Ã«ÂµÃˆÂ´Ã™.
	if (m_pClientList[iClientH]->m_iLevel <= 80) {
		dV1 = (double)(80 - m_pClientList[iClientH]->m_iLevel);
		dV2 = dV1 * 0.025f;
		dV3 = (double)iExp;
		dV1 = (dV2 + 1.025f)*dV3;
		iExp = (int)dV1;
	}
	else {
		// v2.16 2002-5-27 Â·Â¹ÂºÂ§ 100 ÂºÂ¸Â´Ã™ Ã…Â©Â°Ã­ Â³Ã³Â°Ã¦ÃÃ¶Ã€ÃŒÂ¸Ã© Â°Ã¦Ã‡Ã¨Ã„Â¡Ã€Ã‡ 1/10
		if ((m_pClientList[iClientH]->m_iLevel >= 100) &&((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) 
			|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0))) {
				iExp = (iExp/10) ;
			} // v2.16 2002-5-27 Â·Â¹ÂºÂ§ 80 Â°Ãº 100 Â»Ã§Ã€ÃŒÂ°Ã­ Â³Ã³Â°Ã¦ÃÃ¶Ã€ÃŒÂ¸Ã© Â°Ã¦Ã‡Ã¨Ã„Â¡Ã€Ã‡ 1/4 
		else if ((strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "arefarm") == 0) 
			|| (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {
				iExp = (iExp*1/4) ;
			}
	}

	if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) && 
		((dwTime - m_pClientList[iClientH]->m_dwLastActionTime) < 1000*60*5)) {
			// Ã†Ã„Ã†Â¼Â°Â¡ Â¸ÃÂ¾Ã®ÃÂ® Ã€Ã–Â´Ã™Â¸Ã© Â°Ã¦Ã‡Ã¨Ã„Â¡ ÂºÃÂ¹Ã¨ Â¹Ã¦Â¹Ã½Ã€ÃŒ Â´ÃÂ¶Ã³ÃÃ¸Â´Ã™.
			if ((iExp >= m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers > 0)) {
				// Ã€ÃÂ´Ãœ Â¾Ã²Ã€Âº Â°Ã¦Ã‡Ã¨Ã„Â¡Â°Â¡ ÃƒÃ‘ Ã†Ã„Ã†Â¼ Â¸Ã¢Â¹Ã¶ Â¼Ã¶ÂºÂ¸Â´Ã™ Ã€ÃŒÂ»Ã³Ã€ÃŒÂ¶Ã³Â¸Ã© ÂµÂ¿ÂµÃ®Ã‡ÃÂ°Ã” ÂºÃÂ¹Ã¨ 

				// Ã†Ã„Ã†Â¼Â¿Ã¸ÂµÃ© Â¼Ã¶Â¿Â¡ ÂµÃ»Â¶Ã³ Â°Ã¦Ã‡Ã¨Ã„Â¡ Â·Â® ÃÃµÂ°Â¡
				dV1 = (double)m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers;
				dV2 = 2.5f * dV1;
				dV3 = (double)iExp;
				dV1 = ((dV2/100.0f) * dV3) +0.5f;
				iExp += (int)dV1;

				dV1 = (double)iExp;
				if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers <= 0)
					dV2 = 1.0f;
				else dV2 = (double)m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers;
				dV3 = (dV1 / dV2) + 0.5f;
				iUnitValue = (int)dV3;

#if defined(DEF_TESTSERVER)
				iUnitValue = iUnitValue * 10;
#endif


				// Â°Ã¦Ã‡Ã¨Ã„Â¡Â¸Â¦ Â³ÂªÂ´Â«Â´Ã™.
				for (i = 0; i < m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers; i++) {
					iH = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i];
					if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iHP > 0)) {
						char buff[1000];
						wsprintf(buff,"%s GetExp %d",m_pClientList[iH]->m_cCharName,iUnitValue);
						PutLogList(buff);
						m_pClientList[iH]->m_iExpStock += iUnitValue;
					}
				}

				// Â°Ã¸Â°ÃÃ€Ãš Ã€ÃšÂ½Ã…Ã€ÃŒÂ¸Ã©
				if (bIsAttackerOwn == TRUE) m_pClientList[iClientH]->m_iExpStock += (iUnitValue/10);
			}
#if defined(DEF_TESTSERVER)
			else m_pClientList[iClientH]->m_iExpStock += (iExp * 10);
#else
			else m_pClientList[iClientH]->m_iExpStock += iExp;
#endif
		} // if
#if defined(DEF_TESTSERVER)
	else m_pClientList[iClientH]->m_iExpStock += (iExp * 10);
#else
	else m_pClientList[iClientH]->m_iExpStock += iExp;
#endif
}*/

BOOL CGame::bCheckAndConvertPlusWeaponItem(int iClientH, int iItemIndex)
{
	// Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ +1, +2 Ã€ÃŒÂ¸Â§Ã€ÃŒ ÂºÃ™Ã€Âº Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒÂ¶Ã³Â¸Ã© Attribute Ã‡ÃƒÂ·Â¡Â±Ã—Â·Ã Ã†Â¯Â¼ÂºÃ„Â¡Â¸Â¦ Ã€ÃŒÂµÂ¿Â½ÃƒÃ…Â°Â°Ã­ Ã€ÃÂ¹Ã Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â¸Â·Ã ÂºÂ¯Ã‡Ã¼Â½ÃƒÃ…Â²Â´Ã™.
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return FALSE;

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
	case 4:  // Dagger +1
	case 9:  // Short Sword +1
	case 13: // Main Gauge +1
	case 16: // Gradius +1
	case 18: // Long Sword +1
	case 19: // Long Sword +2
	case 21: // Excaliber +1
	case 24: // Sabre +1
	case 26: // Scimitar +1
	case 27: // Scimitar +2
	case 29: // Falchoin +1
	case 30: // Falchion +2
	case 32: // Esterk +1
	case 33: // Esterk +2
	case 35: // Rapier +1
	case 36: // Rapier +2
	case 39: // Broad Sword +1
	case 40: // Broad Sword +2
	case 43: // Bastad Sword +1
	case 44: // Bastad Sword +2
	case 47: // Claymore +1
	case 48: // Claymore +2
	case 51: // Great Sword +1
	case 52: // Great Sword +2
	case 55: // Flameberge +1
	case 56: // Flameberge +2
	case 60: // Light Axe +1
	case 61: // Light Axe +2
	case 63: // Tomahoc +1
	case 64: // Tomohoc +2
	case 66: // Sexon Axe +1
	case 67: // Sexon Axe +2
	case 69: // Double Axe +1
	case 70: // Double Axe +2
	case 72: // War Axe +1
	case 73: // War Axe +2

	case 580: // Battle Axe +1
	case 581: // Battle Axe +2
	case 582: // Sabre +2
		return TRUE;
		break;
	}
	return FALSE;
}

void CGame::ArmorLifeDecrement(int iAttackerH, int iTargetH, char cOwnerType, int iValue)
{
	int iTemp;

	if (m_pClientList[iAttackerH] == NULL) return ;
	// v1.3 Ã‡Ã‡Â°ÃÂ´Ã§Ã‡ÃŸÃ€Â¸Â¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸Ã‡ÃÂ°Ã­ Ã€Ã–Â´Ã‚ Â¸Ã¶Ã…Ã« Â¹Ã¦Â¾Ã®Â±Â¸Ã€Ã‡ Â¼Ã¶Â¸Ã­Ã€Â» ÃÃ™Ã€ÃÂ´Ã™. 
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == NULL) return;
		break;

	case DEF_OWNERTYPE_NPC:	return;
	default: return;
	}

	// v2.16 Â°Â°Ã€Âº Ã†Ã­Ã€ÃŒÂ¸Ã© Â¼Ã¶Â¸Ã­ Â´ÃÃÃ¶ Â¾ÃŠÂ°Ã” 
	if (m_pClientList[iAttackerH]->m_cSide == m_pClientList[iTargetH]->m_cSide) return ;

	// Â¸Ã¶Ã…Ã« Â°Â©Â¿ÃŠ 
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {
		// v1.432 ÃÃŸÂ¸Â³Ã€Ã Â°Ã¦Â¿Ã¬ Â¼Ã¶Â¸Ã­ ÃÃ™ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// Â¼Ã¶Â¸Ã­Ã€ÃŒ Â´Ã™ ÂµÃ‡Â¾ÃºÃ€Â¸Â¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸Ã€Â» Ã‡Ã˜ÃÂ¦Ã‡Ã‘Â´Ã™.
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¸ÃÂ°Â¡ÃÂ³Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ <- Ã€ÃŒÂ°Ã‰ Â¹ÃÃ€Â¸Â¸Ã© Ã€Ã¥Ã‚Ã¸ÃˆÂ­Â¸Ã©Â¿Â¡Â¼Â­ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ„Ã‘Â¾ÃŸ Ã‡Ã‘Â´Ã™.
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€Ã¥Ã‚Ã¸ Ã‡Ã˜ÃÂ¦ Â½ÃƒÃ…Â²Â´Ã™.
			ReleaseItemHandler(iTargetH, iTemp, TRUE);  // <- Ã€ÃŒ Ã‡Ã”Â¼Ã¶Â´Ã‚ Â¼Â­Â¹Ã¶Â¿Â¡Â¼Â­Ã€Ã‡ ÃˆÂ¿Â°ÃºÂ¸Â¸ ÃƒÂ³Â¸Â® 
		}
	}

	// Â¹Ã™ÃÃ¶ ÃˆÂ¤Ã€Âº Â½Ã…Â¹ÃŸÂ·Ã¹ Â¹Ã¦Â¾Ã®Â±Â¸
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

		// v1.432 ÃÃŸÂ¸Â³Ã€Ã Â°Ã¦Â¿Ã¬ Â¼Ã¶Â¸Ã­Ã€ÃŒ ÃÃ™ÃÃ¶ Â¾ÃŠÃ€Â½
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// Â¼Ã¶Â¸Ã­Ã€ÃŒ Â´Ã™ ÂµÃ‡Â¾ÃºÃ€Â¸Â¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸Ã€Â» Ã‡Ã˜ÃÂ¦Ã‡Ã‘Â´Ã™.
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¸ÃÂ°Â¡ÃÂ³Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ <- Ã€ÃŒÂ°Ã‰ Â¹ÃÃ€Â¸Â¸Ã© Ã€Ã¥Ã‚Ã¸ÃˆÂ­Â¸Ã©Â¿Â¡Â¼Â­ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ„Ã‘Â¾ÃŸ Ã‡Ã‘Â´Ã™.
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€Ã¥Ã‚Ã¸ Ã‡Ã˜ÃÂ¦ Â½ÃƒÃ…Â²Â´Ã™.
			ReleaseItemHandler(iTargetH, iTemp, TRUE);  // <- Ã€ÃŒ Ã‡Ã”Â¼Ã¶Â´Ã‚ Â¼Â­Â¹Ã¶Â¿Â¡Â¼Â­Ã€Ã‡ ÃˆÂ¿Â°ÃºÂ¸Â¸ ÃƒÂ³Â¸Â® 
		}
	}

	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

		// v1.432 ÃÃŸÂ¸Â³Ã€Ã Â°Ã¦Â¿Ã¬ Â¼Ã¶Â¸Ã­Ã€ÃŒ ÃÃ™ÃÃ¶ Â¾ÃŠÃ€Â½
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// Â¼Ã¶Â¸Ã­Ã€ÃŒ Â´Ã™ ÂµÃ‡Â¾ÃºÃ€Â¸Â¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸Ã€Â» Ã‡Ã˜ÃÂ¦Ã‡Ã‘Â´Ã™.
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¸ÃÂ°Â¡ÃÂ³Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ <- Ã€ÃŒÂ°Ã‰ Â¹ÃÃ€Â¸Â¸Ã© Ã€Ã¥Ã‚Ã¸ÃˆÂ­Â¸Ã©Â¿Â¡Â¼Â­ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ„Ã‘Â¾ÃŸ Ã‡Ã‘Â´Ã™.
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€Ã¥Ã‚Ã¸ Ã‡Ã˜ÃÂ¦ Â½ÃƒÃ…Â²Â´Ã™.
			ReleaseItemHandler(iTargetH, iTemp, TRUE);  // <- Ã€ÃŒ Ã‡Ã”Â¼Ã¶Â´Ã‚ Â¼Â­Â¹Ã¶Â¿Â¡Â¼Â­Ã€Ã‡ ÃˆÂ¿Â°ÃºÂ¸Â¸ ÃƒÂ³Â¸Â® 
		}
	}

	// Ã†ÃˆÂ°Â©Â¿ÃŠ 
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

		// v1.432 ÃÃŸÂ¸Â³Ã€Ã Â°Ã¦Â¿Ã¬ Â¼Ã¶Â¸Ã­Ã€ÃŒ ÃÃ™ÃÃ¶ Â¾ÃŠÃ€Â½
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// Â¼Ã¶Â¸Ã­Ã€ÃŒ Â´Ã™ ÂµÃ‡Â¾ÃºÃ€Â¸Â¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸Ã€Â» Ã‡Ã˜ÃÂ¦Ã‡Ã‘Â´Ã™.
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¸ÃÂ°Â¡ÃÂ³Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ <- Ã€ÃŒÂ°Ã‰ Â¹ÃÃ€Â¸Â¸Ã© Ã€Ã¥Ã‚Ã¸ÃˆÂ­Â¸Ã©Â¿Â¡Â¼Â­ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ„Ã‘Â¾ÃŸ Ã‡Ã‘Â´Ã™.
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€Ã¥Ã‚Ã¸ Ã‡Ã˜ÃÂ¦ Â½ÃƒÃ…Â²Â´Ã™.
			ReleaseItemHandler(iTargetH, iTemp, TRUE);  // <- Ã€ÃŒ Ã‡Ã”Â¼Ã¶Â´Ã‚ Â¼Â­Â¹Ã¶Â¿Â¡Â¼Â­Ã€Ã‡ ÃˆÂ¿Â°ÃºÂ¸Â¸ ÃƒÂ³Â¸Â® 
		}
	}

	// Ã…ÃµÂ±Â¸ 
	iTemp = m_pClientList[iTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	if ((iTemp != -1) && (m_pClientList[iTargetH]->m_pItemList[iTemp] != NULL)) {

		// v1.432 ÃÃŸÂ¸Â³Ã€Ã Â°Ã¦Â¿Ã¬ Â¼Ã¶Â¸Ã­Ã€ÃŒ ÃÃ™ÃÃ¶ Â¾ÃŠÃ€Â½
		if ((m_pClientList[iTargetH]->m_cSide != 0) && (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan -= iValue;

		if (m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan <= 0) {
			m_pClientList[iTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan = 0;
			// Â¼Ã¶Â¸Ã­Ã€ÃŒ Â´Ã™ ÂµÃ‡Â¾ÃºÃ€Â¸Â¹Ã‡Â·Ã Ã€Ã¥Ã‚Ã¸Ã€Â» Ã‡Ã˜ÃÂ¦Ã‡Ã‘Â´Ã™.
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¸ÃÂ°Â¡ÃÂ³Â´Ã™Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ <- Ã€ÃŒÂ°Ã‰ Â¹ÃÃ€Â¸Â¸Ã© Ã€Ã¥Ã‚Ã¸ÃˆÂ­Â¸Ã©Â¿Â¡Â¼Â­ Ã‡Ã˜ÃÂ¦Â½ÃƒÃ„Ã‘Â¾ÃŸ Ã‡Ã‘Â´Ã™.
			SendNotifyMsg(NULL, iTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[iTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
			// Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Ã€Ã¥Ã‚Ã¸ Ã‡Ã˜ÃÂ¦ Â½ÃƒÃ…Â²Â´Ã™.
			ReleaseItemHandler(iTargetH, iTemp, TRUE);  // <- Ã€ÃŒ Ã‡Ã”Â¼Ã¶Â´Ã‚ Â¼Â­Â¹Ã¶Â¿Â¡Â¼Â­Ã€Ã‡ ÃˆÂ¿Â°ÃºÂ¸Â¸ ÃƒÂ³Â¸Â® 
		}
	}
}

void CGame::AdminOrder_GoTo(int iClientH, char* pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cPlayerName[11],cMapName[32];
	class  CStrTok * pStrTok;
	char *cp;
	WORD *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelGoto) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token == NULL) {
		delete pStrTok;
		return;
	}

	if (strlen(token) > 10) {
		memcpy(cPlayerName,token,10);
	}
	else{
		memcpy(cPlayerName,token,strlen(token));
	}

	for(int i = 1; i < DEF_MAXCLIENTS; i++){
		if (m_pClientList[i] != NULL) {
			if (memcmp(cPlayerName,m_pClientList[i]->m_cCharName, 10) == 0) {
				if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) {
					if(m_pClientList[i]->m_sX == -1 && m_pClientList[i]->m_sX == -1){
						wsprintf(cBuff,"GM Order(%s): GoTo MapName(%s)",m_pClientList[iClientH]->m_cCharName,m_pClientList[i]->m_cMapName);
					}
					else{
						wsprintf(cBuff,"GM Order(%s): GoTo MapName(%s)(%d %d)",m_pClientList[iClientH]->m_cCharName,
							     m_pClientList[i]->m_cMapName,m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
					}
					bSendMsgToLS(MSGID_GAMEMASTERLOG,iClientH,FALSE,cBuff);
					ZeroMemory(cMapName,sizeof(cMapName));
					strcpy(cMapName, m_pClientList[i]->m_cMapName);
					RequestTeleportHandler(iClientH,"2   ", cMapName, m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
				}
				delete pStrTok;
				return;
			}
		}
	}
	m_pClientList[iClientH]->m_bIsAdminOrderGoto = TRUE;

	ZeroMemory(cBuff,sizeof(cBuff));
	
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;

	wp = (WORD *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp,cPlayerName,10);
	cp += 10;

	memcpy(cp,m_pClientList[iClientH]->m_cCharName,10);
	cp += 10;

	bStockMsgToGateServer(cBuff,25);

	delete pStrTok;
}

void CGame::AdminOrder_MonsterCount(int iClientH, char* pData, DWORD dwMsgSize)
{
	int iMonsterCount;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelMonsterCount) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	iMonsterCount = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAliveObject;
	SendNotifyMsg(0,iClientH, DEF_NOTIFY_MONSTERCOUNT, iMonsterCount,NULL,NULL,NULL);
}

// v2.17 2002-7-15 ¿î¿µÀÚ ¸í·É¾î·Î °­Äİ½Ã°£À» ¼³Á¤ÇÑ´Ù.
void CGame::AdminOrder_SetForceRecallTime(int iClientH, char *pData, DWORD dwMsgSize)
{
 class  CStrTok * pStrTok;
 char   seps[] = "= \t\n";
 char   * token, cBuff[256],* cp; 
 WORD * wp ;
 int    iTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;


	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSetRecallTime) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {

		if (token == NULL) 
			 iTime = 0;
		else iTime = atoi(token);
	
		if (iTime < 0) iTime = 0;
	 	
		m_sForceRecallTime = iTime ;

		ZeroMemory(cBuff, sizeof(cBuff));
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_SETFORCERECALLTIME;
		cp++;
	
		wp = (WORD *)cp;
		*wp = iTime ;
		cp += 2;

		bStockMsgToGateServer(cBuff, 3);

		wsprintf(G_cTxt,"(!) Game Server Force Recall Time (%d)min",m_sForceRecallTime) ;
		PutLogList(G_cTxt) ;
	}

	delete pStrTok;
	return ;
}

void CGame::AdminOrder_UnsummonBoss(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelUnsummonBoss) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	for(int i = 1; i < DEF_MAXNPCS; i++){
		if (m_pNpcList[i] != NULL && m_pNpcList[i]->m_bIsSummoned == FALSE) {
			switch(m_pNpcList[i]->m_sType) {
			case 31: //Demon
			case 49: //Hellclaw
			case 45: //GHKABS
			case 47: //BG
			case 50: //Tigerworm
			case 52: //Gagoyle
			case 81: //Abaddon
			case 66: //Wyvern
			case 73: //Fire-Wyvern
				m_pNpcList[i]->m_bIsUnsummoned = TRUE;
				NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
				break;
			}
		}
	}
}

void CGame::AdminOrder_ClearNpc(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelClearNpc) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	for(int i = 1; i < DEF_MAXNPCS; i++){
		if (m_pNpcList[i] != NULL && m_pNpcList[i]->m_bIsSummoned == FALSE) {
			switch(m_pNpcList[i]->m_sType) {
			case 15:
			case 19:
			case 20:
			case 24:
			case 25:
			case 26:
			case 67:
			case 68:
			case 69:
			case 90:
			case 91:
			break;

			default:
				m_pNpcList[i]->m_bIsUnsummoned = TRUE;
				NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
				break;
			}
		}
	}
}

// New 12/05/2004
void CGame::RemoveCrusadeNpcs(void)
{
	for(int i = 0; i < DEF_MAXNPCS; i++){
		if (m_pNpcList[i] != NULL) {
			if ((m_pNpcList[i]->m_sType >= 43 && m_pNpcList[i]->m_sType <= 47) || m_pNpcList[i]->m_sType == 51) {
				NpcKilledHandler(NULL, NULL, i, NULL);
			}
		}
	}
}

void CGame::RemoveCrusadeRecallTime(void)
{
	for(int i = 1; i < DEF_MAXCLIENTS; i++){
		if (m_pClientList[i] != NULL) {
			if (m_pClientList[i]->m_bIsWarLocation == TRUE &&
				m_pClientList[i]->m_bIsPlayerCivil == TRUE &&
				m_pClientList[i]->m_bIsInitComplete == TRUE) {
				m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
			}
		}
	}
}

// New 13/05/2004
BOOL CGame::_bCrusadeLog(int iAction,int iClientH,int iData, char * cName)
{
	char  cTxt[200];

	//  Â·ÃÂ±Ã— Â³Â²Â±Ã¤Â´Ã™. 
	ZeroMemory(cTxt, sizeof(cTxt));

	switch (iAction) {

		case DEF_CRUSADELOG_ENDCRUSADE:
			if (cName == NULL) return FALSE;
			wsprintf(cTxt,"\tEnd Crusade\t%s",cName);
			break;

		case DEF_CRUSADELOG_SELECTDUTY :
			if (cName == NULL) return FALSE;
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tSelect Duty\t(%s)\t \t(%s)", m_pClientList[iClientH]->m_cCharName,cName,m_pClientList[iClientH]->m_cGuildName);
			break ;

		case DEF_CRUSADELOG_GETEXP :
			if (m_pClientList[iClientH] == NULL) return FALSE;
			wsprintf(cTxt, "PC(%s)\tGet Exp\t(%d)\t \t(%s)", m_pClientList[iClientH]->m_cCharName, iData, m_pClientList[iClientH]->m_cGuildName);
			break ;

		case DEF_CRUSADELOG_STARTCRUSADE:
			wsprintf(cTxt,"\tStart Crusade");
			break ;

		default:
			return FALSE;
	}

	bSendMsgToLS(MSGID_GAMECRUSADELOG, iClientH, NULL,cTxt);
	return TRUE ;
}

// Testcode, found reference to it in 3.51, InitPlayerData and RequestTeleportHandler
int CGame::iGetPlayerABSStatus(int iClientH)
{
	int iRet;

	if (m_pClientList[iClientH] == NULL) return 0;

	iRet = 0;

		if (m_pClientList[iClientH]->m_iPKCount != 0) {
			iRet = 8;
		}

		if (m_pClientList[iClientH]->m_cSide != 0) {
			iRet = iRet | 4;
		}

		if (m_pClientList[iClientH]->m_cSide == 1) {
			iRet = iRet | 2;
		}

		if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
			iRet = iRet | 1;

		return iRet;
}

//Init item based in its ID
BOOL CGame::_bInitItemAttr(class CItem * pItem, int iItemID)
{
register int i;

for (i = 0; i < DEF_MAXITEMTYPES; i++) 
	if (m_pItemConfigList[i] != NULL) {
		if (m_pItemConfigList[i]->m_sIDnum == iItemID) {
			// Â°Â°Ã€Âº Ã€ÃŒÂ¸Â§Ã€Â» Â°Â¡ÃÃ¸ Â¾Ã†Ã€ÃŒÃ…Ã› Â¼Â³ÃÂ¤Ã€Â» ÃƒÂ£Â¾Ã’Â´Ã™. Â¼Â³ÃÂ¤Â°ÂªÃ€Â» ÂºÂ¹Â»Ã§Ã‡Ã‘Â´Ã™.
			ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
			strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
			pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
			pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
			pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
			pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
			pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
			pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
			pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
			pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
			pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
			pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
			pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;
			pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;

			pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
			pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
			pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
			pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
			pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
			pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
			pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
			pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;

			pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
			pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

			pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
			pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
			pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;

			pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
			pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;

			return TRUE;
		}
	}
	return FALSE;
}

// New 16/05/2004
void CGame::ReqCreateSlateHandler(int iClientH, char* pData)
{
	int i, iRet;
	short *sp;
	char cItemID[4], ctr[4];
	char *cp, cSlateColour, cData[120];
	BOOL bIsSlatePresent = FALSE;
	CItem * pItem;
	int iSlateType, iEraseReq;
	DWORD *dwp;
	WORD *wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

	for(i = 0; i < 4; i++){
		cItemID[i] = 0;
		ctr[i] = 0;
	}

	cp = (char *)pData;
	cp += 11;

	// 14% chance of creating slates
	if (iDice(1,100) < m_sSlateSuccessRate) bIsSlatePresent = TRUE;

    try{
	// make sure slates really exist
	for(i = 0; i < 4; i++){
		cItemID[i] = *cp;
		cp++;

		if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] == NULL || cItemID[i] >DEF_MAXITEMS){ 
			bIsSlatePresent = FALSE;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);  			
			return; 
		}

		//No duping
		if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 868) // LU
			ctr[0] = 1;
		else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 869) // LD
			ctr[1] = 1;
		else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 870) // RU
			ctr[2] = 1;
		else if (m_pClientList[iClientH]->m_pItemList[cItemID[i]]->m_sIDnum == 871) // RD
			ctr[3] = 1;
	}
     }
     catch(...){
	//Crash Hacker Caught
	bIsSlatePresent = FALSE;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL);  
	wsprintf(G_cTxt, "TSearch Slate Hack: (%s) Player: (%s) - creating slates without correct item!", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
	PutHackLogFileList(G_cTxt);
	DeleteClient(iClientH, TRUE, TRUE);
	return;
     }

	// Are all 4 slates present ??
	if (ctr[0] != 1 || ctr[1] != 1 || ctr[2] != 1 || ctr[3] != 1) {
		bIsSlatePresent = FALSE;
		return; 
	}

	if (m_pClientList[iClientH]->m_iAdminUserLevel > 3) bIsSlatePresent = TRUE;

	// if we failed, kill everything
	if (!bIsSlatePresent) { 
		for(i = 0; i < 4; i++){ 
			if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) {
				ItemDepleteHandler(iClientH,cItemID[i], FALSE);
			}
		} 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATEFAIL, NULL, NULL, NULL, NULL); 
		return; 
	}

	// make the slates
	for(i = 0; i < 4; i++){
		if(m_pClientList[iClientH]->m_pItemList[cItemID[i]] != NULL) {
			ItemDepleteHandler(iClientH,cItemID[i], FALSE);
		}
	}

	pItem = new class CItem;

	i = iDice(1,1000);

	if (i < 50) { // Hp slate
		iSlateType = 1;
		cSlateColour = 32;
	}
	else if (i < 250) { // Bezerk slate
		iSlateType = 2;
		cSlateColour = 3;
	}
	else if (i < 750) { // Exp slate
		iSlateType = 4;
		cSlateColour = 7;
	}
	else if (i < 950) { // Mana slate
		iSlateType = 3;
		cSlateColour = 37;
	}
	else if (i <  1001) { // Hp slate
		iSlateType = 1;
		cSlateColour = 32;
	}

	// Notify client
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SLATE_CREATESUCCESS, iSlateType, NULL, NULL, NULL);

	ZeroMemory(cData,sizeof(cData));

	// Create slates
	if (_bInitItemAttr(pItem, 867) == FALSE) {
		delete pItem;
		return;
	}
	else{
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		pItem->m_sTouchEffectValue3 = (short)timeGetTime();

		_bItemLog(DEF_ITEMLOG_GET, iClientH, -1, pItem);

		pItem->m_sItemSpecEffectValue2 = iSlateType;
		pItem->m_cItemColor = cSlateColour;
		if(_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE){
			ZeroMemory(cData,sizeof(cData));
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp = 1;
			cp++;

			memcpy(cp, pItem->m_cName, 20);
			cp += 20;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
			cp++;

			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;

			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor;
			cp++;

			*cp = (char)pItem->m_sItemSpecEffectValue2;
			cp ++;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;

			if (iEraseReq == 1) delete pItem;

			// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
			switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Ş½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ıÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
			}
		}
		else{
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			SendEventToNearClient_TypeB(MSGID_MAGICCONFIGURATIONCONTENTS, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
										m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem->m_sSprite, pItem->m_sSpriteFrame,
										pItem->m_cItemColor);
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;

			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ¸Ş½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ıÇß´Ù¸é Á¦°ÅÇÑ´Ù.
						DeleteClient(iClientH, TRUE, TRUE);
						break;
			}
		}
	}
	return;
}

void CGame::SetSlateFlag(int iClientH, short sType, bool bFlag)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (sType == DEF_NOTIFY_SLATECLEAR) {
		m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
		m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
		m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
		return;
	}

	if (bFlag == TRUE) {
		if (sType == 1) { // Invincible slate
			m_pClientList[iClientH]->m_iStatus |= 0x400000;
		}
		else if (sType == 3) { // Mana slate
			m_pClientList[iClientH]->m_iStatus |= 0x800000;
		}
		else if (sType == 4) { // Exp slate
			m_pClientList[iClientH]->m_iStatus |= 0x10000;
		}
	}
	else{
		if ((m_pClientList[iClientH]->m_iStatus & 0x400000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFFBFFFFF;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & 0x800000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFF7FFFFF;
		}
		else if ((m_pClientList[iClientH]->m_iStatus & 0x10000) != 0) {
			m_pClientList[iClientH]->m_iStatus &= 0xFFFEFFFF;
		}
	}

	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

// New 18/05/2004
void CGame::SetPlayingStatus(int iClientH)
{
	char cMapName[11], cLocation[11];

	if (m_pClientList[iClientH] == NULL) return;

	ZeroMemory(cMapName, sizeof(cMapName));
	ZeroMemory(cLocation, sizeof(cLocation));

	strcpy(cLocation, m_pClientList[iClientH]->m_cLocation);
	strcpy(cMapName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex]->m_cName);

	m_pClientList[iClientH]->m_cSide = 0;
	m_pClientList[iClientH]->m_bIsOwnLocation = FALSE;
	m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;

	if (memcmp(cLocation, cMapName, 3) == 0) {
		m_pClientList[iClientH]->m_bIsOwnLocation = TRUE;
	}

	if (memcmp(cLocation, "are", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 1;
	else if (memcmp(cLocation, "elv", 3) == 0)
		m_pClientList[iClientH]->m_cSide = 2;
	else{ 
		if (strcmp(cMapName, "elvine") == 0 || strcmp(cMapName, "aresden") == 0) {
			m_pClientList[iClientH]->m_bIsOwnLocation = TRUE;
		}
		m_pClientList[iClientH]->m_bIsNeutral = TRUE;
	}

	if (memcmp(cLocation, "arehunter", 9) == 0 || memcmp(cLocation, "elvhunter", 9) == 0) {
		m_pClientList[iClientH]->m_bIsPlayerCivil = TRUE;
	}

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) == 0) {
		m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;
	}

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "bsmith", 6) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "gldhall", 7) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "gshop", 5) == 0)
		m_pClientList[iClientH]->m_pIsProcessingAllowed = TRUE;
	else
		m_pClientList[iClientH]->m_pIsProcessingAllowed = FALSE;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "wrhus", 5) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "arewrhus", 8) == 0 ||
		memcmp(m_pClientList[iClientH]->m_cMapName, "elvwrhus", 8) == 0)
		m_pClientList[iClientH]->m_bIsInsideWarehouse = TRUE;
	else
		m_pClientList[iClientH]->m_bIsInsideWarehouse = FALSE;

	if (memcmp(m_pClientList[iClientH]->m_cMapName, "wzdtwr", 6) == 0)
		m_pClientList[iClientH]->m_bIsInsideWizardTower = TRUE;
	else
		m_pClientList[iClientH]->m_bIsInsideWizardTower = FALSE;
}

void CGame::ForceChangePlayMode(int iClientH, bool bNotify)
{
	if(m_pClientList[iClientH] == NULL) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "arehunter", 9) == 0)
		strcpy(m_pClientList[iClientH]->m_cLocation, "aresden");
	else if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvhunter", 9) == 0)
		strcpy(m_pClientList[iClientH]->m_cLocation, "elvine");

	if (m_pClientList[iClientH]->m_bIsPlayerCivil == TRUE)
		m_pClientList[iClientH]->m_bIsPlayerCivil = FALSE;

	if (bNotify) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CHANGEPLAYMODE, NULL, NULL, NULL, m_pClientList[iClientH]->m_cLocation);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
	}
}

void CGame::ShowVersion(int iClientH)
{
	char cVerMessage[256];

	ZeroMemory(cVerMessage, sizeof(cVerMessage));
	wsprintf(cVerMessage, "Helbreath Sources %s.%s - www.xtremehb.com", DEF_UPPERVERSION, DEF_LOWERVERSION);
	ShowClientMsg(iClientH, cVerMessage);

}

// v2.15 2002-5-21
void CGame::GSM_RequestShutupPlayer(char * pGMName,WORD wReqServerID, WORD wReqClientH, WORD wTime,char * pPlayer )
{
	char * cp, cTemp[120];
	WORD * wp;
	register int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pPlayer) == 0)) {
			// ÃƒÂ£Â¾Ã’Â´Ã™.
			ZeroMemory(cTemp, sizeof(cTemp));
			cp = (char *)(cTemp);
			*cp = GSM_RESPONSE_SHUTUPPLAYER;
			cp++;

			wp = (WORD *)cp;
			*wp = wReqServerID;
			cp += 2;

			wp = (WORD *)cp;
			*wp = wReqClientH;
			cp += 2;

			memcpy(cp, pGMName, 10);
			cp += 10;

			wp = (WORD *)cp;
			*wp = (WORD) wTime;
			cp += 2;

			memcpy(cp, pPlayer, 10);
			cp += 10;

			// v2.14 Â¼Ã‹Â¾Ã·Â½ÃƒÂ°Â£Ã€Â» ÂºÃÃ€Â¸Â·Ã Â¼Ã¶ÃÂ¤
			m_pClientList[i]->m_iTimeLeft_ShutUp = wTime*20; // 1Ã€ÃŒ 3ÃƒÃŠÂ´Ã™. 20Ã€ÃŒÂ¸Ã© 1ÂºÃ 

			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, wTime, NULL, NULL, pPlayer);

			bStockMsgToGateServer(cTemp, 27);
			return;	
		}
}

// v2.14 05/22/2004 - Hypnotoad - adds pk log
BOOL CGame::_bPKLog(int iAction,int iAttackerH , int iVictumH, char * pNPC)
{
	char  cTxt[1024], cTemp1[120], cTemp2[120];

	//  Â·ÃÂ±Ã— Â³Â²Â±Ã¤Â´Ã™. 
	ZeroMemory(cTxt, sizeof(cTxt));
	ZeroMemory(cTemp1, sizeof(cTemp1));
	ZeroMemory(cTemp2, sizeof(cTemp2));

	if ( m_pClientList[iVictumH] == NULL) return FALSE ;

	switch (iAction) {

		case DEF_PKLOG_REDUCECRIMINAL: 
			wsprintf(cTxt, "(%s) PC(%s)\tReduce\tCC(%d)\t%s(%d %d)\t", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, m_pClientList[iVictumH]->m_iPKCount,
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 

		case DEF_PKLOG_BYPLAYER:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by PC\t \t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
			break;
		case DEF_PKLOG_BYPK:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by PK\tCC(%d)\t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, m_pClientList[iAttackerH]->m_iPKCount,
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case DEF_PKLOG_BYENERMY:
			if ( m_pClientList[iAttackerH] == NULL) return FALSE ;
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by Enemy\t \t%s(%d %d)\t(%s) PC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,m_pClientList[iAttackerH]->m_cIPaddress, m_pClientList[iAttackerH]->m_cCharName);
			break; 
		case DEF_PKLOG_BYNPC:
			if(pNPC==NULL) return FALSE ;
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by NPC\t \t%s(%d %d)\tNPC(%s)", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY,pNPC);
			break; 
		case DEF_PKLOG_BYOTHER:
			wsprintf(cTxt, "(%s) PC(%s)\tKilled by Other\t \t%s(%d %d)\tUnknown", m_pClientList[iVictumH]->m_cIPaddress, m_pClientList[iVictumH]->m_cCharName, 
				m_pClientList[iVictumH]->m_cMapName,m_pClientList[iVictumH]->m_sX,m_pClientList[iVictumH]->m_sY);
			break; 
		default:
			return FALSE;
	}
	PutPvPLogFileList(cTxt);
	return TRUE ;
}

void CGame::RequestResurrectPlayer(int iClientH, bool bResurrect)
{
short sX, sY;
char buff[100];

	if (m_pClientList[iClientH] == NULL) return;

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	if (bResurrect == FALSE) {
		m_pClientList[iClientH]->m_bIsBeingResurrected = FALSE;
		return;
	}

	if (m_pClientList[iClientH]->m_bIsBeingResurrected == FALSE) {
		wsprintf(buff, "(!!!) Player(%s) Tried To Use Resurrection Hack", m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE, TRUE, TRUE);
		return;
	}

	wsprintf(buff, "(*) Resurrect Player! %s", m_pClientList[iClientH]->m_cCharName);
	PutLogList(buff);


	m_pClientList[iClientH]->m_bIsKilled = FALSE;
	// Player's HP becomes half of the Max HP. 
	m_pClientList[iClientH]->m_iHP = iGetMaxHP(iClientH)/2; 
	// Player's MP
	m_pClientList[iClientH]->m_iMP = ((m_pClientList[iClientH]->m_iMag*2)+(m_pClientList[iClientH]->m_iLevel/2))+m_pClientList[iClientH]->m_iInt/2;
	// Player's SP
	m_pClientList[iClientH]->m_iSP = (m_pClientList[iClientH]->m_iStr*2)+(m_pClientList[iClientH]->m_iLevel/2);
	// Player's Hunger
	m_pClientList[iClientH]->m_iHungerStatus = 100;

	m_pClientList[iClientH]->m_bIsBeingResurrected = FALSE;

	// !!! RequestTeleportHandlerÂ³Â»Â¿Â¡Â¼Â­ m_cMapNameÃ€Â» Â¾Â²Â±Ã¢ Â¶Â§Â¹Â®Â¿Â¡ Â±Ã—Â´Ã«Â·Ã Ã†Ã„Â¶Ã³Â¹ÃŒÃ…ÃÂ·Ã Â³Ã‘Â°ÃœÃÃ–Â¸Ã© Â¿Ã€ÂµÂ¿Ã€Ã›
	RequestTeleportHandler(iClientH, "2   ", m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
}

BOOL CGame::bCheckClientAttackFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return FALSE;

	if (m_pClientList[iClientH]->m_dwAttackFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwAttackFreqTime;
		m_pClientList[iClientH]->m_dwAttackFreqTime = dwClientTime;

		if (dwTimeGap < 450) {
			wsprintf(G_cTxt, "Swing Hack: (%s) Player: (%s) - attacking with weapon at irregular rates.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);

			return FALSE;
		}

		//testcode
		//wsprintf(G_cTxt, "Attack: %d", dwTimeGap);
		//PutLogList(G_cTxt);
	}

	return FALSE;
}

BOOL CGame::bCheckClientMagicFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;
	
	if (m_pClientList[iClientH] == NULL) return FALSE;

	if (m_pClientList[iClientH]->m_dwMagicFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;
	else {
		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMagicFreqTime;
		m_pClientList[iClientH]->m_dwMagicFreqTime = dwClientTime;

		if ((dwTimeGap < 1500) && (m_pClientList[iClientH]->m_bMagicConfirm == TRUE)) {
			wsprintf(G_cTxt, "Speed Cast: (%s) Player: (%s) - casting magic at irregular rates. ", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);
			return FALSE;
		}
		
		m_pClientList[iClientH]->m_iSpellCount--;
		m_pClientList[iClientH]->m_bMagicConfirm = FALSE;
		m_pClientList[iClientH]->m_bMagicPauseTime = FALSE;
		
		//testcode
		//wsprintf(G_cTxt, "Magic: %d", dwTimeGap);
		//PutLogList(G_cTxt);
	}

	return FALSE;
}

BOOL CGame::bCheckClientMoveFrequency(int iClientH, DWORD dwClientTime)
{
 DWORD dwTimeGap;
	
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return FALSE;

	if (m_pClientList[iClientH]->m_dwMoveFreqTime == NULL) 
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
	else {
		if (m_pClientList[iClientH]->m_bIsMoveBlocked == TRUE) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
			m_pClientList[iClientH]->m_bIsMoveBlocked = FALSE;
			return FALSE;
		}

		if (m_pClientList[iClientH]->m_bIsAttackModeChange == TRUE) {
			m_pClientList[iClientH]->m_dwMoveFreqTime = NULL;
			m_pClientList[iClientH]->m_bIsAttackModeChange = FALSE;
			return FALSE;
		}

		dwTimeGap = dwClientTime - m_pClientList[iClientH]->m_dwMoveFreqTime;
		m_pClientList[iClientH]->m_dwMoveFreqTime = dwClientTime;
		
		if ((dwTimeGap < 200) && (dwTimeGap >= 0)) {
			wsprintf(G_cTxt, "Speed Hack: (%s) Player: (%s) - running too fast.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
			PutHackLogFileList(G_cTxt);
			DeleteClient(iClientH, TRUE, TRUE);
			return FALSE;
		}

		// testcode
		// wsprintf(G_cTxt, "Move: %d", dwTimeGap);
		// PutLogList(G_cTxt);
	}

	return FALSE;
}

/*
BOOL CGame::bCheckClientInvisibility(short iClientH)
{
	BOOL bFlag;
	int iShortCutIndex;
	int i;
	short sRange;

	if(m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return FALSE;

	bFlag = TRUE;
	iShortCutIndex = 0;

		while(bFlag){

Raven-HBRND(www.hbrnd.com) says:
what i suggest
is .. if its requesting
to see the other side whyle invsie
check the bag
for the neckie

			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;

			if ((bFlag == TRUE) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if ( (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) &&
				     (m_pClientList[i]->m_sX >= m_pClientList[iClientH]->m_sX - 10 - sRange) &&
				 	 (m_pClientList[i]->m_sX <= m_pClientList[iClientH]->m_sX + 10 + sRange) &&
				 	 (m_pClientList[i]->m_sY >= m_pClientList[iClientH]->m_sY - 8 - sRange) &&
					 (m_pClientList[i]->m_sY <= m_pClientList[iClientH]->m_sY + 8 + sRange) ) {

			// iClient = center screen character
			// i = visable characters on screen

					if ( (m_pClientList[iClientH]->m_cSide != m_pClientList[i]->m_cSide) 
								&& (i != iClientH) 
								&& (m_pClientList[iClientH]->m_sAppr4 == m_pClientList[iClientH]->m_sAppr4 & 0x0001)
								) {
						//wsprintf(G_cTxt, "(!) Invisibility Hack Suspect: (%s)", m_pClientList[iClientH]->m_cCharName);
						//PutLogList(G_cTxt);
						//DeleteClient(iClientH, TRUE, TRUE);
						}
					}
			}
		}
	return FALSE;
}*/

void CGame::CrusadeWarStarter()
{
 SYSTEMTIME SysTime;
 int i;

	if (m_bIsCrusadeMode == TRUE) return;
	if (m_bIsCrusadeWarStarter == FALSE) return;

	// °ÔÀÓ ¼­¹ö 1¹ø¿¡¼­¸¸ 
	GetLocalTime(&SysTime);
	
	for (i = 0; i < DEF_MAXSCHEDULE; i++)
	if	((m_stCrusadeWarSchedule[i].iDay == SysTime.wDayOfWeek) && 
		(m_stCrusadeWarSchedule[i].iHour == SysTime.wHour) && 
		(m_stCrusadeWarSchedule[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated crusade is being initiated!");
			GlobalStartCrusadeMode();
			return;
	}
}

void CGame::OnTimer(char cType)
{
DWORD dwTime;

dwTime = timeGetTime();

//if ((dwTime - m_dwGameTime1) > 200) {
GameProcess();
// m_dwGameTime1 = dwTime;
//}


if ((dwTime - m_dwGameTime2) > 3000) {
 CheckClientResponseTime();
 SendMsgToGateServer(MSGID_GAMESERVERALIVE, NULL);
 CheckDayOrNightMode();
 // È­¸é °»½Å 
 InvalidateRect(G_hWnd, NULL, TRUE);
 m_dwGameTime2 = dwTime;
 // v1.41 
 _CheckGateSockConnection();
 
 // v1.41
 if ((m_bIsGameStarted == FALSE)     && (m_bIsItemAvailable == TRUE)      && 
  (m_bIsNpcAvailable == TRUE)     && (m_bIsGateSockAvailable == TRUE)  &&
  (m_bIsLogSockAvailable == TRUE) && (m_bIsMagicAvailable == TRUE)     &&
  (m_bIsSkillAvailable == TRUE)   && (m_bIsPortionAvailable == TRUE)   &&
  (m_bIsQuestAvailable == TRUE)   && (m_bIsBuildItemAvailable == TRUE) && 
  (m_iSubLogSockActiveCount == DEF_MAXSUBLOGSOCK)) {
  // °ÔÀÓÀ» ½ÃÀÛÇÒ ÁØºñ°¡ µÇ¾ú´Ù. ¸Ş½ÃÁö¸¦ º¸³½´Ù.
  PutLogList("Sending start message...");
  SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL);
  m_bIsGameStarted = TRUE;
 }
}
	if ((dwTime - m_dwGameTime6) > 1000) {
		DelayEventProcessor();
		SendStockMsgToGateServer();
		m_dwGameTime6 = dwTime;

		// v2.05
		if (m_iFinalShutdownCount != 0) {
			m_iFinalShutdownCount--;
			wsprintf(G_cTxt, "Final Shutdown...%d", m_iFinalShutdownCount);
			PutLogList(G_cTxt);
			if (m_iFinalShutdownCount <= 1) {
				// 2.14 ¼ºÈÄ´Ï ¼Ë´Ù¿î½Ã ¹«Á¶°Ç ·Î±× ÀúÀå 
				SendMessage(m_hWnd, WM_CLOSE, NULL, NULL);
				return;
				
			}
		}
	}

	if ((dwTime - m_dwGameTime3) > 3000) {
		SyncMiddlelandMapInfo();
		CheckDynamicObjectList();
		DynamicObjectEffectProcessor();
		NoticeHandler();
		SpecialEventHandler();
		EnergySphereProcessor();
		m_dwGameTime3 = dwTime;
	}

	if ((dwTime - m_dwGameTime4) > 600) {
	 MobGenerator();

	 // v1.432-3 Sub-Log-SocketÀ» ÇÑ²¨¹ø¿¡ ¸¸µå´Â °ÍÀÌ ¾Æ´Ï¶ó ³ª´©¾î ¸¸µç´Ù.
	 if (m_iSubLogSockInitIndex < DEF_MAXSUBLOGSOCK) {
	  m_pSubLogSock[m_iSubLogSockInitIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	  m_pSubLogSock[m_iSubLogSockInitIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iSubLogSockInitIndex + 1));
	  m_pSubLogSock[m_iSubLogSockInitIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);
	  wsprintf(G_cTxt, "(!) Try to connect sub-log-socket(%d)... Addr:%s  Port:%d", m_iSubLogSockInitIndex, m_cLogServerAddr, m_iLogServerPort);
	  PutLogList(G_cTxt);
	  m_iSubLogSockInitIndex++;
	 }

	 m_dwGameTime4 = dwTime;
	}



	if ((dwTime - m_dwGameTime5) > 1000*60*3) {
		
		if (m_iMiddlelandMapIndex >= 0) {
			// Crusade
			SaveOccupyFlagData();
			//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
			//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
		}
		m_dwGameTime5 = dwTime;

		// v1.41 ·£´ı ½Ãµå°ª ÃÊ±âÈ­.
		srand( (unsigned)time( NULL ) );   
	}

	if ((dwTime - m_dwFishTime) > 4000) {
		FishProcessor();
		FishGenerator();
		SendCollectedMana();
		CrusadeWarStarter();
		//ApocalypseStarter();
		ApocalypseEnder();
		m_dwFishTime = dwTime;
	}
	
	if ((dwTime - m_dwWhetherTime) > 1000*20) {
		WhetherProcessor();
		m_dwWhetherTime = dwTime;
	}
	
	if ((m_bHeldenianRunning == TRUE) && (m_bIsHeldenianMode == TRUE)) {
		SetHeldenianMode();
	}
	// v1.4311-3 Ãß°¡  µÎ½Ã°£¸¶´Ù »çÅõÀå ¿¹¾àÀ» ÃÊ±âÈ­ÇÏ°í ¿¹¾àÇÑ À¯Àú¿¡°Ô »ç½ÇÀ» ¾Ë·ÁÁØ´Ù. 1000*60*60*2 = 7200000
	if ((dwTime - m_dwCanFightzoneReserveTime) > 7200000) {
		FightzoneReserveProcessor();
		m_dwCanFightzoneReserveTime = dwTime;
	}

	if ((m_bIsServerShutdowned == FALSE) && (m_bOnExitProcess == TRUE) && ((dwTime - m_dwExitProcessTime) > 1000*2)) {
		if (_iForcePlayerDisconect(15) == 0) {
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS COMPLETED! All players are disconnected.");
			m_bIsServerShutdowned = TRUE;

			// v1.41 ¸¸¾à ¼ÒÄÏÀÌ ²÷¾îÁ®¼­ ÀÚµ¿ ¼Ë´Ù¿î µÈ °ÍÀÌ¶ó¸é ´Ù½Ã ¼­¹ö¸¦ ±âµ¿½ÃÅ²´Ù. 
			if ((m_cShutDownCode == 3) || (m_cShutDownCode == 4)) {
				PutLogFileList("(!!!) AUTO-SERVER-REBOOTING!");
				bInit();
				m_iAutoRebootingCount++;
			}
			else {
				// v1.432 ¼­¹ö ¼Ë´Ù¿îÀÌ ³¡³ª¸é ÃÖÁ¾ Á¾·á Ä«¿îÆ® ´Ù¿î¿¡ µé¾î°£´Ù. ¾ÆÁ÷ Àü´ŞµÇÁö ¾ÊÀº ¸Ş½ÃÁö¸¦ Àü¼ÛÇÏ±â À§ÇÑ ¿©À¯½Ã°£À» µÎ´Â°ÍÀÌ ¸ñÀû. v2.05
				if (m_iFinalShutdownCount == 0)	m_iFinalShutdownCount = 20;
			}
		}
		m_dwExitProcessTime = dwTime;
	}

	// v1.432-2 10ÃÊ¸¶´Ù ¼½ÅÍ Á¤º¸ ºĞ¼® 
	if ((dwTime - m_dwMapSectorInfoTime) > 1000*10) {
		m_dwMapSectorInfoTime = dwTime;
		UpdateMapSectorInfo();

		// v2.03 ±¤¹°ÀÌ ³ª¿À´Â ºóµµ¼ö¸¦ ÁÙÀÓ 
		MineralGenerator();

		m_iMapSectorInfoUpdateCount++;
		if (m_iMapSectorInfoUpdateCount >= 5) {
			// ½Ã°£ÀÌ Áö³²¿¡ µû¶ó È°µ¿ ºóµµ Ä«¿îÆ®¸¦ °¨¼Ò½ÃÅ´.
			AgingMapSectorInfo();
			m_iMapSectorInfoUpdateCount = 0;
		}
	}
}

BOOL CGame::bReadScheduleConfigFile(char *pFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == NULL) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀĞÀ» ¼ö ¾ø´Ù.
		PutLogList("(!) Cannot open Schedule file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Schedule file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					if (strcmp(m_cServerName, token) == 0) {
						PutLogList("(!) Success: This server will schedule crusade total war.");
						m_bIsCrusadeWarStarter = TRUE;
					}
					cReadModeA = 0;
					break;

				case 2:
					if (strcmp(m_cServerName, token) == 0) {
						PutLogList("(!) Success: This server will schedule apocalypse.");
						m_bIsApocalypseStarter = TRUE;
					}
					cReadModeA = 0;
					break;

				case 3:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXSCHEDULE) {
							PutLogList("(!) WARNING! Too many crusade war schedule!"); 
							return TRUE;
						}
						m_stCrusadeWarSchedule[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stCrusadeWarSchedule[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stCrusadeWarSchedule[iIndex].iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 4:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXAPOCALYPSE) {
							PutLogList("(!) WARNING! Too many Apocalypse schedule!"); 
							return TRUE;
						}
						m_stApocalypseScheduleStart[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stApocalypseScheduleStart[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stApocalypseScheduleStart[iIndex].iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 5:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXAPOCALYPSE) {
							PutLogList("(!) WARNING! Too many Apocalypse schedule!"); 
							return TRUE;
						}
						m_stApocalypseScheduleEnd[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stApocalypseScheduleEnd[iIndex].iHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stApocalypseScheduleEnd[iIndex].iMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				case 6:
					switch (cReadModeB) {
					case 1:
						if (iIndex >= DEF_MAXHELDENIAN) {
							PutLogList("(!) WARNING! Too many Heldenians scheduled!"); 
							return TRUE;
						}
						m_stHeldenianSchedule[iIndex].iDay = atoi(token);
						cReadModeB = 2;
						break;
					case 2:
						m_stHeldenianSchedule[iIndex].StartiHour = atoi(token);
						cReadModeB = 3;
						break;
					case 3:
						m_stHeldenianSchedule[iIndex].StartiMinute = atoi(token);
						cReadModeB = 4;
						break;
					case 4:
						m_stHeldenianSchedule[iIndex].EndiHour = atoi(token);
						cReadModeB = 5;
						break;
					case 5:
						m_stHeldenianSchedule[iIndex].EndiMinute = atoi(token);
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;

					}
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-server-name", 19) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-server-name", 22) == 0) {
					cReadModeA = 2;
					cReadModeB = 1;
				}
				if (memcmp(token, "crusade-schedule", 16) == 0) {
					cReadModeA = 3;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-schedule-start", 25) == 0) {
					cReadModeA = 4;
					cReadModeB = 1;
				}
				if (memcmp(token, "apocalypse-schedule-end", 23) == 0) {
					cReadModeA = 5;
					cReadModeB = 1;
				}
				if (memcmp(token, "Heldenian-schedule", 18) == 0) {
					cReadModeA = 6;
					cReadModeB = 1;
				}
			}
			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}


void CGame::GlobalStartCrusadeMode()
{
 char * cp, cData[120];
 DWORD * dwp, dwCrusadeGUID;
 SYSTEMTIME SysTime;

	// ¿À·ù·Î ÀÎÇØ ÇÏ·ç¿¡ µÎ¹ø Àü¸éÀüÀÌ ¹ß»ıÇÏ´Â °ÍÀ» ¸·´Â ÄÚµå 
	GetLocalTime(&SysTime);
	if (m_iLatestCrusadeDayOfWeek != -1) {
		if (m_iLatestCrusadeDayOfWeek == SysTime.wDayOfWeek) return;
	}
	else m_iLatestCrusadeDayOfWeek = SysTime.wDayOfWeek;

	dwCrusadeGUID = timeGetTime();

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINCRUSADE;
	cp++;
	dwp = (DWORD *)cp;
	*dwp = dwCrusadeGUID;
	cp += 4;

	bStockMsgToGateServer(cData, 5);

	LocalStartCrusadeMode(dwCrusadeGUID);
}

void CGame::OnStartGameSignal()
{
 int i;
	
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) 
		_bReadMapInfoFiles(i);
	
	bReadCrusadeStructureConfigFile("..\\GameConfigs\\Crusade.cfg");
	_LinkStrikePointMapIndex();
	bReadScheduleConfigFile("..\\GameConfigs\\Schedule.cfg");

	bReadCrusadeGUIDFile("GameData\\CrusadeGUID.txt");
	bReadApocalypseGUIDFile("GameData\\ApocalypseGUID.txt");
	bReadHeldenianGUIDFile("GameData\\HeldenianGUID.txt");
	
	PutLogList("");
	PutLogList("(!) Game Server Activated.");

}

void CGame::RequestGuildTeleportHandler(int iClientH)
{
 register int i;
 char cMapName[11];
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iLockedMapTime != NULL) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
		return;
	}

	// if a guild teleport is set when its not a crusade, log the hacker
	if (!m_bIsCrusadeMode) {
		wsprintf(G_cTxt, "Accessing crusade teleport: (%s) Player: (%s) - setting teleport location when crusade is disabled.", 
			m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	// if a player is using guild teleport and he is not in a guild, log the hacker
	if (m_pClientList[iClientH]->m_iCrusadeDuty == 0) {
		wsprintf(G_cTxt, "Accessing crusade teleport: (%s) Player: (%s) - teleporting when not in a guild", 
			m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	if ((m_pClientList[iClientH]->m_cMapIndex == m_iMiddlelandMapIndex) &&
		m_iMiddlelandMapIndex != -1)
		return;

	for (i = 0; i < DEF_MAXGUILDS; i++) 
	if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
		// ±æµå¸¦ Ã£¾Ò´Ù.
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, m_pGuildTeleportLoc[i].m_cDestMapName);

		//testcode
		wsprintf(G_cTxt, "ReqGuildTeleport: %d %d %d %s", m_pClientList[iClientH]->m_iGuildGUID, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY, cMapName);
		PutLogList(G_cTxt);

		// !!! RequestTeleportHandler³»¿¡¼­ m_cMapNameÀ» ¾²±â ¶§¹®¿¡ ±×´ë·Î ÆÄ¶ó¹ÌÅÍ·Î ³Ñ°ÜÁÖ¸é ¿Àµ¿ÀÛ
		RequestTeleportHandler(iClientH, "2   ", cMapName, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY);
		return;
	}
	
	// ±æµå¿¡ ÇÒ´çµÈ ÅÚ·¹Æ÷Æ® ÁÂÇ¥°¡ ¾ø´Ù. ±æµå ¼Ò¼ÓÀÌ ¾Æ´Ñ °æ¿ì
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: // ¾Æ·¹½ºµ§ ¼Ò¼Ó 
		break;
	case 2: // ¿¤¹ÙÀÎ ¼Ò¼Ó
		break;
	}
}


void CGame::GSM_SetGuildTeleportLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
 int i, iIndex;
 DWORD dwTemp, dwTime;

	// Å¬¶óÀÌ¾ğÆ®·ÎºÎÅÍÀÇ ¿äÃ»ÀÌ ¾Æ´Ï¶ó ´Ù¸¥ ¼­¹ö·ÎºÎÅÍÀÇ ÅÚ·¹Æ÷Æ® ÁÂÇ¥ ¼³Á¤ ¿äÃ»ÀÓ. ÀÀ´äÇÒ ÇÊ¿ä ¾øÀ½.
	
	//testcode
	wsprintf(G_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = timeGetTime();

	// ¸ÕÀú °°Àº GUID¸¦ °¡Áø ±æµå ÅÚ·¹Æ÷Æ® ÁÂÇ¥°¡ ¼³Á¤µÇ¾î ÀÖ´ÂÁö Ã£´Â´Ù.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// ÀÌ¹Ì ±æµå°¡ ÀÖ´Ù.
		if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
			// ³»¿ëÀÌ ÀÏÄ¡ÇÑ´Ù. Å¸ÀÓ ÀÔ·ÂÈÄ ½ºÅµ.
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			// ³»¿ë °»½Å
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
	}
	
	// ¼³Á¤µÈ ³»¿ëÀÌ ¾ø´Ù. »õ·Î ¼³Á¤ÇÑ´Ù.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			// °¡Àå ¿À·§µ¿¾È ÂüÁ¶µÇÁö ¾ÊÀº ¸®½ºÆ®ÀÇ ÀÎµ¦½º¸¦ Ã£´Â´Ù.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	// Ä³½Ã °ø°£ÀÌ ´Ù Ã¡´Ù. ÀÌ·± °æ¿ì ¸®½ºÆ® Áß °¡Àå ¿À·§µ¿¾È »ç¿ëÇÏÁö ¾ÊÀº ¸®½ºÆ®(iIndex)¸¦ »èÁ¦ÇÏ°í ¾÷µ¥ÀÌÆ® ÇÑ´Ù.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;
}


void CGame::RequestSetGuildTeleportLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
 char * cp, cData[120];
 register int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsOnServerChange == TRUE) return;

	// if a player is teleporting and its not a crusade, log the hacker
	if (!m_bIsCrusadeMode) {
		wsprintf(G_cTxt, "Accessing Crusade Set Teleport:(%s) Player: (%s) - setting point when not a crusade.", 
			m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	
	// if a player is teleporting and its not a crusade, log the hacker
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) {
		wsprintf(G_cTxt, "Accessing Crusade Set Teleport: (%s) Player: (%s) - setting point when not a guildmaster.", 
			m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	// v2.04 ÁÂÇ¥ º¸Á¤ 
	if (dY < 100) dY = 100;
	if (dY > 600) dY = 600;

	// °ÔÀÌÆ® ¼­¹ö ¸Ş½ÃÁö ÀÛ¼º 
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDTELEPORTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;
	
	memcpy(cp, pMapName, 10);
	cp += 10;
	//

	dwTime = timeGetTime();

	//testcode
	wsprintf(G_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	// ¸ÕÀú °°Àº GUID¸¦ °¡Áø ±æµå ÅÚ·¹Æ÷Æ® ÁÂÇ¥°¡ ¼³Á¤µÇ¾î ÀÖ´ÂÁö Ã£´Â´Ù.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// ÀÌ¹Ì ±æµå°¡ ÀÖ´Ù.
		if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
			// ³»¿ëÀÌ ÀÏÄ¡ÇÑ´Ù. Å¸ÀÓ ÀÔ·ÂÈÄ ½ºÅµ.
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			// ³»¿ë °»½ÅÈÄ 
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				
			//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û
			bStockMsgToGateServer(cData, 23);
			return;
		}
	}
	
	// ¼³Á¤µÈ ³»¿ëÀÌ ¾ø´Ù. »õ·Î ¼³Á¤ÇÑ´Ù.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;

			//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û  
			bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			// °¡Àå ¿À·§µ¿¾È ÂüÁ¶µÇÁö ¾ÊÀº ¸®½ºÆ®ÀÇ ÀÎµ¦½º¸¦ Ã£´Â´Ù.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	// Ä³½Ã °ø°£ÀÌ ´Ù Ã¡´Ù. ÀÌ·± °æ¿ì ¸®½ºÆ® Áß °¡Àå ¿À·§µ¿¾È »ç¿ëÇÏÁö ¾ÊÀº ¸®½ºÆ®(iIndex)¸¦ »èÁ¦ÇÏ°í ¾÷µ¥ÀÌÆ® ÇÑ´Ù.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;

	//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û
	bStockMsgToGateServer(cData, 23);
}

// New 12/05/2004 Changed
void CGame::MeteorStrikeHandler(int iMapIndex)
{
 int i, ix, iy, dX, dY, iIndex, iTargetIndex, iTotalESG, iEffect;
 int iTargetArray[DEF_MAXSTRIKEPOINTS];
 short sOwnerH;
 char  cOwnerType;
 DWORD dwTime = timeGetTime();
	
	PutLogList("(!) Beginning Meteor Strike Procedure...");

	if (iMapIndex == -1) {
		PutLogList("(X) MeteorStrikeHandler Error! MapIndex -1!");
		return;
	}
	
	if (m_pMapList[iMapIndex] == NULL) {
		PutLogList("(X) MeteorStrikeHandler Error! NULL Map!");
		return;
	}
	
	if (m_pMapList[iMapIndex]->m_iTotalStrikePoints == 0) {
		PutLogList("(X) MeteorStrikeHandler Error! No Strike Points!");
		return;
	}
	
	for (i = 0; i < DEF_MAXSTRIKEPOINTS; i++) iTargetArray[i] = -1;

	iIndex = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iTargetArray[iIndex] = i; // Â½ÂºÃ†Â®Â¶Ã³Ã€ÃŒÃ…Â© Ã†Ã·Ã€ÃÃ†Â®Ã€Ã‡ Ã€ÃÂµÂ¦Â½ÂºÂ¸Â¦ Â³Ã–Â´Ã‚Â´Ã™.
			iIndex++;
		}
	}

	//testcode
	wsprintf(G_cTxt, "(!) Map(%s) has %d available strike points", m_pMapList[iMapIndex]->m_cName, iIndex);
	PutLogList(G_cTxt);

	// Â°Ã¡Â°Ãº ÂºÂ¸Â°Ã­Â¿Ã« Â½ÂºÃ†Â®Â·Â°ÃƒÃ§ Ã…Â¬Â¸Â®Â¾Ã®
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;

	if (iIndex == 0) {
		// Ã†Ã¸Â°ÃÃ‡Ã’ Â°Ã‡Â¹Â°Ã€ÃŒ Â¾Ã¸Â´Ã™. Â¸Ã°ÂµÃ Ã†Ã„Â±Â«ÂµÃ‡Â¾ÃºÂ´Ã™.
		PutLogList("(!) No strike points!");
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}
	else {

		// Ã‡Ã˜Â´Ã§ Â¸ÃŠÃ€Ã‡ Ã…Â¬Â¶Ã³Ã€ÃŒÂ¾Ã°Ã†Â®ÂµÃ©Â¿Â¡Â°Ã” Â¸ÃÃ…Ã—Â¿Ã€ Â°Ã¸Â°Ã ÃˆÂ¿Â°ÃºÂ¸Â¦ ÂºÂ¸Â¿Â©ÃÃ–Â¶Ã³Â´Ã‚ Â¸ÃÂ½ÃƒÃÃ¶ Ã€Ã¼Â¼Ã›
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKEHIT, NULL, NULL, NULL, NULL);
		}
		
		for (i = 0; i < iIndex; i++) {
			// Â¸Ã°ÂµÃ§ Ã†Ã¸Â°Ã Â¸Ã±Ã‡Â¥Â¿Â¡ Â´Ã«Ã‡Ã˜ ÂµÂ¿Ã€ÃÃ‡Ã‘ Â°Ã¸Â°ÃÃ€Â» Â°Â¡Ã‡Ã‘Â´Ã™.
			iTargetIndex = iTargetArray[i];

			if (iTargetIndex == -1) {
				PutLogList("(X) Strike Point MapIndex: -1!");
				goto MSH_SKIP_STRIKE;
			}

			dX = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dX;
			dY = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dY;

			// dX, dY Ã€Â§Ã„Â¡ ÃÃ–Ã€Â§Â¿Â¡ ÃƒÃ–Â¼Ã’ 2Â°Â³ Ã€ÃŒÂ»Ã³Ã€Ã‡ Energy Shield GeneratorÂ°Â¡ ÃÂ¸Ã€Ã§Ã‡ÃÂ¸Ã© Â½ÂºÃ†Â®Â¶Ã³Ã€ÃŒÃ…Â© Ã†Ã·Ã€ÃÃ†Â®Â´Ã‚ Â¹Â«Â»Ã§Ã‡ÃÂ´Ã™. Â±Ã—Â·Â¯Â³Âª 1Â°Â³ Ã€ÃŒÃ‡ÃÃ€ÃŒÂ¸Ã© Â°Ã¸Â°ÃÂ¹ÃÂ¾Ã’Ã€Â»Â¶Â§ HPÂ°Â¡ ÃÃ™Â¾Ã®ÂµÃ§Â´Ã™.
			// NPC ÃÃ–ÂºÂ¯Â¿Â¡ Ã€Ã–Â´Ã‚ Ã€Ã» Ã„Â³Â¸Â¯Ã…ÃÂ¸Â¦ Ã…Â½ÃÃ¶Ã‡Ã˜ Â°Ã¦ÂºÂ¸Â¸Â¦ Â¿Ã¯Â¸Â°Â´Ã™.
			iTotalESG = 0;
			for (ix = dX-10; ix <= dX+10; ix++) 
			for (iy = dY-10; iy <= dY+10; iy++) {
				m_pMapList[iMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH] != NULL) && (m_pNpcList[sOwnerH]->m_sType == 40)) {
					iTotalESG++;
				}
			}
			
			// testcode
			wsprintf(G_cTxt, "(!) Meteor Strike Target(%d, %d) ESG(%d)", dX, dY, iTotalESG);
			PutLogList(G_cTxt);

			if (iTotalESG < 2) {
			
				m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP -= (2 - iTotalESG);
				if (m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP <= 0) {
					// Â°Ã‡Â¹Â°Ã€ÃŒ Ã†Ã„Â±Â«ÂµÃ‡Â¾ÃºÂ´Ã™.
					m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP = 0;
					// Â°Ã‡Â¹Â° Â±Ã¢Â´Ã‰ Â»Ã³Â½Ã‡
					m_pMapList[m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iMapIndex]->m_bIsDisabled = TRUE;
					m_stMeteorStrikeResult.iCrashedStructureNum++;
				}
				else {
					// Â°Ã‡Â¹Â°Ã€ÃŒ Â´Ã«Â¹ÃŒÃÃ¶Â¸Â¦ Â¾Ã²Â¾ÃºÂ´Ã™.
					m_stMeteorStrikeResult.iStructureDamageAmount += (2 - iTotalESG);
					// Â°Ã‡Â¹Â° Â´Ã«Â¹ÃŒÃÃ¶ Ã€Ã”Ã€Âº ÃˆÃ„ ÂºÃ’Ã…Â¸Â´Ã‚ Ã€ÃŒÂ¹ÃŒÃÃ¶ Â»Ã°Ã€Ã” 
					iEffect = iDice(1,5)-1;
					iAddDynamicObjectList(NULL, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE2, iMapIndex, 
						                  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectX[iEffect] +(iDice(1,3) -2), 
										  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectY[iEffect] +(iDice(1,3) -2), 60*1000*50);
				}
			}
MSH_SKIP_STRIKE:;
		}

		// 1ÃƒÃŠ ÃˆÃ„ Â¸ÃÃ…Ã—Â¿Ã€ Â½ÂºÃ†Â®Â¶Ã³Ã€ÃŒÃ…Â© Â°Ã¸Â°Ã Â´Ã«Â¹ÃŒÃÃ¶ ÃˆÂ¿Â°Ãº
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 1000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		// 4ÃƒÃŠ ÃˆÃ„ Â¸ÃÃ…Ã—Â¿Ã€ Â½ÂºÃ†Â®Â¶Ã³Ã€ÃŒÃ…Â© Â°Ã¸Â°Ã Â´Ã«Â¹ÃŒÃÃ¶ ÃˆÂ¿Â°Ãº
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 4000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		// 6ÃƒÃŠ ÃˆÃ„ Â°Ã¸Â°Ã Â°Ã¡Â°Ãº Ã†Ã‡Â´Ãœ.
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}
}

void CGame::_ClearExchangeStatus(int iToH)
{
	if ((iToH <= 0) || (iToH >= DEF_MAXCLIENTS)) return;
	if (m_pClientList[iToH] == NULL) return;

	if (m_pClientList[iToH]->m_cExchangeName != FALSE) 
		SendNotifyMsg(NULL, iToH, DEF_NOTIFY_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL, NULL, NULL,
						NULL, NULL, NULL, NULL, NULL);	

	// m_pClientList[iToH]->m_cExchangeName    = FALSE;
	m_pClientList[iToH]->m_dwInitCCTime     = FALSE;
	m_pClientList[iToH]->m_iAlterItemDropIndex = 0;
	//m_pClientList[iToH]->m_cExchangeItemIndex = -1;
	m_pClientList[iToH]->m_iExchangeH = NULL;

	m_pClientList[iToH]->m_bIsExchangeMode = FALSE;

	ZeroMemory(m_pClientList[iToH]->m_cExchangeName, sizeof(m_pClientList[iToH]->m_cExchangeName));

}

void CGame::CancelExchangeItem(int iClientH)
{
 int iExH;
	
	// Ã‡Ã¶Ã€Ã§ Â±Â³ÃˆÂ¯Ã€Â» ÃƒÃ«Â¼Ã’Ã‡Ã‘Â´Ã™. Â»Ã³Â´Ã«Â¹Ã¦ÂµÂµ Ã€ÃšÂµÂ¿Ã€Â¸Â·Ã ÃƒÃ«Â¼Ã’ÂµÃˆÂ´Ã™. 
	iExH = m_pClientList[iClientH]->m_iExchangeH;
	_ClearExchangeStatus(iExH);
	_ClearExchangeStatus(iClientH);
}

// v2.17 2002-7-15 ¿äÀÏ¿¡ °ü°è¾øÀÌ °­Äİ ½Ã°£À» Á¶Àı ÇÒ ¼ö ÀÖ°Ô ¼öÁ¤ÇÑ´Ù.
void CGame::SetForceRecallTime(int iClientH)
{
	int iTL_ = 0 ;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return ;

	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
		// ³²¾ÆÀÖÀ» ¼ö ÀÖ´Â ÀÜÁ¸ ½Ã°£À» ¼³Á¤ÇØ ÁØ´Ù. 
		// ½Ã°£À» ±¸ÇÑ´ÙÀ½ iWarPeriod¸¦ ±¸ÇÑ´Ù.

		// ¼­¹ö¿¡ °­Äİ ½Ã°£ÀÌ ¼³Á¤µÇ¾î ÀÖÀ¸¸é ¼­¹ö °­Äİ ½Ã°£À» °­Äİ ½Ã°£À¸·Î ÇÑ´Ù.

		if (m_sForceRecallTime > 0 ) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sForceRecallTime ;
		}
		else {
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeMonday; break;  //¿ù¿äÀÏ  3ºĞ 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeTuesday; break;  //È­¿äÀÏ  3ºĞ 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeWednesday; break;  //¼ö¿äÀÏ  3ºĞ 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeThursday; break;  //¸ñ¿äÀÏ  3ºĞ 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeFriday; break; //±İ¿äÀÏ 15ºĞ
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSaturday; break; //Åä¿äÀÏ 45ºĞ 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSunday; break; //ÀÏ¿äÀÏ 60ºĞ
			}
		}
	}
	else { // if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) 
		if (m_sForceRecallTime > 0 ) {
			iTL_ =  20*m_sForceRecallTime ;
		}
		else {

			// ÀÜÁ¸½Ã°£ÀÌ ÀÖ´Ù. ¿äÀÏº° ÀÜÁ¸½Ã°£º¸´Ù Å©¸é 1·Î ÃÊ±âÈ­ 
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 20*m_sRaidTimeMonday; break;  //¿ù¿äÀÏ  3ºĞ 2002-09-10 #1
			case 2:	iTL_ = 20*m_sRaidTimeTuesday; break;  //È­¿äÀÏ  3ºĞ
			case 3:	iTL_ = 20*m_sRaidTimeWednesday; break;  //¼ö¿äÀÏ  3ºĞ
			case 4:	iTL_ = 20*m_sRaidTimeThursday; break;  //¸ñ¿äÀÏ  3ºĞ
			case 5:	iTL_ = 20*m_sRaidTimeFriday; break; //±İ¿äÀÏ 15ºĞ
			case 6:	iTL_ = 20*m_sRaidTimeSaturday; break; //Åä¿äÀÏ 45ºĞ 
			case 0:	iTL_ = 20*m_sRaidTimeSunday; break; //ÀÏ¿äÀÏ 60ºĞ
			}
		}

		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;

	}
	return ;
}

void CGame::CheckForceRecallTime(int iClientH)
{
	SYSTEMTIME SysTime;
	int iTL_;

	if(m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) return;

	if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
		// has admin set a recall time ??
		if (m_sForceRecallTime > 0) {
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = m_sForceRecallTime * 20;
		}
		// use standard recall time calculations
		else{
			GetLocalTime(&SysTime);
			switch(SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeMonday; break;  //¿ù¿äÀÏ  3ºĞ 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeTuesday; break;  //È­¿äÀÏ  3ºĞ 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeWednesday; break;  //¼ö¿äÀÏ  3ºĞ 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeThursday; break;  //¸ñ¿äÀÏ  3ºĞ 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeFriday; break; //±İ¿äÀÏ 15ºĞ
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSaturday; break; //Åä¿äÀÏ 45ºĞ 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSunday; break; //ÀÏ¿äÀÏ 60ºĞ
			}
		}
	}
	else{
		// has admin set a recall time ??
		if (m_sForceRecallTime > 0) {
			iTL_ = m_sForceRecallTime * 20;
		}
		// use standard recall time calculations
		else{
			GetLocalTime(&SysTime);
			switch(SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeMonday; break;  //¿ù¿äÀÏ  3ºĞ 2002-09-10 #1
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeTuesday; break;  //È­¿äÀÏ  3ºĞ 
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeWednesday; break;  //¼ö¿äÀÏ  3ºĞ 
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeThursday; break;  //¸ñ¿äÀÏ  3ºĞ 
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeFriday; break; //±İ¿äÀÏ 15ºĞ
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSaturday; break; //Åä¿äÀÏ 45ºĞ 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*m_sRaidTimeSunday; break; //ÀÏ¿äÀÏ 60ºĞ
			}
		}
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
			m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
	}
}

int ITEMSPREAD_FIEXD_COORD [25][2] =
{
	{ 0,  0},	//1
	{ 1,  0},	//2
	{ 1,  1},	//3
	{ 0,  1},	//4
	{-1,  1},	//5
	{-1,  0},	//6
	{-1, -1},	//7
	{ 0, -1},	//8
	{ 1, -1},	//9
	{ 2, -1},	//10
	{ 2,  0},	//11
	{ 2,  1},	//12
	{ 2,  2},	//13
	{ 1,  2},	//14
	{ 0,  2},	//15
	{-1,  2},	//16
	{-2,  2},	//17
	{-2,  1},	//18
	{-2,  0},	//19
	{-2, -1},	//20
	{-2, -2},	//21
	{-1, -2},	//22
	{ 0, -2},	//23
	{ 1, -2},	//24
	{ 2, -2},	//25
};

BOOL CGame::bGetMultipleItemNamesWhenDeleteNpc(short sNpcType, int iProbability, int iMin, int iMax, short sBaseX, short sBaseY,
											   int iItemSpreadType, int iSpreadRange,
											   int *iItemIDs, POINT *BasePos, int *iNumItem)
{
	int		iProb = 100;
	float	fProb, fProbA, fProbB, fProbC;
	int		iItemID;
	int		iNum = 0;
	
	for(int i=0; i<iMax; i++ )
	{
		if( i>iMin ) iProb = iProbability;

		fProb = (float)(100 - iProb) / 10.0;	//WyvernÃ€Ã‡ Ã†Ã²Â±Ã• 50
		if( fProb < 1.0 ) fProb = 1.0;

		fProbA = fProbB = fProbC = fProb;

		fProbA = fProbA * 8.0f;
		fProbB = fProbB * 4.0f;
		fProbC = fProbC;

		iItemID = 0;

		switch(sNpcType)
		{
		case 69: // Wyvern...stupid koreans
			// ÃƒÃ–Â»Ã³Â±Ã
			switch (iDice(1,4)) {
				case 1: if (iDice(1,(6000 * fProbA)) == 3) iItemID = 845; break; // StormBringer
				case 2: if (iDice(1,(5000 * fProbA)) == 3) iItemID = 848; break; // LightingBlade
				case 3: if (iDice(1,(3000 * fProbA)) == 2) iItemID = 614; break; // SwordofIceElemental
				case 4: if (iDice(1,(4500 * fProbA)) == 3) iItemID = 380; break; // IceStormManual
			}

			// Â»Ã³Â±Ã
			if( iItemID == 0 )
			{
				switch( iDice(1, 6) ) {	
					case  1: if (iDice(1,(500  * fProbB)) == 2) iItemID = 642; break; // KnecklaceOfIcePro       
					case  2: if (iDice(1,(2000 * fProbB)) == 2) iItemID = 643; break; // KnecklaceOfIceEle
					case  3: if (iDice(1,(1000 * fProbB)) == 3) iItemID = 636; break; // RingofGrandMage         	
					case  4: if (iDice(1,(1500  * fProbB)) == 3) iItemID = 734; break; // RingOfArcmage           
					case  5: if (iDice(1,(500  * fProbB)) == 3) iItemID = 634; break; // RingofWizard            
					case  6: if (iDice(1,(500  * fProbB)) == 2) iItemID = 290; break; // Flameberge+3(LLF)
				}
			}
			break; 

		case 73: // Fire-Wyvern
			// ÃƒÃ–Â»Ã³Â±Ã
			switch (iDice(1, 7)) {
				case  1: if (iDice(1,(5000 * fProbA)) == 3) iItemID = 847; break; // DarkExecutor            
				case  2: if (iDice(1,(3000 * fProbA)) == 2) iItemID = 630; break; // RingoftheXelima
				case  3: if (iDice(1,(3000 * fProbA)) == 2) iItemID = 860; break; // NecklaceOfXelima        
				case  4: if (iDice(1,(3000 * fProbA)) == 2) iItemID = 735; break; // RingOfDragonpower       
				case  5: if (iDice(1,(3000 * fProbA)) == 2) iItemID =  20; break; // Excaliber
				case  6: if (iDice(1,(3000 * fProbA)) == 3) iItemID = 382; break; // BloodyShockW.Manual
				case  7: if (iDice(1,(3000 * fProbA)) == 3) iItemID = 381; break; // MassFireStrikeManual  			
			}

			// Â»Ã³Â±Ã
			if( iItemID == 0 )
			{
				switch( iDice(1, 9) ) {
					case  1: if (iDice(1,(1000 * fProbB)) == 2) iItemID = 645; break; // KnecklaceOfEfreet       	
					case  2: if (iDice(1,(500  * fProbB)) == 2) iItemID = 638; break; // KnecklaceOfFirePro			
					case  3: if (iDice(1,(1000 * fProbB)) == 3) iItemID = 636; break; // RingofGrandMage	
					case  4: if (iDice(1,(800  * fProbB)) == 3) iItemID = 734; break; // RingOfArcmage           
					case  5: if (iDice(1,(500  * fProbB)) == 3) iItemID = 634; break; // RingofWizard            
					case  6: if (iDice(1,(500  * fProbB)) == 2) iItemID = 290; break; // Flameberge+3(LLF)
					case  7: if (iDice(1,(500  * fProbB)) == 3) iItemID = 490; break; // BloodSword              
					case  8: if (iDice(1,(500  * fProbB)) == 3) iItemID = 491; break; // BloodAxe              
					case  9: if (iDice(1,(500  * fProbB)) == 3) iItemID = 492; break; // BloodRapier
				}
			}

			break;

		case 81: // Abaddon

			// ÃƒÃ–Â»Ã³Â±Ã
			switch (iDice(1, 6)) {
				case 1: if (iDice(1,(100 * fProbA)) == 3) iItemID = 846; break; // The_Devastator
				case 2: if (iDice(1,(100 * fProbA)) == 3) iItemID = 847; break; // DarkExecutor            
				case 3: if (iDice(1,(100 * fProbA)) == 3) iItemID = 860; break; // NecklaceOfXelima
				case 4: if (iDice(1,(100 * fProbA)) == 3) iItemID = 865; break; // ResurWand(MS.20)
				case 5: if (iDice(1,(100 * fProbA)) == 2) iItemID = 631; break; // RingoftheAbaddon        	
				case 6: if (iDice(1,(100 * fProbA)) == 2) iItemID = 866; break; // BerserkWand(MS.10)
			}

			// Â»Ã³Â±Ã
			if( iItemID == 0 )
			{
				switch( iDice(1, 15) ) {
					case  1: if (iDice(1,(4 * fProbB)) == 3) iItemID = 762; break; // GBattleHammer           
					case  2: if (iDice(1,(4 * fProbB)) == 3) iItemID = 490; break; // BloodSword              
					case  3: if (iDice(1,(4 * fProbB)) == 3) iItemID = 491; break; // BloodAxe                
					case  4: if (iDice(1,(4 * fProbB)) == 3) iItemID = 492; break; // BloodRapier             
					case  5: if (iDice(1,(4 * fProbB)) == 3) iItemID = 611; break; // XelimaAxe
					case  6: if (iDice(1,(4 * fProbB)) == 3) iItemID = 610; break; // XelimaBlade
					case  7: if (iDice(1,(4 * fProbB)) == 3) iItemID = 612; break; // XelimaRapier
					case 10: if (iDice(1,(4 * fProbB)) == 3) iItemID = 645; break; // KnecklaceOfEfreet       	
					case 11: if (iDice(1,(4 * fProbB)) == 3) iItemID = 638; break; // KnecklaceOfFirePro      			
					case 12: if (iDice(1,(4 * fProbB)) == 3) iItemID = 382; break; // BloodyShockW.Manual
					case 13: if (iDice(1,(4 * fProbB)) == 3) iItemID = 381; break; // MassFireStrikeManual  
					case 14: if (iDice(1,(4 * fProbB)) == 3) iItemID = 259; break; // MagicWand(M.Shield)
					case 15: if (iDice(1,(4 * fProbB)) == 3) iItemID = 291; break; // MagicWand(MS30-LLF)
				}
			}
			break;
		} // switch

		// Ã€ÃÂ¹Ã Â¾Ã†Ã€ÃŒÃ…Ã› ....dumb korean idiots
		if( iItemID == 0 )
		{
			switch( iDice(1, 24) ) {
				case  1: if (iDice(1,(2 * fProbC)) == 2) iItemID = 740; break; // BagOfGold-medium
				case  2: if (iDice(1,(2 * fProbC)) == 2) iItemID = 741; break; // BagOfGold-large
				case  3: if (iDice(1,(2 * fProbC)) == 2) iItemID = 742; break; // BagOfGold-largest
				case  4: if (iDice(1,(2 * fProbC)) == 2) iItemID = 868; break; // AcientTablet(LU)
				case  5:
				case  6:
				case  7: if (iDice(1,(2 * fProbC)) == 2) iItemID = 650; break; // ZemstoneOfSacrifice
				case  8:
				case  9: if (iDice(1,(2 * fProbC)) == 2) iItemID = 656; break; // StoneOfXelima
				case 10:
				case 11:
				case 12: if (iDice(1,(2 * fProbC)) == 2) iItemID = 657; break; // StoneOfMerien
				case 13: if (iDice(1,(2 * fProbC)) == 2) iItemID = 333; break; // PlatinumRing          
				case 14: if (iDice(1,(2 * fProbC)) == 2) iItemID = 334; break; // LuckyGoldRing         
				case 15: if (iDice(1,(2 * fProbC)) == 2) iItemID = 335; break; // EmeraldRing           
				case 16: if (iDice(1,(2 * fProbC)) == 2) iItemID = 336; break; // SapphireRing          
				case 17: if (iDice(1,(2 * fProbC)) == 2) iItemID = 337; break; // RubyRing              
				case 18: if (iDice(1,(2 * fProbC)) == 2) iItemID = 290; break; // Flameberge+3(LLF)
				case 19: if (iDice(1,(2 * fProbC)) == 2) iItemID = 292; break; // GoldenAxe(LLF)
				case 20: if (iDice(1,(2 * fProbC)) == 2) iItemID = 259; break; // MagicWand(M.Shield)
				case 21: if (iDice(1,(2 * fProbC)) == 2) iItemID = 300; break; // MagicNecklace(RM10)
				case 22: if (iDice(1,(2 * fProbC)) == 2) iItemID = 311; break; // MagicNecklace(DF+10)
				case 23: if (iDice(1,(2 * fProbC)) == 2) iItemID = 305; break; // MagicNecklace(DM+1)
				case 24: if (iDice(1,(2 * fProbC)) == 2) iItemID = 308; break; // MagicNecklace(MS10)
			}
		}

		// ÃˆÂ®Â·Ã¼Ã€ÃŒ 100 Ã€ÃÂµÂ¥ Â¾Ã†Â¹Â« Â°ÃÂµÂµ Â³ÂªÂ¿Ã€ÃÃ¶ Â¾ÃŠÂ¾Ã’Â´Ã™.
		// Gold ÃÃ˜Â´Ã™. retarded koreans -_-
		if( iItemID == 0 && iProb == 100 ) iItemID = 90; // Gold

		if( iItemID != 0 )
		{
			// item id
			iItemIDs[iNum] = iItemID;

			// item position
			switch(iItemSpreadType)
			{
			case DEF_ITEMSPREAD_RANDOM:
				BasePos[iNum].x = sBaseX + iSpreadRange - iDice(1, iSpreadRange * 2 );
				BasePos[iNum].y = sBaseY + iSpreadRange - iDice(1, iSpreadRange * 2 );
				break;

			case DEF_ITEMSPREAD_FIXED:
				BasePos[iNum].x = sBaseX + ITEMSPREAD_FIEXD_COORD[iNum][0];
				BasePos[iNum].y = sBaseY + ITEMSPREAD_FIEXD_COORD[iNum][1];
				break;
			}
			iNum++;
		}

	} // for

	*iNumItem = iNum;

	return TRUE;

} // bGetMultipleItemNamesWhenDeleteNpc... duh...korean morons

// 05/21/2004 - Hypnotoad - Balances to drop status
void CGame::NpcDeadItemGenerator(int iNpcH, short sAttackerH, char cAttackerType)
{
	class CItem * pItem;
	char  cColor, cItemName[21];
	BOOL  bIsGold;
	int   iGenLevel, iResult, iItemID;
	DWORD dwType, dwValue;
	double dTmp1, dTmp2, dTmp3;

	if (m_pNpcList[iNpcH] == NULL) return;
	if ((cAttackerType != DEF_OWNERTYPE_PLAYER) || (m_pNpcList[iNpcH]->m_bIsSummoned == TRUE)) return;
	if (m_pNpcList[iNpcH]->m_bIsUnsummoned == TRUE) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	bIsGold = FALSE;

	switch (m_pNpcList[iNpcH]->m_sType) {
		// NPC not dropping Gold
	case 21: // Guard
	case 34: // Dummy
	case 64: // Crop
		return;
	}

	// 6500 default; the lower the greater the Weapon/Armor/Wand Drop
	if (iDice(1,10000) >= m_iPrimaryDropRate) {
		// 35% Drop 60% of that is gold
		// 35% Chance of drop (35/100)
		if (iDice(1,10000) <= 6000) {
			iItemID = 90; // Gold: (35/100) * (60/100) = 21%
			// If a non-existing itemID is given create no item
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, iItemID) == FALSE) {
				delete pItem;
				return;	
			}

			pItem->m_dwCount = (DWORD)(iDice(1, (m_pNpcList[iNpcH]->m_iGoldDiceMax - m_pNpcList[iNpcH]->m_iGoldDiceMin)) + m_pNpcList[iNpcH]->m_iGoldDiceMin);

			// v1.42 Gold 
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_iAddGold != NULL)) {
				dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddGold;
				dTmp2 = (double)pItem->m_dwCount;
				dTmp3 = (dTmp1/100.0f)*dTmp2;
				pItem->m_dwCount += (int)dTmp3;
			}
		}
		else {
			// 9000 default; the lower the greater the Weapon/Armor/Wand Drop
			// 35% Drop 40% of that is an Item 
			dTmp1 = m_pClientList[sAttackerH]->m_iRating*m_cRepDropModifier;
			if (dTmp1 > 3000) dTmp1 = 3000;
			if (dTmp1 < -3000) dTmp1 = -3000;
			dTmp2 = (m_iSecondaryDropRate - (dTmp1));
			if (iDice(1,10000) <= dTmp2) { 
				// 40% Drop 90% of that is a standard drop
				// Standard Drop Calculation: (35/100) * (40/100) * (90/100) = 12.6%
				iResult = iDice(1,12000);
				if ((iResult >= 1) && (iResult <= 3000))          dwValue = 1;
				else if ((iResult >= 3001) && (iResult <= 4000))  dwValue = 2;
				else if ((iResult >= 4001) && (iResult <= 5500))  dwValue = 3;
				else if ((iResult >= 5501) && (iResult <= 7000))  dwValue = 4;
				else if ((iResult >= 7001) && (iResult <= 8500))  dwValue = 5;
				else if ((iResult >= 8501) && (iResult <= 9200))  dwValue = 6;
				else if ((iResult >= 9201) && (iResult <= 9800))  dwValue = 7;
				else if ((iResult >= 9801) && (iResult <= 10000)) dwValue = 8;
				else if ((iResult >= 10001) && (iResult <= 12000)) dwValue = 9;

				switch (dwValue) {	
						case 1: iItemID = 95; break; // Green Potion
						case 2: iItemID = 91; break; // Red Potion
						case 3: iItemID = 93; break; // Blue Potion
						case 4: iItemID = 96; break; // Big Green Potion
						case 5: iItemID = 92; break; // Big Red Potion
						case 6: iItemID = 94; break; // Big Blue Potion
						case 7: switch(iDice(1,2)) {
								case 1: iItemID = 390; break; // Power Green Potion
								case 2: iItemID = 95;  break; // Green Potion
								}
								break;
						case 8: switch(iDice(1,6)) {
								case 1: iItemID = 391; break; // Super Power Green Potion
								case 2: iItemID = 650; break; // Zemstone of Sacrifice
								case 3: iItemID = 656; break; // Xelima Stone
								case 4: iItemID = 657; break; // Merien Stone
								case 5: iItemID = 95;  break; // Green Potion
								case 6: switch(iDice(1,5)) {
										case 1: iItemID = 651; break; // GreenBall
										case 2: iItemID = 652; break; // RedBall
										case 3: iItemID = 653; break; // YellowBall
										case 4: iItemID = 654; break; // BlueBall
										case 5: switch(iDice(1,11)) {
												case 1: iItemID = 881; break; // ArmorDye(Indigo)
												case 2: iItemID = 882; break; // ArmorDye(Crimson-Red)
												case 3: iItemID = 883; break; // ArmorDye(Gold)
												case 4: iItemID = 884; break; // ArmorDye(Aqua)
												case 5: iItemID = 885; break; // ArmorDye(Pink)
												case 6: iItemID = 886; break; // ArmorDye(Violet)
												case 7: iItemID = 887; break; // ArmorDye(Blue)
												case 8: iItemID = 888; break; // ArmorDye(Khaki)
												case 9: iItemID = 889; break; // ArmorDye(Yellow)
												case 10: iItemID = 890; break; // ArmorDye(Red)
												case 11: iItemID = 655; break; // PearlBall
												}
												break;
										}
										break;
								}
								break;

						case 9: 		
							SYSTEMTIME SysTime;
							GetLocalTime(&SysTime);
							if (((short)SysTime.wMonth == 12) && (m_pNpcList[iNpcH]->m_sType == 61 || 55)) {
								switch(iDice(1,4)) {
								case 1: iItemID = 780; break; // Red Candy
								case 2: iItemID = 781; break; // Blue Candy
								case 3: iItemID = 782; break; // Green Candy
								case 4: iItemID = 91;  break; // Red Potion
								}
							}
							break;
				}
				// If a non-existing item is created then delete the item
				pItem = new class CItem;
				if (_bInitItemAttr(pItem, iItemID) == FALSE) {
					delete pItem;
					return;	
				}
			}
			else {
				// Valuable Drop Calculation: (35/100) * (40/100) * (10/100) = 1.4%
				// Define iGenLevel using Npc.cfg#
				switch (m_pNpcList[iNpcH]->m_sType) {

				case 10: // Slime
				case 16: // Giant-Ant
				case 22: // Amphis
				case 55: // Rabbit
				case 56: //	Cat
					iGenLevel = 1;
					break;

				case 11: // Skeleton
				case 14: // Orc, Orc-Mage
				case 17: // Scorpion
				case 18: // Zombie
					iGenLevel = 2;
					break;

				case 12: // Stone-Golem
				case 23: // Clay-Golem
					iGenLevel = 3;
					break;

				case 27: // Hellbound
				case 61: // Rudolph
					iGenLevel = 4;
					break; 

				case 72: // Claw-Turtle
				case 76: // Giant-Plant
				case 74: // Giant-Crayfish
				case 13: // Cyclops
				case 28: // Troll
				case 53: // Beholder
				case 60: // Cannibal-Plant
				case 62: // DireBoar
					iGenLevel = 5;
					break;

				case 29: // Orge
				case 33: // WereWolf
				case 48: // Stalker
				case 54: // Dark-Elf
				case 65: // Ice-Golem
			    case 78: // Minotaurus
					iGenLevel = 6;
					break;

		 	    case 70: // Balrogs
				case 71: // Centaurus
				case 30: // Liche
				case 63: // Frost
			    case 79: // Nizie
					iGenLevel = 7;
					break;

				case 31: // Demon
				case 32: // Unicorn
				case 49: // Hellclaw
				case 50: // Tigerworm
				case 52: // Gagoyle
					iGenLevel = 8;
					break; 

				case 58: // MountainGiant
					iGenLevel = 9;
					break;

			    case 77: // MasterMage-Orc
				case 59: // Ettin
				case 75: // Lizards
					iGenLevel = 10;
					break;
				}	

				if (iGenLevel == 0) return;

				// Weapon Drop: 
				// 1.4% chance Valuable Drop 60% that it is a Weapon
				if (iDice(1,10000) <= 6000) {
					if (iDice(1,10000) <= 8000) {
						// 70% the Weapon is Melee
						switch (iGenLevel) { 

				case 1: // Slime, Giant-Ant, Amphis, Rabbit, Cat
					switch (iDice(1,3)) { 
				case 1: iItemID = 1;  break; // Dagger
				case 2: iItemID = 8;  break; // ShortSword
				case 3: iItemID = 59; break; // LightAxe
					}
					break; 

				case 2: // Skeleton, Orc, Orc-Mage, Scorpion, Zombie
					switch (iDice(1,6)) {
						case 1: iItemID = 12;  break; // MainGauche
						case 2: iItemID = 15;  break; // Gradius
						case 3: iItemID = 65;  break; // SexonAxe
						case 4: iItemID = 62;  break; // Tomahoc
						case 5: iItemID = 23;  break; // Sabre
						case 6: iItemID = 31;  break; // Esterk
					}
					break;

				case 3: // Stone-Golem, Clay-Golem
					switch (iDice(1,4)) {
				case 1: iItemID = 17;  break; // LongSword
				case 2: iItemID = 68;  break; // DoubleAxe
				case 3: iItemID = 23;  break; // Sabre
				case 4: iItemID = 31;  break; // Esterk
					}
					break;

				case 4: // Hellbound, Rudolph
					switch (iDice(1,5)) {
				case 1: iItemID = 23;  break; // Sabre
				case 2: iItemID = 25;  break; // Scimitar
				case 3: iItemID = 28;  break; // Falchion
				case 4: iItemID = 31;  break; // Esterk
				case 5: iItemID = 34;  break; // Rapier
					}
					break;

				case 5: // Cyclops, Troll, Beholder, Cannibal-Plant, DireBoar
					switch (iDice(1,3)) {
				case 1: iItemID = 31;  break; // Esterk
				case 2: iItemID = 34;  break; // Rapier
				case 3: iItemID = 71;  break; // WarAxe
					}
					break;

				case 6: // Orge, WereWolf, Stalker, Dark-Elf, Ice-Golem
					switch (iDice(1,6)) {
				case 1: iItemID = 50;  break; // GreatSword
				case 2: iItemID = 54;  break; // Flameberge
				case 3: iItemID = 46;  break; // Claymore
				case 4: iItemID = 31;  break; // Esterk
				case 5: iItemID = 34;  break; // Rapier
				case 6: iItemID = 617; break; // CompositeBow
					}
					break;

				case 7: // Liche, Frost
					switch (iDice(1,4)) {
				case 1: iItemID = 50;  break; // GreatSword
				case 2: iItemID = 54;  break; // Flameberge
				case 3: iItemID = 31;  break; // Esterk
				case 4: iItemID = 34;  break; // Rapier
					}
					break;

				case 8: // Demon, Unicorn, Hellclaw, Tigerworm, Gagoyle
					switch (iDice(1,7)) {
				case 1: iItemID = 50;  break; // GreatSword
				case 2: iItemID = 54;  break; // Flameberge
				case 3: iItemID = 560; break; // BattleAxe
				case 4: iItemID = 31;  break; // Esterk
				case 5: iItemID = 34;  break; // Rapier
				case 6: iItemID = 55;  break; // Flameberge+1
				case 7: iItemID = 615; break; // GiantSword
					}
					break;

				case 9: // MountainGiant
					switch (iDice(1,6)) {
				case 1: iItemID = 23;  break; // Sabre
				case 2: iItemID = 25;  break; // Scimitar
				case 3: iItemID = 28;  break; // Falchion
				case 4: iItemID = 31;  break; // Esterk
				case 5: iItemID = 34;  break; // Rapier
				case 6: iItemID = 760; break; // Hammer
					}
					break;

				case 10: // Ettin
					switch (iDice(1,5)) {
					case 1: iItemID = 46;  break; // Claymore
					case 2: iItemID = 31;  break; // Esterk
					case 3: iItemID = 34;  break; // Rapier
					case 4: iItemID = 760; break; // Hammer
					case 5: iItemID = 761; break; // GiantHammer
					}
					break;

						}
					}
					else {
						// 30% the weapon is a Wand
						switch (iGenLevel) {

						case 2: 
						case 3:
							iItemID = 258; break; // MagicWand(MS0)
						case 4: 
						case 5: 
						case 6: 
							iItemID = 257; break; // MagicWand(MS10)
						case 7:
						case 8:
							iItemID = 256; break; // MagicWand(MS20)
						case 9:
						case 10:
							break;
						}	
					}
				}
				else {
					// 1.4% chance Valuable Drop 40% that drop is an Armor/Shield
					switch (iGenLevel) {

					case 1: // Slime, Giant-Ant, Amphis, Rabbit, Cat
					case 2: // Skeleton, Orc, Orc-Mage, Scorpion, Zombie
						switch (iDice(1,2)) { 
							case 1: iItemID = 79;  break; // WoodShield
							case 2: iItemID = 81;  break; // TargeShield
						}
						break; 

					case 3: // Stone-Golem, Clay-Golem
						iItemID = 81; // TargeShield
						break;

					case 4: // Hellbound, Rudolph
						switch (iDice(1,5)) {
							case 1: iItemID = 454; break; // Hauberk(M)
							case 2: iItemID = 472; break; // Hauberk(W)
							case 3: iItemID = 461; break; // ChainHose(M)
							case 4: iItemID = 482; break; // ChainHose(W)
							case 5: iItemID = 83;  break; // BlondeShield
						}
						break;

					case 5: // Cyclops, Troll, Beholder, Cannibal-Plant, DireBoar
						switch (iDice(1,3)) {
							case 1: iItemID = 455; break; // LeatherArmor(M)
							case 2: iItemID = 475; break; // LeatherArmor(W)
							case 3: iItemID = 84;  break; // IronShield
						}
						break;

					case 6: // Orge, WereWolf, Stalker, Dark-Elf, Ice-Golem
						switch (iDice(1,6)) {
						case 1: switch(iDice(1,2)) {
							case 1: iItemID = 456; break; // ChainMail(M)
							case 2: iItemID = 476; break; // ChainMail(W)
						}
						break;
						case 2: switch(iDice(1,2)) {
							case 1: iItemID = 458; break; // PlateMail(M)
							case 2: iItemID = 478; break; // PlateMail(W)
						}
						break;
						case 3: iItemID = 85; break; // LagiShield
						case 4: switch(iDice(1,8)) {
							case 1: iItemID = 750; break; // Horned-Helm(M)
							case 2: iItemID = 751; break; // Wings-Helm(M)
							case 3: iItemID = 754; break; // Horned-Helm(W)
							case 4: iItemID = 755; break; // Wings-Helm(W)
							case 5: iItemID = 752; break; // Wizard-Cap(M) 
							case 6: iItemID = 753; break; // Wizard-Hat(M)
							case 7: iItemID = 756; break; // Wizard-Cap(W) 
							case 8: iItemID = 757; break; // Wizard-Hat(W) 
						}
						break;	
						case 5: switch(iDice(1,2)) {
							case 1: iItemID = 454; break; // Hauberk(M)
							case 2: iItemID = 472; break; // Hauberk(W)
						}
						break;
						case 6: switch(iDice(1,2)) {
							case 1: iItemID = 461; break; // ChainHose(M)
							case 2: iItemID = 482; break; // ChainHose(W)
						}
						break;
						}
						break;


					case 7: // Liche, Frost
						switch (iDice(1,6)) {
						case 1: switch(iDice(1,2)) {
							case 1: iItemID = 457; break; // ScaleMail(M)
							case 2: iItemID = 477; break; // ScaleMail(W)
							}
							break;
						case 2: switch(iDice(1,2)) {
							case 1: iItemID = 458; break; // PlateMail(M)
							case 2: iItemID = 478; break; // PlateMail(W)
							}
							break;
						case 3: iItemID = 86; break; // KnightShield
						case 4: iItemID = 87; break; // TowerShield
						case 5: switch(iDice(1,2)) {
							case 1: iItemID = 600; break; // Helm(M)
							case 2: iItemID = 602; break; // Helm(M)
							}
							break;
						case 6: switch(iDice(1,2)) {
							case 1: iItemID = 601; break; // Full-Helm(M)
							case 2: iItemID = 603; break; // Full-Helm(M)
							}
							break;
						}
						break;

					case 8: // Demon, Unicorn, Hellclaw, Tigerworm, Gagoyle
						iItemID = 402; // Cape
						break;

					case 9:
					case 10:
						break;
					}
				}
				// 0-None 1-Ã­â€¢â€Ã¬â€šÂ´ÃªÂ¸Â°Ã«Å’â‚¬Ã«Â¯Â¸Ã¬Â§â‚¬Ã¬Â¶â€ÃªÂ°â‚¬ 2-Ã¬Â¤â€˜Ã«Ââ€¦Ã­Å¡Â¨ÃªÂ³Â¼ 3-Ã¬Â â€¢Ã¬ÂËœÃ¬ÂËœ  
				// 5-Ã«Â¯Â¼Ã¬Â²Â©Ã¬ÂËœ 6-ÃªÂ°â‚¬Ã«Â²Â¼Ã¬Å¡Â´ 7-Ã¬ËœË†Ã«Â¦Â¬Ã­â€¢Å“ 8-ÃªÂ°â€¢Ã­â„¢â€Ã«ÂÅ“ 9-ÃªÂ³Â Ã«Å’â‚¬Ã«Â¬Â¸Ã«Âªâ€¦Ã¬ÂËœ 10-Ã«Â§Ë†Ã«Â²â€¢ Ã¬â€Â±ÃªÂ³ÂµÃ¬ÂËœ
				// Ã¬â€¢â€Ã¬ÂÂ´Ã­â€¦Å“Ã¬Ââ€ Ã«Â§Å’Ã«â€œÂ¤ÃªÂ³Â  
				pItem = new class CItem;
				// ÃªÂ¸Â°Ã«Â³Â¸ Ã­Å Â¹Ã¬â€Â±Ã¬Å“Â¼Ã«Â¡Å“ Ã¬â€¢â€Ã¬ÂÂ´Ã­â€¦Å“ Ã¬Æ’ÂÃ¬â€Â± 
				if (_bInitItemAttr(pItem, iItemID) == FALSE) {
					delete pItem;
					return;	
				}

				if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
					// Â°Ã¸Â°Ã Â¹Â«Â±Ã¢Â·Ã¹Â¿Â¡ ÂºÃ™Ã€Â» Â¼Ã¶ Ã€Ã–Â´Ã‚ ÃÂ¢ÂµÃÂ»Ã§Â¸Â¦ Â¼Â±Ã…Ãƒ 
					// Â°Â¡ÂºÂ­Â¿Ã®(3%) Â°Â­ÃˆÂ­ÂµÃˆ(7%) Ã‡ÃŠÂ»Ã¬Ã€Ã‡(15%) Â¹ÃÃƒÂ¸Ã€Ã‡(20%) ÃÂ¤Ã€Ã‡Ã€Ã‡(20%) ÃÃŸÂµÂ¶Ã€Ã‡(16%) Â¿Â¹Â¸Â®Ã‡Ã‘(16%) Â°Ã­Â´Ã«Â¹Â®Â¸Ã­Ã€Ã‡(3%)
					iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 299)) {
						dwType = 6; 
						cColor = 2; 
					}
					else if ((iResult >= 300) && (iResult <= 999)) {
						dwType = 8; 
						cColor = 3;
					}
					else if ((iResult >= 1000) && (iResult <= 2499)) {
						dwType = 1;
						cColor = 5;
					}
					else if ((iResult >= 2500) && (iResult <= 4499)) {
						dwType = 5;
						cColor = 1;
					}
					else if ((iResult >= 4500) && (iResult <= 6499)) {
						dwType = 3;
						cColor = 7;
					}
					else if ((iResult >= 6500) && (iResult <= 8099)) {
						dwType = 2;
						cColor = 4;
					}
					else if ((iResult >= 8100) && (iResult <= 9699)) {
						dwType = 7;
						cColor = 6;
					}
					else if ((iResult >= 9700) && (iResult <= 10000)) {
						dwType = 9;
						cColor = 8;
					}

					// Â¾Ã†Ã€ÃŒÃ…Ã› Â»Ã¶Â»Ã³ Ã€Ã”Â·Ã‚ 
					pItem->m_cItemColor = cColor;

					// Â°Â¡ÂºÂ­Â¿Ã®, Â°Â­ÃˆÂ­ÂµÃˆ, Ã‡ÃŠÂ»Ã¬Ã€Ã‡, Â¹ÃÃƒÂ¸Ã€Ã‡, ÃÂ¤Ã€Ã‡Ã€Ã‡, ÃÃŸÂµÂ¶Ã€Ã‡, Â¿Â¹Â¸Â®Ã‡Ã‘, Â°Ã­Â´Ã«Â¹Â®Â¸Ã­Ã€Ã‡
					// Â¾Ã†Ã€ÃŒÃ…Ã› Main Ã†Â¯Â¼ÂºÃ„Â¡ ÃÂ¤ÂµÂµÂ°Âª Ã€Ã”Â·Ã‚ 

					// Â¾Ã†Ã€ÃŒÃ…Ã› Sub Ã†Â¯Â¼ÂºÃ„Â¡ ÃÂ¤ÂµÂµÂ°Âª Ã€Ã”Â·Ã‚ 
					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

					// Â¹Â«Â±Ã¢Ã€Ã‡ Main Ã†Â¯Â¼ÂºÃ„Â¡Â¿Â¡ ÂµÃ»Â¶Ã³ Â¼Ã¶Ã„Â¡ ÂºÂ¸ÃÂ¤ 
					switch (dwType) {
					case 1: // Ã‡ÃŠÂ»Ã¬ Ã…Â¸Â°Ã ÃƒÃ–Ã€Ãº +5
						if (dwValue <= 5) dwValue = 5;
						break; 
					case 2: // ÃÃŸÂµÂ¶ Ã…Â¸Â°Ã ÃƒÃ–Ã€Ãº +20
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 6: // Â°Ã¦Â·Â®ÃˆÂ­ ÃƒÃ–Ã€Ãº  +16%
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 8: // Â¼Ã¶Â¸Ã­ ÃƒÃ–Ã€Ãº +14%					
						if (dwValue <= 2) dwValue = 2;
						break; 
					}
					// v2.03 912 Â¾Ã†Ã€ÃŒÃ…Ã› Â¼Ã¶ÃÃ˜Ã€ÃŒ 2Ã€ÃŒÃ‡ÃÃ€ÃÂ¶Â§ Ã†Â¯Â¼ÂºÃ„Â¡ ÃƒÃ–Â´Ã«Â°ÂªÃ€Âº 7
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

					// Â¾Ã†Ã€ÃŒÃ…Ã› Main Ã†Â¯Â¼ÂºÃ„Â¡, Â°Âª Ã€Ã”Â·Ã‚
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					// Â¾Ã†Ã€ÃŒÃ…Ã› Sub Ã†Â¯Â¼ÂºÃ„Â¡Â°Â¡ Ã€Ã”Â·Ã‚ÂµÃ‰ ÃˆÂ®Â·Ã¼Ã€Âº 40%
					if (iDice(1,10000) >= 6000) {

						// ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã› Sub Ã†Â¯Â¼ÂºÃ„Â¡ ÃˆÂ¿Â°Ãº ÃÂ¾Â·Ã¹: 
						//ÃƒÃŸÂ°Â¡ ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—(1), ÃƒÃŸÂ°Â¡ Â¸Ã­ÃÃŸÂ°Âª(2), ÃƒÃŸÂ°Â¡ Â¹Ã¦Â¾Ã®Â°Âª(3), HP ÃˆÂ¸ÂºÂ¹Â·Â® ÃƒÃŸÂ°Â¡(4), SP ÃˆÂ¸ÂºÂ¹Â·Â® ÃƒÃŸÂ°Â¡(5)
						//MP ÃˆÂ¸ÂºÂ¹Â·Â® ÃƒÃŸÂ°Â¡(6), ÃƒÃŸÂ°Â¡ Â¸Â¶Â¹Ã½Ã€ÃºÃ‡Ã—(7), Â¹Â°Â¸Â® Â´Ã«Â¹ÃŒÃÃ¶ ÃˆÃ­Â¼Ã¶(8), Â¸Â¶Â¹Ã½ Â´Ã«Â¹ÃŒÃÃ¶ ÃˆÃ­Â¼Ã¶(9)
						//Â¿Â¬Ã…Â¸ Â´Ã«Â¹ÃŒÃÃ¶ ÃƒÃŸÂ°Â¡(10), Â´Ãµ Â¸Â¹Ã€Âº Â°Ã¦Ã‡Ã¨Ã„Â¡(11), Â´ÃµÂ¸Â¹Ã€Âº Gold(12)

						// Â¹Â«Â±Ã¢Â·Ã¹Ã€ÃŒÂ±Ã¢ Â¶Â§Â¹Â®Â¿Â¡ Â°Ã¸Â°Ã Â¸Ã­ÃÃŸ ÃƒÃŸÂ°Â¡(50%), Â¿Â¬Ã…Â¸ Ã…Â¸Â°ÃÃ„Â¡ ÃÃµÂ°Â¡(35%), Â´Ãµ Â¸Â¹Ã€Âº Gold(10%), Â´Ãµ Â¸Â¹Ã€Âº Â°Ã¦Ã‡Ã¨Ã„Â¡(5%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 4999))          dwType = 2;
						else if ((iResult >= 5000) && (iResult <= 8499))  dwType = 10;
						else if ((iResult >= 8500) && (iResult <= 9499))  dwType = 12;
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 11;

						// Â¾Ã†Ã€ÃŒÃ…Ã› Sub Ã†Â¯Â¼ÂºÃ„Â¡ ÃÂ¤ÂµÂµÂ°Âª Ã€Ã”Â·Ã‚ 
						iResult = iDice(1, 30000);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
						else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
						else dwValue = 1; // v2.03 906

						// Â¹Â«Â±Ã¢Ã€Ã‡ Sub Ã†Â¯Â¼ÂºÃ„Â¡Â¿Â¡ ÂµÃ»Â¶Ã³ Â¼Ã¶Ã„Â¡ ÂºÂ¸ÃÂ¤ 
						switch (dwType) {
						case 2: // Â°Ã¸Â°ÃÂ¸Ã­ÃÃŸ ÃƒÃ–Ã€Ãº +21%
							if (dwValue <= 3) dwValue = 3;
							break; 
						case 10: // Â¿Â¬Â¼Ã“ Ã…Â¸Â°Ã ÃƒÃ–Ã€Ãº +1 ÃƒÃ–Â´Ã« 7
							if (dwValue > 7) dwValue = 7; 
							break; 
						case 11: // ExpÂ´Ã‚ Â¹Â«ÃÂ¶Â°Ã‡ +20%
							dwValue = 2;
							break; 
						case 12: // GoldÂ´Ã‚ Â¹Â«ÃÂ¶Â°Ã‡ +50%
							dwValue = 5;
							break; 
						}
						// v2.03 912 Â¾Ã†Ã€ÃŒÃ…Ã› Â¼Ã¶ÃÃ˜Ã€ÃŒ 2Ã€ÃŒÃ‡ÃÃ€ÃÂ¶Â§ Ã†Â¯Â¼ÂºÃ„Â¡ ÃƒÃ–Â´Ã«Â°ÂªÃ€Âº 7
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

						// Â¾Ã†Ã€ÃŒÃ…Ã› Sub Ã†Â¯Â¼ÂºÃ„Â¡ Ã€Ã”Â·Ã‚
						dwType  = dwType << 12;
						dwValue = dwValue << 8;

						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}

				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) {
					// Â¸Â¶Â¹Ã½ Â°Ã¸Â°Ã Â¹Â«Â±Ã¢Â·Ã¹Â¿Â¡ ÂºÃ™Ã€Â» Â¼Ã¶ Ã€Ã–Â´Ã‚ ÃÂ¢ÂµÃÂ»Ã§Â¸Â¦ Â¼Â±Ã…Ãƒ 10, 11
					// Â¸Â¶Â¹Ã½ Â¼ÂºÂ°Ã¸Ã€Ã‡(100%) <- Ã‡Ã¶Ã€Ã§ Â¸Â¶Â¹Ã½ ÃÃ¶Ã†ÃÃ€ÃŒÂ¿Â¡ ÂºÃ™Ã€Â» Â¼Ã¶ Ã€Ã–Â´Ã‚ Â¿Ã¤Â¼Ã’Â°Â¡ Ã€ÃŒÂ°Ã… Â¹Ã›Â¿Â¡ Â¾Ã¸Â´Ã™.
					dwType = 10;
					cColor = 5;

					// Â¾Ã†Ã€ÃŒÃ…Ã› Â»Ã¶Â»Ã³ Ã€Ã”Â·Ã‚ 
					pItem->m_cItemColor = cColor;

					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

					// v2.03 912 Â¾Ã†Ã€ÃŒÃ…Ã› Â¼Ã¶ÃÃ˜Ã€ÃŒ 2Ã€ÃŒÃ‡ÃÃ€ÃÂ¶Â§ Ã†Â¯Â¼ÂºÃ„Â¡ ÃƒÃ–Â´Ã«Â°ÂªÃ€Âº 7
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

					// Â¹Ã¦Â¾Ã®Â±Â¸ Main Ã†Â¯Â¼ÂºÃ„Â¡, Â°Âª Ã€Ã”Â·Ã‚
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					// Â¾Ã†Ã€ÃŒÃ…Ã› Sub Ã†Â¯Â¼ÂºÃ„Â¡Â°Â¡ Ã€Ã”Â·Ã‚ÂµÃ‰ ÃˆÂ®Â·Ã¼Ã€Âº 40%
					if (iDice(1,10000) >= 6000) {

						// ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã› Sub Ã†Â¯Â¼ÂºÃ„Â¡ ÃˆÂ¿Â°Ãº ÃÂ¾Â·Ã¹: 
						//ÃƒÃŸÂ°Â¡ ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—(1), ÃƒÃŸÂ°Â¡ Â¸Ã­ÃÃŸÂ°Âª(2), ÃƒÃŸÂ°Â¡ Â¹Ã¦Â¾Ã®Â°Âª(3), HP ÃˆÂ¸ÂºÂ¹Â·Â® ÃƒÃŸÂ°Â¡(4), SP ÃˆÂ¸ÂºÂ¹Â·Â® ÃƒÃŸÂ°Â¡(5)
						//MP ÃˆÂ¸ÂºÂ¹Â·Â® ÃƒÃŸÂ°Â¡(6), ÃƒÃŸÂ°Â¡ Â¸Â¶Â¹Ã½Ã€ÃºÃ‡Ã—(7), Â¹Â°Â¸Â® Â´Ã«Â¹ÃŒÃÃ¶ ÃˆÃ­Â¼Ã¶(8), Â¸Â¶Â¹Ã½ Â´Ã«Â¹ÃŒÃÃ¶ ÃˆÃ­Â¼Ã¶(9)
						//Â¿Â¬Ã…Â¸ Â´Ã«Â¹ÃŒÃÃ¶ ÃƒÃŸÂ°Â¡(10), Â´Ãµ Â¸Â¹Ã€Âº Â°Ã¦Ã‡Ã¨Ã„Â¡(11), Â´ÃµÂ¸Â¹Ã€Âº Gold(12)

						// Â¹Â«Â±Ã¢Â·Ã¹Ã€ÃŒÂ±Ã¢ Â¶Â§Â¹Â®Â¿Â¡ Â°Ã¸Â°Ã Â¸Ã­ÃÃŸ ÃƒÃŸÂ°Â¡(50%), Â¿Â¬Ã…Â¸ Ã…Â¸Â°ÃÃ„Â¡ ÃÃµÂ°Â¡(35%), Â´Ãµ Â¸Â¹Ã€Âº Gold(10%), Â´Ãµ Â¸Â¹Ã€Âº Â°Ã¦Ã‡Ã¨Ã„Â¡(5%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 4999))          dwType = 2;
						else if ((iResult >= 5000) && (iResult <= 8499))  dwType = 10;
						else if ((iResult >= 8500) && (iResult <= 9499))  dwType = 12;
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 11;

						// Â¾Ã†Ã€ÃŒÃ…Ã› Sub Ã†Â¯Â¼ÂºÃ„Â¡ ÃÂ¤ÂµÂµÂ°Âª Ã€Ã”Â·Ã‚ 
						iResult = iDice(1, 30000);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
						else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
						else dwValue = 1; // v2.03 906

						// v2.03 912 Â¾Ã†Ã€ÃŒÃ…Ã› Â¼Ã¶ÃÃ˜Ã€ÃŒ 2Ã€ÃŒÃ‡ÃÃ€ÃÂ¶Â§ Ã†Â¯Â¼ÂºÃ„Â¡ ÃƒÃ–Â´Ã«Â°ÂªÃ€Âº 7
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

						// Â¹Â«Â±Ã¢Ã€Ã‡ Sub Ã†Â¯Â¼ÂºÃ„Â¡Â¿Â¡ ÂµÃ»Â¶Ã³ Â¼Ã¶Ã„Â¡ ÂºÂ¸ÃÂ¤ 
						switch (dwType) {
						case 2: // Â°Ã¸Â°ÃÂ¸Ã­ÃÃŸ ÃƒÃ–Ã€Ãº +21%
							if (dwValue <= 3) dwValue = 3;
							break; 
						case 10: // Â¿Â¬Â¼Ã“ Ã…Â¸Â°Ã ÃƒÃ–Ã€Ãº +1 ÃƒÃ–Â´Ã« 7
							if (dwValue > 7) dwValue = 7; 
							break; 
						case 11: // ExpÂ´Ã‚ Â¹Â«ÃÂ¶Â°Ã‡ +20%
							dwValue = 2;
							break; 
						case 12: // GoldÂ´Ã‚ Â¹Â«ÃÂ¶Â°Ã‡ +50%
							dwValue = 5;
							break; 
						}

						// Â¾Ã†Ã€ÃŒÃ…Ã› Sub Ã†Â¯Â¼ÂºÃ„Â¡ Ã€Ã”Â·Ã‚
						dwType  = dwType << 12;
						dwValue = dwValue << 8;
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}
				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE) {
					// Â¹Ã¦Â¾Ã®Â±Â¸Â¿Â¡ Â¸Ã‚Â´Ã‚ ÃÂ¢ÂµÃÂ»Ã§Â¿Ã Ã†Â¯Â¼ÂºÃ„Â¡Â¸Â¦ Â¼Â±Ã…Ãƒ, Ã‡Ã’Â´Ã§Ã‡Ã‘Â´Ã™.

					// Â°Â­ÃˆÂ­ÂµÃˆ(60%) Â°Â¡ÂºÂ­Â¿Ã® (30%) Â¸Â¶Â³Âª ÂºÂ¯ÃˆÂ¯Ã€Ã‡(5%) Ã‡ÃŠÂ»Ã¬ ÃƒÃ¦Ã€Ã¼Ã€Ã‡(5%)
					iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 5999))          dwType = 8;
					else if ((iResult >= 6000) && (iResult <= 8999))  dwType = 6;
					else if ((iResult >= 9000) && (iResult <= 9554))  dwType = 11; //dwType = 11;
					else if ((iResult >= 9555) && (iResult <= 10000)) dwType = 12; //dwType = 12;

					// Â¾Ã†Ã€ÃŒÃ…Ã› Sub Ã†Â¯Â¼ÂºÃ„Â¡ ÃÂ¤ÂµÂµÂ°Âª Ã€Ã”Â·Ã‚ 
					iResult = iDice(1, 30000);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
					else dwValue = 1; // v2.03 906

					// Â¹Ã¦Â¾Ã®Â±Â¸Ã€Ã‡ Main Ã†Â¯Â¼ÂºÃ„Â¡Â¿Â¡ ÂµÃ»Â¶Ã³ Â¼Ã¶Ã„Â¡ ÂºÂ¸ÃÂ¤ 
					switch (dwType) {
					case 6: // Â°Ã¦Â·Â®ÃˆÂ­ ÃƒÃ–Ã€Ãº +16%
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 8: // Â¼Ã¶Â¸Ã­ ÃƒÃ–Ã€Ãº +14%
						if (dwValue <= 2) dwValue = 2;
						break; 

					case 11:
					case 12:
						// v2.04
						dwValue = (dwValue+1) / 2;
						if (dwValue < 1) dwValue = 1;
						if ((iGenLevel <= 3) && (dwValue > 2)) dwValue = 2;
						break;
					}
					// v2.03 912 Â¾Ã†Ã€ÃŒÃ…Ã› Â¼Ã¶ÃÃ˜Ã€ÃŒ 2Ã€ÃŒÃ‡ÃÃ€ÃÂ¶Â§ Ã†Â¯Â¼ÂºÃ„Â¡ ÃƒÃ–Â´Ã«Â°ÂªÃ€Âº 7
					if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

					// Â¹Ã¦Â¾Ã®Â±Â¸ Main Ã†Â¯Â¼ÂºÃ„Â¡, Â°Âª Ã€Ã”Â·Ã‚
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					// Â¹Ã¦Â¾Ã®Â±Â¸ Sub Ã†Â¯Â¼ÂºÃ„Â¡Â°Â¡ Ã€Ã”Â·Ã‚ÂµÃ‰ ÃˆÂ®Â·Ã¼Ã€Âº 40%
					if (iDice(1,10000) >= 6000) {

						// ÃˆÃ±Â±Ã Â¾Ã†Ã€ÃŒÃ…Ã› Sub Ã†Â¯Â¼ÂºÃ„Â¡ ÃˆÂ¿Â°Ãº ÃÂ¾Â·Ã¹: 
						//ÃƒÃŸÂ°Â¡ ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—(1), ÃƒÃŸÂ°Â¡ Â¸Ã­ÃÃŸÂ°Âª(2), ÃƒÃŸÂ°Â¡ Â¹Ã¦Â¾Ã®Â°Âª(3), HP ÃˆÂ¸ÂºÂ¹Â·Â® ÃƒÃŸÂ°Â¡(4), SP ÃˆÂ¸ÂºÂ¹Â·Â® ÃƒÃŸÂ°Â¡(5)
						//MP ÃˆÂ¸ÂºÂ¹Â·Â® ÃƒÃŸÂ°Â¡(6), ÃƒÃŸÂ°Â¡ Â¸Â¶Â¹Ã½Ã€ÃºÃ‡Ã—(7), Â¹Â°Â¸Â® Â´Ã«Â¹ÃŒÃÃ¶ ÃˆÃ­Â¼Ã¶(8), Â¸Â¶Â¹Ã½ Â´Ã«Â¹ÃŒÃÃ¶ ÃˆÃ­Â¼Ã¶(9)
						//Â¿Â¬Ã…Â¸ Â´Ã«Â¹ÃŒÃÃ¶ ÃƒÃŸÂ°Â¡(10), Â´Ãµ Â¸Â¹Ã€Âº Â°Ã¦Ã‡Ã¨Ã„Â¡(11), Â´ÃµÂ¸Â¹Ã€Âº Gold(12)

						// Â¹Ã¦Â¾Ã®Â±Â¸ Ã€ÃŒÂ±Ã¢ Â¶Â§Â¹Â®Â¿Â¡ 
						// ÃƒÃŸÂ°Â¡Â¹Ã¦Â¾Ã®Â°Âª(10%) ÃƒÃŸÂ°Â¡ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã—(30%)    SPÃˆÂ¸ÂºÂ¹ÃƒÃŸÂ°Â¡(15%)  HPÃˆÂ¸ÂºÂ¹ÃƒÃŸÂ°Â¡(10%) 
						// MPÃˆÂ¸ÂºÂ¹ ÃƒÃŸÂ°Â¡(10%) ÃƒÃŸÂ°Â¡Â¸Â¶Â¹Ã½Ã€ÃºÃ‡Ã—(15%) Â¹Â°Â¸Â®Â´Ã«Â¹ÃŒÃÃ¶ÃˆÃ­Â¼Ã¶(3%) Â¸Â¶Â¹Ã½Â´Ã«Â¹ÃŒÃÃ¶ÃˆÃ­Â¼Ã¶(3%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 999))           dwType = 3;
						else if ((iResult >= 1000) && (iResult <= 3999))  dwType = 1;
						else if ((iResult >= 4000) && (iResult <= 5499))  dwType = 5;
						else if ((iResult >= 5500) && (iResult <= 6499))  dwType = 4;
						else if ((iResult >= 6500) && (iResult <= 7499))  dwType = 6;
						else if ((iResult >= 7500) && (iResult <= 9399))  dwType = 7;
						else if ((iResult >= 9400) && (iResult <= 9799))  dwType = 8;
						else if ((iResult >= 9800) && (iResult <= 10000)) dwType = 9;

						// Â¾Ã†Ã€ÃŒÃ…Ã› Sub Ã†Â¯Â¼ÂºÃ„Â¡ ÃÂ¤ÂµÂµÂ°Âª Ã€Ã”Â·Ã‚ 
						iResult = iDice(1, 30000);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 17400))  dwValue = 2;  // 6600/29348 = 22.4%
						else if ((iResult >= 17400) && (iResult < 22400))  dwValue = 3;  // 4356/29348 = 14.8%
						else if ((iResult >= 22400) && (iResult < 25400))  dwValue = 4;  // 2874/29348 = 9.7%
						else if ((iResult >= 25400) && (iResult < 27400))  dwValue = 5;  // 1897/29348 = 6.4%
						else if ((iResult >= 27400) && (iResult < 28400))  dwValue = 6;  // 1252/29348 = 4.2%
						else if ((iResult >= 28400) && (iResult < 28900))  dwValue = 7;  // 826/29348 = 2.8%
						else if ((iResult >= 28900) && (iResult < 29300))  dwValue = 8;  // 545/29348 = 1.85%
						else if ((iResult >= 29300) && (iResult < 29600))  dwValue = 9;  // 360/29348 = 1.2%
						else if ((iResult >= 29600) && (iResult < 29800))  dwValue = 10; // 237/29348 = 0.8%
						else if ((iResult >= 29800) && (iResult < 29900))  dwValue = 11; // 156/29348 = 0.5%
						else if ((iResult >= 29900) && (iResult < 29970))  dwValue = 12; // 103/29348 = 0.3%
						else if ((iResult >= 29970) && (iResult <= 30000))  dwValue = 13; // 68/29348 = 0.1%
						else dwValue = 1; // v2.03 906

						// Â¹Ã¦Â¾Ã®Â±Â¸Ã€Ã‡ Sub Ã†Â¯Â¼ÂºÃ„Â¡Â¿Â¡ ÂµÃ»Â¶Ã³ Â¼Ã¶Ã„Â¡ ÂºÂ¸ÃÂ¤ 
						switch (dwType) {
						case 1: // ÂµÂ¶Â¼ÂºÃ€ÃºÃ‡Ã— ÃƒÃ–Ã€Ãº +21%
						case 3: // Â¹Â°Â¸Â®Â¹Ã¦Â¾Ã® ÃƒÃ–Ã€Ãº +21%
						case 7: // Â¸Â¶Â¹Ã½ Ã€ÃºÃ‡Ã— ÃƒÃ–Ã€Ãº +21%
						case 8: // Â¹Â°Â¸Â®ÃˆÃ­Â¼Ã¶ ÃƒÃ–Ã€Ãº +9%
						case 9: // Â¸Â¶Â¹Ã½ÃˆÃ­Â¼Ã¶ ÃƒÃ–Ã€Ãº +9%
							if (dwValue <= 3) dwValue = 3;
							break; 
						}
						// v2.03 912 Â¾Ã†Ã€ÃŒÃ…Ã› Â¼Ã¶ÃÃ˜Ã€ÃŒ 2Ã€ÃŒÃ‡ÃÃ€ÃÂ¶Â§ Ã†Â¯Â¼ÂºÃ„Â¡ ÃƒÃ–Â´Ã«Â°ÂªÃ€Âº 7
						if ((iGenLevel <= 2) && (dwValue > 7)) dwValue = 7;

						// Â¾Ã†Ã€ÃŒÃ…Ã› Sub Ã†Â¯Â¼ÂºÃ„Â¡ Ã€Ã”Â·Ã‚
						dwType  = dwType << 12;
						dwValue = dwValue << 8;
						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}

				// Ã«Â§Ë†Ã¬Â§â‚¬Ã«Â§â€°Ã¬Å“Â¼Ã«Â¡Å“ Ã­Å Â¹Ã¬â€Â±Ã¬Â¹ËœÃ«Â¥Â¼ Ã­Å Â¹Ã¬Ë†Ëœ Ã¬â€¢â€Ã¬ÂÂ´Ã­â€¦Å“Ã¬â€”Â Ã«Â§Å¾ÃªÂ²Å’Ã«Ââ€ Ã«Â³â‚¬ÃªÂ²Â½ 
				_AdjustRareItemValue(pItem);
			}
		}

		// Ã¬â€¢â€Ã¬ÂÂ´Ã­â€¦Å“Ã¬â€”Â ÃªÂ³Â Ã¬Å“Â  Ã¬Â½â€Ã«â€œÅ“ Ã¬Å¾â€¦Ã«Â Â¥ 
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		//pItem->m_sTouchEffectValue3 = timeGetTime();
		// Ã«Â§Ë†Ã¬Â§â‚¬Ã«Â§â€° Ã¬Ë†Â«Ã¬Å¾ÂÃ«Å â€ Ã¬â€¢â€Ã¬ÂÂ´Ã­â€¦Å“ Ã¬Æ’ÂÃ¬â€Â± Ã¬â€ºâ€, Ã¬ÂÂ¼	
		SYSTEMTIME SysTime;
		char cTemp[256];
		GetLocalTime(&SysTime);
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
		pItem->m_sTouchEffectValue3 = atoi(cTemp);

		// Ã¬â€¢â€Ã¬ÂÂ´Ã­â€¦Å“Ã¬Ââ€ Ã¬â€Å“Ã¬Å¾Ë†Ã«Å â€ Ã¬Å“â€Ã¬Â¹ËœÃ¬â€”Â Ã«â€“Â¨Ã¬â€“Â´Ã«Å“Â¨Ã«Â¦Â°Ã«â€¹Â¤. 
		m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, 
			m_pNpcList[iNpcH]->m_sY, 
			pItem);

		// Ã«â€¹Â¤Ã«Â¥Â¸ Ã­ÂÂ´Ã«ÂÂ¼Ã¬ÂÂ´Ã¬â€“Â¸Ã­Å Â¸Ã¬â€”ÂÃªÂ²Å’ Ã¬â€¢â€Ã¬ÂÂ´Ã­â€¦Å“Ã¬ÂÂ´ Ã«â€“Â¨Ã¬â€“Â´Ã¬Â§â€ ÃªÂ²Æ’Ã¬Ââ€ Ã¬â€¢Å’Ã«Â¦Â°Ã«â€¹Â¤. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
			m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
			pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

		// Ã«Â¡Å“ÃªÂ·Â¸ Ã«â€šÂ¨ÃªÂ¸Â´Ã«â€¹Â¤.
		_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, NULL, pItem);
	}
}

BOOL CGame::bReadAdminSetConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadMode, cGSMode[16] = "";
	char seps[] = "= \t\n";
	class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
	 return FALSE;
	}
	else {
		 PutLogList("(!) Reading settings file...");
		 cp = new char[dwFileSize+2];
		 ZeroMemory(cp, dwFileSize+2);
		 fread(cp, dwFileSize, 1, pFile);

		 pStrTok = new class CStrTok(cp, seps);
		 token = pStrTok->pGet();
		 //token = strtok( cp, seps );   
		 while( token != NULL )   {

		 if (cReadMode != 0) {
		   switch (cReadMode) {

		   case 1:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGMKill = atoi(token);
			}
			else{
				m_iAdminLevelGMKill = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		   case 2:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGMRevive = atoi(token);
			}
			else{
				m_iAdminLevelGMRevive = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		   case 3:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGMCloseconn = atoi(token);
			}
			else{
				m_iAdminLevelGMCloseconn = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		   case 4:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGMCheckRep = atoi(token);
			}
			else{
				m_iAdminLevelGMCheckRep = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 5:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelWho = atoi(token);
			}
			else{
				m_iAdminLevelWho = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 6:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelEnergySphere = atoi(token);
			}
			else{
				m_iAdminLevelEnergySphere = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 7:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelShutdown = atoi(token);
			}
			else{
				m_iAdminLevelShutdown = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 8:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelObserver = atoi(token);
			}
			else{
				m_iAdminLevelObserver = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 9:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelShutup = atoi(token);
			}
			else{
				m_iAdminLevelShutup = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 10:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCallGaurd = atoi(token);
			}
			else{
				m_iAdminLevelCallGaurd = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 11:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonDemon = atoi(token);
			}
			else{
				m_iAdminLevelSummonDemon = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------		   
		  case 12:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonDeath = atoi(token);
			}
			else{
				m_iAdminLevelSummonDeath = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 13:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelReserveFightzone = atoi(token);
			}
			else{
				m_iAdminLevelReserveFightzone = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 14:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCreateFish = atoi(token);
			}
			else{
				m_iAdminLevelCreateFish = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 15:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelTeleport = atoi(token);
			}
			else{
				m_iAdminLevelTeleport = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 16:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCheckIP = atoi(token);
			}
			else{
				m_iAdminLevelCheckIP = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 17:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelPolymorph = atoi(token);
			}
			else{
				m_iAdminLevelPolymorph = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 18:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetInvis = atoi(token);
			}
			else{
				m_iAdminLevelSetInvis = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 19:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetZerk = atoi(token);
			}
			else{
				m_iAdminLevelSetZerk = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 20:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetIce = atoi(token);
			}
			else{
				m_iAdminLevelSetIce = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 21:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGetNpcStatus = atoi(token);
			}
			else{
				m_iAdminLevelGetNpcStatus = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------				
		  case 22:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetAttackMode = atoi(token);
			}
			else{
				m_iAdminLevelSetAttackMode = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 23:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelUnsummonAll = atoi(token);
			}
			else{
				m_iAdminLevelUnsummonAll = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 24:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelUnsummonDemon = atoi(token);
			}
			else{
				m_iAdminLevelUnsummonDemon = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 25:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummon = atoi(token);
			}
			else{
				m_iAdminLevelSummon = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------			
		  case 26:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonAll = atoi(token);
			}
			else{
				m_iAdminLevelSummonAll = 4;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 27:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonPlayer = atoi(token);
			}
			else{
				m_iAdminLevelSummonPlayer = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 28:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelDisconnectAll = atoi(token);
			}
			else{
				m_iAdminLevelDisconnectAll = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 29:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelEnableCreateItem = atoi(token);
			}
			else{
				m_iAdminLevelEnableCreateItem = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------			
		  case 30:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCreateItem = atoi(token);
			}
			else{
				m_iAdminLevelCreateItem = 4;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 31:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelStorm = atoi(token);
			}
			else{
				m_iAdminLevelStorm = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 32:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelWeather = atoi(token);
			}
			else{
				m_iAdminLevelWeather = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 33:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetStatus = atoi(token);
			}
			else{
				m_iAdminLevelSetStatus = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 34:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelGoto = atoi(token);
			}
			else{
				m_iAdminLevelGoto = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 35:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelMonsterCount = atoi(token);
			}
			else{
				m_iAdminLevelMonsterCount = 1;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------			
		  case 36:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSetRecallTime = atoi(token);
			}
			else{
				m_iAdminLevelSetRecallTime = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 37:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelUnsummonBoss = atoi(token);
			}
			else{
				m_iAdminLevelUnsummonBoss = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------	
		  case 38:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelClearNpc = atoi(token);
			}
			else{
				m_iAdminLevelClearNpc = 3;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------				
		  case 39:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelTime = atoi(token);
			}
			else{
				m_iAdminLevelTime = 2;
			}
			cReadMode = 0;
			break;
//----------------------------------------------------------------
		  case 40:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelPushPlayer = atoi(token);
			}
			else{
				m_iAdminLevelPushPlayer = 2;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 41:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelSummonGuild = atoi(token);
			}
			else{
				m_iAdminLevelSummonGuild = 3;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 42:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCheckStatus = atoi(token);
			}
			else{
				m_iAdminLevelCheckStatus = 1;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
		  case 43:
			if ((strlen(token) > 0) && (strlen(token) < 9))
			{
				m_iAdminLevelCleanMap = atoi(token);
			}
			else{
				m_iAdminLevelCleanMap = 1;
			}
			cReadMode = 0;
			break;
//-----------------------------------------------------------------
			}
		  }
		  else {
			if (memcmp(token, "Admin-Level-/kill", 17) == 0)						cReadMode = 1;
			if (memcmp(token, "Admin-Level-/revive", 19) == 0)						cReadMode = 2;
			if (memcmp(token, "Admin-Level-/closecon", 21) == 0)					cReadMode = 3;
			if (memcmp(token, "Admin-Level-/checkrep", 21) == 0)					cReadMode = 4;
			if (memcmp(token, "Admin-Level-/who", 16) == 0)							cReadMode = 5;
			if (memcmp(token, "Admin-Level-/energysphere", 25) == 0)				cReadMode = 6;
			if (memcmp(token, "Admin-Level-/shutdownthisserverrightnow", 39) == 0)	cReadMode = 7;
			if (memcmp(token, "Admin-Level-/setobservermode", 28) == 0)				cReadMode = 8;
			if (memcmp(token, "Admin-Level-/shutup", 19) == 0)						cReadMode = 9;
			if (memcmp(token, "Admin-Level-/attack", 19) == 0)						cReadMode = 10;
			if (memcmp(token, "Admin-Level-/summondemon", 24) == 0)					cReadMode = 11;
			if (memcmp(token, "Admin-Level-/summondeath", 24) == 0)					cReadMode = 12;
			if (memcmp(token, "Admin-Level-/reservefightzone", 28) == 0)			cReadMode = 13;
			if (memcmp(token, "Admin-Level-/createfish", 23) == 0)					cReadMode = 14;
			if (memcmp(token, "Admin-Level-/teleport", 21) == 0)					cReadMode = 15;
			if (memcmp(token, "Admin-Level-/checkip", 20) == 0)						cReadMode = 16;
			if (memcmp(token, "Admin-Level-/polymorph", 22) == 0)					cReadMode = 17;
			if (memcmp(token, "Admin-Level-/setinvi", 20) == 0)						cReadMode = 18;
			if (memcmp(token, "Admin-Level-/setzerk", 20) == 0)						cReadMode = 19;
			if (memcmp(token, "Admin-Level-/setfreeze", 22) == 0)					cReadMode = 20;
			if (memcmp(token, "Admin-Level-/gns", 16) == 0)							cReadMode = 21;
			if (memcmp(token, "Admin-Level-/setattackmode", 26) == 0)				cReadMode = 22;
			if (memcmp(token, "Admin-Level-/unsummonall", 24) == 0)					cReadMode = 23;
			if (memcmp(token, "Admin-Level-/unsummondemon", 26) == 0)				cReadMode = 24;
			if (memcmp(token, "Admin-Level-/summonnpc", 22) == 0)					cReadMode = 25;
			if (memcmp(token, "Admin-Level-/summonall", 22) == 0)					cReadMode = 26;
			if (memcmp(token, "Admin-Level-/summonplayer", 25) == 0)				cReadMode = 27;
			if (memcmp(token, "Admin-Level-/disconnectall", 26) == 0)				cReadMode = 28;
			if (memcmp(token, "Admin-Level-/enableadmincreateitem", 34) == 0)		cReadMode = 29;
			if (memcmp(token, "Admin-Level-/createitem", 23) == 0)					cReadMode = 30;
			if (memcmp(token, "Admin-Level-/storm", 18) == 0)						cReadMode = 31;
			if (memcmp(token, "Admin-Level-/weather", 20) == 0)						cReadMode = 32;
			if (memcmp(token, "Admin-Level-/setstatus", 22) == 0)					cReadMode = 33;
			if (memcmp(token, "Admin-Level-/goto", 17) == 0)						cReadMode = 34;
			if (memcmp(token, "Admin-Level-/monstercount", 17) == 0)				cReadMode = 35;
			if (memcmp(token, "Admin-Level-/setforcerecalltime", 23) == 0)			cReadMode = 36;
			if (memcmp(token, "Admin-Level-/unsummonboss", 25) == 0)				cReadMode = 37;
			if (memcmp(token, "Admin-Level-/clearnpc", 21) == 0)					cReadMode = 38;
			if (memcmp(token, "Admin-Level-/time", 17) == 0)						cReadMode = 39;
			if (memcmp(token, "Admin-Level-/send", 17) == 0)						cReadMode = 40;
			if (memcmp(token, "Admin-Level-/summonguild", 24) == 0)					cReadMode = 41;
			if (memcmp(token, "Admin-Level-/checkstatus", 24) == 0)					cReadMode = 42;	
			if (memcmp(token, "Admin-Level-/clearmap", 21) == 0)					cReadMode = 43;	
		  }

		  token = pStrTok->pGet();
		  //token = strtok( NULL, seps );
		 }
		 delete pStrTok;
		 delete cp;
		}
		if (pFile != NULL) fclose(pFile);

		return TRUE;
}

void CGame::AdminOrder_Time(int iClientH, char * pData, DWORD dwMsgSize)
{
	//Time command By ACiDx Last edit on Sept,06,04
	BOOL m_bManualTime;
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;
	int i;

		if ((dwMsgSize)	<= 0) return;
		if (m_pClientList[iClientH] == NULL) return;
		if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelTime) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
			return;
		}
	
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();

		if (token != NULL) {
			if (token[0] == '2') {
				m_cDayOrNight = 2;
				wsprintf(G_cTxt, "(%s) Admin(%s) Order: Forces night mode", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
				m_bManualTime = TRUE;
			}
			else if (token[0] == '1') {
				m_cDayOrNight = 1;
				wsprintf(G_cTxt, "(%s) Admin(%s) Order: Forces day mode", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				m_bManualTime = TRUE;
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
			}
			else if (token[0] == '0') {		
				wsprintf(G_cTxt, "(%s) Admin(%s) Order: Disables force time", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
				m_bManualTime = FALSE;
				bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
			}
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			if ((m_pClientList[i]->m_cMapIndex >= 0) && 
				(m_pMapList[m_pClientList[i]->m_cMapIndex] != NULL) &&
				(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == FALSE))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_TIMECHANGE, m_cDayOrNight, NULL, NULL, NULL);	
		}
	}

	delete pStrTok;
}

void CGame::AdminOrder_CheckRep(int iClientH, char *pData,DWORD dwMsgSize)
{
 class  CStrTok * pStrTok;
 short m_iRating;
 char   * token, cName[11], cTargetName[11], cRepMessage[256], cTemp[256], seps[] = "= \t\n", cBuff[256];
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	ZeroMemory(cTemp, sizeof(cTemp));
	ZeroMemory(cRepMessage, sizeof(cRepMessage));
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		wsprintf(cRepMessage, " You have %d reputation points.", m_pClientList[iClientH]->m_iRating);
		ShowClientMsg(iClientH, cRepMessage);
	} 
	else {
		if ((dwMsgSize)	<= 0) return;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();

		token = pStrTok->pGet();
		
		if (token != NULL) {
			ZeroMemory(cName, sizeof(cName));
			strcpy(cName, token);
		} 
		else {
			ZeroMemory(cName, sizeof(cName));
			strcpy(cName, "null");
		}

		token = pStrTok->pGet();
		
		if (token != NULL) {
			m_iRating = atoi(token);
		} 
		
		if (token == NULL) { 
			token = "null"; 
		}
		
			if (cName != NULL) {
			token = cName;

				if (strlen(token) > 10) 
  					memcpy(cTargetName, token, 10);
				else memcpy(cTargetName, token, strlen(token));

				for (i = 1; i < DEF_MAXCLIENTS; i++) 
  					if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
						wsprintf(cRepMessage, " %s has %d reputation points.", m_pClientList[i]->m_cCharName, m_pClientList[i]->m_iRating);
						ShowClientMsg(iClientH, cRepMessage);
					}
			}
	}
}

void CGame::AdminOrder_Pushplayer(int iClientH, char * pData, DWORD dwMsgSize)
{
//Push Player- By:ACiDx  Monday , September 2004
	//Teleports a Defined Player to Defined Destination
	// /push playername mapname sX dX
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256], cName[11], cTargetName[11];
 class  CStrTok * pStrTok;
 register int dX, dY;
 register int i;
 BOOL   bFlag;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));

	dX = dY = -1;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelPushPlayer) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dY = atoi(token);
	}

	if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		token = cName;

	if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			bFlag = FALSE;
			//Asks For Flag on maps
			if (strcmp("2ndmiddle", cMapName) == 0) bFlag = TRUE;
			if (strcmp("abaddon", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("arebrk11", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arebrk12", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arebrk21", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arebrk22", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arefarm", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arejail", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aremidl", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aremidr", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aresden", cMapName) == 0) bFlag = TRUE;
			if (strcmp("aresdend1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("areuni", cMapName) == 0) bFlag = TRUE;
			if (strcmp("arewrhus", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bisle", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("bsmith_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("bsmith_2f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("BtField", cMapName) == 0) bFlag = TRUE;
			if (strcmp("cath_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("cath_2", cMapName) == 0)      bFlag = TRUE;
			if (strcmp("cityhall_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("cityhall_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("CmdHall_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("CmdHall_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("default", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("dglv4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("druncncity", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("elvbrk11", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvbrk12", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvbrk21", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvbrk22", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvfarm", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvine", cMapName) == 0)  bFlag = TRUE;
			if (strcmp("elvined1", cMapName) == 0)    bFlag = TRUE;
			if (strcmp("elvjail", cMapName) == 0)    bFlag = TRUE;
			if (strcmp("elvmidl", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvmidr", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvuni", cMapName) == 0) bFlag = TRUE;
			if (strcmp("elvwrhus", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone5", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone6", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone7", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone8", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone9", cMapName) == 0) bFlag = TRUE;
			if (strcmp("fightzone10", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gldhall_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gldhall_2", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("GodH", cMapName) == 0)   bFlag = TRUE;
			if (strcmp("gshop_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gshop_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("gshop_2", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("gshop_2f", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("HRampart", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("huntzone1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("huntzone2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("huntzone3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("huntzone4", cMapName) == 0) bFlag = TRUE;
			if (strcmp("icebound", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("inferniaA", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("inferniaB", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("maze", cMapName) == 0) bFlag = TRUE; 
			if (strcmp("middled1n", cMapName) == 0) bFlag = TRUE;
			if (strcmp("middled1x", cMapName) == 0) bFlag = TRUE;
			if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;
			if (strcmp("penalty", cMapName) == 0) bFlag = TRUE;
			if (strcmp("procella", cMapName) == 0) bFlag = TRUE;
			if (strcmp("resurr1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("resurr2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("toh1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("toh2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("toh3", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_1f", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wrhus_2", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("wrhus_2f", cMapName) == 0)     bFlag = TRUE;
			if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = TRUE;
			if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = TRUE;
			if (strcmp("Test", cMapName) == 0) bFlag = TRUE;
			if (strcmp("GMMap", cMapName) == 0) bFlag = TRUE;

			//Defines I as Max clients
				if (bFlag == TRUE)
					//Reqeust the Push/Teleport
					RequestTeleportHandler(i, "2   ", cMapName, dX, dY);
   					wsprintf(G_cTxt,"(%s) GM(%s) sends (%s) Player(%s) to [%s](%d,%d)",m_pClientList[iClientH]->m_cIPaddress, 
						m_pClientList[iClientH]->m_cCharName, m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName, cMapName, dX, dY);
					bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
				delete pStrTok;
				return;
			}
}
}

/*void CGame::AdminOrder_SummonGuild(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, * cp, cBuff[256], cMapName[11], char cGuildName[20]; 
 WORD   *wp;
 int    pX, pY, i;
 class  CStrTok * pStrTok;
 DWORD  dwGoldCount;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize) <= 0) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelSummonGuild) {
		// Admin user levelÃ€ÃŒ Â³Â·Â¾Ã†Â¼Â­ Ã€ÃŒ Â±Ã¢Â´Ã‰Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶ Â¾Ã¸Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	if (m_pClientList[iClientH]->m_iAdminUserLevel == 0) {
		// dwGoldCount = player gold
		dwGoldCount = dwGetItemCount(iClientH, "Gold");
		// if summonguildcost is greater than player gold return
		if (m_iSummonGuildCost > dwGoldCount) {
			return;
		}
		// if summonguildcost is less than player gold
		else {
			// reduce gold by summonguildcost
			SetItemCount(iClientH, "Gold", dwGoldCount - m_iSummonGuildCost);
		}
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;
	//memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
	memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);

	if (strlen(token) > 20)
			memcpy(cGuildName, token, 20);
		else memcpy(cGuildName, token, strlen(token));

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cGuildName, token) == 0)) {
			RequestTeleportHandler(i, "2   ", cMapName, pX, pY);
	}//m_pClientList[i]->m_cCharName

	wsprintf(G_cTxt,"GM Order(%s): PC(%s) Summoned to (%s)", m_pClientList[iClientH]->m_cGuildName, cGuildName, cMapName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_SUMMONGUILD;
	cp++;

	memcpy(cp, cGuildName, 20);
	cp += 20;

	memcpy(cp, cMapName, 10);
	cp += 10;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sX;
	cp += 2;

	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_sY;
	cp += 2;

	bStockMsgToGateServer(cBuff, 25);

	delete pStrTok;
}*/

void CGame::SendCollectedMana()
{
 char * cp, cData[120];
 WORD * wp;

	//SendMsgToGateServer(MSGID_COLLECTEDMANA, NULL);

	// ¸ğÀÎ ¸¶³ª°¡ ¾ø´Ù¸é ¸Ş½ÃÁö Àü¼ÛÇÏÁö ¾Ê´Â´Ù. ¸¶³ª ½ºÅæÀÌ ¾ø´Â ¸Ê¿¡¼­ ¸Ş½ÃÁö¸¦ Àü¼ÛÇÏ¸é ¾ÈµÈ´Ù.
	if ((m_iCollectedMana[1] == 0) && (m_iCollectedMana[2] == 0)) return;

	//testcode
	wsprintf(G_cTxt, "Sending Collected Mana: %d %d", m_iCollectedMana[1], m_iCollectedMana[2]);
	PutLogList(G_cTxt);

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp = GSM_COLLECTEDMANA;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[1];
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[2];
	cp += 2;

	CollectedManaHandler(m_iCollectedMana[1], m_iCollectedMana[2]);

	bStockMsgToGateServer(cData, 5);
	
	// ±×µ¿¾È ¸ğÀº ¸¶³ª·® º¸³»°í Å¬¸®¾î.
	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;
}

void CGame::CollectedManaHandler(WORD wAresdenMana, WORD wElvineMana)
{
	if (m_iAresdenMapIndex != -1) {
		m_iAresdenMana += wAresdenMana;
		//testcode
		if (wAresdenMana > 0) {
			wsprintf(G_cTxt, "Aresden Mana: %d Total:%d", wAresdenMana, m_iAresdenMana);
			PutLogList(G_cTxt);
		}
	}

	if (m_iElvineMapIndex != -1) {
		m_iElvineMana += wElvineMana;
		//testcode
		if (wElvineMana > 0) {
			wsprintf(G_cTxt, "Elvine Mana: %d Total:%d", wElvineMana, m_iElvineMana);
			PutLogList(G_cTxt);
		}
	}
}

//New Changed 11/05/2004
// v2.15 ¸ŞÅ×¿À¿¡ ¸ÂÀ»¶§ ³²Àº °Ç¹° HP ¸¦ º¸¿©ÁÖ±â À§ÇÑ ·çÆ¾ 
// ÁÖÀÇ ÇöÀç °Ç¹°ÀÌ 4°³ÀÎ °æ¿ì¿¡ ¸ÂÃç¼­ ·çÆ¾ÀÌ Çü¼º µÇ¾î ÀÖ´Ù.
void CGame::CalcMeteorStrikeEffectHandler(int iMapIndex)
{
 int i, iActiveStructure, iStructureHP[DEF_MAXSTRIKEPOINTS] ;
 char * cp, * cp2, cData[120], cWinnerSide, cTempData[120];
 WORD * wp;

	if (m_bIsCrusadeMode == FALSE) return;

	// »ç¿ëÀÚ¿¡°Ô ³²Àº °Ç¹°ÀÇ HP¸¦ º¸¿©ÁÖ±â À§ÇÑ º¯¼ö ÃÊ±âÈ­ 
	for(i = 0 ; i < DEF_MAXSTRIKEPOINTS; i++)
		iStructureHP[i] = 0 ;

	// Æø°İÀÇ È¿°ú¸¦ °è»êÇÑ´Ù. ¸ğµç °Ç¹°ÀÌ ÆÄ±«µÇ¾ú´Ù¸é Àü¸éÀü ¸ğµå Á¾·á. ±×·¸Áö ¾ÊÀ¸¸é °á°ú¸¦ ¸ğµç ¼­¹ö¿¡ ¸®Æ÷Æ®.
	iActiveStructure = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iActiveStructure++;
			iStructureHP[i] = m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP ;
		}
	}
	
	//testcode
	wsprintf(G_cTxt, "ActiveStructure:%d  MapIndex:%d AresdenMap:%d ElvineMap:%d", iActiveStructure, iMapIndex, m_iAresdenMapIndex, m_iElvineMapIndex);
	PutLogList(G_cTxt);

	if (iActiveStructure == 0) {
		// ÀÛµ¿ÁßÀÎ °Ç¹°ÀÌ ¾ø´Ù. Å©·ç¼¼ÀÌµå ¸ğµå Á¾·á: ´Ù¸¥ ¼­¹ö¿¡ ¾Ë·ÁÁØ´Ù.
		// Å©·ç¼¼ÀÌµå ¸ğµå Á¾·áµÊÀ» ÇöÀç ¼­¹öÀÇ Å¬¶óÀÌ¾ğÆ®µé¿¡°Ô ¹Ù·Î Àü´Ş.
		if (iMapIndex == m_iAresdenMapIndex) {
			cWinnerSide = 2;
			LocalEndCrusadeMode(2); // ÀÌ±ä ÂÊÀº ¿¤¹ÙÀÎ
		}
		else if (iMapIndex == m_iElvineMapIndex) {
			cWinnerSide = 1;
			LocalEndCrusadeMode(1); // ÀÌ±ä ÂÊÀº ¾Æ·¹½ºµ§
		}
		else {
			cWinnerSide = 0;
			LocalEndCrusadeMode(0); 
		}
		
		// ´Ù¸¥ ¼­¹ö¿¡ Å©·ç¼¼ÀÌµå Á¾·á¸¦ ¾Ë¸².
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_ENDCRUSADE;
		cp++;

		*cp = cWinnerSide;
		cp++;			

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		bStockMsgToGateServer(cData, 18);

	}
	else {
		// ÇÇÇØ »óÈ²À» ¸ğµç ¼­¹ö·Î ¸®Æ÷Æ®.
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_GRANDMAGICRESULT;
		cp++;
		
		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD) iActiveStructure;
		cp += 2;

		//v2.15 Ãß°¡  ÅäÅ» °Ç¹°ÀÇ °¹¼ö 
		ZeroMemory(cTempData, sizeof(cTempData));
		cp2 = (char *)(cTempData); 

		wp = (WORD *)cp2;
		*wp = (WORD) m_pMapList[iMapIndex]->m_iTotalStrikePoints;
		cp2 += 2;

		for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints;i++){
			wp = (WORD *)cp2;
			*wp = (WORD) iStructureHP[i];
			cp2 += 2;
		}

		memcpy(cp,cTempData,2*(m_pMapList[iMapIndex]->m_iTotalStrikePoints+1) ) ;

		// v2.15 
		bStockMsgToGateServer(cData, 18 + (m_pMapList[iMapIndex]->m_iTotalStrikePoints+1)*2 );
		
		// ÇöÀç ¼­¹ö¿¡´Â ½ºÅå ¸Ş½ÃÁö°¡ ¿ÀÁö ¾ÊÀ¸¹Ç·Î Á÷Á¢ Àü´ŞÇÑ´Ù.
		// v2.15 °Ç¹°ÀÇ °¹¼ö¿Í HP¸¦ º¸³½´Ù.
		GrandMagicResultHandler(m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure,m_pMapList[iMapIndex]->m_iTotalStrikePoints, cTempData);
	}

	// °á°ú º¸°í¿ë ½ºÆ®·°Ãç Å¬¸®¾î
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;
}

void CGame::_LinkStrikePointMapIndex()
{
 int i, z, x;

	// ¸¶À»°ú °Ç¹° ³»ºÎ¸¦ ´Ù¸¥ ¼­¹ö¿¡ ¶ç¿ì¸é ¸µÅ©°¡ ºÒ°¡´ÉÇÏ¹Ç·Î ´Ù¿îµÈ´Ù!
	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_iTotalStrikePoints != 0)) {
		// ½ºÆ®¶óÀÌÅ© Æ÷ÀÎÆ®°¡ Á¤ÀÇµÈ ¸ÊÀÌ´Ù. °¢°¢ÀÇ ½ºÆ®¶óÀÌÅ© Æ÷ÀÎÆ®¿Í ¿¬°èµÈ ¸ÊÀÇ ÀÎµ¦½º¸¦ ±¸ÇØ ÀúÀåÇÑ´Ù.
		for (z = 0; z < DEF_MAXSTRIKEPOINTS; z++) 
		if (strlen(m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) != 0) {
			for (x = 0; x < DEF_MAXMAPS; x++) 
			if ((m_pMapList[x] != NULL) && (strcmp(m_pMapList[x]->m_cName,m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) == 0)) {
				// ÀÎµ¦½º¸¦ ±¸Çß´Ù. ÀúÀåÇÑ´Ù.
				m_pMapList[i]->m_stStrikePoint[z].iMapIndex = x;
				//testcode
				wsprintf(G_cTxt, "(!) Map(%s) Strike Point(%d) Related Map(%s) Index(%d)", m_pMapList[i]->m_cName, z, m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName, x);
				PutLogList(G_cTxt);

				goto LSPMI_LOOPBREAK;
			}
LSPMI_LOOPBREAK:;
		}
	}
}

BOOL CGame::_bRegisterMap(char * pName) //×¢²áµØÍ¼ĞÅÏ¢
{
 int i;
 char cTmpName[11], cTxt[120];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);
	for (i = 0; i < DEF_MAXMAPS; i++)//±éÀúËùÓĞµØÍ¼£¬ÕÒµ½ºÍm_pMapList[i]Á´±íÖĞÒ»ÑùµÄµØÍ¼ Èç¹ûµØÍ¼ÒÑ¾­´ò¿ª¾Í·µ»Ø¼Ù
	if ((m_pMapList[i] != NULL) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
		wsprintf(cTxt, "(!!!) Ö´ĞĞ´íÎó! µØÍ¼ (%s) ÒÑ¾­´æÔÚ! ²»ĞèÒªÔÙ´Î¼ÓÔØ.", cTmpName);
		PutLogList(cTxt);//Ğ´ÈëÈÕÖ¾
		return FALSE;
	}

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] == NULL) {//Èç¹ûÄÚ·ÅµØÍ¼Á´±íÎª¿Õ£¬¾ÍĞÂ¿ª±ÙÄÚ´æ¿Õ¼ä
		m_pMapList[i] = (class CMap *)new class CMap(this);
		wsprintf(cTxt, "(*) Add map (%s)   - Loading map info files...", pName);
		PutLogList(cTxt);
		if (m_pMapList[i]->bInit(pName) == FALSE) {//³õÊ¼»¯µØÍ¼£¬¶ÁÈ¡µØÍ¼ĞÅÏ¢
			wsprintf(cTxt, "(!!!) ¶ÁÎÄ¼şÊı¾İÊ§°Ü!", pName);
			PutLogList(cTxt);
			return FALSE;	
		};
		
		PutLogList("(*) Êı¾İ¶ÁÈ¡³É¹¦.");
		//²é¿´pNameµØÍ¼ÓëÄÇ¸öµØÍ¼µÄÃû³ÆÒ»Ñù£¬ ¾Í°ÑµØÍ¼Ë÷Òı ¸³ÖµÎªi
		
		if ((m_iMiddlelandMapIndex == -1) && (strcmp("middleland", pName) == 0)) 
			m_iMiddlelandMapIndex = i;

		if ((m_iAresdenMapIndex == -1) && (strcmp("aresden", pName) == 0)) 
			m_iAresdenMapIndex = i;

		if ((m_iElvineMapIndex == -1) && (strcmp("elvine", pName) == 0)) 
			m_iElvineMapIndex = i;

		if ((m_iBTFieldMapIndex == -1) && (strcmp("BtField", pName) == 0)) 
			m_iBTFieldMapIndex = i;

		if ((m_iGodHMapIndex == -1) && (strcmp("GodH", pName) == 0)) 
			m_iGodHMapIndex = i;

		m_iTotalMaps++; //¼ÆËã×Ü¹²¼ÓÔØÁË¶àÉÙ¸öµØÍ¼¡£
		return TRUE;
	}

	wsprintf(cTxt, "(!!!) ´íÎó! µØÍ¼ (%s) ²»ÄÜ±»¼ÓÔØ - Ã»ÓĞ¿Õ¼ä.", pName);
	PutLogList(cTxt);
	return FALSE;
}

//New Changed 11/05/2004
void CGame::GrandMagicResultHandler(char *cMapName, int iCrashedStructureNum, int iStructureDamageAmount, int iCasualities, int iActiveStructure, int iTotalStrikePoints, char * cData)
{
 int i;
	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) {
		SendNotifyMsg(NULL, i, DEF_NOTIFY_GRANDMAGICRESULT, iCrashedStructureNum, iStructureDamageAmount, iCasualities, cMapName, iActiveStructure, NULL, NULL, NULL, NULL, iTotalStrikePoints, cData);
	}
}

void CGame::AdminOrder_CheckStats(int iClientH, char *pData,DWORD dwMsgSize)
{
 char cStatMessage[256];
 char   seps[] = "= \t\n";
 char   cBuff[256];
 class  CStrTok * pStrTok;
 char   * token, cName[11], cTargetName[11];
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
		if ((dwMsgSize)	<= 0) return;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();

		token = pStrTok->pGet();
		
		if (token != NULL) {
			ZeroMemory(cName, sizeof(cName));
			strcpy(cName, token);
		} 
		else {
			ZeroMemory(cName, sizeof(cName));
			strcpy(cName, "null");
		}

		token = pStrTok->pGet();
		
		if (token == NULL) { 
			token = "null"; 
		}
		
			if (cName != NULL) {
			token = cName;

				if (strlen(token) > 10) 
  					memcpy(cTargetName, token, 10);
				else memcpy(cTargetName, token, strlen(token));

				for (i = 1; i < DEF_MAXCLIENTS; i++)
  					if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
						// m_iStr, m_iInt, m_iVit, m_iDex, m_iMag, m_iCharisma
						ZeroMemory(cStatMessage, sizeof(cStatMessage));
						wsprintf(cStatMessage, "Str:%d Dex:%d Vit:%d Int:%d Mag:%d Chr:%d", m_pClientList[i]->m_iStr,  m_pClientList[i]->m_iDex, m_pClientList[i]->m_iVit, m_pClientList[i]->m_iInt,m_pClientList[i]->m_iMag, m_pClientList[i]->m_iCharisma);
						ShowClientMsg(iClientH, cStatMessage);
					}
			}
}

// v2.16 2002-5-21 Â°Ã­Â±Â¤Ã‡Ã¶ ÃƒÃŸÂ°Â¡
BOOL CGame::bCheckIsItemUpgradeSuccess(int iClientH, int iItemIndex, int iSomH, BOOL bBonus)
{
	int iValue, iProb, iResult;

	/*.text:004B46A0               push    ebp
	.text:004B46A1                 mov     ebp, esp
	.text:004B46A3                 sub     esp, 54h
	.text:004B46A6                 push    ebx
	.text:004B46A7                 push    esi
	.text:004B46A8                 push    edi
	.text:004B46A9                 mov     [ebp+m_pClientList], ecx
	.text:004B46AC                 mov     eax, [ebp+iClientH]
	.text:004B46AF                 mov     ecx, [ebp+m_pClientList[]]
	.text:004B46B2                 mov     edx, [ecx+eax*4+16Ch]
	.text:004B46B9                 mov     eax, [ebp+iSomH]
	.text:004B46BC                 cmp     dword ptr [edx+eax*4+m_pItemList[]], 0
	.text:004B46C4                 jnz     short loc_4B46CD
	.text:004B46C6                 xor     eax, eax
	.text:004B46C8                 jmp     loc_4B48D1*/
	if (m_pClientList[iClientH]->m_pItemList[iSomH] == NULL) return FALSE;

	/*.text:004B46CD               mov     ecx, [ebp+iClientH]
	.text:004B46D0                 mov     edx, [ebp+m_pClientList]
	.text:004B46D3                 mov     eax, [edx+ecx*4+16Ch]
	.text:004B46DA                 mov     ecx, [ebp+iItemIndex]
	.text:004B46DD                 mov     edx, [eax+ecx*4+m_pItemList]
	.text:004B46E4                 mov     eax, [edx+m_dwAttribute]
	.text:004B46E7                 and     eax, 0F0000000h
	.text:004B46EC                 shr     eax, 1Ch // 28
	.text:004B46EF                 mov     [ebp+iValue], eax*/
	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x0F0000000) >> 28;

	switch (iValue) {
	case 0: iProb = 30; break;  // +1 :90%     +1~+2
	case 1: iProb = 25; break;  // +2 :80%      +3
	case 2: iProb = 20; break;  // +3 :48%      +4 
	case 3: iProb = 15; break;  // +4 :24%      +5
	case 4: iProb = 10; break;  // +5 :9.6%     +6
	case 5: iProb = 10; break;  // +6 :2.8%     +7
	case 6: iProb =  8; break;  // +7 :0.57%    +8
	case 7: iProb =  8; break;  // +8 :0.05%    +9
	case 8: iProb =  5; break;  // +9 :0.004%   +10
	case 9: iProb =  3; break;  // +10:0.00016%
	default: iProb = 1; break;
	}

	if (((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) && (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 > 100)) {	
		if (iProb > 20) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 10);
		else if (iProb > 7) 
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 20);
		else
			iProb += (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 / 40);
	}
	if ( bBonus == TRUE) iProb *=2 ;

	iProb *= 100;
	iResult = iDice(1,10000);

	if (iProb >= iResult) { 
		_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
		return TRUE;
	}

	_bItemLog(DEF_ITEMLOG_UPGRADEFAIL, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

	return FALSE;
}

BOOL CGame::bReadAdminListConfigFile(char *pFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;
 char len;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == NULL) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀĞÀ» ¼ö ¾ø´Ù.
		PutLogList("(!) Cannot open AdminList.cfg file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading AdminList.cfg...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
						if (iIndex >= DEF_MAXADMINS) {
							PutLogList("(!) WARNING! Too many GMs on the AdminList.cfg!"); 
							return TRUE;
						}
						len = strlen(token);
						if(len > 10) len = 10;
						ZeroMemory(m_stAdminList[iIndex].m_cGMName, sizeof(m_stAdminList[iIndex].m_cGMName));
						memcpy(m_stAdminList[iIndex].m_cGMName, token, strlen(token));
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
				}
			}
			else {
				if (memcmp(token, "verified-admin", 14) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

BOOL CGame::bReadBannedListConfigFile(char *pFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;
 int   iIndex;
 char len;

	cReadModeA = 0;
	cReadModeB = 0;
	iIndex = 0;

	hFile = CreateFile(pFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(pFn, "rt");
	if (pFile == NULL) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀĞÀ» ¼ö ¾ø´Ù.
		PutLogList("(!) Cannot open BannedList.cfg file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading BannedList.cfg...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
						if (iIndex >= DEF_MAXBANNED) {
							PutLogList("(!) WARNING! Too many banned on the BannedList.cfg!"); 
							return TRUE;
						}
						len = strlen(token);
						if(len > 20) len = 20;
						ZeroMemory(m_stBannedList[iIndex].m_cBannedIPaddress, sizeof(m_stBannedList[iIndex].m_cBannedIPaddress));
						memcpy(m_stBannedList[iIndex].m_cBannedIPaddress, token, strlen(token));
						iIndex++;
						cReadModeA = 0;
						cReadModeB = 0;
						break;
				}
			}
			else {
				if (memcmp(token, "banned-ip", 9) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			}
			
			token = pStrTok->pGet();
		}
		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CGame::AdminOrder_CleanMap(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	class  CStrTok * pStrTok;
	char   * token, cMapName[11], cBuff[256];
	BOOL bFlag = FALSE;	//Used to check if we are on the map we wanna clear
	int i;
	CItem *pItem;
	short sRemainItemSprite, sRemainItemSpriteFrame, dX, dY;
	char cRemainItemColor, len;


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < m_iAdminLevelCleanMap) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);

		for (i = 0; i < DEF_MAXMAPS; i++)	//Enum all maps
			if (m_pMapList[i] != NULL) {	//Is allocated map
				if (memcmp(m_pMapList[i]->m_cName, cMapName, 10) == 0) {	//is map same name
					bFlag = TRUE; //Set flag
					//Get X and Y coords
					int m_x = m_pMapList[i]->m_sSizeX;
					int m_y = m_pMapList[i]->m_sSizeY;
					for(int j = 1; j < m_x; j++)
						for(int k = 1; k < m_y; k++){
							do {	//Delete all items on current tile
								pItem = m_pMapList[i]->pGetItem(j, k, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); // v1.4
								if (pItem != NULL) {
									delete pItem;	//Delete item;
								}
							} while(pItem != NULL);
						}
					break;	//Break outo f loop
				}
			}

		if (!bFlag) {	//Notify GM he has to be on the map he clears
		}
		else{	//Notify GM that all items have been cleared
			for(int i = 1; i < DEF_MAXCLIENTS; i++){
				if (m_pClientList[i] != NULL) {
				len = strlen(cMapName);
				if(len > 10) len = 10;
				if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cMapName, len) != 0) return;
				dX = m_pClientList[i]->m_sX;
				dY = m_pClientList[i]->m_sY;
				ZeroMemory(cMapName,sizeof(cMapName));
				strcpy(cMapName, m_pClientList[i]->m_cMapName);
				RequestTeleportHandler(i,"2   ", cMapName, dX, dY);
				}
			}
		}
	}

	delete pStrTok;
	return;
}

void CGame::ShowClientMsg(int iClientH, char* pMsg)
{
	char * cp, cTemp[256];
	DWORD * dwp, dwMsgSize;
	WORD * wp;
	short * sp;

	ZeroMemory(cTemp, sizeof(cTemp));

	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;

	wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	memcpy(cp, "HGServer", 8); // Player name :P
	cp += 10;

	*cp = 10; // chat type
	cp++;

	dwMsgSize = strlen(pMsg);
	if(dwMsgSize > 50) dwMsgSize = 50;
	memcpy(cp, pMsg, dwMsgSize);
	cp += dwMsgSize;

	m_pClientList[iClientH]->m_pXSock->iSendMsg(cTemp, dwMsgSize + 22);
}

void CGame::Command_YellowBall(int iClientH, char* pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cPlayerName[11],cMapName[32];
	class  CStrTok * pStrTok;
	char *cp;
	WORD *wp;
	int iSoxH, iSoX, i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	iSoX = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
		case 653: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
		}
	}
	if (iSoX > 0) {	
		
		ZeroMemory(cPlayerName, sizeof(cPlayerName));
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();

		token = pStrTok->pGet();
		if (token == NULL) {
			delete pStrTok;
			return;
		}

		if (strlen(token) > 10) {
			memcpy(cPlayerName,token,10);
		}
		else{
			memcpy(cPlayerName,token,strlen(token));
		}

		for(int i = 1; i < DEF_MAXCLIENTS; i++){
			if (m_pClientList[i] != NULL) {
				if (memcmp(cPlayerName,m_pClientList[i]->m_cCharName,10) == 0) {
					if ((m_pClientList[iClientH]->m_cLocation) != (m_pClientList[i]->m_cLocation)) return;
					ZeroMemory(cMapName,sizeof(cMapName));
					strcpy(cMapName, m_pClientList[i]->m_cMapName);
					wsprintf(G_cTxt, "(%s) Player: (%s) - YellowBall MapName(%s)(%d %d)", m_pClientList[i]->m_cIPaddress, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cMapName,m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
					PutItemLogFileList(G_cTxt);
					ItemDepleteHandler(iClientH, iSoxH, TRUE);
					RequestTeleportHandler(iClientH,"2   ", cMapName, m_pClientList[i]->m_sX,m_pClientList[i]->m_sY);
					delete pStrTok;
					return;
				}
			}
		}
		m_pClientList[iClientH]->m_bIsAdminOrderGoto = TRUE;

		ZeroMemory(cBuff,sizeof(cBuff));
		
		cp = (char *)cBuff;
		*cp = GSM_REQUEST_FINDCHARACTER;
		cp++;

		wp = (WORD *)cp;
		*wp = m_wServerID_GSS;
		cp += 2;

		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;

		memcpy(cp,cPlayerName,10);
		cp += 10;

		memcpy(cp,m_pClientList[iClientH]->m_cCharName,10);
		cp += 10;

		bStockMsgToGateServer(cBuff,25);

		delete pStrTok;
	}
}

void CGame::Command_RedBall(int iClientH, char *pData,DWORD dwMsgSize)
{
 char seps[] = "= \t\n", cName[21], cNpcName[21], cNpcWaypoint[11];	
 register int iNamingValue, tX, tY, i, x, iNpcID;
 int iSoxH, iSoX;
    
	if (m_pClientList[iClientH] == NULL) return;
	if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone1", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone2", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone3", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone4", 9) != 0)) return;
		     
	    iSoX = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
			case 652: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
			}
		}
		if (iSoX > 0) {			
			iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
		
			}
			else {
		
				ZeroMemory(cNpcName, sizeof(cNpcName));
				switch (iDice(1,5)) {
					case 1: strcpy(cNpcName, "Wyvern"); iNpcID = 66; break; 
					case 2: strcpy(cNpcName, "Hellclaw"); iNpcID = 49; break;
					case 3: strcpy(cNpcName, "Demon");  iNpcID = 31; break;
					case 4: strcpy(cNpcName, "Tigerworm"); iNpcID = 50; break;
					case 5: strcpy(cNpcName, "Gagoyle"); iNpcID = 52; break;
				}
				ZeroMemory(cName, sizeof(cName));
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;

				ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

				tX = (int)m_pClientList[iClientH]->m_sX;
				tY = (int)m_pClientList[iClientH]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
					DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					wsprintf(G_cTxt, "(%s) Player: (%s) - RedBall used %s [%s(%d, %d)] ", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, cNpcName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, tX, tY );
					PutItemLogFileList(G_cTxt);
				}
			}

		for (x = 1; x < DEF_MAXCLIENTS; x++)
		if ((m_pClientList[x] != NULL) && (m_pClientList[x]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, x, DEF_NOTIFY_SPAWNEVENT, tX, tY, iNpcID, NULL, NULL, NULL);
		}
		ItemDepleteHandler(iClientH, iSoxH, TRUE);
		}
}

void CGame::Command_BlueBall(int iClientH, char *pData,DWORD dwMsgSize)

{
 char seps[] = "= \t\n";
 char   cName_Master[10], cName_Slave[10], cNpcName[256], cWaypoint[11], cSA; 
 int    pX, pY, j, iNum, iNamingValue, iNpcID;
 register int i, x;
 BOOL   bMaster;
 int iSoxH, iSoX;
    
	if (m_pClientList[iClientH] == NULL) return;
	if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone1", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone2", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone3", 9) != 0) &&
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "huntzone4", 9) != 0)) return;

		     
	    iSoX = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
			switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
			case 654: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
			}
		}
		if (iSoX > 0) {			
			iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
		
			}
			else {
		
				ZeroMemory(cNpcName, sizeof(cNpcName));

				switch (iDice(1,38)) {
					case 1: strcpy(cNpcName, "Slime");			iNpcID = 10; break;
					case 2: strcpy(cNpcName, "Giant-Ant");		iNpcID = 15; break;
					case 3: strcpy(cNpcName, "Zombie");			iNpcID = 17; break;
					case 4: strcpy(cNpcName, "Scorpion");		iNpcID = 16; break;
					case 5: strcpy(cNpcName, "Skeleton");		iNpcID = 11; break;
					case 6: strcpy(cNpcName, "Orc-Mage");		iNpcID = 14; break;
					case 7: strcpy(cNpcName, "Clay-Golem");		iNpcID = 23; break;
					case 8: strcpy(cNpcName, "Stone-Golem");	iNpcID = 12; break;
					case 9: strcpy(cNpcName, "Hellbound");		iNpcID = 27; break;
					case 10: strcpy(cNpcName, "Giant-Frog");	iNpcID = 57; break;
					case 11: strcpy(cNpcName, "Troll");			iNpcID = 28; break;
					case 12: strcpy(cNpcName, "Cyclops");		iNpcID = 13; break;
					case 13: strcpy(cNpcName, "Ice-Golem");		iNpcID = 65; break;
					case 14: strcpy(cNpcName, "Beholder");		iNpcID = 53; break;
					case 15: strcpy(cNpcName, "Cannibal-Plant");iNpcID = 60; break;
					case 16: strcpy(cNpcName, "Orge");			iNpcID = 29; break;
			        case 17: strcpy(cNpcName, "Mountain-Giant");iNpcID = 58; break;
                    case 18: strcpy(cNpcName, "DireBoar");		iNpcID = 62; break;
			        case 19: strcpy(cNpcName, "Liche");			iNpcID = 30; break;
				    case 20: strcpy(cNpcName, "Stalker");		iNpcID = 48; break;
                    case 21: strcpy(cNpcName, "WereWolf");		iNpcID = 33; break;
				    case 22: strcpy(cNpcName, "Dark-Elf");		iNpcID = 54; break;
				    case 23: strcpy(cNpcName, "Frost");			iNpcID = 63; break;
					case 24: strcpy(cNpcName, "Orc");			iNpcID = 14; break;
					case 25: strcpy(cNpcName, "Ettin");			iNpcID = 59; break;
					case 26: strcpy(cNpcName, "Tentocle");		iNpcID = -1; break;
					case 27: strcpy(cNpcName, "Giant-Crayfish");iNpcID = -1; break;
					case 28: strcpy(cNpcName, "Giant-Plant");	iNpcID = -1; break;
					case 29: strcpy(cNpcName, "Rudolph");		iNpcID = -1; break;
					case 30: strcpy(cNpcName, "Claw-Turtle");	iNpcID = -1; break;
					case 31: strcpy(cNpcName, "Centaurus");		iNpcID = -1; break;
					case 32: strcpy(cNpcName, "Barlog");		iNpcID = -1; break;
					case 33: strcpy(cNpcName, "Giant-Lizard");	iNpcID = -1; break;
					case 34: strcpy(cNpcName, "MasterMage-Orc");iNpcID = -1; break;
					case 35: strcpy(cNpcName, "Minotaurs");		iNpcID = -1; break;
					case 36: strcpy(cNpcName, "Unicorn");		iNpcID = -1; break;
					case 37: strcpy(cNpcName, "Nizie");			iNpcID = -1; break;
				}

				iNum = 10;
	cSA = 0;
	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;

	/*ZeroMemory(cBallMessage, sizeof(cBallMessage));
	wsprintf(cBallMessage, "BlueBall event-%s %s(%d,%d)", cNpcName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, pX, pY);

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[iClientH]->m_cLocation) == (m_pClientList[i]->m_cLocation))
			ShowClientMsg(i, cBallMessage);*/

	wsprintf(G_cTxt, "(!) BlueBallEvent: SummonMob (%s)-(%d)", cNpcName, iNum);
	PutLogList(G_cTxt);

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
	if (iNamingValue != -1) {
	
		ZeroMemory(cName_Master, sizeof(cName_Master));
		wsprintf(cName_Master, "XX%d", iNamingValue);
		cName_Master[0] = '_';
		cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
		if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE, TRUE)) == FALSE) {
		
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
	}		

	for (j = 0; j < (iNum - 1); j++) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// Slave Mob
			ZeroMemory(cName_Slave, sizeof(cName_Slave));
			wsprintf(cName_Slave, "XX%d", iNamingValue);
			cName_Slave[0] = '_';
			cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
		
				
			if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE) == FALSE) {
		
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				// Slave
				bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
			}
		}
	}

	//delete pStrTok;

				}
			}

		for (x = 1; x < DEF_MAXCLIENTS; x++)
		if ((m_pClientList[x] != NULL) && (m_pClientList[x]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, x, DEF_NOTIFY_SPAWNEVENT, pX, pY, iNpcID, NULL, NULL, NULL);
		}
		ItemDepleteHandler(iClientH, iSoxH, TRUE);
}

/*
at the end of client connection have a true switch
at the start of client move handler check if the switch is true
if it is not true add 1 warning, if the warning reaches 3
delete client and log him, if the true switch
*/
//and when a client walks into a map with dynamic portal
//[KLKS] - [Pretty Good Coders] says:
//u gotta inform it
//[KLKS] - [Pretty Good Coders] says:
//or else they wont see it

/*void CGame::OpenApocalypseGate(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	//m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAliveObject;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_APOCGATEOPEN, 95, 31, NULL, m_pClientList[iClientH]->m_cMapName);
}*/

void CGame::GlobalEndApocalypseMode()
{
 char * cp, cData[120];

	if (m_bIsApocalypseMode == FALSE) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_ENDAPOCALYPSE;
	cp++;
	
	LocalEndApocalypse();

	bStockMsgToGateServer(cData, 5);
}

void CGame::GlobalUpdateConfigs(char cConfigType)
{
 char * cp, cData[120];

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_UPDATECONFIGS;
	cp++;

	*cp = (char)cConfigType;
	cp++;			

	LocalUpdateConfigs(cConfigType);

	bStockMsgToGateServer(cData, 5);
}

void CGame::LocalUpdateConfigs(char cConfigType)
{
	if (cConfigType == 1) {
		bReadSettingsConfigFile("..\\GameConfigs\\Settings.cfg");
		PutLogList("(!!!) Settings.cfg updated successfully!");
	}
	if (cConfigType == 2) {
		bReadAdminListConfigFile("..\\GameConfigs\\AdminList.cfg");
		PutLogList("(!!!) AdminList.cfg updated successfully!");
	}
	if (cConfigType == 3) {
		bReadBannedListConfigFile("..\\GameConfigs\\BannedList.cfg");
		PutLogList("(!!!) BannedList.cfg updated successfully!");
	}
	if (cConfigType == 4) {
		bReadAdminSetConfigFile("..\\GameConfigs\\AdminSettings.cfg");
		PutLogList("(!!!) AdminSettings.cfg updated successfully!");
	}
}

void CGame::LocalEndApocalypse()
{
 int i;
	
	m_bIsApocalypseMode = FALSE;

	for (i = 1; i < DEF_MAXCLIENTS; i++) {
	if (m_pClientList[i] != NULL) {		
			SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATEENDMSG, NULL, NULL, NULL, NULL);
		}
	}
	wsprintf(G_cTxt,"(!)Apocalypse Mode OFF.");
	PutLogList(G_cTxt);
}

void CGame::LocalStartApocalypse(DWORD dwApocalypseGUID)
{
 int i;
 //DWORD dwApocalypse;

	m_bIsApocalypseMode = TRUE;

	if (dwApocalypseGUID != NULL) {
		_CreateApocalypseGUID(dwApocalypseGUID);
		//m_dwApocalypseGUID = dwApocalypse;
	}

	for (i = 1; i < DEF_MAXCLIENTS; i++) {
	if (m_pClientList[i] != NULL) {		
			SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCGATESTARTMSG, NULL, NULL, NULL, NULL);		
			//RequestTeleportHandler(i, "0   ");
			//SendNotifyMsg(NULL, i, DEF_NOTIFY_APOCFORCERECALLPLAYERS, NULL, NULL, NULL, NULL);
		}
	}
	wsprintf(G_cTxt,"(!)Apocalypse Mode ON.");
	PutLogList(G_cTxt);
}

BOOL CGame::bReadApocalypseGUIDFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶Ã€Ã‡ ÃƒÃŠÂ±Ã¢ÃˆÂ­ Ã†Ã„Ã€ÃÃ€Â» Ã€ÃÃ€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.
		PutLogList("(!) Cannot open ApocalypseGUID file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading ApocalypseGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwApocalypseGUID = atoi(token);
					wsprintf(G_cTxt, "ApocalypseGUID = %d", m_dwApocalypseGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "ApocalypseGUID", 14) == 0) cReadMode = 1;
			}
			
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

BOOL CGame::bReadHeldenianGUIDFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// Â°Ã”Ã€Ã“Â¼Â­Â¹Ã¶Ã€Ã‡ ÃƒÃŠÂ±Ã¢ÃˆÂ­ Ã†Ã„Ã€ÃÃ€Â» Ã€ÃÃ€Â» Â¼Ã¶ Â¾Ã¸Â´Ã™.
		PutLogList("(!) Cannot open HeldenianGUID file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading HeldenianGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwHeldenianGUID = atoi(token);
					wsprintf(G_cTxt, "HeldenianGUID = %d", m_dwHeldenianGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				case 2:
					m_sLastHeldenianWinner = atoi(token);
					wsprintf(G_cTxt, "HeldenianWinnerSide = %d", m_sLastHeldenianWinner);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "HeldenianGUID", 13) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}
			
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}

void CGame::_CreateApocalypseGUID(DWORD dwApocalypseGUID)
{
 char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;
		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));
	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"ApocalypseGUID.Txt");
		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		// Ã†Ã„Ã€ÃÃ€Â» Â¸Â¸ÂµÃ© Â¼Ã¶ Â¾Ã¸Â°Ã…Â³Âª Â»Ã§Ã€ÃŒÃÃ®Â°Â¡ ÃÃ¶Â³ÂªÃ„Â¡Â°Ã” Ã€Ã›Ã€Âº Â°Ã¦Â¿Ã¬Â´Ã‚ . 
		wsprintf(cTxt, "(!) Cannot create ApocalypseGUID(%d) file", dwApocalypseGUID);
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));
		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "ApocalypseGUID = %d\n", dwApocalypseGUID);
		strcat(cTemp, cTxt);
		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		
		wsprintf(cTxt, "(O) ApocalypseGUID(%d) file created", dwApocalypseGUID);
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}

/*void CGame::ApocalypseStarter()
{
 SYSTEMTIME SysTime;
 int i;

	if (m_bIsApocalypseMode == TRUE) return;
	if (m_bIsApocalypseStarter == FALSE) return;

	GetLocalTime(&SysTime);
	
	for (i = 0; i < DEF_MAXAPOCALYPSE; i++)
	if	((m_stApocalypseScheduleStart[i].iDay == SysTime.wDayOfWeek) && 
		(m_stApocalypseScheduleStart[i].iHour == SysTime.wHour) && 
		(m_stApocalypseScheduleStart[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated apocalypse is initiated!");
			GlobalStartApocalypseMode();
			return;
	}
}*/

void CGame::ApocalypseEnder()
{
 SYSTEMTIME SysTime;
 int i;

	if (m_bIsApocalypseMode == FALSE) return;
	if (m_bIsApocalypseStarter == FALSE) return;

	GetLocalTime(&SysTime);
	
	for (i = 0; i < DEF_MAXAPOCALYPSE; i++)
	if	((m_stApocalypseScheduleEnd[i].iDay == SysTime.wDayOfWeek) && 
		(m_stApocalypseScheduleEnd[i].iHour == SysTime.wHour) && 
		(m_stApocalypseScheduleEnd[i].iMinute == SysTime.wMinute)) {
			PutLogList("(!) Automated apocalypse is concluded!");
			GlobalEndApocalypseMode();
			return;
	}
}	

// New 06/05/2004
// Party Code
void CGame::RequestCreatePartyHandler(int iClientH)
{
	char *cp, cData[120];
	DWORD * dwp;
	WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) {
		// Ã†Ã„Ã†Â¼ Â»Ã³Ã…Ã‚Â°Â¡ Ã€ÃŒÂ¹ÃŒ ÃÂ¸Ã€Ã§Ã‡ÃÂ¸Ã© Ã†Ã„Ã†Â¼Â¸Â¦ Â¸Â¸ÂµÃ© Â¼Ã¶ Â¾Ã¸Â´Ã™.
		return;
	}

	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;

	// Gate ServerÂ¿Â¡ Ã†Ã„Ã†Â¼ Â»Ã½Â¼ÂºÃˆÃ„ PartyIDÂ¸Â¦ Â¾Ã‹Â·ÃÃÃ™ Â°ÃÃ€Â» Â¿Ã¤ÃƒÂ»Ã‡Ã‘Â´Ã™. 
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;

	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 1; // 1, request
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;

	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

	//testcode
	wsprintf(G_cTxt, "Request Create Party: %d", iClientH);
	PutLogList(G_cTxt);
}

// Last Updated October 28, 2004 - 3.51 translation
void CGame::PartyOperationResultHandler(char *pData)
{
	char * cp, cResult, cName[12];
	WORD * wp;
	int i, iClientH, iPartyID, iTotal;

	cp = (char *)(pData + 4);
	wp = (WORD *)cp;
	cp += 2;

	switch (*wp) {
	case 1:
		cResult = *cp;
		cp++;

		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Create(iClientH, cName, cResult, iPartyID);

		wsprintf(G_cTxt, "party Operation Result: Create(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;

	case 2:
		wp = (WORD *)cp;
		iPartyID = *wp;
		cp += 2;

		PartyOperationResult_Delete(iPartyID);

		wsprintf(G_cTxt, "party Operation Result: Delete(PartyID:%d)", iPartyID);
		PutLogList(G_cTxt);
		break;

	case 3:
		wp = (WORD *)cp;
		iClientH = *wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		if ((iClientH < 0) && (iClientH > DEF_MAXCLIENTS)) return;
		if (m_pClientList[iClientH] == NULL) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, cName) != 0) return;

		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == iClientH) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = 0;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers--;

				wsprintf(G_cTxt, "PartyID:%d member:%d Out(Clear) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORH_LOOPBREAK1;
			}
PORH_LOOPBREAK1:;

				for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
				if ((m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) && (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] != 0)) {
					m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i]   = m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1];
					m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i+1] = 0;
				}

				m_pClientList[iClientH]->m_iPartyID = NULL;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;

				wsprintf(G_cTxt, "Party Status NULL: %s", m_pClientList[iClientH]->m_cCharName);
				PutLogList(G_cTxt);

				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 8, 0, NULL, NULL);
				break;

	case 4:
		cResult = *cp;
		cp++;

		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Join(iClientH, cName, cResult, iPartyID);

		wsprintf(G_cTxt, "party Operation Result: Join(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;

	case 5:
		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iTotal = (int)*wp;
		cp += 2;

		PartyOperationResult_Info(iClientH, cName, iTotal, cp);

		wsprintf(G_cTxt, "party Operation Result: Info(ClientH:%d Total:%d)", iClientH, iTotal);
		PutLogList(G_cTxt);
		break;

	case 6:
		cResult = *cp;
		cp++;

		wp = (WORD *)cp;
		iClientH = (int)*wp;
		cp += 2;

		ZeroMemory(cName, sizeof(cName));
		memcpy(cName, cp, 10);
		cp += 10;

		wp = (WORD *)cp;
		iPartyID = (int)*wp;
		cp += 2;

		PartyOperationResult_Dismiss(iClientH, cName, cResult, iPartyID);

		wsprintf(G_cTxt, "party Operation Result: Dismiss(ClientH:%d PartyID:%d)", iClientH, iPartyID);
		PutLogList(G_cTxt);
		break;
	}
}


void CGame::PartyOperationResult_Create(int iClientH, char *pName, int iResult, int iPartyID)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD * wp;
	int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

	switch (iResult) {
	case 0: // Ã†Ã„Ã†Â¼ Â»Ã½Â¼Âº Â½Ã‡Ã†Ã 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 1, 0, NULL, NULL);
		break;

	case 1: // Ã†Ã„Ã†Â¼ Â»Ã½Â¼Âº Â¼ÂºÂ°Ã¸ 
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 1, 1, NULL, NULL);

		// Â°Ã”Ã€Ã“ Â¼Â­Â¹Ã¶Ã€Ã‡ Ã†Ã„Ã†Â¼ Â¸Â®Â½ÂºÃ†Â®Â¿Â¡ ÂµÃ®Â·Ã.
		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;
				//testcode
				wsprintf(G_cTxt, "PartyID:%d member:%d New Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORC_LOOPBREAK1;
			}
PORC_LOOPBREAK1:;

			// Â¸Â¸Â¾Ã  Ã†Ã„Ã†Â¼ Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡Ã‘ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Ã€Ã–Â´Ã™Â¸Ã© 
			if ((m_pClientList[iClientH]->m_iReqJoinPartyClientH != NULL) && (strlen(m_pClientList[iClientH]->m_cReqJoinPartyName) != NULL)) {
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				dwp = (DWORD *)cp;
				*dwp = MSGID_PARTYOPERATION;
				cp += 4;
				wp = (WORD*)cp;
				*wp = 3; // Ã†Ã„Ã†Â¼ Â¸Ã¢Â¹Ã¶ ÃƒÃŸÂ°Â¡ Â¿Ã¤ÃƒÂ»
				cp += 2;
				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
				cp += 2;
				memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
				cp += 10;
				wp = (WORD *)cp;
				*wp = m_pClientList[iClientH]->m_iPartyID;
				cp += 2;
				SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
				// Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ ÂºÂ¸Â³Ã‚Ã€Â¸Â´Ã Ã…Â¬Â¸Â®Â¾Ã®
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
				ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
			}
			break;
	}
}

// Last Updated October 28, 2004 - 3.51 translation
void CGame::PartyOperationResult_Join(int iClientH, char *pName, int iResult, int iPartyID)
{
	int i;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iResult) {
	case 0:
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = NULL;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 4, 0, NULL, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1:
		if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) return;
		if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;

		m_pClientList[iClientH]->m_iPartyID = iPartyID;
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_CONFIRM;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 4, 1, NULL, pName);

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));

		for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
			if (m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] == 0) {
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iIndex[i] = iClientH;
				m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers++;

				wsprintf(G_cTxt, "PartyID:%d member:%d In(Join) Total:%d", m_pClientList[iClientH]->m_iPartyID, iClientH, m_stPartyInfo[m_pClientList[iClientH]->m_iPartyID].iTotalMembers);
				PutLogList(G_cTxt);
				goto PORC_LOOPBREAK1;
			}
PORC_LOOPBREAK1:;

			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((i != iClientH) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 4, 1, NULL, pName);
				}
				break;
	}
}

void CGame::PartyOperationResult_Dismiss(int iClientH, char *pName, int iResult, int iPartyID)
{
	int i;
	// iClientHÂ´Ã‚ Ã€ÃŒÂ¹ÃŒ Â»Ã§Â¶Ã³ÃÃ¶Â°Ã­ Â¾Ã¸Â´Ã‚ Ã„Â³Â¸Â¯Ã…ÃÃ€ÃÂ¼Ã¶ÂµÂµ Ã€Ã–Â´Ã™.

	switch (iResult) {
	case 0: // Ã†Ã„Ã†Â¼ Ã…Â»Ã…Ã° Â½Ã‡Ã†Ã ? Ã€ÃŒÂ·Â± Ã€ÃÃ€ÃŒ?
		break;

	case 1: // Ã†Ã„Ã†Â¼ Ã…Â»Ã…Ã° Â¼ÂºÂ°Ã¸ 
		if (iClientH == NULL) {
			// iClientH Â°Â¡ NULLÃ€ÃŒÂ¸Ã© Â¼Â­Â¹Ã¶ Ã€ÃŒÂµÂ¿ÃÃŸ ÃÂ¢Â¼Ã“ ÃÂ¾Â·Ã¡ÂµÃ‡Â¾Ã® Â°Â­ÃÂ¦ ÃÂ¦Â°Ã… Â¿Ã¤ÃƒÂ»ÂµÃˆ Â°ÃÃ€Ã“.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
					iClientH = i;
					goto PORD_LOOPBREAK;
				}
PORD_LOOPBREAK:;

				// Â°Ã”Ã€Ã“ Â¼Â­Â¹Ã¶Ã€Ã‡ Ã†Ã„Ã†Â¼ Â¸Â®Â½ÂºÃ†Â®Â¿Â¡Â¼Â­ Ã‡Ã˜ÃÂ¦.
				for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
					if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
						m_stPartyInfo[iPartyID].iIndex[i] = 0;
						m_stPartyInfo[iPartyID].iTotalMembers--;
						//testcode
						wsprintf(G_cTxt, "PartyID:%d member:%d Out Total:%d", iPartyID, iClientH, m_stPartyInfo[iPartyID].iTotalMembers);
						PutLogList(G_cTxt);
						goto PORC_LOOPBREAK1;
					}
PORC_LOOPBREAK1:;
					// Â¸Â®Â½ÂºÃ†Â® Ã€ÃÂµÂ¦Â½ÂºÃ€Ã‡ ÂºÃ³Â°Ã¸Â°Â£Ã€Â» ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
					for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
						if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) {
							m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
							m_stPartyInfo[iPartyID].iIndex[i+1] = 0;
						}

						if (m_pClientList[iClientH] != NULL) {
							m_pClientList[iClientH]->m_iPartyID = NULL;
							m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
							m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
						}

						// Â¸Ã°ÂµÃ§ Ã†Ã„Ã†Â¼Â¿Ã¸ÂµÃ©Â¿Â¡Â°Ã” Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
						for (i = 1; i < DEF_MAXCLIENTS; i++)
							if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
								SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 6, 1, NULL, pName);
							}
							return;
		}

		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING)) return;
		if ((m_pClientList[iClientH] != NULL) && (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0)) return;

		// Â¸Ã°ÂµÃ§ Ã†Ã„Ã†Â¼Â¿Ã¸ÂµÃ©Â¿Â¡Â°Ã” Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 6, 1, NULL, pName);
			}

			// Â°Ã”Ã€Ã“ Â¼Â­Â¹Ã¶Ã€Ã‡ Ã†Ã„Ã†Â¼ Â¸Â®Â½ÂºÃ†Â®Â¿Â¡Â¼Â­ Ã‡Ã˜ÃÂ¦.
			for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
				if (m_stPartyInfo[iPartyID].iIndex[i] == iClientH) {
					m_stPartyInfo[iPartyID].iIndex[i] = 0;
					m_stPartyInfo[iPartyID].iTotalMembers--;
					//testcode
					wsprintf(G_cTxt, "PartyID:%d member:%d Out Total:%d", iPartyID, iClientH, m_stPartyInfo[iPartyID].iTotalMembers);
					PutLogList(G_cTxt);
					goto PORC_LOOPBREAK2;
				}
PORC_LOOPBREAK2:;
				// Â¸Â®Â½ÂºÃ†Â® Ã€ÃÂµÂ¦Â½ÂºÃ€Ã‡ ÂºÃ³Â°Ã¸Â°Â£Ã€Â» ÃÂ¦Â°Ã…Ã‡Ã‘Â´Ã™.
				for (i = 0; i < DEF_MAXPARTYMEMBERS-1; i++)
					if ((m_stPartyInfo[iPartyID].iIndex[i] == 0) && (m_stPartyInfo[iPartyID].iIndex[i+1] != 0)) {
						m_stPartyInfo[iPartyID].iIndex[i]   = m_stPartyInfo[iPartyID].iIndex[i+1];
						m_stPartyInfo[iPartyID].iIndex[i+1] = 0;
					}

					if (m_pClientList[iClientH] != NULL) {
						m_pClientList[iClientH]->m_iPartyID = NULL;
						m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
						m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
					}
					break;
	}
}

void CGame::PartyOperationResult_Delete(int iPartyID)
{
	int i;

	for (i = 0; i < DEF_MAXPARTYMEMBERS; i++)
	{
		m_stPartyInfo[iPartyID].iIndex[i] = 0;
		m_stPartyInfo[iPartyID].iTotalMembers = 0;
	}

	// Ã†Ã„Ã†Â¼ Ã‡Ã˜Â»ÃªÂµÃŠ 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iPartyID == iPartyID)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PARTY, 2, 0, NULL, NULL);
			m_pClientList[i]->m_iPartyID = NULL;
			m_pClientList[i]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
			m_pClientList[i]->m_iReqJoinPartyClientH = NULL;
			//testcode
			wsprintf(G_cTxt, "Notify delete party: %d", i);
			PutLogList(G_cTxt);
		}
}



void CGame::RequestJoinPartyHandler(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * cp, * token, cBuff[256], cData[120], cName[12];
	class  CStrTok * pStrTok;
	DWORD * dwp;
	WORD  * wp;
	int i;

	// Ã†Ã„Ã†Â¼ Â°Â¡Ã€Ã” Â¿Â©ÂºÃÂ¸Â¦ Â¹Â¯Â°Ã­ Ã€Ã–Â´Ã™.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if ((m_bAdminSecurity == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();

	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	}
	else return;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, cName) == 0)) {
			// Â°Ã”Ã€ÃŒÃ†Â® Â¼Â­Â¹Ã¶Â·Ã Ã†Ã„Ã†Â¼ Â¸Ã¢Â¹Ã¶ Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡Ã‘Â´Ã™.
			if ((m_pClientList[i]->m_iPartyID == NULL) || (m_pClientList[i]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM)) {
				// Ã†Ã„Ã†Â¼Â¿Â¡ Â°Â¡Ã€Ã”Ã‡ÃÂ°Ã­Ã€Ãš Ã‡Ã‘ Ã„Â³Â¸Â¯Ã…ÃÂ°Â¡ Ã†Ã„Ã†Â¼ Â¸Â¶Â½ÂºÃ…ÃÂ°Â¡ Â¾Ã†Â´ÃÂ´Ã™.
				return;
			}

			ZeroMemory(cData, sizeof(cData));
			
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; // Ã†Ã„Ã†Â¼ Â¸Ã¢Â¹Ã¶ ÃƒÃŸÂ°Â¡ Â¿Ã¤ÃƒÂ»
			cp += 2;
			wp = (WORD *)cp;
			*wp = iClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[i]->m_iPartyID;
			cp += 2;
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
			return;
		}

		// Â°Â¡Ã€Ã”Ã‡ÃÂ°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Ã†Ã„Ã†Â¼ Â¸Â¶Â½ÂºÃ…ÃÂ°Â¡ Ã‡Ã¶Ã€Ã§ Â¼Â­Â¹Ã¶Â¿Â¡ ÃÂ¸Ã€Ã§Ã‡ÃÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
}



void CGame::RequestDismissPartyHandler(int iClientH)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 4; // Â¸Ã¢Â¹Ã¶ ÃÂ¦Â°Ã… Â¿Ã¤ÃƒÂ»
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);

	m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
}


void CGame::GetPartyInfoHandler(int iClientH)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	dwp = (DWORD *)cp;
	*dwp = MSGID_PARTYOPERATION;
	cp += 4;
	wp = (WORD*)cp;
	*wp = 5; // Ã†Ã„Ã†Â¼ ÃÂ¤ÂºÂ¸ Â¿Ã¤ÃƒÂ»
	cp += 2;
	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;
	memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
	cp += 10;
	wp = (WORD *)cp;
	*wp = m_pClientList[iClientH]->m_iPartyID;
	cp += 2;
	SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
}


void CGame::PartyOperationResult_Info(int iClientH, char * pName, int iTotal, char *pNameList)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (strcmp(m_pClientList[iClientH]->m_cCharName, pName) != 0) return;
	if (m_pClientList[iClientH]->m_iPartyStatus != DEF_PARTYSTATUS_CONFIRM) return;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PARTY, 5, 1, iTotal, pNameList);
}

void CGame::RequestDeletePartyHandler(int iClientH)
{
	char * cp, cData[120];
	DWORD * dwp;
	WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iPartyID != NULL) {
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		dwp = (DWORD *)cp;
		*dwp = MSGID_PARTYOPERATION;
		cp += 4;
		wp = (WORD*)cp;
		*wp = 4; // Â¸Ã¢Â¹Ã¶ ÃÂ¦Â°Ã… Â¿Ã¤ÃƒÂ»
		cp += 2;
		wp = (WORD *)cp;
		*wp = iClientH;
		cp += 2;
		memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
		cp += 10;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_iPartyID;
		cp += 2;
		SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		// Â»Ã³Ã…Ã‚ ÂºÂ¯ÃˆÂ¯
		m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_PROCESSING;
	}
}

void CGame::RequestAcceptJoinPartyHandler(int iClientH, int iResult)
{
	char *cp, cData[120];
	DWORD * dwp;
	WORD * wp;
	int iH;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iResult) {
	case 0: // Ã†Ã„Ã†Â¼ Â°Â¡Ã€Ã” Â½Ã…ÃƒÂ» Â°Ã…ÂºÃÂµÃ‡Â¾ÃºÃ€Â½Ã€Â» Â¾Ã‹Â·ÃÃÃ˜Â´Ã™.
		iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
		if (m_pClientList[iH] == NULL) {
			// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¼Â­Â¹Ã¶Â»Ã³Â¿Â¡ Â¾Ã¸Â´Ã™.
			return;
		}
		if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
			// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¼Â­Â¹Ã¶Â»Ã³Â¿Â¡ Â¾Ã¸Â´Ã™.
			return;
		}
		if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
			// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Â»Ã³Ã…Ã‚Â°Â¡ ÂºÂ¯Â°Ã¦ÂµÃ‡Â¾ÃºÂ´Ã™.
			return;
		}
		if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
			// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Â±Ã—Â¶Â§ Â±Ã— Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¾Ã†Â´ÃÂ´Ã™.
			return;
		}

		SendNotifyMsg(NULL, iH, DEF_NOTIFY_PARTY, 7, 0, NULL, NULL);
		//testcode
		wsprintf(G_cTxt, "Party join reject(3) ClientH:%d ID:%d", iH, m_pClientList[iH]->m_iPartyID);
		PutLogList(G_cTxt);

		m_pClientList[iH]->m_iPartyID = NULL;
		m_pClientList[iH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
		m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));

		m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		break;

	case 1: // Ã†Ã„Ã†Â¼ Â°Â¡Ã€Ã” Â½Ã…ÃƒÂ» Â½Ã‚Ã€Ã
		if ((m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM) && (m_pClientList[iClientH]->m_iPartyID != NULL)) {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == NULL) {
				// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¼Â­Â¹Ã¶Â»Ã³Â¿Â¡ Â¾Ã¸Â´Ã™.
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¼Â­Â¹Ã¶Â»Ã³Â¿Â¡ Â¾Ã¸Â´Ã™.
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Â»Ã³Ã…Ã‚Â°Â¡ ÂºÂ¯Â°Ã¦ÂµÃ‡Â¾ÃºÂ´Ã™.
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Â±Ã—Â¶Â§ Â±Ã— Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¾Ã†Â´ÃÂ´Ã™.
				return;
			}

			// Â°Â¡Ã€Ã” ÃƒÂ³Â¸Â® Ã‡Ã‘Â´Ã™.
			ZeroMemory(cData, sizeof(cData));
			cp = (char *)cData;
			dwp = (DWORD *)cp;
			*dwp = MSGID_PARTYOPERATION;
			cp += 4;
			wp = (WORD*)cp;
			*wp = 3; // Ã†Ã„Ã†Â¼ Â¸Ã¢Â¹Ã¶ ÃƒÃŸÂ°Â¡ Â¿Ã¤ÃƒÂ»
			cp += 2;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			cp += 2;
			memcpy(cp, m_pClientList[iClientH]->m_cReqJoinPartyName, 10);
			cp += 10;
			wp = (WORD *)cp;
			*wp = m_pClientList[iClientH]->m_iPartyID;
			cp += 2;
			SendMsgToGateServer(MSGID_PARTYOPERATION, iClientH, cData);
		}
		else {
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;
			if (m_pClientList[iH] == NULL) {
				// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¼Â­Â¹Ã¶Â»Ã³Â¿Â¡ Â¾Ã¸Â´Ã™.
				return;
			}
			if (strcmp(m_pClientList[iH]->m_cCharName, m_pClientList[iClientH]->m_cReqJoinPartyName) != 0) {
				// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¼Â­Â¹Ã¶Â»Ã³Â¿Â¡ Â¾Ã¸Â´Ã™.
				return;
			}
			if (m_pClientList[iH]->m_iPartyStatus != DEF_PARTYSTATUS_PROCESSING) {
				// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Ã€Ã‡ Â»Ã³Ã…Ã‚Â°Â¡ ÂºÂ¯Â°Ã¦ÂµÃ‡Â¾ÃºÂ´Ã™.
				return;
			}
			if ((m_pClientList[iH]->m_iReqJoinPartyClientH != iClientH) || (strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) != 0)) {
				// Â°Â¡Ã€Ã”Ã€Â» Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Â±Ã—Â¶Â§ Â±Ã— Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¾Ã†Â´ÃÂ´Ã™.
				return;
			}

			if (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_NULL) {
				// Â½Ã…ÃƒÂ» Â¹ÃÃ€Âº Ã‡ÃƒÂ·Â¹Ã€ÃŒÂ¾Ã®Â°Â¡ Â¾Ã†Â¹Â«Â·Â± Ã†Ã„Ã†Â¼Â¿Â¡ÂµÂµ Â°Â¡Ã€Ã”Ã‡ÃÂ°Ã­ Ã€Ã–ÃÃ¶ Â¾ÃŠÂ´Ã™. Ã€ÃŒ Ã„Â³Â¸Â¯Ã…ÃÂ¸Â¦ Ã†Ã„Ã†Â¼ Â¸Â¶Â½ÂºÃ…ÃÂ·Ã Â½Ã…ÃƒÂ»Ã‡Ã‘Â´Ã™.
				RequestCreatePartyHandler(iClientH);
			}
			else {
				// ÃƒÂ³Â¸Â® ÂºÃ’Â°Â¡
			}
		}
		break;

	case 2: // Ã†Ã„Ã†Â¼ Â°Â¡Ã€Ã” Â½Ã…ÃƒÂ» ÃƒÃ«Â¼Ã’
		// Ã€ÃŒ Â¸ÃÂ½ÃƒÃÃ¶Â¸Â¦ Â¹ÃÂ±Ã¢ Ã€Ã¼Â¿Â¡ Ã€ÃŒÂ¹ÃŒ Ã†Ã„Ã†Â¼Â¿Â¡ Â°Â¡Ã€Ã”ÂµÃ‡Â¾ÃºÂ´Ã™Â¸Ã© Ã…Â»Ã…Ã° ÃƒÂ³Â¸Â®Â¸Â¦ Ã‡Ã‘Â´Ã™.
		if ((m_pClientList[iClientH]->m_iPartyID != NULL) && (m_pClientList[iClientH]->m_iPartyStatus == DEF_PARTYSTATUS_CONFIRM)) {
			// Â¸Ã¢Â¹Ã¶ ÃÂ¦Â°Ã…Â¸Â¦ Â¿Ã¤ÃƒÂ»Ã‡Ã‘Â´Ã™.
			RequestDismissPartyHandler(iClientH);
		}
		else {
			// Â°Â¡Ã€Ã” Â½Ã…ÃƒÂ» Â»Ã³Ã…Ã‚Â¿Â´Â´Ã¸ Â°ÂªÂµÃ©Ã€Â» ÃƒÃŠÂ±Ã¢ÃˆÂ­ Ã‡Ã‘Â´Ã™.
			iH = m_pClientList[iClientH]->m_iReqJoinPartyClientH;

			// Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Ã„Â³Â¸Â¯Ã…ÃÂ°Â¡ ÃÂ¢Â¼Ã“Ã€Â» Â²Ã·Ã€Âº Â»Ã³Ã…Ã‚Â¶Ã³Â¸Ã© NULLÃ€Ã Â¼Ã¶ Ã€Ã–Â´Ã™.
			if ((m_pClientList[iH] != NULL) && (m_pClientList[iH]->m_iReqJoinPartyClientH == iClientH) && 
				(strcmp(m_pClientList[iH]->m_cReqJoinPartyName, m_pClientList[iClientH]->m_cCharName) == 0)) {
					// Â½Ã…ÃƒÂ»Ã‡ÃŸÂ´Ã¸ Ã„Â³Â¸Â¯Ã…ÃÃ€Ã‡ Ã†Ã„Ã†Â¼ Â¾Ã†Ã€ÃŒÂµÃ°Â¿Ã Â»Ã³Ã…Ã‚Â´Ã‚ Â°Ã‡ÂµÃ¥Â¸Â®ÃÃ¶ Â¾ÃŠÂ´Ã‚Â´Ã™.
					m_pClientList[iH]->m_iReqJoinPartyClientH = NULL;
					ZeroMemory(m_pClientList[iH]->m_cReqJoinPartyName, sizeof(m_pClientList[iH]->m_cReqJoinPartyName));
				}

				m_pClientList[iClientH]->m_iPartyID = NULL;
				m_pClientList[iClientH]->m_iPartyStatus = DEF_PARTYSTATUS_NULL;
				m_pClientList[iClientH]->m_iReqJoinPartyClientH = NULL;
				ZeroMemory(m_pClientList[iClientH]->m_cReqJoinPartyName, sizeof(m_pClientList[iClientH]->m_cReqJoinPartyName));
		}
		break;
	}
}

// v2.16 2002-5-21 Â°Ã­Â±Â¤Ã‡Ã¶Â¼Ã¶ÃÂ¤ : Ã‡Ã”Â¼Ã¶ Â¸Ã°ÂµÃ ÂºÂ¯Â°Ã¦ÂµÃŠ 
void CGame::RequestItemUpgradeHandler(int iClientH, int iItemIndex)
{
	int i, iItemX,iItemY, iSoM, iSoX, iSomH, iSoxH, iValue; // v2.172
	DWORD dwTemp, dwSWEType;
	double dV1, dV2, dV3;
	short sItemUpgrade = 2;

	if (m_pClientList[iClientH] == NULL) return;
	if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;

	iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28;
	if (iValue >= 15 || iValue < 0 ) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 1, NULL, NULL, NULL);
		return;
	}

	switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cCategory) {
	case 1: // Â°Ã‹, ÂµÂµÂ³Â¢
			switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
				case 703: // Â»Ã³Â¾Ã®Ã€Ã‡ Ã‡ÃƒÂ·Â¥Â¹Ã¶Â±Ã— 
				case 709: // ÃˆÃ¦Â±Ã¢Â»Ã§Ã€Ã‡ Ã‡ÃƒÂ·Â¥Â¹Ã¶Â±Ã— 
				case 718:
				case 727: // ÃˆÃ…Â¿Â©Â±Ã¢Â»Ã§Ã€Ã‡ Ã‡ÃƒÂ·Â¥Â¹Ã¶Â±Ã— 
				case 736: // Â»ÃµÂ·ÃÂ¿Ã® Â»Ã³Â¾Ã®Ã€Ã‡ Ã€ÃšÃ€ÃŒÂ¾Ã°Ã†Â®Â¼Ã’ÂµÃ¥
				case 737: // Â»ÃµÂ·ÃÂ¿Ã® ÃˆÃ¦Â±Ã¢Â»Ã§Ã€Ã‡ Ã€ÃšÃ€ÃŒÂ¾Ã°Ã†Â®Â¼Ã’ÂµÃ¥
				case 745:
					if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) 
					{ 
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL); // Ã‡ÃŠÂ¿Ã¤Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â¼Ã¶Ã„Â¡Â°Â¡ Â¾Ã¸Â½Ã€Â´ÃÂ´Ã™.
						return; 
					}
					// Â¾Ã†Ã€ÃŒÃ…Ã› Â·Â¹ÂºÂ§Â¾Ã·Ã€ÃŒ Â³Ã´Â¾Ã†ÃÃºÂ¼Ã¶Â·Ã Â¾Ã†Ã€ÃŒÃ…Ã› Â·Â¹ÂºÂ§Â¾Ã·Ã‡ÃÂ±Ã¢Â°Â¡ Â¾Ã®Â·Ã†Â´Ã™.
					// v2.15 ÃÃ¶ÃÂ¸ Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â°Ã¸Â½Ã„ x(x+6)/8 +2 

					sItemUpgrade = (iValue*(iValue+6)/8) + 2 ;

					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
					{
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÂºÃ’Â°Â¡Â´Ã‰Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã”Â´ÃÂ´Ã™.
						return; 
					}

					if (( m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
					{ 
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL); // Ã‡ÃŠÂ¿Ã¤Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â¼Ã¶Ã„Â¡Â°Â¡ Â¾Ã¸Â½Ã€Â´ÃÂ´Ã™.
						return; 
					}

					m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade ; 

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

					if((iValue == 0) && m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 703) 
					{
						iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
						iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

						// Â±Ã¢ÃÂ¸Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

						m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
						m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
						m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;

						if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , "Â»Ã³Â¾Ã®Ã€Ã‡Ã€ÃšÃ€ÃŒÂ¾Ã°Ã†Â®Â¼Ã’ÂµÃ¥") == FALSE) {
							// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Ã‡ÃÂ°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã› Â¸Â®Â½ÂºÃ†Â®Â»Ã³Â¿Â¡ Â¾Ã¸Â´Ã™. Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥Â°Â¡ ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™.
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
							return;
						}

						// Â¾Ã†Ã€ÃŒÃ…Ã›Â¿Â¡ Â»Ã§Â¿Ã«Ã€Ãš Â°Ã­Ã€Â¯ Â¹Ã¸ÃˆÂ£Â¸Â¦ Ã€Ã”Â·Ã‚Ã‡Ã‘Â´Ã™. Â´Ã™Â¸Â¥ Ã„Â³Â¸Â¯Ã…ÃÂ´Ã‚ Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶Â°Â¡ Â¾Ã¸Â´Ã™.
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

						iValue += 2;
						if (iValue > 15) iValue = 15;
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; // ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã® 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ÂµÃˆ ÂºÃ±Ã†Â®Â°Âª Ã€Ã”Â·Ã‚

						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
						_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
						break ;

					} 
					else if( (iValue == 0) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 709) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 727))) 
					{

						iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
						iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

						// Â±Ã¢ÃÂ¸Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

						m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
						m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
						m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;

						if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , "ÃˆÃ¦Â±Ã¢Â»Ã§Ã€Ã‡Ã€ÃšÃ€ÃŒÂ¾Ã°Ã†Â®Â¼Ã’ÂµÃ¥") == FALSE) {
							// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Ã‡ÃÂ°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã› Â¸Â®Â½ÂºÃ†Â®Â»Ã³Â¿Â¡ Â¾Ã¸Â´Ã™. Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥Â°Â¡ ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™.
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
							return;
						}

						// Â¾Ã†Ã€ÃŒÃ…Ã›Â¿Â¡ Â»Ã§Â¿Ã«Ã€Ãš Â°Ã­Ã€Â¯ Â¹Ã¸ÃˆÂ£Â¸Â¦ Ã€Ã”Â·Ã‚Ã‡Ã‘Â´Ã™. Â´Ã™Â¸Â¥ Ã„Â³Â¸Â¯Ã…ÃÂ´Ã‚ Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶Â°Â¡ Â¾Ã¸Â´Ã™.
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

						iValue += 2;
						if (iValue > 15) iValue = 15;
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; // ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã® 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ÂµÃˆ ÂºÃ±Ã†Â®Â°Âª Ã€Ã”Â·Ã‚

						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;

						_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
						break;
					} else 
					{
						iValue += 2;
						if (iValue > 15) iValue = 15;
						dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
						dwTemp = dwTemp & 0x0FFFFFFF; // ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã® 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ÂµÃˆ ÂºÃ±Ã†Â®Â°Âª Ã€Ã”Â·Ã‚
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					}
					break;

				default:

					// v2.16 2002-5-21 Â°Ã­Â±Â¤Ã‡Ã¶Â¼Ã¶ÃÂ¤
					// Â°Ã­Â´Ã«Ã€Ã‡~ ÃÂ¢ÂµÃÂ»Ã§Â°Â¡ ÂºÃ™Â´Ã‚ Â¹Â«Â±Ã¢Â´Ã‚ Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÂºÃ’Â°Â¡Â´Ã‰
					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
						dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
						if (dwSWEType == 9) {
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÂºÃ’Â°Â¡Â´Ã‰Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã”Â´ÃÂ´Ã™.
							return;
						}
					}
					// Ã€ÃÂ¹Ã Â¹Â«Â±Ã¢ Â¾Ã†Ã€ÃŒÃ…Ã›
					// v2.16 2002-5-21 Â°Ã­Â±Â¤Ã‡Ã¶Â¼Ã¶ÃÂ¤
					iSoX = iSoM = 0;
					for (i = 0; i < DEF_MAXITEMS; i++)
						if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
							switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
								case 656: iSoX++; iSoxH = i; break; // Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª ÃÂ¦Â¸Â®Â¸Â¶ 
								case 657: iSoM++; iSomH = i; break; // Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª Â¸ÃÂ¸Â®Â¿Â£ 
							}
						}
						// Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª ÃÂ¦Â¸Â®Â¸Â¶Â°Â¡ Ã€Ã–Â´Ã™.
						if (iSoX > 0) {
							if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) {
								// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â½Ã‡Ã†Ã 
								SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
								// Â½Ã‡Ã†ÃÃ‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã¸Â¾Ã˜Â´Ã™.
								iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
								if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, FALSE); // v2.172 +1 -> +2 Â´ÃœÂ°Ã¨Â¿Â¡Â¼Â­ Â½Ã‡Ã†ÃÃ‡ÃÂ¸Ã© Â»Ã§Â¶Ã³ÃÃ¼ 
								// Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª ÃÂ¦Â¸Â®Â¸Â¶ Â¾Ã¸Â¾Ã˜Â´Ã™.
								ItemDepleteHandler(iClientH, iSoxH, FALSE);	
								return;
							}

							if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
								// ÃÂ¦Ã€Ã›ÂµÃˆ Â¹Â«Â±Ã¢ Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÃƒÃ–Â´Ã« +10
								iValue++;
								if (iValue > 10) 
									iValue = 10;
								else {
									// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â¼ÂºÂ°Ã¸. Â¾Ã†Ã€ÃŒÃ…Ã› Ã†Â¯Â¼Âº Â¹Ã™Â²Ã™Â°Ã­
									dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
									dwTemp = dwTemp & 0x0FFFFFFF; // ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã® 
									m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ÂµÃˆ ÂºÃ±Ã†Â®Â°Âª Ã€Ã”Â·Ã‚	
									// Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª ÃÂ¦Â¸Â®Â¸Â¶ Â¾Ã¸Â¾Ã˜Â´Ã™.
									ItemDepleteHandler(iClientH, iSoxH, FALSE);
								}
							}
							else {
								// Ã€ÃÂ¹Ã Â¹Â«Â±Ã¢ Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÃƒÃ–Â´Ã« +7
								iValue++;
								if (iValue > 7) 
									iValue = 7;
								else {
									// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â¼ÂºÂ°Ã¸. Â¾Ã†Ã€ÃŒÃ…Ã› Ã†Â¯Â¼Âº Â¹Ã™Â²Ã™Â°Ã­
									dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
									dwTemp = dwTemp & 0x0FFFFFFF; // ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã® 
									m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ÂµÃˆ ÂºÃ±Ã†Â®Â°Âª Ã€Ã”Â·Ã‚	
									// Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª ÃÂ¦Â¸Â®Â¸Â¶ Â¾Ã¸Â¾Ã˜Â´Ã™.
									ItemDepleteHandler(iClientH, iSoxH, FALSE);
								}
							}
						}

						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						break;
			}
			break;

	case 3: // ÃˆÂ° 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		break;

	case 5: // Â¹Ã¦Ã†Ã
		// Â¸Ã°ÂµÃ Ã€ÃÂ¹Ã Â¾Ã†Ã€ÃŒÃ…Ã›
		// v2.16 2002-5-21 Â°Ã­Â±Â¤Ã‡Ã¶Â¼Ã¶ÃÂ¤
		// Â°Â­ÃˆÂ­ÂµÃˆ~ ÃÂ¢ÂµÃÂ»Ã§Â°Â¡ ÂºÃ™Â´Ã‚ Â¹Ã¦Â¾Ã®Â±Â¸Â´Ã‚ Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÂºÃ’Â°Â¡Â´Ã‰
		if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
			dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
			if (dwSWEType == 8) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÂºÃ’Â°Â¡Â´Ã‰Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã”Â´ÃÂ´Ã™.
				return;
			}
		}
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
			case 620: // Â¸ÃÂ¸Â®Â¿Â£-Â½Ã‡ÂµÃ¥
			case 623: // GM-Â½Ã‡ÂµÃ¥
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÂºÃ’Â°Â¡Â´Ã‰Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã”Â´ÃÂ´Ã™.
				return;
			default: break;
		}


		iSoX = iSoM = 0;
		for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
				switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
					case 656: iSoX++; iSoxH = i; break; // Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª ÃÂ¦Â¸Â®Â¸Â¶ 
					case 657: iSoM++; iSomH = i; break; // Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª Â¸ÃÂ¸Â®Â¿Â£ 
				}
			}

			// Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª Â¸ÃÂ¸Â®Â¿Â£Ã€ÃŒ Ã€Ã–Â´Ã™.			
			if (iSoM > 0) {
				// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â¼ÂºÂ°Ã¸ ÃˆÂ®Â·Ã¼ Â°Ã¨Â»Ãª.
				if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH,TRUE) == FALSE) {
					// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â½Ã‡Ã†Ã 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
					if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, FALSE); // v2.172 +1 -> +2 Â´ÃœÂ°Ã¨Â¿Â¡Â¼Â­ Â½Ã‡Ã†ÃÃ‡ÃÂ¸Ã© Â»Ã§Â¶Ã³ÃÃ¼ 
					// Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª Â¸ÃÂ¸Â®Â¿Â£ Â¾Ã¸Â¾Ã˜Â´Ã™.
					ItemDepleteHandler(iClientH, iSomH, FALSE);	
					return;
				}

				// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â¼ÂºÂ°Ã¸!
				iValue++;
				if (iValue > 10) 
					iValue = 10; // Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Ã‡Ã‘Â°Ã¨ 
				else {
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; // ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã® 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ÂµÃˆ ÂºÃ±Ã†Â®Â°Âª Ã€Ã”Â·Ã‚	

					if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
						// ÃÂ¦Ã€Ã› Â¹Ã¦Â¾Ã®Â±Â¸ Ã€ÃŒÂ¹Ã‡Â·Ã Â¼Ã¶Â¸Ã­ +20%
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.2f * dV1;
						dV3 = dV1 + dV2;
					}
					else {
						// Ã€ÃÂ¹Ã Â¹Ã¦Â¾Ã®Â±Â¸ Ã€ÃŒÂ¹Ã‡Â·Ã Â¼Ã¶Â¸Ã­ +15%
						dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
						dV2 = 0.15f * dV1;
						dV3 = dV1 + dV2;
					}
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
					// Â¿Â¡Â·Â¯ Â¹Ã¦ÃÃ¶Â¿Ã« Ã„ÃšÂµÃ¥ 
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
					// Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª Â¸ÃÂ¸Â®Â¿Â£ Â¾Ã¸Â¾Ã˜Â´Ã™.
					ItemDepleteHandler(iClientH, iSomH, FALSE);	
				}
			}
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
			break;

	case 6: // Â¹Ã¦Â¾Ã®Â±Â¸ 
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
			case 621: // Â¸ÃÂ¸Â®Â¿Â£-Ã‡ÃƒÂ·Â¹Ã€ÃŒÃ†Â®Â¸ÃÃ€ÃM
			case 622: // Â¸ÃÂ¸Â®Â¿Â£-Ã‡ÃƒÂ·Â¹Ã€ÃŒÃ†Â®Â¸ÃÃ€ÃW

			case 700: // Â»Ã³Â¾Ã®Ã€Ã‡ ÃˆÂ£Â¹Ã¶Ã…Â©
			case 701: // Â»Ã³Â¾Ã®Ã€Ã‡Ã‡Â®-Ã‡Ã¯Â¸Â§ 
			case 702: // Â»Ã³Â¾Ã®Ã€Ã‡Â·Â¹Â±Ã«Â½Âº 
			case 704: // Â»Ã³Â¾Ã®Ã€Ã‡ Ã‡ÃƒÂ·Â¹Ã€ÃŒÃ†Â® Â¸ÃÃ€Ã 
			case 706: // ÃˆÃ¦Â±Ã¢Â»Ã§Ã€Ã‡...
			case 707:
			case 708:
			case 710:
			case 711: // ÃˆÃ¦Â¸Â¶Â¹Ã½Â»Ã§Ã€Ã‡ ÃˆÂ£Â¹Ã¶Ã…Â©
			case 712: // ÃƒÂ¼Ã€ÃÂ¸ÃÃ€Ã
			case 713: // Â·Â¹Â±Ã«Â½Âº 
			case 724: // ÃˆÃ¦Â¿Â©Â±Ã¢Â»Ã§Ã€Ã‡...
			case 725:
			case 726:
			case 728:
			case 729: // ÃˆÃ¦Â¿Â©Â¸Â¶Â¹Ã½Â»Ã§Ã€Ã‡...
			case 730:
			case 731:
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÂºÃ’Â°Â¡Â´Ã‰Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã”Â´ÃÂ´Ã™.
				return;

			default:
				// Â¸Ã°ÂµÃ Ã€ÃÂ¹Ã Â¾Ã†Ã€ÃŒÃ…Ã›
				// v2.16 2002-5-21 Â°Ã­Â±Â¤Ã‡Ã¶Â¼Ã¶ÃÂ¤
				// Â°Â­ÃˆÂ­ÂµÃˆ~ ÃÂ¢ÂµÃÂ»Ã§Â°Â¡ ÂºÃ™Â´Ã‚ Â¹Ã¦Â¾Ã®Â±Â¸Â´Ã‚ Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÂºÃ’Â°Â¡Â´Ã‰
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
					dwSWEType  = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
					if (dwSWEType == 8) {
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÂºÃ’Â°Â¡Â´Ã‰Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã”Â´ÃÂ´Ã™.
						return;
					}
				}
				iSoX = iSoM = 0;
				for (i = 0; i < DEF_MAXITEMS; i++)
					if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
						switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
							case 656: iSoX++; iSoxH = i; break; // Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª ÃÂ¦Â¸Â®Â¸Â¶ 
							case 657: iSoM++; iSomH = i; break; // Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª Â¸ÃÂ¸Â®Â¿Â£ 
						}
					}

					// Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª Â¸ÃÂ¸Â®Â¿Â£Ã€ÃŒ Ã€Ã–Â´Ã™.			
					if (iSoM > 0) {
						// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â¼ÂºÂ°Ã¸ ÃˆÂ®Â·Ã¼ Â°Ã¨Â»Ãª.
						if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSomH, TRUE) == FALSE) {
							// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â½Ã‡Ã†Ã 
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
							iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
							if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, FALSE); // v2.172 +1 -> +2 Â´ÃœÂ°Ã¨Â¿Â¡Â¼Â­ Â½Ã‡Ã†ÃÃ‡ÃÂ¸Ã© Â»Ã§Â¶Ã³ÃÃ¼ 
							// Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª Â¸ÃÂ¸Â®Â¿Â£ Â¾Ã¸Â¾Ã˜Â´Ã™.
							ItemDepleteHandler(iClientH, iSomH, FALSE);	
							return;
						}

						// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â¼ÂºÂ°Ã¸!
						iValue++;
						if (iValue > 10) 
							iValue = 10; // Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Ã‡Ã‘Â°Ã¨ 
						else {
							dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							dwTemp = dwTemp & 0x0FFFFFFF; // ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã® 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ÂµÃˆ ÂºÃ±Ã†Â®Â°Âª Ã€Ã”Â·Ã‚	

							if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
								// ÃÂ¦Ã€Ã› Â¹Ã¦Â¾Ã®Â±Â¸ Ã€ÃŒÂ¹Ã‡Â·Ã Â¼Ã¶Â¸Ã­ +20%
								dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
								dV2 = 0.2f * dV1;
								dV3 = dV1 + dV2;
							}
							else {
								// Ã€ÃÂ¹Ã Â¹Ã¦Â¾Ã®Â±Â¸ Ã€ÃŒÂ¹Ã‡Â·Ã Â¼Ã¶Â¸Ã­ +15%
								dV1 = (double)m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;
								dV2 = 0.15f * dV1;
								dV3 = dV1 + dV2;
							}
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = (short)dV3;
							// Â¿Â¡Â·Â¯ Â¹Ã¦ÃÃ¶Â¿Ã« Ã„ÃšÂµÃ¥ 
							if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 < 0) 
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
							// Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª Â¸ÃÂ¸Â®Â¿Â£ Â¾Ã¸Â¾Ã˜Â´Ã™.
							ItemDepleteHandler(iClientH, iSomH, FALSE);	
						}
					}
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2);
					break;
		}
		break;

	case 8: // ÃÃ¶Ã†ÃÃ€ÃŒ 
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
			case 291: // Â¸Ã…ÃÃ·Â¿Ã¸ÂµÃ¥(LLF)

			case 714: // ÃˆÃ¦Â¸Â¶Â¹Ã½Â»Ã§Ã€Ã‡ ÃÃ¶Ã†ÃÃ€ÃŒ 
			case 732: // ÃˆÃ¦Â¿Â©Â¸Â¶Â¹Ã½Â»Ã§Ã€Ã‡ ÃÃ¶Ã†ÃÃ€ÃŒ
			case 738: // ÃˆÃ¦Â¸Â¶Â¹Ã½Â»Ã§Ã€Ã‡ Â¸Ã…ÃÃ·Â¿Ã¸ÂµÃ¥

				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3))
				{
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 2, NULL, NULL, NULL); // Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÂºÃ’Â°Â¡Â´Ã‰Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Ã”Â´ÃÂ´Ã™.
					return; 
				}

				if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0)
				{ 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL); // Ã‡ÃŠÂ¿Ã¤Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â¼Ã¶Ã„Â¡Â°Â¡ Â¾Ã¸Â½Ã€Â´ÃÂ´Ã™.
					return; 
				}
				// Â¾Ã†Ã€ÃŒÃ…Ã› Â·Â¹ÂºÂ§Â¾Ã·Ã€ÃŒ Â³Ã´Â¾Ã†ÃÃºÂ¼Ã¶Â·Ã Â¾Ã†Ã€ÃŒÃ…Ã› Â·Â¹ÂºÂ§Â¾Ã·Ã‡ÃÂ±Ã¢Â°Â¡ Â¾Ã®Â·Ã†Â´Ã™.
				// v2.15 ÃÃ¶ÃÂ¸ Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â°Ã¸Â½Ã„ x(x+6)/8 +2 
				sItemUpgrade = (iValue*(iValue+6)/8) + 2 ;

				if ((m_pClientList[iClientH]->m_iGizonItemUpgradeLeft - sItemUpgrade ) < 0) 
				{ 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMUPGRADEFAIL, 3, NULL, NULL, NULL); // Ã‡ÃŠÂ¿Ã¤Ã‡Ã‘ Â¾Ã†Ã€ÃŒÃ…Ã› Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â¼Ã¶Ã„Â¡Â°Â¡ Â¾Ã¸Â½Ã€Â´ÃÂ´Ã™.
					return; 
				}

				m_pClientList[iClientH]->m_iGizonItemUpgradeLeft -= sItemUpgrade; 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMUPGRADELEFT, m_pClientList[iClientH]->m_iGizonItemUpgradeLeft, NULL, NULL, NULL);

				if (iValue == 0 ){
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				}

				if( (iValue == 4) && ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 714) || (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum == 732))) 
				{
					iItemX = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x ;
					iItemY = m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y ;

					// Â±Ã¢ÃÂ¸Ã€Ã‡ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â»Ã¨ÃÂ¦Ã‡Ã‘Â´Ã™.
					delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
					m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

					m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;

					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].x = iItemX ;
					m_pClientList[iClientH]->m_ItemPosList[iItemIndex].y = iItemY ;

					if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex] , "ÃˆÃ¦Â¸Â¶Â¹Ã½Â»Ã§Ã€Ã‡Â¸Ã…ÃÃ·Â¿Ã¸ÂµÃ¥") == FALSE) {
						// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Ã‡ÃÂ°Ã­Ã€Ãš Ã‡ÃÂ´Ã‚ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã› Â¸Â®Â½ÂºÃ†Â®Â»Ã³Â¿Â¡ Â¾Ã¸Â´Ã™. Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥Â°Â¡ ÂºÃ’Â°Â¡Â´Ã‰Ã‡ÃÂ´Ã™.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
						return;
					}

					// Â¾Ã†Ã€ÃŒÃ…Ã›Â¿Â¡ Â»Ã§Â¿Ã«Ã€Ãš Â°Ã­Ã€Â¯ Â¹Ã¸ÃˆÂ£Â¸Â¦ Ã€Ã”Â·Ã‚Ã‡Ã‘Â´Ã™. Â´Ã™Â¸Â¥ Ã„Â³Â¸Â¯Ã…ÃÂ´Ã‚ Ã€ÃŒ Â¾Ã†Ã€ÃŒÃ…Ã›Ã€Â» Â»Ã§Â¿Ã«Ã‡Ã’ Â¼Ã¶Â°Â¡ Â¾Ã¸Â´Ã™.
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;

					iValue += 2;
					if (iValue > 15) iValue = 15;
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; // ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã® 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ÂµÃˆ ÂºÃ±Ã†Â®Â°Âª Ã€Ã”Â·Ã‚

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIZONITEMCANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2,
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute ) ;
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;


				} else
				{
					iValue += 2;
					if (iValue > 15) iValue = 15; 
					dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
					dwTemp = dwTemp & 0x0FFFFFFF; // ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã® 
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ÂµÃˆ ÂºÃ±Ã†Â®Â°Âª Ã€Ã”Â·Ã‚
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
					_bItemLog(DEF_ITEMLOG_UPGRADESUCCESS, iClientH, (int) -1, m_pClientList[iClientH]->m_pItemList[iItemIndex]);
					break;
				}

			default:
				// Ã€ÃÂ¹Ã Â¾Ã†Ã€ÃŒÃ…Ã›
				// v2.16 2002-5-21 Â°Ã­Â±Â¤Ã‡Ã¶Â¼Ã¶ÃÂ¤
				iSoX = iSoM = 0;
				for (i = 0; i < DEF_MAXITEMS; i++)
					if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
						switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
							case 656: iSoX++; iSoxH = i; break; // Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª ÃÂ¦Â¸Â®Â¸Â¶ 
							case 657: iSoM++; iSomH = i; break; // Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª Â¸ÃÂ¸Â®Â¿Â£ 
						}
					}
					// Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª ÃÂ¦Â¸Â®Â¸Â¶Â°Â¡ Ã€Ã–Â´Ã™.
					if (iSoX > 0) {
						// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â¼ÂºÂ°Ã¸ ÃˆÂ®Â·Ã¼ Â°Ã¨Â»Ãª.
						if (bCheckIsItemUpgradeSuccess(iClientH, iItemIndex, iSoxH) == FALSE) {
							// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â½Ã‡Ã†Ã 
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
							iValue = (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0xF0000000) >> 28; // v2.172
							if (iValue >= 1) ItemDepleteHandler(iClientH, iItemIndex, FALSE); // v2.172 +1 -> +2 Â´ÃœÂ°Ã¨Â¿Â¡Â¼Â­ Â½Ã‡Ã†ÃÃ‡ÃÂ¸Ã© Â»Ã§Â¶Ã³ÃÃ¼ 
							// Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª ÃÂ¦Â¸Â®Â¸Â¶ Â¾Ã¸Â¾Ã˜Â´Ã™.
							ItemDepleteHandler(iClientH, iSoxH, FALSE);	
							return;
						}

						iValue++;
						if (iValue > 7) 
							iValue = 7;
						else {
							// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ Â¼ÂºÂ°Ã¸. Â¾Ã†Ã€ÃŒÃ…Ã› Ã†Â¯Â¼Âº Â¹Ã™Â²Ã™Â°Ã­
							dwTemp = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute;
							dwTemp = dwTemp & 0x0FFFFFFF; // ÂºÃ±Ã†Â® Ã…Â¬Â¸Â®Â¾Ã® 
							m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = dwTemp | (iValue << 28); // Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ÂµÃˆ ÂºÃ±Ã†Â®Â°Âª Ã€Ã”Â·Ã‚	
							// Â½ÂºÃ…Ã¦ Â¿Ã€ÂºÃª ÃÂ¦Â¸Â®Â¸Â¶ Â¾Ã¸Â¾Ã˜Â´Ã™.
							ItemDepleteHandler(iClientH, iSoxH, FALSE);
						}
					}

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);

					break;
		}
		break;

		/*	case 13: // Â·ÃÂºÃª
		switch (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sIDnum) {
		case 715: // ÃˆÃ¦Â¸Â¶Â¹Ã½Â»Ã§Ã€Ã‡ Â·ÃÂºÃª 
		case 733: // ÃˆÃ¦Â¿Â©Â¸Â¶Â¹Ã½Â»Ã§Ã€Ã‡ Â·ÃÂºÃª
		if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;
		break;

		default:
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		break;
		}
		break;
		*/
	default:
		// Â¾Ã·Â±Ã—Â·Â¹Ã€ÃŒÂµÃ¥ ÂµÃˆ Â°Ã Â¾Ã¸Ã€Â½.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMATTRIBUTECHANGE, iItemIndex, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute, NULL, NULL);
		break;
	}
}

/*void CGame::Command_GreenBall(int iClientH, char * pData, DWORD dwMsgSize) 
{ 
char   seps[] = "= \t\n"; 
char   * token, cBuff[256]; 
class  CStrTok * pStrTok; 
char cPrevMode; 
int i, j, sType, sTime; 
DWORD dwTime; 
short itemeq;

    iSoX = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[i]->m_sIDnum) {
		case 652: iSoX++; iSoxH = i; break; // ½ºÅæ ¿Àºê Á¦¸®¸¶ 
		}
	}

  dwTime = timeGetTime(); 

  if (m_pClientList[iClientH] == NULL) return; 
  if ((dwMsgSize)   <= 0) return; 

  ZeroMemory(cBuff, sizeof(cBuff)); 
  memcpy(cBuff, pData, dwMsgSize); 

  pStrTok = new class CStrTok(cBuff, seps); 
  token = pStrTok->pGet(); 
  token = pStrTok->pGet(); 
   
  if (token == NULL) { 
     delete pStrTok; 
     return; 
  } 

  sTime = 600;
   
  for (i = 0; i < DEF_MAXMAPS; i++) { 
     if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) { 
        cPrevMode = m_pMapList[i]->m_cWhetherStatus; 
        if (m_pMapList[i]->m_cWhetherStatus != NULL) { 
           if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
              m_pMapList[i]->m_cWhetherStatus = NULL; 
        } 
        else { 
           sTime *= 1000; 
           m_pMapList[i]->m_cWhetherStatus = sType; 
           m_pMapList[i]->m_dwWhetherStartTime = dwTime; 
           m_pMapList[i]->m_dwWhetherLastTime  = sTime; 
        } 
        if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) { 
           for (j = 1; j < DEF_MAXCLIENTS; j++) 
           if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
              SendNotifyMsg(NULL, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);    
        } 
     } 
  } 
	ItemDepleteHandler(iClientH, itemeq, FALSE);
}*/

void CGame::TimeHitPointsUp(int iClientH)
{
 register int iMaxHP, iTemp, iTotal;
 double dV1, dV2, dV3;

	/*
	.text:0043A679                 mov     [ebp+m_pClientList], ecx
	.text:0043A67C                 mov     eax, [ebp+iClientH]
	.text:0043A67F                 mov     ecx, [ebp+m_pClientList]
	.text:0043A682                 cmp     dword ptr [ecx+eax*4+16Ch], 0 ; m_pClientList[iClientH] == 0
	.text:0043A68A                 jnz     short loc_43A691;
	.text:0043A68C                 jmp     loc_43A8F4;
	*/
	if (m_pClientList[iClientH] == NULL) return;

	/*
	.text:0043A691                 mov     edx, [ebp+iClientH]
	.text:0043A694                 mov     eax, [ebp+m_pClientList]
	.text:0043A697                 mov     ecx, [eax+edx*4+16Ch] ; m_pClientList[iClientH]->
	.text:0043A69E                 cmp     dword ptr [ecx+2Ch], 0 ; m_bIsInitComplete == 0
	.text:0043A6A2                 jnz     short loc_43A6A9;
	.text:0043A6A4                 jmp     break loc_43A8F4;
	*/
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	/*
	.text:0043A6A9                 mov     edx, [ebp+iClientH]
	.text:0043A6AC                 mov     eax, [ebp+m_pClientList]
	.text:0043A6AF                 mov     ecx, [eax+edx*4+16Ch] ; m_pClientList[iClientH]->
	.text:0043A6B6                 cmp     dword ptr [ecx+0B6Ch], 0 ; m_iHungerStatus <= 0
	.text:0043A6BD                 jg      short loc_43A6C4
	.text:0043A6BF                 jmp     loc_43A8F4
	*/	
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;

	/*
	.text:0043A6C4                 mov     edx, [ebp+iClientH]
	.text:0043A6C7                 mov     eax, [ebp+m_pClientList]
	.text:0043A6CA                 mov     ecx, [eax+edx*4+16Ch] ; m_pClientList[iClientH]->
	.text:0043A6D1                 cmp     dword ptr [ecx+0C8h], 1 ; m_bIsKilled == TRUE
	.text:0043A6D8                 jnz     short loc_43A6DF
	.text:0043A6DA                 jmp     loc_43A8F4
	*/
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	/*
	.text:0043A6DF                 mov     edx, [ebp+iClientH]
	.text:0043A6E2                 mov     eax, [ebp+m_pClientList]
	.text:0043A6E5                 mov     ecx, [eax+edx*4+16Ch] ; m_pClientList[iClientH]->
	.text:0043A6EC                 cmp     dword ptr [ecx+864h], 1 ; m_pClientList[i]->m_bSkillUsingStatus[19]
	.text:0043A6F3                 jnz     short loc_43A6FA
	.text:0043A6F5                 jmp     loc_43A8F4
	*/
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;
	
	/*
	.text:0043A6FA                 mov     edx, [ebp+iClientH]
	.text:0043A6FD                 push    edx
	.text:0043A6FE                 mov     ecx, [ebp+m_pClientList]
	.text:0043A701                 call    CGame__iGetMaxHP
	.text:0043A706                 mov     [ebp+iMaxHP], eax
	*/
	iMaxHP = iGetMaxHP(iClientH);

	/*
	.text:0043A709                 mov     eax, [ebp+iClientH]
	.text:0043A70C                 mov     ecx, [ebp+m_pClientList]
	.text:0043A70F                 mov     edx, [ecx+eax*4+16Ch]
	.text:0043A716                 mov     eax, [edx+0ACh] ; m_iHP < iMaxHP
	.text:0043A71C                 cmp     eax, [ebp+iMaxHP]
	.text:0043A71F                 jge     loc_43A8DD
	*/
	if (m_pClientList[iClientH]->m_iHP < iMaxHP) {
		
		/*
		.text:0043A725                 mov     ecx, [ebp+iClientH]
		.text:0043A728                 mov     edx, [ebp+m_pClientList]
		.text:0043A72B                 mov     eax, [edx+ecx*4+16Ch] ; m_pClientList[iClientH]->
		.text:0043A732                 mov     ecx, [eax+120h] ; m_iVit
		.text:0043A738                 push    ecx
		.text:0043A739                 push    1
		.text:0043A73B                 mov     ecx, [ebp+m_pClientList]
		.text:0043A73E                 call    CGame__iDice
		.text:0043A743                 mov     [ebp+iTemp], eax
		*/
		iTemp = iDice(1, (m_pClientList[iClientH]->m_iVit));

		/*
		.text:0043A746                 mov     edx, [ebp+iClientH]
		.text:0043A749                 mov     eax, [ebp+m_pClientList]
		.text:0043A74C                 mov     ecx, [eax+edx*4+16Ch] ; m_pClientList[iClientH]->
		.text:0043A753                 mov     eax, [ecx+120h] ; m_iVit
		.text:0043A759                 cdq
		.text:0043A75A                 sub     eax, edx
		.text:0043A75C                 sar     eax, 1
		.text:0043A75E                 cmp     [ebp+iTemp], eax
		.text:0043A761                 jge     short loc_43A77E
		.text:0043A763                 mov     edx, [ebp+iClientH]
		.text:0043A766                 mov     eax, [ebp+m_pClientList]
		.text:0043A769                 mov     ecx, [eax+edx*4+16Ch] ; m_pClientList[iClientH]->
		.text:0043A770                 mov     eax, [ecx+120h] ; m_iVit
		.text:0043A776                 cdq
		.text:0043A777                 sub     eax, edx
		.text:0043A779                 sar     eax, 1
		.text:0043A77B                 mov     [ebp+iTemp], eax
		*/
		if (iTemp < (m_pClientList[iClientH]->m_iVit/2)) iTemp = (m_pClientList[iClientH]->m_iVit/2);

		/*
		.text:0043A77E                 mov     edx, [ebp+iClientH]
		.text:0043A781                 mov     eax, [ebp+m_pClientList]
		.text:0043A784                 mov     ecx, [eax+edx*4+16Ch] ; m_pClientList[iClientH]->
		.text:0043A78B                 cmp     dword ptr [ecx+0C1Ch], 0 ; m_iSideEffect_MaxHPdown != 0
		.text:0043A792                 jz      short loc_43A7B3
		*/
		if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)

			/*
			.text:0043A7A5                 idiv    dword ptr [ecx+0C1Ch] ; m_iSideEffect_MaxHPdown
			.text:0043A7AB                 mov     edx, [ebp+iTemp] ; (iTemp / m_iSideEffect_MaxHPdown)
			.text:0043A7AE                 sub     edx, eax
			.text:0043A7B0                 mov     [ebp+iTemp], edx ; iTemp =
			*/
			iTemp -= (iTemp / m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

		/*
		.text:0043A7B3                 mov     eax, [ebp+iClientH]
		.text:0043A7B6                 mov     ecx, [ebp+m_pClientList]
		.text:0043A7B9                 mov     edx, [ecx+eax*4+16Ch]
		.text:0043A7C0                 mov     eax, [ebp+iTemp]
		.text:0043A7C3                 add     eax, [edx+0B0h]
		.text:0043A7C9                 mov     [ebp+iTotal], eax
		*/
		iTotal = iTemp + m_pClientList[iClientH]->m_iHPstock;

		/*
		.text:0043A7CC                 mov     ecx, [ebp+iClientH]
		.text:0043A7CF                 mov     edx, [ebp+m_pClientList]
		.text:0043A7D2                 mov     eax, [edx+ecx*4+16Ch] ; m_pClientList[iClientH]->
		.text:0043A7D9                 mov     ecx, [ebp+iTotal]
		.text:0043A7DC                 add     ecx, [eax+0B4h]
		.text:0043A7E2                 mov     [ebp+iTotal], ecx ; iTotal =
		.text:0043A7E5                 mov     edx, [ebp+iClientH]
		.text:0043A7E8                 mov     eax, [ebp+m_pClientList]
		.text:0043A7EB                 mov     ecx, [eax+edx*4+16Ch]
		.text:0043A7F2                 cmp     dword ptr [ecx+0E60h], 0 ; m_iAddHP == 0
		.text:0043A7F9                 jz      short loc_43A830
		.text:0043A7FB                 fild    [ebp+iTotal]
		.text:0043A7FE                 fstp    [ebp+var_20]
		.text:0043A801                 mov     edx, [ebp+iClientH]
		.text:0043A804                 mov     eax, [ebp+m_pClientList]
		.text:0043A807                 mov     ecx, [eax+edx*4+16Ch]
		.text:0043A80E                 fild    dword ptr [ecx+0E60h] ; m_iAddHP
		.text:0043A814                 fst     [ebp+var_28]
		.text:0043A817                 fdiv    ds:dbl_4ECBB8
		.text:0043A81D                 fmul    [ebp+var_20]
		.text:0043A820                 fst     [ebp+var_18]
		.text:0043A823                 call    __ftol
		.text:0043A828                 mov     edx, [ebp+iTotal]
		.text:0043A82B                 add     edx, eax
		.text:0043A82D                 mov     [ebp+iTotal], edx
		*/
		if (m_pClientList[iClientH]->m_iAddHP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddHP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		/*
		.text:0043A830                 mov     eax, [ebp+iClientH]
		.text:0043A833                 mov     ecx, [ebp+m_pClientList]
		.text:0043A836                 mov     edx, [ecx+eax*4+16Ch] ; m_pClientList[iClientH]->
		.text:0043A83D                 mov     eax, [edx+0ACh] ; m_iHP
		.text:0043A843                 add     eax, [ebp+iTotal]
		.text:0043A846                 mov     ecx, [ebp+iClientH]
		.text:0043A849                 mov     edx, [ebp+m_pClientList]
		.text:0043A84C                 mov     ecx, [edx+ecx*4+16Ch] ; m_pClientList[iClientH]->
		.text:0043A853                 mov     [ecx+0ACh], eax ; m_iHP
		*/
		m_pClientList[iClientH]->m_iHP += iTotal;

		/*
		.text:0043A859                 mov     edx, [ebp+iClientH]
		.text:0043A85C                 mov     eax, [ebp+m_pClientList]
		.text:0043A85F                 mov     ecx, [eax+edx*4+16Ch] ; m_pClientList[iClientH]->
		.text:0043A866                 mov     edx, [ecx+0ACh] ; m_iHP
		.text:0043A86C                 cmp     edx, [ebp+iMaxHP]
		.text:0043A86F                 jle     short loc_43A887
		.text:0043A871                 mov     eax, [ebp+iClientH]
		.text:0043A874                 mov     ecx, [ebp+m_pClientList]
		.text:0043A877                 mov     edx, [ecx+eax*4+16Ch] ; m_pClientList[iClientH]->
		.text:0043A87E                 mov     eax, [ebp+iMaxHP]
		.text:0043A881                 mov     [edx+0ACh], eax ; m_iHP
		*/
		if (m_pClientList[iClientH]->m_iHP > iMaxHP) m_pClientList[iClientH]->m_iHP = iMaxHP;

		/*
		.text:0043A887                 mov     ecx, [ebp+iClientH]
		.text:0043A88A                 mov     edx, [ebp+m_pClientList]
		.text:0043A88D                 mov     eax, [edx+ecx*4+16Ch] ; m_pClientList[iClientH]->
		.text:0043A894                 cmp     dword ptr [eax+m_iHP], 0
		.text:0043A89B                 jg      short loc_43A8B4
		.text:0043A89D                 mov     ecx, [ebp+iClientH]
		.text:0043A8A0                 mov     edx, [ebp+m_pClientList]
		.text:0043A8A3                 mov     eax, [edx+ecx*4+16Ch] ; m_pClientList[iClientH]->
		.text:0043A8AA                 mov     dword ptr [eax+m_iHP], 0
		*/
		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;
		/*
		.text:0043A8B4                 push    0               ; pString2
		.text:0043A8B6                 push    0               ; sV9
		.text:0043A8B8                 push    0               ; sV8
		.text:0043A8BA                 push    0               ; sV7
		.text:0043A8BC                 push    0               ; sV6
		.text:0043A8BE                 push    0               ; sV5
		.text:0043A8C0                 push    0               ; sV4
		.text:0043A8C2                 push    0               ; pString
		.text:0043A8C4                 push    0               ; sV3
		.text:0043A8C6                 push    0               ; sV2
		.text:0043A8C8                 push    0               ; sV1
		.text:0043A8CA                 push    0B07h           ; wMsgType DEF_NOTIFY_HP
		.text:0043A8CF                 mov     ecx, [ebp+iClientH]
		.text:0043A8D2                 push    ecx             ; iToH
		.text:0043A8D3                 push    0               ; iFromH
		.text:0043A8D5                 mov     ecx, [ebp+m_pClientList]
		.text:0043A8D8                 call    CGame__SendNotifyMsg
		*/
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
	}
	/*
	.text:0043A8DD                 mov     edx, [ebp+iClientH]
	.text:0043A8E0                 mov     eax, [ebp+m_pClientList]
	.text:0043A8E3                 mov     ecx, [eax+edx*4+16Ch]
	.text:0043A8EA                 mov     dword ptr [ecx+0B0h], 0 ; m_iHPstock = 0
	*/
	m_pClientList[iClientH]->m_iHPstock = 0;
}

char CGame::_cCheckHeroItemEquipped(int iClientH)
{
	short sHeroLeggings, sHeroHauberk, sHeroArmor, sHeroHelm;

	if (m_pClientList[iClientH] == NULL) return 0;

	sHeroHelm = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
	sHeroArmor = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
	sHeroHauberk = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
	sHeroLeggings = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];

	if ((sHeroHelm < 0) || (sHeroLeggings < 0) || (sHeroArmor < 0) || (sHeroHauberk < 0)) return 0; 

	if(m_pClientList[iClientH]->m_pItemList[sHeroHelm] == NULL) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sHeroLeggings] == NULL) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sHeroArmor] == NULL) return 0;
	if(m_pClientList[iClientH]->m_pItemList[sHeroHauberk] == NULL) return 0;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 403) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 411) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 423)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 407) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 415) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 419) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 423)) return 2;
	
	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 404) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 412) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 424)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 408) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 416) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 420) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 424)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 405) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 413) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 425)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 409) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 417) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 421) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 425)) return 2;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 406) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 414) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 426)) return 1;

	if ((m_pClientList[iClientH]->m_pItemList[sHeroHelm]->m_sIDnum == 410) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroArmor]->m_sIDnum == 418) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroHauberk]->m_sIDnum == 422) &&
		(m_pClientList[iClientH]->m_pItemList[sHeroLeggings]->m_sIDnum == 426)) return 2;

	return 0;
}

BOOL CGame::bPlantSeedBag(int iMapIndex, int dX, int dY, int iItemEffectValue1, int iItemEffectValue2, int iClientH)
{
 int iNamingValue, tX, tY;
 short sOwnerH;
 char cOwnerType, cNpcName[21], cName[21], cNpcWaypointIndex[11];
 BOOL bRet;

	if(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture >= 200){
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMOREAGRICULTURE, NULL, NULL, NULL, NULL);
		return FALSE;
	}

	if (iItemEffectValue2 > m_pClientList[iClientH]->m_cSkillMastery[2]) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURESKILLLIMIT, NULL, NULL, NULL, NULL);
		return FALSE;
	}

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();

	if (iNamingValue == -1) {
	}
	else{
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	if (sOwnerH != NULL && sOwnerH == DEF_OWNERTYPE_NPC && m_pNpcList[sOwnerH]->m_cActionLimit == 5) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
		return FALSE;
	}
	else{
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsFarm(dX, dY) == FALSE) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_AGRICULTURENOAREA, NULL, NULL, NULL, NULL);
		return FALSE;
	}
	
	ZeroMemory(cNpcName, sizeof(cNpcName));
	strcpy(cNpcName, "Crops");
	ZeroMemory(cName, sizeof(cName));
	wsprintf(cName, "XX%d", iNamingValue);
	cName[0] = '_';
	cName[1] = iMapIndex+65;

	ZeroMemory(cNpcWaypointIndex,sizeof(cNpcWaypointIndex));
	tX = dX;
	tY = dY;

	bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypointIndex, NULL, NULL, 0, FALSE, TRUE);
	if (bRet == FALSE) {
			m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
		} 
		else{
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
			if (m_pNpcList[sOwnerH] == NULL) return 0;
				m_pNpcList[sOwnerH]->m_cCropType = iItemEffectValue1;
					switch (iItemEffectValue1) {
					case 1: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 2: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 3: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 4: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 5: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 6: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 7: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 8: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 9: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 10: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 11: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 12: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					case 13: m_pNpcList[sOwnerH]->m_cCropSkill = iItemEffectValue2; break;
					default: m_pNpcList[sOwnerH]->m_cCropSkill = 100; break;				
				}
				m_pNpcList[sOwnerH]->m_sAppr2 = 1;
				SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
				wsprintf(G_cTxt, "(skill:%d type:%d)plant(%s) Agriculture begin(%d,%d) sum(%d)!", m_pNpcList[sOwnerH]->m_cCropSkill, m_pNpcList[sOwnerH]->m_cCropType, cNpcName, tX, tY, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalAgriculture);
				PutLogList(G_cTxt);
				return TRUE;
			}
		}
	}
	return FALSE;
}

/*BOOL CGame::bCheckFarmingSkill(char m_cFarmingSkill, char m_cCropSkill, char m_cHarvestCount)
{
 int iRoll;	

	m_cFarmingSkill = ((m_cFarmingSkill - 20)/10)
	m_cCropSkill = ((m_cCropSkill - 20)/10)

	if ((m_cCropSkill < 0) && (m_cCropSkill > 8)) return FALSE;
	if ((m_cFarmingSkill < 0) && (m_cFarmingSkill > 8)) return FALSE;

	iRoll = iDice(1,100)
		if (m_cHarvestCount == 1) {
			if (iRoll >= (m_cCropSkill*m_cFarmingSkill)) {
				2Ah 42
			}
		}
		else if (m_cHarvestCount == 2) {
				28h 40
		}

}*/

void CGame::_CheckFarmingAction(short sAttackerH, short sTargetH, BOOL bType)
{
 char cCropType;
 int iItemID;
 class CItem * pItem;

 iItemID = 0;
 cCropType = 0;

	cCropType = m_pNpcList[sTargetH]->m_cCropType;
	switch (cCropType) {
	case 1: GetExp(sAttackerH, iDice(3,10)); iItemID = 820; break; // WaterMelon
	case 2: GetExp(sAttackerH, iDice(3,10)); iItemID = 821; break; // Pumpkin
	case 3: GetExp(sAttackerH, iDice(4,10)); iItemID = 822; break; // Garlic
	case 4: GetExp(sAttackerH, iDice(4,10)); iItemID = 823; break; // Barley
	case 5: GetExp(sAttackerH, iDice(5,10)); iItemID = 824; break; // Carrot
	case 6: GetExp(sAttackerH, iDice(5,10)); iItemID = 825; break; // Radish
	case 7: GetExp(sAttackerH, iDice(6,10)); iItemID = 826; break; // Corn
	case 8: GetExp(sAttackerH, iDice(6,10)); iItemID = 827; break; // ChineseBellflower
	case 9: GetExp(sAttackerH, iDice(7,10)); iItemID = 828; break; // Melone
	case 10: GetExp(sAttackerH, iDice(7,10)); iItemID = 829; break; // Tommato
	case 11: GetExp(sAttackerH, iDice(8,10)); iItemID = 830; break; // Grapes
	case 12: GetExp(sAttackerH, iDice(8,10)); iItemID = 831; break; // BlueGrapes
	case 13: GetExp(sAttackerH, iDice(9,10)); iItemID = 832; break; // Mushroom
	default: GetExp(sAttackerH, iDice(10,10)); iItemID = 721; break; // Ginseng
	
	}
	
	pItem = new class CItem;
	if (_bInitItemAttr(pItem, iItemID) == FALSE) {
		delete pItem;
	}
	if (bType == 0) {
		m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->bSetItem(m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[sAttackerH]->m_cMapIndex,
			m_pClientList[sAttackerH]->m_sX, m_pClientList[sAttackerH]->m_sY,  pItem->m_sSprite, 
			pItem->m_sSpriteFrame, pItem->m_cItemColor, FALSE);
	}
	else if (bType == 1) {
		m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bSetItem(m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY, pItem);
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[sTargetH]->m_cMapIndex,
			m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY,  pItem->m_sSprite, 
			pItem->m_sSpriteFrame, pItem->m_cItemColor, FALSE);
	} 

}

void CGame::CalculateEnduranceDecrement(short sTargetH, short sAttackerH, char cTargetType, int iArmorType)
{
 short sItemIndex;
 int iDownValue = 1, iHammerChance = 100;

	if (m_pClientList[sTargetH] == NULL) return;

	if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_cSide != m_pClientList[sAttackerH]->m_cSide)) {
			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
				case 14: 
					if ((31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4)) || (32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))) {
						sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
						if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 761) { // BattleHammer 
								iDownValue = 30;
								break;
							}
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
								iDownValue = 35;
								break;
							}
							if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 843) { // BarbarianHammer
								iDownValue = 30;
								break;
							}
						}
					}
					else { 
						iDownValue = 20; break;
					}
				case 10: iDownValue = 3; break;
				default: iDownValue = 1; break;
				}

				if (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType)
						case 52: iDownValue = 0; iHammerChance = 0;
				}
			}
		}
		
		if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan > 0)) {
				m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan -= iDownValue;
		}

		if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan <= 0) {
			m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan = 0;
			SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, NULL, NULL);
			ReleaseItemHandler(sTargetH, iArmorType, TRUE);
			return;

		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_sUsingWeaponSkill == 14) && (iHammerChance == 100)) {
			if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan < 2000) {
				iHammerChance = iDice(6, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
			}
			else {
				iHammerChance = iDice(4, (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wMaxLifeSpan - m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan));
			}
			
			if ((31 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4)) || (32 == ((m_pClientList[sAttackerH]->m_sAppr2  & 0x0FF0) >> 4))) {
				sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
				if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 761) { // BattleHammer 
						iHammerChance = iHammerChance/2; 
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 762) { // GiantBattleHammer
						iHammerChance = ((iHammerChance*5)*(2/9));
					}
					if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 843) { // GiantBattleHammer
						iHammerChance = ((iHammerChance*5)*(2/9));
					}
				}
			}
			if ((m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum == 622) || (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_sIDnum == 621)) {
				iHammerChance = 0;
			}
			if (m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan < iHammerChance) {
				wsprintf(G_cTxt, "(iHammerChance (%d), target armor endurance (%d)!", iHammerChance, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_wCurLifeSpan);
				PutLogList(G_cTxt);
				ReleaseItemHandler(sTargetH, iArmorType, TRUE);
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[sTargetH]->m_pItemList[iArmorType]->m_cEquipPos, iArmorType, NULL, NULL);
				return;
			}
		}
	}
}

int CGame::iCalculateAttackEffect(short sTargetH, char cTargetType, short sAttackerH, char cAttackerType, int tdX, int tdY, int iAttackMode, BOOL bNearAttack, BOOL bIsDash, BOOL bArrowUse)
{
	int    iAP_SM, iAP_L, iAttackerHitRatio, iTargetDefenseRatio, iDestHitRatio, iResult, iAP_Abs_Armor, iAP_Abs_Shield;
	char   cAttackerName[21], cAttackerDir, cAttackerSide, cTargetDir, cProtect, cCropSkill, cFarmingSkill;
	short  sWeaponIndex, sAttackerWeapon, dX, dY, sX, sY, sAtkX, sAtkY, sTgtX, sTgtY;
	DWORD  dwTime;
	WORD   wWeaponType;
	double dTmp1, dTmp2, dTmp3;
	BOOL   bKilled;
	BOOL   bNormalMissileAttack;
	BOOL   bIsAttackerBerserk;
	int    iKilledDice, iDamage, iExp, iWepLifeOff, iSideCondition, iMaxSuperAttack, iWeaponSkill, iComboBonus, iTemp;
	int    iAttackerHP, iMoveDamage, iRepDamage;
	char   cAttackerSA;
	int    iAttackerSAvalue, iHitPoint;
	char   cDamageMoveDir;
	int    iPartyID, iConstructionPoint, iWarContribution, tX, tY, iDst1, iDst2;
	short sItemIndex;
	short sSkillUsed;

	dwTime = timeGetTime();
	bKilled = FALSE;
	iExp = 0;
	iPartyID = 0;
	bNormalMissileAttack = FALSE;
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	cAttackerSA      = NULL;
	iAttackerSAvalue = NULL;
	wWeaponType      = NULL;

	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sAttackerH] == NULL) return 0;
		if ((m_bAdminSecurity == TRUE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0)) return 0;
		if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) && (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) return 0;
		if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] == NULL) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) && (m_bIsHeldenianMode == TRUE)) return 0;
		if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[sAttackerH]->m_bIsPlayerCivil == TRUE) && (cTargetType == DEF_OWNERTYPE_PLAYER)) return 0;

		if ((m_pClientList[sAttackerH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_PLAYER, FALSE);
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
		}
		
		if ((m_pClientList[sAttackerH]->m_sAppr2 & 0xF000) == 0) return 0;

		iAP_SM = 0;
		iAP_L  = 0;

		wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);

		sSkillUsed = m_pClientList[sAttackerH]->m_sUsingWeaponSkill;
		if ((bIsDash == TRUE) && (m_pClientList[sAttackerH]->m_cSkillMastery[sSkillUsed] != 100) && (wWeaponType != 25) && (wWeaponType != 27)) {
			wsprintf(G_cTxt, "TSearch Fullswing Hack: (%s) Player: (%s) - dashing with only (%d) weapon skill.", m_pClientList[sAttackerH]->m_cIPaddress, m_pClientList[sAttackerH]->m_cCharName, m_pClientList[sAttackerH]->m_cSkillMastery[sSkillUsed]);
			PutHackLogFileList(G_cTxt);
			DeleteClient(sAttackerH, TRUE, TRUE);
			return 0;
		}

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
				
		if (wWeaponType == 0) {
			iAP_SM = iAP_L    = iDice(1, (m_pClientList[sAttackerH]->m_iStr / 12));
			if (iAP_SM <= 0) iAP_SM = 1;
			if (iAP_L  <= 0) iAP_L  = 1;
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio + m_pClientList[sAttackerH]->m_cSkillMastery[5];
			m_pClientList[sAttackerH]->m_sUsingWeaponSkill = 5 ;

		}
		else if ((wWeaponType >= 1) && (wWeaponType < 40)) {
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;

			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;

			dTmp1 = (double)iAP_SM;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				dTmp2 = 1.0f;
			else dTmp2 = (double)m_pClientList[sAttackerH]->m_iStr;

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_SM = (int)(dTmp3 +0.5f);

			dTmp1 = (double)iAP_L;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				dTmp2 = 1.0f;
			else dTmp2 = (double)m_pClientList[sAttackerH]->m_iStr;

			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_L = (int)(dTmp3 +0.5f);
		}
		else if (wWeaponType >= 40) {
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;

			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;
			bNormalMissileAttack = TRUE;

			iAP_SM += iDice(1, (m_pClientList[sAttackerH]->m_iStr / 20));
			iAP_L  += iDice(1, (m_pClientList[sAttackerH]->m_iStr / 20));
		}
	
		iAttackerHitRatio += 50;
		if (iAP_SM <= 0) iAP_SM = 1;
		if (iAP_L  <= 0) iAP_L  = 1;

		if (m_pClientList[sAttackerH]->m_iCustomItemValue_Attack != 0) {
			if ((m_pClientList[sAttackerH]->m_iMinAP_SM != 0) && (iAP_SM < m_pClientList[sAttackerH]->m_iMinAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMinAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMinAP_L != 0) && (iAP_L < m_pClientList[sAttackerH]->m_iMinAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMinAP_L;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_SM != 0) && (iAP_SM > m_pClientList[sAttackerH]->m_iMaxAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMaxAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_L != 0) && (iAP_L > m_pClientList[sAttackerH]->m_iMaxAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMaxAP_L;
			}
		}

		if (m_pClientList[sAttackerH]->m_cHeroArmourBonus == 1) {
			iAttackerHitRatio += 100;
			iAP_SM += 5;
			iAP_L += 5;
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 851) || // KlonessEsterk 
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 863) || // KlonessWand(MS.20)
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 864)) { // KlonessWand(MS.10) 
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
					if (iRepDamage < 5) iRepDamage = 5;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == NULL) return 0;
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
						if (iRepDamage > 10) iRepDamage = 10;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
					}
				}
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 861) || // BerserkWand(MS.20)
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 862)) { // BerserkWand(MS.10)
					iAP_SM += 1;
					iAP_L += 1;
			}
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 847) && 
				(m_cDayOrNight == 2)) {
					iAP_SM += 4;
					iAP_L += 4;
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 848) && 
				(m_cDayOrNight == 1)) {
					iAP_SM += 4;
					iAP_L += 4;
			}
			if ((m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 849) || // KlonessBlade 
				(m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 850)) { // KlonessAxe
				if (m_pClientList[sAttackerH]->m_iRating > 0) {
					iRepDamage = m_pClientList[sAttackerH]->m_iRating/100;
					if (iRepDamage < 5) iRepDamage = 5;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
				}
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == NULL) return 0;
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/10);
						if (iRepDamage > 10) iRepDamage = 10;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
					}
				}
			}
		}

		sItemIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_NECK];
		if ((sItemIndex != -1) && (m_pClientList[sAttackerH]->m_pItemList[sItemIndex] != NULL)) {
			if (m_pClientList[sAttackerH]->m_pItemList[sItemIndex]->m_sIDnum == 859) { // NecklaceOfKloness  
				if (cTargetType == DEF_OWNERTYPE_PLAYER) {
					if (m_pClientList[sTargetH] == NULL) return 0;
						iRepDamage = (abs(m_pClientList[sTargetH]->m_iRating)/20);
						if (iRepDamage > 5) iRepDamage = 5;
						iAP_SM += iRepDamage;
						iAP_L += iRepDamage;
				}
			}
		}

		cAttackerDir = m_pClientList[sAttackerH]->m_cDir;
		strcpy(cAttackerName, m_pClientList[sAttackerH]->m_cCharName);

		if (m_pClientList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0)
			bIsAttackerBerserk = TRUE;
		else bIsAttackerBerserk = FALSE;
		
		if ((bArrowUse != TRUE) && (m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {

			dTmp1 = (double)iAP_SM;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_SM += iTemp;

			dTmp1 = (double)iAP_L;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_L += iTemp;

			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
				case 6:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); iAttackerHitRatio  += 30 ; break;

				case 7:  iAP_SM *= 1; iAP_L *= 1; break;
				
				case 8:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); iAttackerHitRatio += 30 ; break;
				case 10:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5) ;                           break;
				case 14:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5) ; iAttackerHitRatio += 20 ; break;
				case 21:  iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5); iAttackerHitRatio +=  50 ; break;
				default: break;
			}
			iAttackerHitRatio += 100;
			iAttackerHitRatio += m_pClientList[sAttackerH]->m_iCustomItemValue_Attack;
		}

		if (bIsDash == TRUE) {

			iAttackerHitRatio += 20;

			switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
				case 8:  iAP_SM += (iAP_SM/10); iAP_L += (iAP_L/10); break;
				case 10: iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5);break;
				case 14: iAP_SM += (iAP_SM/5); iAP_L += (iAP_L/5);break;
				default: break;
			}
		}

		iAttackerHP = m_pClientList[sAttackerH]->m_iHP;
		iAttackerHitRatio += m_pClientList[sAttackerH]->m_iAddAR;

		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		iPartyID = m_pClientList[sAttackerH]->m_iPartyID;
		break;

	case DEF_OWNERTYPE_NPC:

		if (m_pNpcList[sAttackerH] == NULL) return 0;
		if (m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_bIsAttackEnabled == FALSE) return 0;

		if ((m_pNpcList[sAttackerH]->m_iStatus & 0x10) != 0) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_NPC, FALSE);
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
			m_pNpcList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_INVISIBILITY] = NULL;
		}

		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		iAP_SM = 0;
		iAP_L  = 0;

		if (m_pNpcList[sAttackerH]->m_cAttackDiceThrow != 0) 
			iAP_L = iAP_SM = iDice(m_pNpcList[sAttackerH]->m_cAttackDiceThrow, m_pNpcList[sAttackerH]->m_cAttackDiceRange);

		iAttackerHitRatio = m_pNpcList[sAttackerH]->m_iHitRatio;

		cAttackerDir = m_pNpcList[sAttackerH]->m_cDir;
		memcpy(cAttackerName, m_pNpcList[sAttackerH]->m_cNpcName, 20);

		if (m_pNpcList[sAttackerH]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] != 0)
			bIsAttackerBerserk = TRUE;
		else bIsAttackerBerserk = FALSE;

		iAttackerHP = m_pNpcList[sAttackerH]->m_iHP;
		cAttackerSA = m_pNpcList[sAttackerH]->m_cSpecialAbility;

		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:

		if (m_pClientList[sTargetH] == NULL) return 0;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return 0;
		if ((m_pClientList[sTargetH]->m_iStatus & 0x400000) != 0) return 0;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == FALSE) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsPlayerCivil == TRUE)) return 0;
				
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsNeutral == TRUE) && 
			(m_pClientList[sTargetH]->m_iPKCount == 0) && (m_pClientList[sTargetH]->m_bIsOwnLocation == TRUE)) return 0;
		
		if ((m_pClientList[sTargetH]->m_sX != tdX) || (m_pClientList[sTargetH]->m_sY != tdY)) return 0;

		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return 0;

		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) 
			&& (m_pClientList[sTargetH]->m_iPKCount == 0)) return 0;

		if ((m_pClientList[sTargetH]->m_iPartyID != NULL) && (iPartyID == m_pClientList[sTargetH]->m_iPartyID)) return 0;

		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pClientList[sTargetH]->m_iDefenseRatio;
		m_pClientList[sTargetH]->m_dwLogoutHackCheck = dwTime;
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE)) { 
			iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
			if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
				iAP_SM = iAP_SM / 2;
				iAP_L  = iAP_L / 2;
			}
			else {
				if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
					if (m_pClientList[sAttackerH]->m_iGuildGUID == m_pClientList[sTargetH]->m_iGuildGUID) return 0;
					else {
						iAP_SM = iAP_SM / 2;
						iAP_L  = iAP_L / 2;
					}
				}
				else return 0;
			}
		}

		iTargetDefenseRatio += m_pClientList[sTargetH]->m_iAddDR;
		


		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:

		if (m_pNpcList[sTargetH] == NULL) return 0;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return 0;

		if ((m_pNpcList[sTargetH]->m_sX != tdX) || (m_pNpcList[sTargetH]->m_sY != tdY)) return 0;

		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pNpcList[sTargetH]->m_iDefenseRatio;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {		
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return 0;
				break;
			}

			if ((wWeaponType == 25) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
				if ((m_pClientList[sAttackerH]->m_iCrusadeDuty != 2) && (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) break;
						
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 36:
				case 37:
				case 38:
				case 39:
					// administrators instantly build crusade structures
					if (m_pClientList[sAttackerH]->m_iAdminUserLevel > 0) {
						m_pNpcList[sTargetH]->m_sAppr2 = 0;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
				
					switch (m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1:
						m_pNpcList[sTargetH]->m_sAppr2 = 0;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						switch (m_pNpcList[sTargetH]->m_sType) {
						case 36: iConstructionPoint = 700; iWarContribution = 700; break;
						case 37: iConstructionPoint = 700; iWarContribution = 700; break;
						case 38: iConstructionPoint = 500; iWarContribution = 500; break;
						case 39: iConstructionPoint = 500; iWarContribution = 500; break;
						}
										
						m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
						if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
							m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;
						wsprintf(G_cTxt, "Construction Complete! WarContribution: +%d", iWarContribution);
						PutLogList(G_cTxt);
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
						break;
					case 5:
						m_pNpcList[sTargetH]->m_sAppr2 = 1;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
					case 10:
						m_pNpcList[sTargetH]->m_sAppr2 = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
					}
					break;
				}
				
				m_pNpcList[sTargetH]->m_iBuildCount--;
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				return 0;
			}
			if ((wWeaponType == 27) && (m_pNpcList[sTargetH]->m_cCropType != 0) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
				cFarmingSkill = m_pClientList[sAttackerH]->m_cSkillMastery[2];
				cCropSkill = m_pNpcList[sTargetH]->m_cCropSkill;
				if (cFarmingSkill < 20) return 0;
				if (m_pClientList[sAttackerH]->m_iLevel < 20) return 0;
				switch(m_pNpcList[sTargetH]->m_sType) {
				case 64:
					switch(m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1:	
						m_pNpcList[sTargetH]->m_sAppr2 = 3;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						//sub_4B67E0
						CalculateSSN_SkillIndex(sAttackerH, 2, cFarmingSkill <= cCropSkill + 10);
						_CheckFarmingAction(sAttackerH, sTargetH, 1);
						DeleteNpc(sTargetH);
						return 0;
					case 8:	
						m_pNpcList[sTargetH]->m_sAppr2 = 3;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						CalculateSSN_SkillIndex(sAttackerH, 2, cFarmingSkill <= cCropSkill + 10);
						_CheckFarmingAction(sAttackerH, sTargetH, 0);	
						break;
					case 18:
						m_pNpcList[sTargetH]->m_sAppr2 = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						CalculateSSN_SkillIndex(sAttackerH, 2, cFarmingSkill <= cCropSkill + 10);
						_CheckFarmingAction(sAttackerH, sTargetH, 0);	
						break;

					}
					break;
				}
				m_pNpcList[sTargetH]->m_iBuildCount--;
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				return 0;
			}
		}

		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;
		break;
	}

	if ( (cAttackerType == DEF_OWNERTYPE_PLAYER) && (cTargetType == DEF_OWNERTYPE_PLAYER) ) {

		sX = m_pClientList[sAttackerH]->m_sX;
		sY = m_pClientList[sAttackerH]->m_sY;

		dX = m_pClientList[sTargetH]->m_sX;
		dY = m_pClientList[sTargetH]->m_sY;

		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) return 0;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) return 0;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sAttackerH]->m_iDex > 50) {
			iAttackerHitRatio += (m_pClientList[sAttackerH]->m_iDex - 50); 	
		}
	}

	if (wWeaponType >= 40) {
		switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
		case 0:	break;
		case 1:	iAttackerHitRatio -= (iAttackerHitRatio / 20); break;
		case 2:	iAttackerHitRatio -= (iAttackerHitRatio / 10); break;
		case 3:	iAttackerHitRatio -= (iAttackerHitRatio / 4);  break;
		}
	}

	if (iAttackerHitRatio < 0)   iAttackerHitRatio = 0;    
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT];
		break;

	case DEF_OWNERTYPE_NPC:
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]; 
		break;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] == NULL) {
				m_pClientList[sAttackerH]->m_bIsItemEquipped[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] = FALSE;
				DeleteClient(sAttackerH, TRUE, TRUE);
				return 0;
			}

			if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_ARROW) {
				if (m_pClientList[sAttackerH]->m_cArrowIndex == -1) {
					return 0;
				}
				else {
					if (m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex] == NULL) 
						return 0;

					if (bArrowUse != TRUE)
						m_pClientList[sAttackerH]->m_pItemList[m_pClientList[sAttackerH]->m_cArrowIndex]->m_dwCount--;
					if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount <= 0) {

						ItemDepleteHandler(sAttackerH, m_pClientList[sAttackerH]->m_cArrowIndex, FALSE);
						m_pClientList[sAttackerH]->m_cArrowIndex = _iGetArrowItemIndex(sAttackerH);
					}
					else {
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_SETITEMCOUNT, m_pClientList[sAttackerH]->m_cArrowIndex, m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount, FALSE, NULL);
						iCalcTotalWeight(sAttackerH);
					}
				}
				if (cProtect == 1) return 0;
			}
			else {
				switch (cProtect) {
				case 3: iTargetDefenseRatio += 40;  break;
				case 4: iTargetDefenseRatio += 100; break;
				}
				if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
			}
		}
	}
	else {
		switch (cProtect) {
		case 1: 
			switch (m_pNpcList[sAttackerH]->m_sType) {
				case 54:
					if ((abs(sTgtX - m_pNpcList[sAttackerH]->m_sX) >= 1) || (abs(sTgtY - m_pNpcList[sAttackerH]->m_sY) >= 1)) return 0; 
					}
					break;
		case 3: iTargetDefenseRatio += 40;  break;
		case 4: iTargetDefenseRatio += 100; break;
		}
		if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
	}

	if (cAttackerDir == cTargetDir) iTargetDefenseRatio = iTargetDefenseRatio / 2;
	if (iTargetDefenseRatio < 1)   iTargetDefenseRatio = 1;

	dTmp1 = (double)(iAttackerHitRatio);
	dTmp2 = (double)(iTargetDefenseRatio);
	dTmp3 = (dTmp1 / dTmp2) * 50.0f;
	iDestHitRatio = (int)(dTmp3); 

	if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
	if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;

	if ((bIsAttackerBerserk == TRUE) && (iAttackMode < 20)) {
		iAP_SM = iAP_SM * 2;
		iAP_L  = iAP_L  * 2;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
		iAP_L  += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
	}

	if (bNearAttack == TRUE) {
		iAP_SM = iAP_SM / 2;
		iAP_L  = iAP_L / 2;
	}

	if (cTargetType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
		iAP_L  -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (iAP_SM <= 1) iAP_SM = 1;
		if (iAP_L  <= 1) iAP_L  = 1;
	}
	else {
		if (iAP_SM <= 0) iAP_SM = 0;
		if (iAP_L  <= 0) iAP_L  = 0;
	}

	iResult = iDice(1, 100);

	if (iResult <= iDestHitRatio) {
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {

			if (((m_pClientList[sAttackerH]->m_iHungerStatus <= 10) || (m_pClientList[sAttackerH]->m_iSP <= 0)) && (iDice(1,10) == 5)) return FALSE;	
			m_pClientList[sAttackerH]->m_iComboAttackCount++;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount < 0) m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount > 4) m_pClientList[sAttackerH]->m_iComboAttackCount = 1;
			iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
			iComboBonus = iGetComboAttackBonus(iWeaponSkill, m_pClientList[sAttackerH]->m_iComboAttackCount);

			if ((m_pClientList[sAttackerH]->m_iComboAttackCount > 1) && (m_pClientList[sAttackerH]->m_iAddCD != NULL))
				iComboBonus += m_pClientList[sAttackerH]->m_iAddCD;

			iAP_SM += iComboBonus;
			iAP_L  += iComboBonus;

			switch (m_pClientList[sAttackerH]->m_iSpecialWeaponEffectType) {
				case 0: break;
				case 1:
					if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {
						iAP_SM += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
						iAP_L  += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
					}
					break;

				case 2:
					cAttackerSA = 61;
					iAttackerSAvalue = m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue*5; 
					break;

				case 3:
					cAttackerSA = 62;
					break;
			}

			if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
				iAP_SM += iAP_SM/3;
				iAP_L  += iAP_L/3;
			}

			if (bCheckHeldenianMap(sAttackerH, m_iBTFieldMapIndex, DEF_OWNERTYPE_PLAYER) == 1) {
				iAP_SM += iAP_SM/3;
				iAP_L  += iAP_L/3;
			}
			
			if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
				if (m_pClientList[sAttackerH]->m_iLevel <= 80) {
					iAP_SM += iAP_SM;
					iAP_L += iAP_L;
				}
				else if (m_pClientList[sAttackerH]->m_iLevel <= 100) {
					iAP_SM += (iAP_SM* 7)/10;
					iAP_L += (iAP_L* 7)/10;
				} else {
					iAP_SM += iAP_SM/3;
					iAP_L += iAP_L/3;
				}
			}
		}

		switch (cTargetType) {
		case DEF_OWNERTYPE_PLAYER:
			ClearSkillUsingStatus(sTargetH);
			if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) {
				return 0;
			}
			else {
				switch (cAttackerSA) {
					case 62:
						if (m_pClientList[sTargetH]->m_iRating < 0) {
							iTemp = abs(m_pClientList[sTargetH]->m_iRating)/10;
							if (iTemp > 10) iTemp = 10;
							iAP_SM += iTemp;
						}
						break;
				}

				iAP_Abs_Armor  = 0;
				iAP_Abs_Shield = 0;
				iTemp = iDice(1,10000);
				if ((iTemp >= 1) && (iTemp < 5000))           iHitPoint = 1;
				else if ((iTemp >= 5000) && (iTemp < 7500))   iHitPoint = 2;
				else if ((iTemp >= 7500) && (iTemp < 9000))   iHitPoint = 3;
				else if ((iTemp >= 9000) && (iTemp <= 10000)) iHitPoint = 4;

				switch (iHitPoint) {
				case 1:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] > 0) {
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;
						iAP_Abs_Armor = (int)dTmp3;
					}
					break;
				case 2:
					if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
						m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) > 0) {
							if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
								m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) >= 80)
								dTmp1 = 80.0f;
							else dTmp1 = (double)(m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] + m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]);
							dTmp2 = (double)iAP_SM;
							dTmp3 = (dTmp1 / 100.0f) * dTmp2;

							iAP_Abs_Armor = (int)dTmp3;
						}
						break;

				case 3: 
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] > 0) {
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 4:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] > 0) {
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] >= 80)
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;
				}

				if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield > 0) {
					if (iDice(1,100) <= (m_pClientList[sTargetH]->m_cSkillMastery[11])) {
						CalculateSSN_SkillIndex(sTargetH, 11, 1);
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield >= 80) 
							dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Shield;
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Shield = (int)dTmp3;

						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
							if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
								m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
							if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) {
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
								ReleaseItemHandler(sTargetH, iTemp, TRUE);
							}
						}
					}
				}

				iAP_SM = iAP_SM - (iAP_Abs_Armor + iAP_Abs_Shield);
				if (iAP_SM <= 0) iAP_SM = 1;

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_bIsSpecialAbilityEnabled == TRUE)) {
					switch (m_pClientList[sAttackerH]->m_iSpecialAbilityType) {
						case 0: break;
						case 1:
							iTemp = (m_pClientList[sTargetH]->m_iHP / 2);
							if (iTemp > iAP_SM) iAP_SM = iTemp;
							if (iAP_SM <= 0) iAP_SM = 1;
							break;
						case 2:
							if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sTargetH, DEF_OWNERTYPE_PLAYER, TRUE);
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + 30000, 
									sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
							break;
						case 3:
							if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 0) {
								m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 2;
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + 10000, 
									sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 10, NULL, NULL);
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, 10, NULL, NULL);
							}
							break;
						case 4:
							iAP_SM = (m_pClientList[sTargetH]->m_iHP);
							break;
						case 5:
							m_pClientList[sAttackerH]->m_iHP += iAP_SM;
							if (iGetMaxHP(sAttackerH) < m_pClientList[sAttackerH]->m_iHP) m_pClientList[sAttackerH]->m_iHP = iGetMaxHP(sAttackerH);
							SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
							break;
					}
				}

				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
						case 50:
							if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
								sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
							else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
							if (sWeaponIndex != -1)	m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
							break;
						case 51:
							if (iHitPoint == m_pClientList[sTargetH]->m_iSpecialAbilityEquipPos)
								iAP_SM = 0;
							break;
						case 52:
							iAP_SM = 0;
							break;
					}
				}

				if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
					(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iAP_SM)) {
						iAP_SM = m_pClientList[sTargetH]->m_iHP - 1;
					}

				switch (iHitPoint) {
				case 1:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						CalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;

				case 2:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						CalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					else {
						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
							CalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
						}
					}
					break;

				case 3:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						CalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;

				case 4:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						CalculateEnduranceDecrement(sTargetH, sAttackerH, cTargetType, iTemp);
					}
					break;
				}
	
				if ((cAttackerSA == 2) && (m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] != 0)) {
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT ], NULL, NULL);
					switch(m_pClientList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]) {
					case 1:
						SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
						break;
					case 2:
					case 5:
						SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
						break;
					case 3:
					case 4:
						SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
						break;
					}
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);
				}

				if ( (m_pClientList[sTargetH]->m_bIsPoisoned == FALSE) && 
					((cAttackerSA == 5) || (cAttackerSA == 6) || (cAttackerSA == 61)) ) {
					if (bCheckResistingPoisonSuccess(sTargetH, DEF_OWNERTYPE_PLAYER) == FALSE) {
						m_pClientList[sTargetH]->m_bIsPoisoned = TRUE;
						if (cAttackerSA == 5)		m_pClientList[sTargetH]->m_iPoisonLevel = 15;
						else if (cAttackerSA == 6)  m_pClientList[sTargetH]->m_iPoisonLevel = 40;
						else if (cAttackerSA == 61) m_pClientList[sTargetH]->m_iPoisonLevel = iAttackerSAvalue;

						m_pClientList[sTargetH]->m_dwPoisonTime = dwTime;
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sTargetH]->m_iPoisonLevel, NULL, NULL);
						SetPoisonFlag(sTargetH, DEF_OWNERTYPE_PLAYER, TRUE);
					}
				}

				m_pClientList[sTargetH]->m_iHP -= iAP_SM;
				if (m_pClientList[sTargetH]->m_iHP <= 0) {
					if (cAttackerType == DEF_OWNERTYPE_PLAYER)
						bAnalyzeCriminalAction(sAttackerH, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iAP_SM);	
					bKilled     = TRUE;
					iKilledDice = m_pClientList[sTargetH]->m_iLevel;
				}
				else {
					if (iAP_SM > 0) {
						if (m_pClientList[sTargetH]->m_iAddTransMana > 0) {
							dTmp1 = (double)m_pClientList[sTargetH]->m_iAddTransMana;
							dTmp2 = (double)iAP_SM;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iTemp = (2*m_pClientList[sTargetH]->m_iMag) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->m_iInt/2);
							m_pClientList[sTargetH]->m_iMP += (int)dTmp3;
							if (m_pClientList[sTargetH]->m_iMP > iTemp) m_pClientList[sTargetH]->m_iMP = iTemp;
						}
						if (m_pClientList[sTargetH]->m_iAddChargeCritical > 0) {
							if (iDice(1,100) < (m_pClientList[sTargetH]->m_iAddChargeCritical)) {
								iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
								if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
									SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
							}
						}

					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

					if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
						sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
					else sAttackerWeapon = 1;

					if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
						iMoveDamage = 60;
					else iMoveDamage = 40;

					if (iAP_SM >= iMoveDamage) {
						if (sTgtX == sAtkX) {
							if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE;
								else if (sTgtY > sAtkY) cDamageMoveDir = 5;
								else if (sTgtY < sAtkY) cDamageMoveDir = 1;
							}
							else if (sTgtX > sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 3;
									else if (sTgtY > sAtkY) cDamageMoveDir = 4;
									else if (sTgtY < sAtkY) cDamageMoveDir = 2;
								}
								else if (sTgtX < sAtkX) {
									if (sTgtY == sAtkY)     cDamageMoveDir = 7;
										else if (sTgtY > sAtkY) cDamageMoveDir = 6;
										else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
								}
							m_pClientList[sTargetH]->m_iLastDamage = iAP_SM;

							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iAP_SM, sAttackerWeapon, NULL);
						}
						else {
CAE_SKIPDAMAGEMOVE:;
							int iProb;
							if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
								switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
									case 6 : iProb = 3500; break;
									case 8 : iProb = 1000; break;
									case 9 : iProb = 2900; break;
									case 10: iProb = 2500; break;
									case 14: iProb = 2000; break;
									case 21: iProb = 2000; break;
									default: iProb = 1; break;
								}
							}
							else iProb = 1;

							if (iDice(1,10000) >= iProb) 
								SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iAP_SM, sAttackerWeapon, NULL);		
							}

							if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
								m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
								bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
							}

							m_pClientList[sTargetH]->m_iSuperAttackCount++;
							if (m_pClientList[sTargetH]->m_iSuperAttackCount > 14) { 
								m_pClientList[sTargetH]->m_iSuperAttackCount = 0;
								iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
								if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
									SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
							}
						}
					}
				}
				break;				   

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_DEAD) return 0;
			if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return 0;
			if (m_bIsCrusadeMode == TRUE) {
				if (cAttackerSide == m_pNpcList[sTargetH]->m_cSide) {
					switch (m_pNpcList[sTargetH]->m_sType) {
						case 40:
						case 41:
						case 43:
						case 44:
						case 45:
						case 46:
						case 47: 
						case 51:
							return 0;

						default: break;
					}
				}
				else {
					switch (m_pNpcList[sTargetH]->m_sType) {
						case 41:
							if (cAttackerSide != 0) {
								m_pNpcList[sTargetH]->m_iV1 += iAP_L;
								if (m_pNpcList[sTargetH]->m_iV1 > 500) {
									m_pNpcList[sTargetH]->m_iV1 = 0;
									m_pNpcList[sTargetH]->m_iManaStock--;
									if (m_pNpcList[sTargetH]->m_iManaStock <= 0) m_pNpcList[sTargetH]->m_iManaStock = 0;
									wsprintf(G_cTxt, "ManaStock down: %d", m_pNpcList[sTargetH]->m_iManaStock);
									PutLogList(G_cTxt);
								}
							}
							break;
					}
				}
			}
			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
				case 1:
				case 2:
				return 0;
				}

			if (m_pNpcList[sTargetH]->m_cSize == 0)	
				iDamage = iAP_SM;					
			else iDamage = iAP_L;

			if (m_pNpcList[sTargetH]->m_iAbsDamage < 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)(abs(m_pNpcList[sTargetH]->m_iAbsDamage))/100.0f;
				dTmp3 = dTmp1 * dTmp2;
				dTmp2 = dTmp1 - dTmp3;
				iDamage = (int)dTmp2;
				if (iDamage < 0) iDamage = 1;
				else if ((m_pNpcList[sTargetH]->m_sType == 31) && (cAttackerType == 1) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_iSpecialAbilityType == 7))
					iDamage += iDice(3,2);
			}


			if ((cAttackerSA == 2) && (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0)) {
					switch(m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT]) {
					case 1:
						SetProtectionFromArrowFlag(sTargetH, DEF_OWNERTYPE_NPC, FALSE);
						break;
					case 2:
					case 5:
						SetMagicProtectionFlag(sTargetH, DEF_OWNERTYPE_NPC, FALSE);
						break;
					case 3:
					case 4:
						SetDefenseShieldFlag(sTargetH, DEF_OWNERTYPE_NPC, FALSE);
						break;
					}
				m_pNpcList[sTargetH]->m_cMagicEffectStatus[DEF_MAGICTYPE_PROTECT] = NULL;
				bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_PROTECT);					  
			}

			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
			case 0:
			case 3:
			case 5:
				m_pNpcList[sTargetH]->m_iHP -= iDamage;
				break;
			}

			if (m_pNpcList[sTargetH]->m_iHP <= 0) {
				NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
				bKilled = TRUE;
				iKilledDice = m_pNpcList[sTargetH]->m_iHitDice;
			}
			else {
				if ((m_pNpcList[sTargetH]->m_sType != 21) && (m_pNpcList[sTargetH]->m_sType != 55) && (m_pNpcList[sTargetH]->m_sType != 56)
					&& (m_pNpcList[sTargetH]->m_cSide == cAttackerSide)) goto CAE_SKIPCOUNTERATTACK;

				if (m_pNpcList[sTargetH]->m_cActionLimit != 0) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_bIsPermAttackMode == TRUE) goto CAE_SKIPCOUNTERATTACK;
				if ((m_pNpcList[sTargetH]->m_bIsSummoned == TRUE) && (m_pNpcList[sTargetH]->m_iSummonControlMode == 1)) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_sType == 51) goto CAE_SKIPCOUNTERATTACK;

				if (iDice(1,3) == 2) {
					if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
						tX = tY = 0;
						switch (m_pNpcList[sTargetH]->m_cTargetType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) {
									tX = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
									tY = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) {
									tX = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
									tY = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
								}
								break;
							}

						iDst1 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);

						tX = tY = 0;
						switch (cAttackerType) {
							case DEF_OWNERTYPE_PLAYER:
								if (m_pClientList[sAttackerH] != NULL) {
									tX = m_pClientList[sAttackerH]->m_sX;
									tY = m_pClientList[sAttackerH]->m_sY;
								}
								break;

							case DEF_OWNERTYPE_NPC:
								if (m_pNpcList[sAttackerH] != NULL) {
									tX = m_pNpcList[sAttackerH]->m_sX;
									tY = m_pNpcList[sAttackerH]->m_sY;
								}
								break;
						}

						iDst2 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);

						if (iDst2 <= iDst1) {
							m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
							m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
							m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
							m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
						}
					}
					else {
						m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
						m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
					}
				}

CAE_SKIPCOUNTERATTACK:;

				if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0))
					m_pNpcList[sTargetH]->m_dwTime = dwTime;

				if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
					sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
				else sAttackerWeapon = 1;

				if ((wWeaponType < 40) && (m_pNpcList[sTargetH]->m_cActionLimit == 4)) {
 					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE2;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
					}

					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];

					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
					}

					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;

					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);

 					if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) {
						if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
							iExp = (m_pNpcList[sTargetH]->m_iExp/3);
							if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0)
								iExp += m_pNpcList[sTargetH]->m_iNoDieRemainExp;

							if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}

							if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

							GetExp(sAttackerH, iExp);

							DeleteNpc(sTargetH);
							return FALSE;
						}
					}

CAE_SKIPDAMAGEMOVE2:;
				}
				else {
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, sAttackerWeapon, NULL);
				}

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}
				else if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 2) {
					if ((m_pNpcList[sTargetH]->m_iHitDice > 50) && (iDice(1, 10) == 5)) {
						m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
						bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
					}
				}

				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					(cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
						if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
							iExp = iDamage;
							m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
						}
						else {
							iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
							m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
						}

						if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
							dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
							dTmp2 = (double)iExp;
							dTmp3 = (dTmp1/100.0f)*dTmp2;
							iExp += (int)dTmp3;
						}

						if (m_bIsCrusadeMode == TRUE) iExp = iExp/3;

						if (m_pClientList[sAttackerH]->m_iLevel > 100 ) {
							switch (m_pNpcList[sTargetH]->m_sType) {
							case 55:
							case 56:
								iExp = 0;
								break;
							default: break;
							}
						}
					}
			}
			break;
		}

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
				sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];

			if ((sWeaponIndex != -1) && (bArrowUse != TRUE)) {
				if ((m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) &&
					(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum != 231) ) {
						if (bKilled == FALSE)
							CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, 1);
						else {
							if (m_pClientList[sAttackerH]->m_iHP <= 3)
								CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice)*2);
							else CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice));
						}
					}

					if ( (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) && 
						(m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wMaxLifeSpan != 0) ) {
							iWepLifeOff = 1;
							if ((wWeaponType >= 1) && (wWeaponType < 40)) {
								switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
								case 0:	break;
								case 1:	if (iDice(1,3) == 1) iWepLifeOff++; break;
								case 2:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,2); break;
								case 3:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,3); break;
								}
							}

							if (m_pClientList[sAttackerH]->m_cSide != 0) {
								if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan < iWepLifeOff) 
									m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
								else m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan -= iWepLifeOff;
							}

							if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan == 0) {
								SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_cEquipPos, sWeaponIndex, NULL, NULL);
								ReleaseItemHandler(sAttackerH, sWeaponIndex, TRUE);
							}
						}
			}
			else {
				if (wWeaponType == 0) {
					CalculateSSN_SkillIndex(sAttackerH, 5, 1);
				}
			}
		}
	}
	else {
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
		}
	}

	return iExp;
}

// October 19, 2004 - 3.51 translated
void CGame::_GrandMagicLaunchMsgSend(int iType, char cAttackerSide)
{
 char * cp, cBuff[120];
 WORD * wp;

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_GRANDMAGICLAUNCH;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)iType;
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)cAttackerSide;
	cp += 2;
	
	bStockMsgToGateServer(cBuff, 5);
}

// October 19, 2004 - 3.51 translated
BOOL CGame::_bNpcBehavior_ManaCollector(int iNpcH)
{
 int dX, dY, iMaxMP, iTotal;
 short sOwnerH;
 char  cOwnerType;
 double dV1, dV2, dV3;
 BOOL bRet;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;

	bRet = FALSE;
	for (dX = m_pNpcList[iNpcH]->m_sX-5; dX <= m_pNpcList[iNpcH]->m_sX+5; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-5; dY <= m_pNpcList[iNpcH]->m_sY+5; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pNpcList[iNpcH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) {
					iMaxMP = (2*m_pClientList[sOwnerH]->m_iMag) + (2*m_pClientList[sOwnerH]->m_iLevel) + (m_pClientList[sOwnerH]->m_iInt/2);
					if (m_pClientList[sOwnerH]->m_iMP < iMaxMP) {
						iTotal = iDice(1, (m_pClientList[sOwnerH]->m_iMag));
						if (m_pClientList[sOwnerH]->m_iAddMP != 0) {
							dV2 = (double)iTotal;
							dV3 = (double)m_pClientList[sOwnerH]->m_iAddMP;
							dV1 = (dV3 / 100.0f)*dV2;
							iTotal += (int)dV1;
						}

						m_pClientList[sOwnerH]->m_iMP += iTotal;
		
						if (m_pClientList[sOwnerH]->m_iMP > iMaxMP) 
							m_pClientList[sOwnerH]->m_iMP = iMaxMP;

						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
					}
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if ((m_pNpcList[sOwnerH]->m_sType == 42) && (m_pNpcList[sOwnerH]->m_iV1 > 0)) {
					if (m_pNpcList[sOwnerH]->m_iV1 >= 3) {
						m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += 3;
						m_pNpcList[sOwnerH]->m_iV1 -= 3;
						bRet = TRUE;
					}
					else {
						m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide] += m_pNpcList[sOwnerH]->m_iV1; 
						m_pNpcList[sOwnerH]->m_iV1 = 0;
						bRet = TRUE;
					}
				}
				break;
			}
		}
	}
	return bRet;
}

// October 19, 2004 - 3.51 translated
void CGame::MeteorStrikeMsgHandler(char cAttackerSide)
{
 int i;
 DWORD dwTime = timeGetTime();
	
	switch (cAttackerSide) {
	case 1:
		if (m_iElvineMapIndex != -1) {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine") == 0) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 1, NULL, NULL, NULL);
				}
				else {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
				}
			}
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 5000, NULL, NULL, m_iElvineMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
			}
		}
		break;

	case 2:
		if (m_iAresdenMapIndex != -1) {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden") == 0) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 3, NULL, NULL, NULL);
				}
				else {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
				}
			}
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 1000*5, NULL, NULL, m_iAresdenMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
			}
		}
		break;
	}
}

// October 19, 2004 - 3.51 translated
void CGame::_NpcBehavior_GrandMagicGenerator(int iNpcH)
{
	switch (m_pNpcList[iNpcH]->m_cSide) {
	case 1:
		if (m_iAresdenMana > DEF_GMGMANACONSUMEUNIT) {
			m_iAresdenMana = 0 ; 
			m_pNpcList[iNpcH]->m_iManaStock++;
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				_GrandMagicLaunchMsgSend(1, 1);
				MeteorStrikeMsgHandler(1);
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iAresdenMana = 0;
			}
			wsprintf(G_cTxt, "(!) Aresden GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
			PutLogList(G_cTxt);
		}
		break;

	case 2:
		if (m_iElvineMana > DEF_GMGMANACONSUMEUNIT) {
			m_iElvineMana = 0 ; 
			m_pNpcList[iNpcH]->m_iManaStock++;
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				_GrandMagicLaunchMsgSend(1, 2);
				MeteorStrikeMsgHandler(2);
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iElvineMana = 0;
			}
			wsprintf(G_cTxt, "(!) Elvine GMG %d/%d", m_pNpcList[iNpcH]->m_iManaStock, m_pNpcList[iNpcH]->m_iMaxMana);
			PutLogList(G_cTxt);
		}
		break;
	}
}

// October 19, 2004 - 3.51 translated
BOOL CGame::_bNpcBehavior_Detector(int iNpcH)
{
int dX, dY;
 short sOwnerH;
 char  cOwnerType, cSide;
 BOOL  bFlag = FALSE;
                       
	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;

	for (dX = m_pNpcList[iNpcH]->m_sX-10; dX <= m_pNpcList[iNpcH]->m_sX+10; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-10; dY <= m_pNpcList[iNpcH]->m_sY+10; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

		cSide = 0;
		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				cSide = m_pClientList[sOwnerH]->m_cSide;
				break;

			case DEF_OWNERTYPE_NPC:
				cSide = m_pNpcList[sOwnerH]->m_cSide;
				break;
			}
		}

		if ((cSide != 0) && (cSide != m_pNpcList[iNpcH]->m_cSide)) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
					SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);			
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
					SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);			
				}
				break;
			}
			
			bFlag = TRUE;
		}
	}

	return bFlag;
}

// October 19,2004 - 3.51 translated
void CGame::NpcBehavior_Dead(int iNpcH)			   
{
 DWORD dwTime;

	if (m_pNpcList[iNpcH] == NULL) return; 

	dwTime = timeGetTime();
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
	}

	if ((dwTime - m_pNpcList[iNpcH]->m_dwDeadTime) > m_pNpcList[iNpcH]->m_dwRegenTime)
		DeleteNpc(iNpcH);
}

// v2.15 2002-8-7 // 2002-09-06 #1
/*BOOL CGame::_bDecodeNpcItemConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iNpcConfigListIndex = 0, k = 0;
 class CStrTok * pStrTok;
 class CNpcItem * pTempNpcItem = NULL ;
  
	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:

				switch (cReadModeB) {

				case 1:
					// NPC ÀÌ¸§
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Too long Npc name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					for (iNpcConfigListIndex = 0; iNpcConfigListIndex < DEF_MAXNPCTYPES; iNpcConfigListIndex++)
						if (m_pNpcConfigList[iNpcConfigListIndex] != NULL) {
							if(strcmp(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName,token) == 0) {
								PutLogList(token);
								break;	
							}
						}
					if (iNpcConfigListIndex == DEF_MAXNPCTYPES ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - No exist Npc Name");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					if( strlen(token) > 2 ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Type Error.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iNpcItemType = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Too long Item name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					if (pTempNpcItem == NULL)
						pTempNpcItem = new class CNpcItem();

					if( memcmp(token,"[ENDITEM]",9) == 0 ){
						cReadModeA = 0 ;
						cReadModeB = 0 ;

						if ( pTempNpcItem  != NULL) {
							delete pTempNpcItem ; 
							pTempNpcItem = NULL ;
						}
						break;
					}
					
					strcpy(pTempNpcItem->m_cName, token);
					if(!m_bReceivedItemList)	// ITEM List°¡ ¿ÀÁö ¾Ê¾Ò´Ù.
					{
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration error - Before Item List receiving.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					for(k=0; k < DEF_MAXITEMTYPES; k++)
					{
						if ( m_pItemConfigList[k] == NULL )
							continue;
			
						if (strcmp(token, m_pItemConfigList[k]->m_cName) == 0 ) {
							pTempNpcItem->m_sItemID = m_pItemConfigList[k]->m_sIDnum;
							break;
						}
					}

					if ( k == DEF_MAXITEMTYPES ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration error - Do Not exist in ITEM LIST");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeB = 4;
					break;

				case 4:
					// Ã¹¹øÂ° È®·ü
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					pTempNpcItem->m_sFirstProbability = atoi(token);

					if (pTempNpcItem->m_sFirstProbability <= 0 ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - First probability have wrong value");
						delete pContents;
						delete pStrTok;
						return FALSE ; 
					}

					// Ã¹¹øÂ° È®·ü¿¡ ´ëÇÑ Å¸°Ù°ªÀ» ÀÓÀÇ·Î ÁØ´Ù. 
					if ( pTempNpcItem->m_sFirstProbability > 13) 
						pTempNpcItem->m_cFirstTargetValue = 13;
					else if ( pTempNpcItem->m_sFirstProbability > 3) 
						pTempNpcItem->m_cFirstTargetValue = 3;
					else 
						pTempNpcItem->m_cFirstTargetValue = 1;
						
					cReadModeB = 5;
					break;

				case 5:
					// µÎ¹øÂ° È®·ü
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					pTempNpcItem->m_sSecondProbability = atoi(token);

					if (pTempNpcItem->m_sSecondProbability <= 0 ) {
						PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file error - Second probability have wrong value");
						delete pContents;
						delete pStrTok;
						return FALSE ; 
					}

					// µÎ¹øÂ° È®·ü¿¡ ´ëÇÑ Å¸°Ù°ªÀ» ÀÓÀÇ·Î ÁØ´Ù. 
					if ( pTempNpcItem->m_sSecondProbability > 13) 
						pTempNpcItem->m_cSecondTargetValue = 13 ;
					else if ( pTempNpcItem->m_sSecondProbability > 3) 
						pTempNpcItem->m_cSecondTargetValue = 3 ;
					else 
						pTempNpcItem->m_cSecondTargetValue = 1 ;

					cReadModeB = 3;
			
					// vector¿¡ ÇöÀç ±îÁö ÀĞ¾î µå¸° °ªÀ» ³Ö´Â´Ù. 
					m_pNpcConfigList[iNpcConfigListIndex]->m_vNpcItem.push_back(*pTempNpcItem);

					// 2002-09-17 #1 NPCITEM Type 2ÀÏ °æ¿ì
					if( m_pNpcConfigList[iNpcConfigListIndex]->m_iNpcItemMax < pTempNpcItem->m_sSecondProbability )
						m_pNpcConfigList[iNpcConfigListIndex]->m_iNpcItemMax = pTempNpcItem->m_sSecondProbability;

					break;

				} // switch #2

			default: 
				break;

			} // switch #1
		} // if
		else {

			if (memcmp(token, "NpcItem", 7) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			
			}
		}
		token = pStrTok->pGet();
	}

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! NPCITEM configuration file contents error!");
		return FALSE;
	}

	return TRUE;

} // _bDecodeNpcItemConfigFileContents()*/

BOOL CGame::bGetItemNameWhenDeleteNpc(int & iItemID, short sNpcType)
{ 
	int iResult; 
	// NPCë¥¼ ì‚­ì œí• ë•Œ íŠ¹ìˆ˜ ì•„ì´í…œì„ ë°œìƒì‹œí‚¬ ê²ƒì¸ì§€ì˜ ì—¬ë¶€ë¥¼ ê³„ì‚°í•œë‹¤. 

	switch (sNpcType) { 
		case 49: // Hellclaw 
			iResult = iDice(1,20000);
			if ((iResult >= 1) && (iResult <=  5000)) iItemID = 308 ;		    // MagicNecklace(MS10)
			else if ((iResult > 5000) && (iResult <=  10000)) iItemID = 259 ;	// MagicWand(M.Shield)
			else if ((iResult > 10000) && (iResult <= 13000))  iItemID = 337 ;  // RubyRing
			else if ((iResult > 13000) && (iResult <= 15000))  iItemID = 335 ;  // EmeraldRing
			else if ((iResult > 15000) && (iResult <= 17500))  iItemID = 300 ;  // MagicNecklace(RM10)
			else if ((iResult > 17500) && (iResult <= 18750))  iItemID = 311 ;  // MagicNecklace(DF+10)
			else if ((iResult > 18750) && (iResult <= 19000))  iItemID = 305 ;  // MagicNecklace(DM+1)
			else if ((iResult > 19000) && (iResult <= 19700))  iItemID = 634 ;  // RingofWizard
			else if ((iResult > 19700) && (iResult <= 19844))  iItemID = 635 ;  // RingofMage
			else if ((iResult > 19844) && (iResult <= 19922))  iItemID = 643 ;  // KnecklaceOfIceEle	
			else if ((iResult > 19922) && (iResult <= 19961))  iItemID = 640 ;  // KnecklaceOfSufferent
			else if ((iResult > 19961) && (iResult <= 19981))  iItemID = 637 ;  // KnecklaceOfLightPro
			else if ((iResult > 19981) && (iResult <= 19991))  iItemID = 620 ;  // MerienShield	
			else if ((iResult > 19991) && (iResult <= 19996))  iItemID = 644 ;  // KnecklaceOfAirEle	
			else if ((iResult > 19996) && (iResult <= 19999))  iItemID = 614 ;  // SwordofIceElemental	
			else if ((iResult > 19999) && (iResult <= 20000))  iItemID = 636 ;	// RingofGrandMage
			return TRUE;
		
		case 50: // Tigerworm
			iResult = iDice(1,10000);
			if ((iResult >= 1) && (iResult <= 4999)) {
				if (iDice(1,2) == 1) 
					 iItemID = 311 ;  // MagicNecklace(DF+10)
				else iItemID = 305 ;  // MagicNecklace(DM+1)
			}
			else if ((iResult > 5000) && (iResult <= 7499))  iItemID = 614 ;  // SwordofIceElemental	
			else if ((iResult > 7500) && (iResult <= 8749))  iItemID = 290 ;  // Flameberge+3(LLF)
			else if ((iResult > 8750) && (iResult <= 9374))  iItemID = 633 ;  // RingofDemonpower
			else if ((iResult > 9375) && (iResult <= 9687))  iItemID = 492 ;  // BloodRapier		
			else if ((iResult > 9688) && (iResult <= 9843))  iItemID = 490 ;  // BloodSword		
			else if ((iResult > 9844) && (iResult <= 9921))  iItemID = 491 ;  // BloodAxe		
			else if ((iResult > 9922) && (iResult <= 9960))  iItemID = 291 ;  // MagicWand(MS30-LLF)	
			else if ((iResult > 9961) && (iResult <= 9980))  iItemID = 630 ;  // RingoftheXelima	
			else if ((iResult > 9981) && (iResult <= 9990))  iItemID = 612 ;  // XelimaRapier	
			else if ((iResult > 9991) && (iResult <= 9996))  iItemID = 610 ;  // XelimaBlade	
			else if ((iResult > 9996) && (iResult <= 9998))  iItemID = 611 ;  // XelimaAxe	
			else if ((iResult > 9999) && (iResult <= 10000)) iItemID = 631 ;  // RingoftheAbaddon
			return TRUE;

			default:
		   break; 
		}

	if (iDice(1,45) == 13) {
		switch (sNpcType) {
		case 11: if (iDice(1,550) != 11) return FALSE; break;	  // Skeleton   2 * 100	
		case 12: if (iDice(1,400) != 11) return FALSE; break;	  // Stone-Golem 2 * 100	
		case 13: if (iDice(1,100) != 11) return FALSE; break;	  // Cyclops  6 * 100	
		case 14: if (iDice(1,700) != 11) return FALSE; break;	  // Orc 4 * 100	
		case 17: if (iDice(1,600) != 11) return FALSE; break;	  // Scorpoin 5 * 100	
		case 18: if (iDice(1,850) != 11) return FALSE; break;	  // Zombie 1 * 100	
		case 22: if (iDice(1,600) != 11) return FALSE; break;	  // Amphis 5 * 100	
		case 23: if (iDice(1,400) != 11) return FALSE; break;	  // Clay-Golem 2 * 100	
		case 27: if (iDice(1,100) != 11) return FALSE; break;	  // Hellhound 7 * 100	
		case 28: if (iDice(1,100) != 11) return FALSE; break;	  // Troll 5 * 100	
		case 29: if (iDice(1,150) != 11) return FALSE; break;	  // Orge  7 * 100	
		case 30: if (iDice(1,120) != 11) return FALSE; break;	  // Liche 1 * 100   
		case 31: break; 	                                      // Demon 5 * 100	
		case 32: if (iDice(1,200) != 11) return FALSE; break;	  // Unicorn 5 * 100	
		case 33: if (iDice(1,300) != 11) return FALSE; break;	  // WereWolf 7 * 100
		case 48: if (iDice(1,100) != 11) return FALSE; break;	  // Stalker 
		case 52: if (iDice(1,300) != 11) return FALSE; break;     // Gagoyle
		case 53: if (iDice(1,500) != 11) return FALSE; break;	  // Beholder
		case 54: if (iDice(1,200) != 11) return FALSE; break;	  // Dark-Elf
		case 57: if (iDice(1,400) != 11) return FALSE; break;	  // Giant-Frog
		case 63: if (iDice(1,300) != 11) return FALSE; break;	  // Frost
		case 79: if (iDice(1,200) != 11) return FALSE; break;	  // Nizie
		case 70: if (iDice(1,200) != 11) return FALSE; break;	  // Barlog
		case 71: if (iDice(1,200) != 11) return FALSE; break;	  // Centaurus
		default: return FALSE;
		}
	}
	else return FALSE;

//http://www.helbreath.com/down/d_patch_v2.htm

	switch (sNpcType) {
	case 11: // Skeleton
	case 17: // Scorpoin
	case 14: // Orc
	case 28: // Troll
	case 57: // Giant-Frog
		switch (iDice(1,7)) {
		case 1: iItemID = 334 ; break; // LuckyGoldRing
		case 2: iItemID = 336 ; break; // SapphireRing
		case 3: if (iDice(1,15) == 3) iItemID = 335 ; break; // EmeraldRing
		case 4: iItemID = 337 ; break; // RubyRing
		case 5: iItemID = 333 ; break; // PlatinumRing
		case 6: if (iDice(1,15) == 3) iItemID = 634 ; break; // RingofWizard
		case 7: if (iDice(1,25) == 3) iItemID = 635 ; break; // RingofMage
		}
		break;
	
	case 13: // Cyclops
	case 27: // Hellhound
	case 29: // Orge
		switch (iDice(1,7)) {
		case 1: iItemID = 311 ; break; // MagicNecklace(DF+10)
		case 2: if (iDice(1,20) == 13) iItemID = 308 ; break; // MagicNecklace(MS10)
		case 3: if (iDice(1,10) == 13) iItemID = 305 ; break; // MagicNecklace(DM+1)
		case 4: iItemID = 300 ; break; // MagicNecklace(RM10)
		case 5: if (iDice(1,30) == 13) iItemID = 632 ; break; // RingofOgrepower
		case 6: if (iDice(1,30) == 13) iItemID = 637 ; break; // KnecklaceOfLightPro
		case 7: if (iDice(1,30) == 13) iItemID = 638 ; break; // KnecklaceOfFirePro
			}
		break;

	case 18: // Zombie
	case 22: // Amphis
		switch (iDice(1,4)) {
		case 1: if (iDice(1,75) == 13) iItemID = 613 ; break; // SwordofMedusa
		case 2: if (iDice(1,20) == 13) iItemID = 639 ; break; // KnecklaceOfPoisonPro
		case 3: if (iDice(1,40) == 13) iItemID = 641 ; break; // KnecklaceOfMedusa
		case 4: if (iDice(1,30) == 13) iItemID = 640 ; break; // KnecklaceOfSufferent
		}
		break;

	case 12: // Stone-Golem
		switch (iDice(1,5)) {
		case 1: if (iDice(1,40) == 13) iItemID = 620 ; break; // MerienShield
		case 2: if (iDice(1,40) == 13) iItemID = 621 ; break; // MerienPlateMail(M)
		case 3: if (iDice(1,40) == 13) iItemID = 622 ; break; // MerienPlateMail(W)
		case 4: if (iDice(1,20) == 11) iItemID = 644 ; break; // KnecklaceOfAirEle
		case 5: if (iDice(1,20) == 11) iItemID = 647 ; break; // KnecklaceOfStoneGolem
		}
		break;

	case 23: // Clay-Golem
		switch (iDice(1,4)) {
		case 1: if (iDice(1,40) == 13) iItemID = 620 ; break; // MerienShield	
		case 2: if (iDice(1,40) == 13) iItemID = 621 ; break; // MerienPlateMail(M)
		case 3: if (iDice(1,40) == 13) iItemID = 622 ; break; // MerienPlateMail(W)
		case 4: if (iDice(1,20) == 11) iItemID = 644 ; break; // KnecklaceOfAirEle
		}
		break;

	case 32: // Unicorn
		switch (iDice(1,4)) {
		case 1: if (iDice(1,40) == 13) iItemID = 620 ; break; // MerienShield	
		case 2: if (iDice(1,40) == 13) iItemID = 621 ; break; // MerienPlateMail(M)
		case 3: if (iDice(1,40) == 13) iItemID = 622 ; break; // MerienPlateMail(W)
		case 4: if (iDice(1,20) == 11) iItemID = 644 ; break; // KnecklaceOfAirEle
		case 5: if (iDice(1,20) == 11) iItemID = 848 ; break; // Lighting Blade
		}
		break;
		
	case 33: // WereWolf
	case 48: // Stalker
		switch (iDice(1,2)) {
		case 1: if (iDice(1,30) == 3) iItemID = 290 ; break; // Flameberge+3(LLF)
		case 2: iItemID = 292 ; break; // GoldenAxe(LLF)
		}
		break;

	case 30: // Liche
		switch (iDice(1,8)) {
		case 1: if (iDice(1,10) == 3) iItemID = 380 ; break; // IceStormManual
		case 2: iItemID = 259 ; break; // MagicWand(M.Shield)
		case 3: if (iDice(1,30) == 3) iItemID = 291 ; break; // MagicWand(MS30-LLF)
		case 4: if (iDice(1,10) == 3) iItemID = 614 ; break; // SwordofIceElemental	
		case 5: if (iDice(1,10) == 3) iItemID = 642 ; break; // KnecklaceOfIcePro
		case 6: if (iDice(1,15) == 3) iItemID = 643 ; break; // KnecklaceOfIceEle	
		case 7: if (iDice(1,30) == 3) iItemID = 636 ; break; // RingofGrandMage
		case 8: if (iDice(1,30) == 3) iItemID = 734 ; break; // RingOfArcmage
		}
		break;

	case 31: // Demon 
		switch (iDice(1,8)) {
		case 1: if (iDice(1,30) == 3) iItemID = 382 ; break; // BloodyShockW.Manual
		case 2: iItemID = 491 ; break; // BloodAxe
		case 3: if (iDice(1,10) == 3) iItemID = 490 ; break; // BloodSword
		case 4: iItemID = 492 ; break; // BloodRapier
		case 5: if (iDice(1,10) == 3) iItemID = 381 ; break; // MassFireStrikeManual
		case 6: if (iDice(1,30) == 3) iItemID = 633 ; break; // RingofDemonpower
		case 7: if (iDice(1,10) == 3) iItemID = 645 ; break; // KnecklaceOfEfreet
		case 8: if (iDice(1,20) == 3) iItemID = 616 ; break; // DemonSlayer
		}
		break;

	case 52: // Gagoyle
		switch (iDice(1,11)) {
		case 1: if (iDice(1,30) == 3) iItemID = 382 ; break; // BloodyShockW.Manual	
		case 2: if (iDice(1,20) == 3) iItemID = 610 ; break; // XelimaBlade	
		case 3: if (iDice(1,20) == 3) iItemID = 611 ; break; // XelimaAxe	
		case 4: if (iDice(1,20) == 3) iItemID = 612 ; break; // XelimaRapier
		case 5: if (iDice(1,10) == 3) iItemID = 381 ; break; // MassFireStrikeManual
		case 6: if (iDice(1,30) == 3) iItemID = 633 ; break; // RingofDemonpower
		case 7: if (iDice(1,10) == 3) iItemID = 645 ; break; // KnecklaceOfEfreet
		case 8: if (iDice(1,40) == 3) iItemID = 630 ; break; // RingoftheXelima	
		case 9: if (iDice(1,50) == 3) iItemID = 631 ; break; // RingoftheAbaddon
		case 10: if (iDice(1,20) == 3) iItemID = 735; break; // RingOfDragonpower
		case 11: if (iDice(1,40) == 3) iItemID = 20 ; break; // Excalibur
		case 12: if (iDice(1,60) == 3) iItemID = 846; break; // The_Devastator
		}
		break;

	case 53: // Beholder
		if (iDice(1,20) == 11) iItemID = 646; break; // KnecklaceOfBeholder	
		break;

	case 54: // Dark-Elf
		if (iDice(1,20) == 11) iItemID = 618; break; // DarkElfBow
		break;

	case 63: // Frost
		if (iDice(1,40) == 11) iItemID = 845; break; // StormBringer	
		break;

	case 79: // Nizie
		if (iDice(1,20) == 11) iItemID = 845; break; // StormBringer	
		break;

	case 70: // Barlog
		if (iDice(1,40) == 11) iItemID = 846; break; // The_Devastator
		break;

	case 71: // Centaurus
		if (iDice(1,20) == 11) iItemID = 848; break; // Lighting Blade
		break;

	} 

	if (iItemID == 0) 
		return FALSE; 
	else return TRUE; 
}

/*BOOL CGame::bGetItemNameWhenDeleteNpc(int &iItemID, short sNpcType)
{ 
 class	CNpcItem * CTempNpcItem;
 int	iResult;
 int	iNpcIndex;
 int	iNumNpcitem;
 int	iIndex;
 int	iDiceValue;
 BOOL	bFirstDice = FALSE, bSecondDice = FALSE;

	for (iNpcIndex = 0; iNpcIndex < DEF_MAXNPCTYPES; iNpcIndex++) {
		if (m_pNpcConfigList[iNpcIndex] != NULL) {
			if (m_pNpcConfigList[iNpcIndex]->m_sType == sNpcType) break; 
		}
	}

	if (iNpcIndex == DEF_MAXNPCTYPES) return FALSE;
	if (m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size() <=  0)  return FALSE; // sub_4BAFD0
	switch (m_pNpcConfigList[iNpcIndex]->m_iNpcItemType) {
	case 1:
		iResult = iDice(1, m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size()) - 1;
		CTempNpcItem = m_pNpcConfigList[iNpcIndex]->m_vNpcItem.at(iResult);
		if (iDice(1,CTempNpcItem.m_sFirstProbability) == CTempNpcItem.m_cFirstTargetValue) bFirstDice  = TRUE;
		if (iDice(1,CTempNpcItem.m_sSecondProbability) == CTempNpcItem.m_cSecondTargetValue) bSecondDice = TRUE;
		if ((bFirstDice == TRUE) && (bSecondDice == TRUE)) {
			iItemID = CTempNpcItem.m_sItemID;
			wsprintf(G_cTxt,"NpcType 1 (%d) size(%d) %s(%d) (%d)", sNpcType, m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size(), CTempNpcItem.m_cName, CTempNpcItem.m_sItemID);
			PutLogList(G_cTxt);
		}
		break;

	case 2:
		iNumNpcitem = m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size(); // sub_4BAFD0
		iDiceValue  = iDice(1, m_pNpcConfigList[iNpcIndex]->m_iNpcItemMax);
		for (iIndex = 0; iIndex < iNumNpcitem; iIndex++) {
			CTempNpcItem = m_pNpcConfigList[iNpcIndex]->m_vNpcItem.at(iIndex); // sub_4BB010
			if(CTempNpcItem.m_sFirstProbability <= iDiceValue && iDiceValue < CTempNpcItem.m_sSecondProbability) {
				iItemID = CTempNpcItem.m_sItemID;
				wsprintf(G_cTxt,"NpcType 2 (%d) size(%d) %s(%d) (%d)", sNpcType, m_pNpcConfigList[iNpcIndex]->m_vNpcItem.size(), CTempNpcItem.m_cName, CTempNpcItem.m_sItemID);
				break;
			}
		}
		break;
	} // switch

	if (iItemID <= 0)
		return FALSE;

	return TRUE;
}*/

/*
void CGame::StormBringer(int iClientH, short dX, short dY)
{
	char cOwnerType;
	short sOwner, sAppr2, sAttackerWeapon;
	int  iDamage, iTemp, iV1, iV2, iV3;

	//ArchAngel Fix

	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] != -1) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);

		iTemp = m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]; 
		sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);

		if (memcmp(m_pClientList[iClientH]->m_pItemList[iTemp]->m_cName, "StormBringer", 12) == 0){ 

			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwner]->m_iAdminUserLevel < 3) {
					if (sAppr2 != 0) {
						iV1 = m_pClientList[iClientH]->m_cAttackDiceThrow_L;
						iV2 = m_pClientList[iClientH]->m_cAttackDiceRange_L;
						iV3 = m_pClientList[iClientH]->m_cAttackBonus_L;

						if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0){
							iDamage = iDice(iV1*2,iV2*2)+iV3;
						}					
						else{
							iDamage = iDice(iV1,iV2)+iV3;
						}

						m_pClientList[sOwner]->m_iHP -= iDamage;
						if (m_pClientList[sOwner]->m_iHP <= 0){
							sAttackerWeapon = 1;
							m_pClientList[sOwner]->m_iHP = 0;

							m_pClientList[sOwner]->m_bIsKilled = TRUE;
							m_pClientList[sOwner]->m_iLastDamage = iDamage;
							SendNotifyMsg(NULL, sOwner, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
							SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, iDamage, sAttackerWeapon, NULL);
							m_pMapList[m_pClientList[sOwner]->m_cMapIndex]->ClearOwner(14, sOwner, DEF_OWNERTYPE_PLAYER, m_pClientList[sOwner]->m_sX, m_pClientList[sOwner]->m_sY);
							m_pMapList[m_pClientList[sOwner]->m_cMapIndex]->SetDeadOwner(sOwner, DEF_OWNERTYPE_PLAYER, m_pClientList[sOwner]->m_sX, m_pClientList[sOwner]->m_sY);
						}
						else{
							SendNotifyMsg(NULL, sOwner, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);	
							SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
						}
					}
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (sAppr2 != 0) {
					if (m_pNpcList[sOwner]->m_cSize == 0){
						iV1 = m_pClientList[iClientH]->m_cAttackDiceThrow_SM;
						iV2 = m_pClientList[iClientH]->m_cAttackDiceRange_SM;
						iV3 = m_pClientList[iClientH]->m_cAttackBonus_SM;
					}
					else if (m_pNpcList[sOwner]->m_cSize == 1){
						iV1 = m_pClientList[iClientH]->m_cAttackDiceThrow_L;
						iV2 = m_pClientList[iClientH]->m_cAttackDiceRange_L;
						iV3 = m_pClientList[iClientH]->m_cAttackBonus_L;
					}

					if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0){
						iDamage = iDice(iV1*2,iV2*2)+iV3;
					}
					else{
						iDamage = iDice(iV1,iV2)+iV3;
					}

					m_pNpcList[sOwner]->m_iHP -= iDamage;
					if (m_pNpcList[sOwner]->m_iHP <= 0){
						sAttackerWeapon = 1;
						m_pNpcList[sOwner]->m_iHP = 0;

						m_pNpcList[sOwner]->m_sBehaviorTurnCount = 0;
						m_pNpcList[sOwner]->m_cBehavior = DEF_BEHAVIOR_DEAD;
						m_pNpcList[sOwner]->m_dwDeadTime = timeGetTime();
						SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, iDamage, sAttackerWeapon, NULL);
						m_pMapList[m_pNpcList[sOwner]->m_cMapIndex]->ClearOwner(10, sOwner, DEF_OWNERTYPE_NPC, m_pNpcList[sOwner]->m_sX, m_pNpcList[sOwner]->m_sY);
						m_pMapList[m_pNpcList[sOwner]->m_cMapIndex]->SetDeadOwner(sOwner, DEF_OWNERTYPE_NPC, m_pNpcList[sOwner]->m_sX, m_pNpcList[sOwner]->m_sY);
					}
					else{
						SendEventToNearClient_TypeA(sOwner, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
					}	
				}
				break;
			}
		}
	}
}*/

BOOL CGame::_bCheckCharacterData(int iClientH)
{
 register int i;

	if ((m_pClientList[iClientH]->m_iStr > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iVit > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iDex > m_sCharStatLimit) ||
        (m_pClientList[iClientH]->m_iMag > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iInt > m_sCharStatLimit) || (m_pClientList[iClientH]->m_iCharisma > m_sCharStatLimit)) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) stat points are greater then server accepts.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}
				
	if ((m_pClientList[iClientH]->m_iLevel > m_sMaxPlayerLevel) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) level above max server level.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}

	if (m_pClientList[iClientH]->m_iExp < 0) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) experience is below 0 - (Exp:%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iExp);
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}

	if ((m_pClientList[iClientH]->m_iHP > iGetMaxHP(iClientH)) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) HP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iHP, iGetMaxHP(iClientH));
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}

	if ((m_pClientList[iClientH]->m_iMP > iGetMaxMP(iClientH)) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) MP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iMP, iGetMaxMP(iClientH));
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}

	if ((m_pClientList[iClientH]->m_iSP > iGetMaxSP(iClientH)) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) {
		wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) SP: current/maximum (%d/%d).", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iSP, iGetMaxSP(iClientH));
		PutHackLogFileList(G_cTxt);
		return FALSE;
	}

	/*if (m_pClientList[iClientH]->m_iAdminUserLevel != 0) {
		for (i = 0; i < DEF_MAXADMINS; i++) {
			if(strlen(m_stAdminList[i].m_cGMName) == 0) break; //No more GM's on list
			if ((strlen(m_stAdminList[i].m_cGMName)) == (strlen(m_pClientList[iClientH]->m_cCharName))) {
				if(memcmp(m_stAdminList[i].m_cGMName, m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) != 0){

				}
				else {
					wsprintf(G_cTxt, "Packet Editing: (%s) Player: (%s) is an unaccepted admin.", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
					PutHackLogFileList(G_cTxt);
					return FALSE;
				}
			}
		}
	}*/

	for (i = 0; i < DEF_MAXBANNED; i++) {
		if(strlen(m_stBannedList[i].m_cBannedIPaddress) == 0) break; //No more GM's on list
		if ((strlen(m_stBannedList[i].m_cBannedIPaddress)) == (strlen(m_pClientList[iClientH]->m_cIPaddress))) {
			if(memcmp(m_stBannedList[i].m_cBannedIPaddress, m_pClientList[iClientH]->m_cIPaddress, strlen(m_pClientList[iClientH]->m_cIPaddress)) == 0){
				wsprintf(G_cTxt,"Client Rejected: Banned: (%s)", m_pClientList[iClientH]->m_cIPaddress);
				PutLogList(G_cTxt);
				return FALSE;
			}
			else {

			}
		}
	}

	return TRUE;
}

void CGame::GlobalEndHeldenianMode()
{
 char * cp, cData[32];

	if (m_bIsHeldenianMode == FALSE) return;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_ENDHELDENIAN; // 22
	cp++;
	
	bStockMsgToGateServer(cData, 1);
	LocalEndHeldenianMode();

}

void CGame::LocalEndHeldenianMode()
{
 register int i, x, n;
	
	if (m_bIsHeldenianMode == FALSE) return;
	m_bIsHeldenianMode = FALSE;
	m_bHeldenianInitiated = TRUE;
	
	m_dwHeldenianFinishTime = time(NULL);
	if (var_88C == 1) {
		if (m_cHeldenianModeType == 1) {
			if (m_iHeldenianAresdenLeftTower > m_iHeldenianElvineLeftTower) {
				m_cHeldenianVictoryType = 1;
			}
			else if (m_iHeldenianAresdenLeftTower < m_iHeldenianElvineLeftTower) {
				m_cHeldenianVictoryType = 2;
			}
			else if (m_iHeldenianAresdenDead < m_iHeldenianElvineDead) {
				m_cHeldenianVictoryType = 1;
			}
			else if (m_iHeldenianAresdenDead > m_iHeldenianElvineDead) {
				m_cHeldenianVictoryType = 2;
			}
			else {
				m_sLastHeldenianWinner = m_cHeldenianVictoryType;
			}
		}
		else if (m_cHeldenianModeType == 2) {
			m_sLastHeldenianWinner = m_cHeldenianVictoryType;
		}
		m_sLastHeldenianWinner = m_cHeldenianVictoryType;
		if (bNotifyHeldenianWinner() == FALSE) {
			wsprintf(G_cTxt, "(!) HELDENIAN End. Result Report Failed");
			PutLogList(G_cTxt);
		}
	}
	wsprintf(G_cTxt, "(!) HELDENIAN End. %d", m_sLastHeldenianWinner);
	PutLogList(G_cTxt);

	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((i < 0) || (i > 100)) break;
	if (m_pMapList[i] != NULL) {
		for (x = 0; x < DEF_MAXCLIENTS; x++)
		if ((m_pClientList[x] != NULL) && (m_pClientList[x]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, x, DEF_NOTIFY_HELDENIANEND, NULL, NULL, NULL, NULL);
			if (m_pMapList[m_pClientList[x]->m_cMapIndex]->m_bIsHeldenianMap == TRUE) {
				for (n = 0; n < DEF_MAXNPCS; n++)
				if ((m_pNpcList[n] != NULL) && (m_pMapList[m_pNpcList[n]->m_cMapIndex] != NULL) && (m_pNpcList[n]->m_bIsSummoned == TRUE)) {
					RemoveHeldenianNpc(n);
				}
				RemoveOccupyFlags(x);
			}
		}
	}
	_CreateHeldenianGUID(m_dwHeldenianGUID, m_cHeldenianVictoryType);
}

BOOL CGame::bNotifyHeldenianWinner()
{
	if (var_88C == 0) {
		bSendMsgToLS(MSGID_REQUEST_HELDENIAN_WINNER, NULL, 1, NULL);
		return TRUE;
	}
	else {
		return FALSE;
	}

}

void CGame::RemoveHeldenianNpc(int iNpcH)
{
	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	m_pNpcList[iNpcH]->m_bIsKilled = TRUE;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = 0;
	m_pNpcList[iNpcH]->m_dwRegenTime = 0;
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

	ReleaseFollowMode(iNpcH, DEF_OWNERTYPE_NPC);
	m_pNpcList[iNpcH]->m_iTargetIndex = 0;
	m_pNpcList[iNpcH]->m_cTargetType = 0;
			
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, NULL, 1, NULL);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	m_pNpcList[iNpcH]->m_cBehavior = 4;
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();

}

void CGame::RemoveOccupyFlags(int iMapIndex)
{
 DWORD dwTime = timeGetTime();
 register i;
 short dX, dY;
 int iDynamicObjectIndex;
 class COccupyFlag * iOccupyFlagIndex;
 class CTile * pTile;
 int iy, ix;

 if (m_pMapList[iMapIndex] == NULL) return;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++) 
	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != FALSE) return;
	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != FALSE) {
		dX = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX;
		dY = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY;
		pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + dX + dY*m_pMapList[iMapIndex]->m_sSizeY);
		m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;
		iDynamicObjectIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iDynamicObjectIndex;
		if (m_pDynamicObjectList[iDynamicObjectIndex] == 0) return;

		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
			m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
			m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);

		m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);
		
		iOccupyFlagIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i];

		if (m_pDynamicObjectList[iDynamicObjectIndex] == 0) {
			for (ix = dX - 2; ix <= dX + 2; ix++)
			for (iy = dY - 2; iy <= dY + 2; iy++) {
				pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + ix + iy*m_pMapList[iMapIndex]->m_sSizeY);
				pTile->m_sOwner = NULL;
			}
		}
	}
}

void CGame::_CreateHeldenianGUID(DWORD dwHeldenianGUID, int iWinnerSide)
{
 char * cp, cTxt[256], cFn[256], cTemp[1024];	
 FILE * pFile;
		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));
	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"HeldenianGUID.Txt");
		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		wsprintf(cTxt, "(!) Cannot create HeldenianGUID(%d) file", dwHeldenianGUID);
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));
		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "HeldenianGUID = %d", dwHeldenianGUID);
		strcat(cTemp, cTxt);

		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);
		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		
		wsprintf(cTxt, "(O) HeldenianGUID(%d) file created", dwHeldenianGUID);
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}

/*********************************************************************************************************************
**  BOOL CGame::bCheckHeldenianMap(int sAttackerH, int iMapIndex, char cType)										**
**  description			:: checks if the player is in the specified map												**
**  last updated		:: November 22, 2004; 6:19 PM; Hypnotoad													**
**	return value		:: BOOL																						**
**  commentary			::	-	translated from scratch using IDA Pro												**
**						::	-	changed pTile->m_cOwner to m_iOccupyStatus											**
**						::	-	added check to prevent access violation if pTile == NULL							**
**						::	-	removed 4 return(s) after "iRet = 1;" and placed at end								**
*********************************************************************************************************************/
BOOL CGame::bCheckHeldenianMap(int sAttackerH, int iMapIndex, char cType) 
{
 short tX, tY;
 int iRet;
 class CTile * pTile;

	iRet = 0;
	if (m_pClientList[sAttackerH] == NULL) return 0;
	if ((m_bIsHeldenianMode == 1) || (m_cHeldenianType == 1)) {
		if (cType == DEF_OWNERTYPE_PLAYER) {
			if ((m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex] != NULL) && (m_pClientList[sAttackerH]->m_cSide > 0)) {
				tX = m_pClientList[sAttackerH]->m_sX;
				tY = m_pClientList[sAttackerH]->m_sY;
				if ((tX < 0) || (tX >= m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeX) || 
					(tY < 0) || (tY >= m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeY)) return 0;
				pTile = (class CTile *)(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_pTile + tX + tY*m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_sSizeY);
				if (pTile == NULL) return 0;
				if (pTile->m_iOccupyStatus != NULL) {
					if (pTile->m_iOccupyStatus < 0) {
						if (m_pClientList[sAttackerH]->m_cSide == 1) {
							iRet = 1;
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						if (m_pClientList[sAttackerH]->m_cSide == 2) {
							iRet = 1;
						}
					}
				}
			}
		} 
		else if (cType == DEF_OWNERTYPE_NPC) {
			if ((m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex] != NULL) && (iMapIndex != -1) && (m_pNpcList[sAttackerH]->m_cSide > 0)) {
				tX = m_pNpcList[sAttackerH]->m_sX;
				tY = m_pNpcList[sAttackerH]->m_sY;
				pTile = (class CTile *)(m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_pTile + tX + tY*m_pMapList[m_pNpcList[sAttackerH]->m_cMapIndex]->m_sSizeY);
				if (pTile == NULL) return 0;
				if (pTile->m_iOccupyStatus != NULL) {
					if (pTile->m_iOccupyStatus < 0) {
						if (m_pNpcList[sAttackerH]->m_cSide == 1) {
							iRet = 1;
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						if (m_pNpcList[sAttackerH]->m_cSide == 2) {
							iRet = 1;
						}
					}
				}
			}
		}
	}
	return iRet;
}

void CGame::RequestHeldenianTeleport(int iClientH, char * pData, DWORD dwMsgSize)
{
 char cTmpName[21], * cp, cTxt[512], cMapName[11];
 short tX, tY, cLoc, * sp;
 WORD wResult;
 int iRet, iWhyReturn, iProcessed;

	iProcessed = 1;
	if (m_pClientList[iClientH] == NULL) return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, cp);
	if (strcmp(cTmpName, "Gail") == 0) {
		ZeroMemory(cTxt, sizeof(cTxt));
		if ((m_bIsHeldenianMode == 1) && (m_pClientList[iClientH]->m_bIsPlayerCivil != TRUE) && (m_pClientList[iClientH]->m_cSide == 2 || m_pClientList[iClientH]->m_cSide ==1 )) {
			if (m_cHeldenianType == 1) {
				ZeroMemory(cMapName, sizeof(cMapName));
				memcpy(cMapName, "BtField", 10);
				if (m_pClientList[iClientH]->m_cSide == 1) {
					tX = 68;
					tY = 225;
					cLoc = 1;
				}
				else if (m_pClientList[iClientH]->m_cSide == 2) {
					tX = 202;
					tY = 70;
					cLoc = 2;
				}
			}
			else if (m_cHeldenianType == 2) {
				ZeroMemory(cMapName, sizeof(cMapName));
				memcpy(cMapName, "HRampart", 10);
				if (m_pClientList[iClientH]->m_cSide == m_sLastHeldenianWinner) {
					tX = 81;
					tY = 42;
					cLoc = 3;
				}
				else {
					tX = 156;
					tY = 153;
					cLoc = 4;
				}
			}
		wResult = DEF_MSGTYPE_CONFIRM;
		iProcessed = 1;
		iWhyReturn = 0;
		}
	}
	
	wResult = DEF_MSGTYPE_REJECT;
	iProcessed = 0;
	iWhyReturn = 0;

	sp = (short *)cp;
	*sp = 4; 
	cp += 4;

	sp = (short *)cp;
	*sp = cLoc; 
	cp += 4;

	memcpy(cp, cMapName, 10);
	cp += 10;

	sp = (short *)cp;
	*sp = tX; 
	cp += 4;

	sp = (short *)cp;
	*sp = tY; 
	cp += 4;

	sp = (short *)cp;
	*sp = iWhyReturn; 
	cp += 4;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cTxt, 36);
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			DeleteClient(iClientH, TRUE, TRUE);
			break;
	}
}

void CGame::HeldenianWarStarter()
{
 SYSTEMTIME SysTime;
 int i;
	
	GetLocalTime(&SysTime);
	if (var_89C == TRUE) return;
	if (var_8A0 == FALSE) return;

	for (i = 0; i < DEF_MAXSCHEDULE; i++) 
		if (m_bIsApocalypseMode == TRUE) return;
		if (m_bIsCrusadeMode == TRUE) return;
		if ((m_stHeldenianSchedule[i].iDay != SysTime.wDayOfWeek) &&
			(m_stHeldenianSchedule[i].StartiHour != SysTime.wHour) &&
			(m_stHeldenianSchedule[i].StartiMinute != SysTime.wMinute)) {
			wsprintf(G_cTxt,"Heldenian Start : time(%d %d:%d), index(%d)",SysTime.wDayOfWeek, SysTime.wHour, SysTime.wMinute, i);
			PutLogFileList(G_cTxt);
			var_8A0 = TRUE;
			GlobalStartHeldenianMode();
		}
}

void CGame::HeldenianWarEnder()
{
 SYSTEMTIME SysTime;
 int i;
	
	GetLocalTime(&SysTime);

	for (i = 0; i < DEF_MAXSCHEDULE; i++) 
		if (var_89C != TRUE) return;
		if (var_8A0 != TRUE) return;
		if ((m_stHeldenianSchedule[i].iDay != SysTime.wDayOfWeek) &&
			(m_stHeldenianSchedule[i].EndiHour != SysTime.wHour) &&
			(m_stHeldenianSchedule[i].EndiMinute != SysTime.wMinute)) {
			wsprintf(G_cTxt,"Heldenian End : time(%d %d:%d), index(%d)",SysTime.wDayOfWeek, SysTime.wHour, SysTime.wMinute, i);
			PutLogFileList(G_cTxt);
			if (m_cHeldenianModeType == 2) {
				m_cHeldenianVictoryType = m_sLastHeldenianWinner;
			}
			GlobalEndHeldenianMode();
		}
}

void CGame::GlobalStartHeldenianMode()
{
 char cData[120], * cp;
 DWORD dwTime, * dwp;
 WORD * wp;

	dwTime = timeGetTime();
	ZeroMemory(cData,sizeof(cData));

	cp = (char *)cData;
	*cp = GSM_STARTHELDENIAN; // 21
	cp++;
	
	wp  = (WORD *)cp;
	*wp = m_cHeldenianModeType;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = m_sLastHeldenianWinner;
	cp += 2;

	dwp = (DWORD *)cp;
	*dwp = dwTime;
	cp += 4;

	bStockMsgToGateServer(cData, 9);
	LocalStartHeldenianMode(m_cHeldenianModeType, m_sLastHeldenianWinner, dwTime);

}

/*********************************************************************************************************************
**  void CGame::LocalStartHeldenianMode(short sV1, short sV2, DWORD dwHeldenianGUID)								**
**  description			:: localy performs all required tasks upon recieving heldenian initiate message				**
**  last updated		:: December 10, 2004; 12:02 PM; Hypnotoad													**
**	return value		:: void																						**
**  commentary			::	-	translated from scratch using official 3.51 chinese hgserver						**
*********************************************************************************************************************/
void CGame::LocalStartHeldenianMode(short sV1, short sV2, DWORD dwHeldenianGUID)
{
 int i, x, z, iNamingValue;
 char cName[11], cTmp[21], cNpcWaypointIndex[10], cSide, cOwnerType;
 short sOwnerH;
 BOOL bRet;
 int dX, dY;

	if (m_bIsHeldenianMode == TRUE) return;

	if ((m_cHeldenianModeType == -1) || (m_cHeldenianModeType != sV1)) m_cHeldenianModeType = sV1;
	if ((m_sLastHeldenianWinner != -1) && (m_sLastHeldenianWinner == sV2)) {
		wsprintf(G_cTxt,"Heldenian Mode : %d , Heldenian Last Winner : %d", m_cHeldenianModeType, m_sLastHeldenianWinner);
		PutLogFileList(G_cTxt);
	}

	if (dwHeldenianGUID != 0) {
		_CreateHeldenianGUID(dwHeldenianGUID, 0);
		m_dwHeldenianGUID = dwHeldenianGUID;
	}
	m_iHeldenianAresdenLeftTower = 0;
	m_iHeldenianElvineLeftTower = 0;
	m_iHeldenianAresdenDead = 0;
	m_iHeldenianElvineDead = 0;

	for (i = 0; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) {
			if (m_pClientList[i]->m_bIsInitComplete != TRUE) break;
			m_pClientList[i]->m_cVar = 2;
			SendNotifyMsg(NULL, i, DEF_NOTIFY_HELDENIANTELEPORT,  NULL , NULL, NULL, NULL);
			m_pClientList[i]->m_iWarContribution = 0;
			m_pClientList[i]->m_iConstructionPoint = (m_pClientList[i]->m_iCharisma * 300);
			if (m_pClientList[i]->m_iConstructionPoint > 12000) m_pClientList[i]->m_iConstructionPoint = 12000;
			SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, 1, NULL);
		}
	}

	for (x = 0; x < DEF_MAXMAPS; x++) {
		if (m_pMapList[x] == NULL) break;
		if (m_pMapList[x]->m_bIsHeldenianMap == TRUE) {
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_bIsInitComplete != TRUE) break;
				if (m_pClientList[i]->m_iAdminUserLevel >= 1) break;
				if (m_pClientList[i]->m_cMapIndex != x) break;
				SendNotifyMsg(NULL, i, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);
				RequestTeleportHandler(i, "1   ", NULL, -1, -1);
			}
			for (i = 0; i < DEF_MAXNPCS; i++) {
				if (m_pNpcList[i] == NULL) break;
				if (m_pNpcList[i]->m_bIsKilled != FALSE) break;
				if (m_pNpcList[i]->m_cMapIndex != x) break;
				m_pNpcList[i]->m_bIsSummoned = TRUE;
				RemoveHeldenianNpc(i);
			}
		
			if (m_cHeldenianModeType == 1) {
				if (strcmp(m_pMapList[x]->m_cName, "BtField") == 0) {
					for (i = 0; i < MAX_HELDENIANTOWER; i++) {
						iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID < 1)  break;
						if (m_pMapList[x]->m_stHeldenianTower[i].sTypeID > DEF_MAXNPCTYPES) break;
						if (iNamingValue != -1) {
							dX = m_pMapList[x]->m_stHeldenianTower[i].dX;
							dY = m_pMapList[x]->m_stHeldenianTower[i].dY;
 							cSide = m_pMapList[x]->m_stHeldenianTower[i].cSide;
							for (z = 0; z < DEF_MAXNPCTYPES; z++) {
								if (m_pNpcConfigList[z] == NULL) break;
								if (m_pNpcConfigList[z]->m_sType == m_pMapList[x]->m_stHeldenianTower[i].sTypeID) {
									ZeroMemory(cTmp, sizeof(cTmp));
									strcpy(cTmp, m_pNpcConfigList[z]->m_cNpcName);
								}
							}
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = i + 65;
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, NULL, NULL, cSide, FALSE, FALSE, FALSE, TRUE, FALSE);
							if (bRet == FALSE) {
								m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[sOwnerH] != NULL) && (sOwnerH > 0) && (sOwnerH < DEF_MAXNPCS)) {
									m_pNpcList[sOwnerH]->m_iBuildCount = 0;
								}
								if (cSide == 1)	m_iHeldenianAresdenLeftTower += 1;
								if (cSide == 2) m_iHeldenianElvineLeftTower += 1;
							}
						}
					}
					wsprintf(G_cTxt,"HeldenianAresdenLeftTower : %d , HeldenianElvineLeftTower : %d", m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower);
					PutLogFileList(G_cTxt);
					UpdateHeldenianStatus();
				}
			}
			else if (m_cHeldenianModeType == 2) {
				if (strcmp(m_pMapList[x]->m_cName, "HRampart") == 0) {
					for (i = 0; i < DEF_MAXHELDENIANDOOR; i++) {
						iNamingValue = m_pMapList[x]->iGetEmptyNamingValue();
						if (iNamingValue != -1) {
							dX = m_pMapList[x]->m_stHeldenianGateDoor[i].dX;
							dY = m_pMapList[x]->m_stHeldenianGateDoor[i].dY;
							cSide = m_sLastHeldenianWinner;
							for (z = 0; z < DEF_MAXNPCTYPES; z++) {
								if (m_pNpcConfigList[z] == NULL) break;
								if (m_pNpcConfigList[z]->m_sType == 91) {
									ZeroMemory(cTmp, sizeof(cTmp));
									strcpy(cTmp, m_pNpcConfigList[z]->m_cNpcName);
								}
							}
							ZeroMemory(cName, sizeof(cName));
							wsprintf(cName, "XX%d", iNamingValue);
							cName[0] = 95;
							cName[1] = i + 65;
							bRet = bCreateNewNpc(cTmp, cName, m_pMapList[x]->m_cName, (rand() % 3), 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypointIndex, NULL, NULL, cSide, FALSE, FALSE, FALSE, TRUE, FALSE);
							if (bRet == FALSE) {
								m_pMapList[x]->SetNamingValueEmpty(iNamingValue);
							}
							else {
								//m_pMapList[x]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
								if ((m_pNpcList[bRet] != NULL) && (bRet > 0) && (bRet < DEF_MAXNPCS)) {
									m_pNpcList[bRet]->m_iBuildCount = 0;
									m_pNpcList[bRet]->m_cDir = m_pMapList[x]->m_stHeldenianGateDoor[i].cDir;
								}
							}
						}
					}
				}
			}
		}
	}
	m_bHeldenianInitiated = TRUE;
	m_bIsHeldenianMode = TRUE;
	wsprintf(G_cTxt,"(!) HELDENIAN Start.");
	PutLogFileList(G_cTxt);
	m_dwHeldenianStartTime = time(NULL);
}

void CGame::ManualStartHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize)
{
 char cHeldenianType, cBuff[256], * token, seps[] = "= \t\n";
 SYSTEMTIME SysTime;
 class CStrTok * pStrTok;
 int iV1;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);

	if (m_bIsHeldenianMode == TRUE) return;
	if (m_bIsApocalypseMode == TRUE) return;
	if (m_bIsCrusadeMode == TRUE) return;
	if ((dwMsgSize != NULL) && (pData != NULL)) {
		m_bHeldenianRunning = TRUE;
		GetLocalTime(&SysTime);

		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);
		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != NULL) {
			iV1 = atoi(token);
			iV1 += (SysTime.wHour*24 + SysTime.wMinute*60);
			m_dwHeldenianStartHour = (iV1/24);
			m_dwHeldenianStartMinute = (iV1/60);
		}
		token = pStrTok->pGet();
		if (token != NULL) {
			cHeldenianType = atoi(token);
			if ((cHeldenianType == 1) || (cHeldenianType == 2)) {
				m_cHeldenianModeType = cHeldenianType;
			}
		}
		delete pStrTok;
	}
	GlobalStartHeldenianMode();
	wsprintf(G_cTxt,"GM Order(%s): begin Heldenian", m_pClientList[iClientH]->m_cCharName);
	PutLogFileList(G_cTxt);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
}

void CGame::ManualEndHeldenianMode(int iClientH, char *pData, DWORD dwMsgSize)
{
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
	}

	if (m_bIsHeldenianMode == TRUE) {
		GlobalEndHeldenianMode();
		m_bHeldenianRunning = FALSE;
		wsprintf(G_cTxt,"GM Order(%s): end Heldenian", m_pClientList[iClientH]->m_cCharName);
		bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, G_cTxt);
	}
}

/*void CGame::GlobalStartApocalypseMode(int iClientH, char *pData, DWORD dwMsgSize)
{
 char * cp, cData[120], cBuff[256];
 DWORD * dwp, dwApocalypseGUID;
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
	}
	if (m_bIsApocalypseMode == TRUE) return;
	if (m_bIsHeldenianMode == TRUE) return;
	if (m_bIsCrusadeMode == TRUE) return;
	if (dwMsgSize != NULL) && (pData != NULL) {
		m_bIsApocalypseGateOpen = TRUE;
		GetLocalTime(&SysTime);
		ZeroMemory(cBuff, sizeof(cBuff));
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
		if (token != NULL) {
			var_124 = atoi(token);
			m_dwApocalypseStartHour = SysTime.wHour;
			m_dwApocalypseStartMinute = SysTime.wMinute;
		}
		else {
			return;
		}
	}
	sub_4AD0E0();
	wsprintf(cTemp, "(%s) GM Order(%s): beginapocalypse", m_pClientList[iClientH]->m_cIPaddress, m_pClientList[iClientH]->m_cCharName);
	bSendMsgToLS(MSGID_GAMEMASTERLOG, iClientH, FALSE, cTemp);
	delete pStrTok;
}*/

void CGame::AutomatedHeldenianTimer()
{
 DWORD dwTime;
 int x, i;

	dwTime = time(NULL);
	if ((dwTime == m_dwHeldenianStartTime - 300) && (m_bHeldenianInitiated != TRUE) && (m_bIsHeldenianMode != TRUE)) {
		wsprintf(G_cTxt,"Heldenian Fight Start");
		PutLogFileList(G_cTxt);
		m_bIsHeldenianMode = FALSE;
		for (x = 0; x < DEF_MAXMAPS; x++) {
			if (m_pMapList[x] == NULL) return;
			if (m_pMapList[x]->m_bIsHeldenianMap == TRUE) return;
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] == NULL) return;
				if (m_pClientList[i]->m_bIsInitComplete != TRUE) return;
				if (m_pClientList[i]->m_cMapIndex == x) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_HELDENIANSTART, NULL , NULL, NULL, NULL);					
				}
			}
		}
	}
	if ((dwTime > (180 - var_A38)) && (m_bHeldenianInitiated == TRUE) && (m_bIsHeldenianMode != FALSE)) {
		wsprintf(G_cTxt,"Heldenian Fight End");
		PutLogFileList(G_cTxt);
		m_bHeldenianInitiated = FALSE;
		for (x = 0; x < DEF_MAXMAPS; x++) {
			if (m_pMapList[x] == NULL) return;
			if (m_pMapList[x]->m_bIsHeldenianMap == TRUE) return;
			for (i = 0; i < DEF_MAXCLIENTS; i++) {
				if (m_pClientList[i] == NULL) return;
				if (m_pClientList[i]->m_bIsInitComplete != TRUE) return;
				if (m_pClientList[i]->m_cMapIndex == x) {
					SendNotifyMsg(NULL, i, DEF_NOTIFY_0BE8, NULL , NULL, NULL, NULL);
					RequestTeleportHandler(i, "1   ", NULL, -1, -1);
				}
			}
		}
	}
}

/*void sub_4AB850()
{
 SYSTEMTIME SysTime;

 GetLocalTime(&SysTime);
}*/

void CGame::AdminOrder_GetFightzoneTicket(int iClientH)
{
 int iReserveTime, iFightzoneTN, iFightzoneN;
 char cTemp[21];
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "fightzone", 9) == 0) {
		
		iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +3);  
		
		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = atoi(cTemp);
		
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		
		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}
	else {
		iReserveTime = m_pClientList[iClientH]->m_iReserveTime;
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iReserveTime = SysTime.wMonth*10000 + SysTime.wDay*100 + (SysTime.wHour +2);  
		
		ZeroMemory(cTemp, sizeof(cTemp));
		strcpy(cTemp, (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName +9));
		iFightzoneN  = m_pClientList[iClientH]->m_iFightzoneNumber;
		iFightzoneTN = m_pClientList[iClientH]->m_iFightZoneTicketNumber;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = 10;
		m_pClientList[iClientH]->m_iFightzoneNumber = 1;
		
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);
		GetFightzoneTicketHandler(iClientH);

		m_pClientList[iClientH]->m_iFightzoneNumber = iFightzoneN;
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = iFightzoneTN;
		m_pClientList[iClientH]->m_iReserveTime = iReserveTime;
	}
}

void CGame::SetHeldenianMode()
{
 SYSTEMTIME SysTime;

	GetLocalTime(&SysTime);
	m_dwHeldenianStartHour = SysTime.wHour;
	m_dwHeldenianStartMinute = SysTime.wMinute;
		
	if (m_cHeldenianModeType != 2) {
		m_cHeldenianVictoryType = m_sLastHeldenianWinner;
	}
}

void CGame::CheckCrusadeResultCalculation(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cVar == 1) return;

	if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_dwCrusadeGUID != 0)) {
		if (m_pClientList[iClientH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION) m_pClientList[iClientH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;	
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_iCrusadeWinnerSide == 0) {
				m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution/6);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);		
				_bCrusadeLog(DEF_CRUSADELOG_GETEXP, iClientH, (m_pClientList[iClientH]->m_iWarContribution/6), NULL) ;
			}
			else {
				if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide) {
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*100;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 100) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*40 ;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel;
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);
					_bCrusadeLog(DEF_CRUSADELOG_GETEXP,iClientH,m_pClientList[iClientH]->m_iWarContribution,NULL) ;
				}
				else if (m_iCrusadeWinnerSide != m_pClientList[iClientH]->m_cSide) {
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*100;
					}
					else if (m_pClientList[iClientH]->m_iLevel <= 100) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*40 ;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel;
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution/10 ;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, -1*m_pClientList[iClientH]->m_iWarContribution, NULL);						
					_bCrusadeLog(DEF_CRUSADELOG_GETEXP,iClientH,(m_pClientList[iClientH]->m_iWarContribution/10),NULL) ;
				}
			}
		}
		else {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		m_pClientList[iClientH]->m_iCrusadeDuty     = 0;
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwCrusadeGUID    = 0;
		m_pClientList[iClientH]->m_dwSpeedHackCheckTime = timeGetTime();
		m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	}
}

/*void CGame::CheckHeldenianResultCalculation(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cVar == 2) return;
	if ((m_cHeldenianModeType != 0) && (m_pClientList[iClientH]->m_dwCrusadeGUID != 0)) {
	m_pClientList[]->m_dwCrusadeGUID  


}*/

void CGame::NotifyStartHeldenianMode()
{
 register int i, x;
	
	if (m_bIsHeldenianMode == TRUE) return;
	if (m_bHeldenianInitiated == TRUE) return;
	if (var_88C != TRUE) {
		PutLogList("Heldenian Fight Start");
		m_bHeldenianInitiated = FALSE;
		for (i = 0; i < DEF_MAXMAPS; i++) {
			if (m_pMapList[i] == NULL) return;
			if (m_pMapList[i]->m_bIsHeldenianMap != TRUE) return;
			for (x = 0; x < DEF_MAXCLIENTS; x++) {
				if (m_pClientList[x] == NULL) return;
				if (m_pClientList[x]->m_bIsInitComplete != TRUE) return;
				if (m_pClientList[x]->m_cMapIndex == i) {
					SendNotifyMsg(NULL, x, DEF_NOTIFY_HELDENIANSTART, NULL, NULL, NULL, NULL);
				}
			}
		}
	}
}

BOOL CGame::UpdateHeldenianStatus()
{
 register int i;
 BOOL bFlag;
 int iShortCutIndex, iClientH;

	if (m_bIsHeldenianMode != TRUE) return FALSE;
	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL) {
		if (m_pMapList[i]->m_bIsHeldenianMap == TRUE) {
			bFlag = TRUE;
			iShortCutIndex = 0;
		}
		if (bFlag == TRUE) {
			iClientH = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (iClientH == 0) {
				bFlag = 0;
			}
			else {
				if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) && (strcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, "BtField") == 0)) {
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELDENIANCOUNT, m_iHeldenianAresdenLeftTower, m_iHeldenianElvineLeftTower, m_iHeldenianAresdenDead, NULL, m_iHeldenianElvineDead, NULL);
				}
			}
		}
	}
	return TRUE;
}